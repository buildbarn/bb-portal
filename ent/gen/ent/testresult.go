// Code generated by ent, DO NOT EDIT.

package ent

import (
	"encoding/json"
	"fmt"
	"strings"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/buildbarn/bb-portal/ent/gen/ent/testresult"
	"github.com/buildbarn/bb-portal/ent/gen/ent/testsummary"
)

// TestResult is the model entity for the TestResult schema.
type TestResult struct {
	config `json:"-"`
	// ID of the ent.
	ID int64 `json:"id,omitempty"`
	// Run holds the value of the "run" field.
	Run int32 `json:"run,omitempty"`
	// Shard holds the value of the "shard" field.
	Shard int32 `json:"shard,omitempty"`
	// Attempt holds the value of the "attempt" field.
	Attempt int32 `json:"attempt,omitempty"`
	// Status holds the value of the "status" field.
	Status string `json:"status,omitempty"`
	// StatusDetails holds the value of the "status_details" field.
	StatusDetails string `json:"status_details,omitempty"`
	// CachedLocally holds the value of the "cached_locally" field.
	CachedLocally bool `json:"cached_locally,omitempty"`
	// TestAttemptStart holds the value of the "test_attempt_start" field.
	TestAttemptStart time.Time `json:"test_attempt_start,omitempty"`
	// TestAttemptDurationInMs holds the value of the "test_attempt_duration_in_ms" field.
	TestAttemptDurationInMs int64 `json:"test_attempt_duration_in_ms,omitempty"`
	// Warning holds the value of the "warning" field.
	Warning []string `json:"warning,omitempty"`
	// Strategy holds the value of the "strategy" field.
	Strategy string `json:"strategy,omitempty"`
	// CachedRemotely holds the value of the "cached_remotely" field.
	CachedRemotely bool `json:"cached_remotely,omitempty"`
	// ExitCode holds the value of the "exit_code" field.
	ExitCode int32 `json:"exit_code,omitempty"`
	// Hostname holds the value of the "hostname" field.
	Hostname string `json:"hostname,omitempty"`
	// TimingBreakdown holds the value of the "timing_breakdown" field.
	TimingBreakdown map[string]interface{} `json:"timing_breakdown,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the TestResultQuery when eager-loading is set.
	Edges                     TestResultEdges `json:"edges"`
	test_summary_test_results *int64
	selectValues              sql.SelectValues
}

// TestResultEdges holds the relations/edges for other nodes in the graph.
type TestResultEdges struct {
	// TestSummary holds the value of the test_summary edge.
	TestSummary *TestSummary `json:"test_summary,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [1]bool
	// totalCount holds the count of the edges above.
	totalCount [1]map[string]int
}

// TestSummaryOrErr returns the TestSummary value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e TestResultEdges) TestSummaryOrErr() (*TestSummary, error) {
	if e.TestSummary != nil {
		return e.TestSummary, nil
	} else if e.loadedTypes[0] {
		return nil, &NotFoundError{label: testsummary.Label}
	}
	return nil, &NotLoadedError{edge: "test_summary"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*TestResult) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case testresult.FieldWarning, testresult.FieldTimingBreakdown:
			values[i] = new([]byte)
		case testresult.FieldCachedLocally, testresult.FieldCachedRemotely:
			values[i] = new(sql.NullBool)
		case testresult.FieldID, testresult.FieldRun, testresult.FieldShard, testresult.FieldAttempt, testresult.FieldTestAttemptDurationInMs, testresult.FieldExitCode:
			values[i] = new(sql.NullInt64)
		case testresult.FieldStatus, testresult.FieldStatusDetails, testresult.FieldStrategy, testresult.FieldHostname:
			values[i] = new(sql.NullString)
		case testresult.FieldTestAttemptStart:
			values[i] = new(sql.NullTime)
		case testresult.ForeignKeys[0]: // test_summary_test_results
			values[i] = new(sql.NullInt64)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the TestResult fields.
func (tr *TestResult) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case testresult.FieldID:
			value, ok := values[i].(*sql.NullInt64)
			if !ok {
				return fmt.Errorf("unexpected type %T for field id", value)
			}
			tr.ID = int64(value.Int64)
		case testresult.FieldRun:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field run", values[i])
			} else if value.Valid {
				tr.Run = int32(value.Int64)
			}
		case testresult.FieldShard:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field shard", values[i])
			} else if value.Valid {
				tr.Shard = int32(value.Int64)
			}
		case testresult.FieldAttempt:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field attempt", values[i])
			} else if value.Valid {
				tr.Attempt = int32(value.Int64)
			}
		case testresult.FieldStatus:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field status", values[i])
			} else if value.Valid {
				tr.Status = value.String
			}
		case testresult.FieldStatusDetails:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field status_details", values[i])
			} else if value.Valid {
				tr.StatusDetails = value.String
			}
		case testresult.FieldCachedLocally:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field cached_locally", values[i])
			} else if value.Valid {
				tr.CachedLocally = value.Bool
			}
		case testresult.FieldTestAttemptStart:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field test_attempt_start", values[i])
			} else if value.Valid {
				tr.TestAttemptStart = value.Time
			}
		case testresult.FieldTestAttemptDurationInMs:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field test_attempt_duration_in_ms", values[i])
			} else if value.Valid {
				tr.TestAttemptDurationInMs = value.Int64
			}
		case testresult.FieldWarning:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field warning", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &tr.Warning); err != nil {
					return fmt.Errorf("unmarshal field warning: %w", err)
				}
			}
		case testresult.FieldStrategy:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field strategy", values[i])
			} else if value.Valid {
				tr.Strategy = value.String
			}
		case testresult.FieldCachedRemotely:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field cached_remotely", values[i])
			} else if value.Valid {
				tr.CachedRemotely = value.Bool
			}
		case testresult.FieldExitCode:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field exit_code", values[i])
			} else if value.Valid {
				tr.ExitCode = int32(value.Int64)
			}
		case testresult.FieldHostname:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field hostname", values[i])
			} else if value.Valid {
				tr.Hostname = value.String
			}
		case testresult.FieldTimingBreakdown:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field timing_breakdown", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &tr.TimingBreakdown); err != nil {
					return fmt.Errorf("unmarshal field timing_breakdown: %w", err)
				}
			}
		case testresult.ForeignKeys[0]:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for edge-field test_summary_test_results", value)
			} else if value.Valid {
				tr.test_summary_test_results = new(int64)
				*tr.test_summary_test_results = int64(value.Int64)
			}
		default:
			tr.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the TestResult.
// This includes values selected through modifiers, order, etc.
func (tr *TestResult) Value(name string) (ent.Value, error) {
	return tr.selectValues.Get(name)
}

// QueryTestSummary queries the "test_summary" edge of the TestResult entity.
func (tr *TestResult) QueryTestSummary() *TestSummaryQuery {
	return NewTestResultClient(tr.config).QueryTestSummary(tr)
}

// Update returns a builder for updating this TestResult.
// Note that you need to call TestResult.Unwrap() before calling this method if this TestResult
// was returned from a transaction, and the transaction was committed or rolled back.
func (tr *TestResult) Update() *TestResultUpdateOne {
	return NewTestResultClient(tr.config).UpdateOne(tr)
}

// Unwrap unwraps the TestResult entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (tr *TestResult) Unwrap() *TestResult {
	_tx, ok := tr.config.driver.(*txDriver)
	if !ok {
		panic("ent: TestResult is not a transactional entity")
	}
	tr.config.driver = _tx.drv
	return tr
}

// String implements the fmt.Stringer.
func (tr *TestResult) String() string {
	var builder strings.Builder
	builder.WriteString("TestResult(")
	builder.WriteString(fmt.Sprintf("id=%v, ", tr.ID))
	builder.WriteString("run=")
	builder.WriteString(fmt.Sprintf("%v", tr.Run))
	builder.WriteString(", ")
	builder.WriteString("shard=")
	builder.WriteString(fmt.Sprintf("%v", tr.Shard))
	builder.WriteString(", ")
	builder.WriteString("attempt=")
	builder.WriteString(fmt.Sprintf("%v", tr.Attempt))
	builder.WriteString(", ")
	builder.WriteString("status=")
	builder.WriteString(tr.Status)
	builder.WriteString(", ")
	builder.WriteString("status_details=")
	builder.WriteString(tr.StatusDetails)
	builder.WriteString(", ")
	builder.WriteString("cached_locally=")
	builder.WriteString(fmt.Sprintf("%v", tr.CachedLocally))
	builder.WriteString(", ")
	builder.WriteString("test_attempt_start=")
	builder.WriteString(tr.TestAttemptStart.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("test_attempt_duration_in_ms=")
	builder.WriteString(fmt.Sprintf("%v", tr.TestAttemptDurationInMs))
	builder.WriteString(", ")
	builder.WriteString("warning=")
	builder.WriteString(fmt.Sprintf("%v", tr.Warning))
	builder.WriteString(", ")
	builder.WriteString("strategy=")
	builder.WriteString(tr.Strategy)
	builder.WriteString(", ")
	builder.WriteString("cached_remotely=")
	builder.WriteString(fmt.Sprintf("%v", tr.CachedRemotely))
	builder.WriteString(", ")
	builder.WriteString("exit_code=")
	builder.WriteString(fmt.Sprintf("%v", tr.ExitCode))
	builder.WriteString(", ")
	builder.WriteString("hostname=")
	builder.WriteString(tr.Hostname)
	builder.WriteString(", ")
	builder.WriteString("timing_breakdown=")
	builder.WriteString(fmt.Sprintf("%v", tr.TimingBreakdown))
	builder.WriteByte(')')
	return builder.String()
}

// TestResults is a parsable slice of TestResult.
type TestResults []*TestResult
