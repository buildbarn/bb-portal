// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"sync/atomic"

	"entgo.io/contrib/entgql"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/schema"
	"github.com/99designs/gqlgen/graphql"
	"github.com/buildbarn/bb-portal/ent/gen/ent/action"
	"github.com/buildbarn/bb-portal/ent/gen/ent/actioncachestatistics"
	"github.com/buildbarn/bb-portal/ent/gen/ent/actiondata"
	"github.com/buildbarn/bb-portal/ent/gen/ent/actionsummary"
	"github.com/buildbarn/bb-portal/ent/gen/ent/artifactmetrics"
	"github.com/buildbarn/bb-portal/ent/gen/ent/authenticateduser"
	"github.com/buildbarn/bb-portal/ent/gen/ent/bazelinvocation"
	"github.com/buildbarn/bb-portal/ent/gen/ent/build"
	"github.com/buildbarn/bb-portal/ent/gen/ent/buildgraphmetrics"
	"github.com/buildbarn/bb-portal/ent/gen/ent/configuration"
	"github.com/buildbarn/bb-portal/ent/gen/ent/cumulativemetrics"
	"github.com/buildbarn/bb-portal/ent/gen/ent/evaluationstat"
	"github.com/buildbarn/bb-portal/ent/gen/ent/garbagemetrics"
	"github.com/buildbarn/bb-portal/ent/gen/ent/instancename"
	"github.com/buildbarn/bb-portal/ent/gen/ent/invocationfiles"
	"github.com/buildbarn/bb-portal/ent/gen/ent/invocationtarget"
	"github.com/buildbarn/bb-portal/ent/gen/ent/memorymetrics"
	"github.com/buildbarn/bb-portal/ent/gen/ent/metrics"
	"github.com/buildbarn/bb-portal/ent/gen/ent/missdetail"
	"github.com/buildbarn/bb-portal/ent/gen/ent/networkmetrics"
	"github.com/buildbarn/bb-portal/ent/gen/ent/packageloadmetrics"
	"github.com/buildbarn/bb-portal/ent/gen/ent/packagemetrics"
	"github.com/buildbarn/bb-portal/ent/gen/ent/runnercount"
	"github.com/buildbarn/bb-portal/ent/gen/ent/sourcecontrol"
	"github.com/buildbarn/bb-portal/ent/gen/ent/systemnetworkstats"
	"github.com/buildbarn/bb-portal/ent/gen/ent/target"
	"github.com/buildbarn/bb-portal/ent/gen/ent/targetmetrics"
	"github.com/buildbarn/bb-portal/ent/gen/ent/testresult"
	"github.com/buildbarn/bb-portal/ent/gen/ent/testsummary"
	"github.com/buildbarn/bb-portal/ent/gen/ent/timingmetrics"
	"github.com/hashicorp/go-multierror"
	"golang.org/x/sync/semaphore"
)

// Noder wraps the basic Node method.
type Noder interface {
	IsNode()
}

var actionImplementors = []string{"Action", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*Action) IsNode() {}

var actioncachestatisticsImplementors = []string{"ActionCacheStatistics", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*ActionCacheStatistics) IsNode() {}

var actiondataImplementors = []string{"ActionData", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*ActionData) IsNode() {}

var actionsummaryImplementors = []string{"ActionSummary", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*ActionSummary) IsNode() {}

var artifactmetricsImplementors = []string{"ArtifactMetrics", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*ArtifactMetrics) IsNode() {}

var authenticateduserImplementors = []string{"AuthenticatedUser", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*AuthenticatedUser) IsNode() {}

var bazelinvocationImplementors = []string{"BazelInvocation", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*BazelInvocation) IsNode() {}

var buildImplementors = []string{"Build", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*Build) IsNode() {}

var buildgraphmetricsImplementors = []string{"BuildGraphMetrics", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*BuildGraphMetrics) IsNode() {}

var configurationImplementors = []string{"Configuration", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*Configuration) IsNode() {}

var cumulativemetricsImplementors = []string{"CumulativeMetrics", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*CumulativeMetrics) IsNode() {}

var evaluationstatImplementors = []string{"EvaluationStat", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*EvaluationStat) IsNode() {}

var garbagemetricsImplementors = []string{"GarbageMetrics", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*GarbageMetrics) IsNode() {}

var instancenameImplementors = []string{"InstanceName", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*InstanceName) IsNode() {}

var invocationfilesImplementors = []string{"InvocationFiles", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*InvocationFiles) IsNode() {}

var invocationtargetImplementors = []string{"InvocationTarget", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*InvocationTarget) IsNode() {}

var memorymetricsImplementors = []string{"MemoryMetrics", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*MemoryMetrics) IsNode() {}

var metricsImplementors = []string{"Metrics", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*Metrics) IsNode() {}

var missdetailImplementors = []string{"MissDetail", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*MissDetail) IsNode() {}

var networkmetricsImplementors = []string{"NetworkMetrics", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*NetworkMetrics) IsNode() {}

var packageloadmetricsImplementors = []string{"PackageLoadMetrics", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*PackageLoadMetrics) IsNode() {}

var packagemetricsImplementors = []string{"PackageMetrics", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*PackageMetrics) IsNode() {}

var runnercountImplementors = []string{"RunnerCount", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*RunnerCount) IsNode() {}

var sourcecontrolImplementors = []string{"SourceControl", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*SourceControl) IsNode() {}

var systemnetworkstatsImplementors = []string{"SystemNetworkStats", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*SystemNetworkStats) IsNode() {}

var targetImplementors = []string{"Target", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*Target) IsNode() {}

var targetmetricsImplementors = []string{"TargetMetrics", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*TargetMetrics) IsNode() {}

var testresultImplementors = []string{"TestResult", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*TestResult) IsNode() {}

var testsummaryImplementors = []string{"TestSummary", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*TestSummary) IsNode() {}

var timingmetricsImplementors = []string{"TimingMetrics", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*TimingMetrics) IsNode() {}

var errNodeInvalidID = &NotFoundError{"node"}

// NodeOption allows configuring the Noder execution using functional options.
type NodeOption func(*nodeOptions)

// WithNodeType sets the node Type resolver function (i.e. the table to query).
// If was not provided, the table will be derived from the universal-id
// configuration as described in: https://entgo.io/docs/migrate/#universal-ids.
func WithNodeType(f func(context.Context, int64) (string, error)) NodeOption {
	return func(o *nodeOptions) {
		o.nodeType = f
	}
}

// WithFixedNodeType sets the Type of the node to a fixed value.
func WithFixedNodeType(t string) NodeOption {
	return WithNodeType(func(context.Context, int64) (string, error) {
		return t, nil
	})
}

type nodeOptions struct {
	nodeType func(context.Context, int64) (string, error)
}

func (c *Client) newNodeOpts(opts []NodeOption) *nodeOptions {
	nopts := &nodeOptions{}
	for _, opt := range opts {
		opt(nopts)
	}
	if nopts.nodeType == nil {
		nopts.nodeType = func(ctx context.Context, id int64) (string, error) {
			return c.tables.nodeType(ctx, c.driver, id)
		}
	}
	return nopts
}

// Noder returns a Node by its id. If the NodeType was not provided, it will
// be derived from the id value according to the universal-id configuration.
//
//	c.Noder(ctx, id)
//	c.Noder(ctx, id, ent.WithNodeType(typeResolver))
func (c *Client) Noder(ctx context.Context, id int64, opts ...NodeOption) (_ Noder, err error) {
	defer func() {
		if IsNotFound(err) {
			err = multierror.Append(err, entgql.ErrNodeNotFound(id))
		}
	}()
	table, err := c.newNodeOpts(opts).nodeType(ctx, id)
	if err != nil {
		return nil, err
	}
	return c.noder(ctx, table, id)
}

func (c *Client) noder(ctx context.Context, table string, id int64) (Noder, error) {
	switch table {
	case action.Table:
		query := c.Action.Query().
			Where(action.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, actionImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case actioncachestatistics.Table:
		query := c.ActionCacheStatistics.Query().
			Where(actioncachestatistics.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, actioncachestatisticsImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case actiondata.Table:
		query := c.ActionData.Query().
			Where(actiondata.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, actiondataImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case actionsummary.Table:
		query := c.ActionSummary.Query().
			Where(actionsummary.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, actionsummaryImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case artifactmetrics.Table:
		query := c.ArtifactMetrics.Query().
			Where(artifactmetrics.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, artifactmetricsImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case authenticateduser.Table:
		query := c.AuthenticatedUser.Query().
			Where(authenticateduser.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, authenticateduserImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case bazelinvocation.Table:
		query := c.BazelInvocation.Query().
			Where(bazelinvocation.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, bazelinvocationImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case build.Table:
		query := c.Build.Query().
			Where(build.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, buildImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case buildgraphmetrics.Table:
		query := c.BuildGraphMetrics.Query().
			Where(buildgraphmetrics.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, buildgraphmetricsImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case configuration.Table:
		query := c.Configuration.Query().
			Where(configuration.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, configurationImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case cumulativemetrics.Table:
		query := c.CumulativeMetrics.Query().
			Where(cumulativemetrics.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, cumulativemetricsImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case evaluationstat.Table:
		query := c.EvaluationStat.Query().
			Where(evaluationstat.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, evaluationstatImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case garbagemetrics.Table:
		query := c.GarbageMetrics.Query().
			Where(garbagemetrics.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, garbagemetricsImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case instancename.Table:
		query := c.InstanceName.Query().
			Where(instancename.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, instancenameImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case invocationfiles.Table:
		query := c.InvocationFiles.Query().
			Where(invocationfiles.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, invocationfilesImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case invocationtarget.Table:
		query := c.InvocationTarget.Query().
			Where(invocationtarget.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, invocationtargetImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case memorymetrics.Table:
		query := c.MemoryMetrics.Query().
			Where(memorymetrics.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, memorymetricsImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case metrics.Table:
		query := c.Metrics.Query().
			Where(metrics.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, metricsImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case missdetail.Table:
		query := c.MissDetail.Query().
			Where(missdetail.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, missdetailImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case networkmetrics.Table:
		query := c.NetworkMetrics.Query().
			Where(networkmetrics.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, networkmetricsImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case packageloadmetrics.Table:
		query := c.PackageLoadMetrics.Query().
			Where(packageloadmetrics.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, packageloadmetricsImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case packagemetrics.Table:
		query := c.PackageMetrics.Query().
			Where(packagemetrics.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, packagemetricsImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case runnercount.Table:
		query := c.RunnerCount.Query().
			Where(runnercount.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, runnercountImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case sourcecontrol.Table:
		query := c.SourceControl.Query().
			Where(sourcecontrol.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, sourcecontrolImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case systemnetworkstats.Table:
		query := c.SystemNetworkStats.Query().
			Where(systemnetworkstats.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, systemnetworkstatsImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case target.Table:
		query := c.Target.Query().
			Where(target.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, targetImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case targetmetrics.Table:
		query := c.TargetMetrics.Query().
			Where(targetmetrics.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, targetmetricsImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case testresult.Table:
		query := c.TestResult.Query().
			Where(testresult.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, testresultImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case testsummary.Table:
		query := c.TestSummary.Query().
			Where(testsummary.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, testsummaryImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case timingmetrics.Table:
		query := c.TimingMetrics.Query().
			Where(timingmetrics.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, timingmetricsImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	default:
		return nil, fmt.Errorf("cannot resolve noder from table %q: %w", table, errNodeInvalidID)
	}
}

func (c *Client) Noders(ctx context.Context, ids []int64, opts ...NodeOption) ([]Noder, error) {
	switch len(ids) {
	case 1:
		noder, err := c.Noder(ctx, ids[0], opts...)
		if err != nil {
			return nil, err
		}
		return []Noder{noder}, nil
	case 0:
		return []Noder{}, nil
	}

	noders := make([]Noder, len(ids))
	errors := make([]error, len(ids))
	tables := make(map[string][]int64)
	id2idx := make(map[int64][]int, len(ids))
	nopts := c.newNodeOpts(opts)
	for i, id := range ids {
		table, err := nopts.nodeType(ctx, id)
		if err != nil {
			errors[i] = err
			continue
		}
		tables[table] = append(tables[table], id)
		id2idx[id] = append(id2idx[id], i)
	}

	for table, ids := range tables {
		nodes, err := c.noders(ctx, table, ids)
		if err != nil {
			for _, id := range ids {
				for _, idx := range id2idx[id] {
					errors[idx] = err
				}
			}
		} else {
			for i, id := range ids {
				for _, idx := range id2idx[id] {
					noders[idx] = nodes[i]
				}
			}
		}
	}

	for i, id := range ids {
		if errors[i] == nil {
			if noders[i] != nil {
				continue
			}
			errors[i] = entgql.ErrNodeNotFound(id)
		} else if IsNotFound(errors[i]) {
			errors[i] = multierror.Append(errors[i], entgql.ErrNodeNotFound(id))
		}
		ctx := graphql.WithPathContext(ctx,
			graphql.NewPathWithIndex(i),
		)
		graphql.AddError(ctx, errors[i])
	}
	return noders, nil
}

func (c *Client) noders(ctx context.Context, table string, ids []int64) ([]Noder, error) {
	noders := make([]Noder, len(ids))
	idmap := make(map[int64][]*Noder, len(ids))
	for i, id := range ids {
		idmap[id] = append(idmap[id], &noders[i])
	}
	switch table {
	case action.Table:
		query := c.Action.Query().
			Where(action.IDIn(ids...))
		query, err := query.CollectFields(ctx, actionImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case actioncachestatistics.Table:
		query := c.ActionCacheStatistics.Query().
			Where(actioncachestatistics.IDIn(ids...))
		query, err := query.CollectFields(ctx, actioncachestatisticsImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case actiondata.Table:
		query := c.ActionData.Query().
			Where(actiondata.IDIn(ids...))
		query, err := query.CollectFields(ctx, actiondataImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case actionsummary.Table:
		query := c.ActionSummary.Query().
			Where(actionsummary.IDIn(ids...))
		query, err := query.CollectFields(ctx, actionsummaryImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case artifactmetrics.Table:
		query := c.ArtifactMetrics.Query().
			Where(artifactmetrics.IDIn(ids...))
		query, err := query.CollectFields(ctx, artifactmetricsImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case authenticateduser.Table:
		query := c.AuthenticatedUser.Query().
			Where(authenticateduser.IDIn(ids...))
		query, err := query.CollectFields(ctx, authenticateduserImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case bazelinvocation.Table:
		query := c.BazelInvocation.Query().
			Where(bazelinvocation.IDIn(ids...))
		query, err := query.CollectFields(ctx, bazelinvocationImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case build.Table:
		query := c.Build.Query().
			Where(build.IDIn(ids...))
		query, err := query.CollectFields(ctx, buildImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case buildgraphmetrics.Table:
		query := c.BuildGraphMetrics.Query().
			Where(buildgraphmetrics.IDIn(ids...))
		query, err := query.CollectFields(ctx, buildgraphmetricsImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case configuration.Table:
		query := c.Configuration.Query().
			Where(configuration.IDIn(ids...))
		query, err := query.CollectFields(ctx, configurationImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case cumulativemetrics.Table:
		query := c.CumulativeMetrics.Query().
			Where(cumulativemetrics.IDIn(ids...))
		query, err := query.CollectFields(ctx, cumulativemetricsImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case evaluationstat.Table:
		query := c.EvaluationStat.Query().
			Where(evaluationstat.IDIn(ids...))
		query, err := query.CollectFields(ctx, evaluationstatImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case garbagemetrics.Table:
		query := c.GarbageMetrics.Query().
			Where(garbagemetrics.IDIn(ids...))
		query, err := query.CollectFields(ctx, garbagemetricsImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case instancename.Table:
		query := c.InstanceName.Query().
			Where(instancename.IDIn(ids...))
		query, err := query.CollectFields(ctx, instancenameImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case invocationfiles.Table:
		query := c.InvocationFiles.Query().
			Where(invocationfiles.IDIn(ids...))
		query, err := query.CollectFields(ctx, invocationfilesImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case invocationtarget.Table:
		query := c.InvocationTarget.Query().
			Where(invocationtarget.IDIn(ids...))
		query, err := query.CollectFields(ctx, invocationtargetImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case memorymetrics.Table:
		query := c.MemoryMetrics.Query().
			Where(memorymetrics.IDIn(ids...))
		query, err := query.CollectFields(ctx, memorymetricsImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case metrics.Table:
		query := c.Metrics.Query().
			Where(metrics.IDIn(ids...))
		query, err := query.CollectFields(ctx, metricsImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case missdetail.Table:
		query := c.MissDetail.Query().
			Where(missdetail.IDIn(ids...))
		query, err := query.CollectFields(ctx, missdetailImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case networkmetrics.Table:
		query := c.NetworkMetrics.Query().
			Where(networkmetrics.IDIn(ids...))
		query, err := query.CollectFields(ctx, networkmetricsImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case packageloadmetrics.Table:
		query := c.PackageLoadMetrics.Query().
			Where(packageloadmetrics.IDIn(ids...))
		query, err := query.CollectFields(ctx, packageloadmetricsImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case packagemetrics.Table:
		query := c.PackageMetrics.Query().
			Where(packagemetrics.IDIn(ids...))
		query, err := query.CollectFields(ctx, packagemetricsImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case runnercount.Table:
		query := c.RunnerCount.Query().
			Where(runnercount.IDIn(ids...))
		query, err := query.CollectFields(ctx, runnercountImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case sourcecontrol.Table:
		query := c.SourceControl.Query().
			Where(sourcecontrol.IDIn(ids...))
		query, err := query.CollectFields(ctx, sourcecontrolImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case systemnetworkstats.Table:
		query := c.SystemNetworkStats.Query().
			Where(systemnetworkstats.IDIn(ids...))
		query, err := query.CollectFields(ctx, systemnetworkstatsImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case target.Table:
		query := c.Target.Query().
			Where(target.IDIn(ids...))
		query, err := query.CollectFields(ctx, targetImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case targetmetrics.Table:
		query := c.TargetMetrics.Query().
			Where(targetmetrics.IDIn(ids...))
		query, err := query.CollectFields(ctx, targetmetricsImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case testresult.Table:
		query := c.TestResult.Query().
			Where(testresult.IDIn(ids...))
		query, err := query.CollectFields(ctx, testresultImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case testsummary.Table:
		query := c.TestSummary.Query().
			Where(testsummary.IDIn(ids...))
		query, err := query.CollectFields(ctx, testsummaryImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case timingmetrics.Table:
		query := c.TimingMetrics.Query().
			Where(timingmetrics.IDIn(ids...))
		query, err := query.CollectFields(ctx, timingmetricsImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	default:
		return nil, fmt.Errorf("cannot resolve noders from table %q: %w", table, errNodeInvalidID)
	}
	return noders, nil
}

type tables struct {
	once  sync.Once
	sem   *semaphore.Weighted
	value atomic.Value
}

func (t *tables) nodeType(ctx context.Context, drv dialect.Driver, id int64) (string, error) {
	tables, err := t.Load(ctx, drv)
	if err != nil {
		return "", err
	}
	idx := int(id / (1<<32 - 1))
	if idx < 0 || idx >= len(tables) {
		return "", fmt.Errorf("cannot resolve table from id %v: %w", id, errNodeInvalidID)
	}
	return tables[idx], nil
}

func (t *tables) Load(ctx context.Context, drv dialect.Driver) ([]string, error) {
	if tables := t.value.Load(); tables != nil {
		return tables.([]string), nil
	}
	t.once.Do(func() { t.sem = semaphore.NewWeighted(1) })
	if err := t.sem.Acquire(ctx, 1); err != nil {
		return nil, err
	}
	defer t.sem.Release(1)
	if tables := t.value.Load(); tables != nil {
		return tables.([]string), nil
	}
	tables, err := t.load(ctx, drv)
	if err == nil {
		t.value.Store(tables)
	}
	return tables, err
}

func (*tables) load(ctx context.Context, drv dialect.Driver) ([]string, error) {
	rows := &sql.Rows{}
	query, args := sql.Dialect(drv.Dialect()).
		Select("type").
		From(sql.Table(schema.TypeTable)).
		OrderBy(sql.Asc("id")).
		Query()
	if err := drv.Query(ctx, query, args, rows); err != nil {
		return nil, err
	}
	defer rows.Close()
	var tables []string
	return tables, sql.ScanSlice(rows, &tables)
}
