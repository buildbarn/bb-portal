// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"

	"entgo.io/contrib/entgql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/buildbarn/bb-portal/ent/gen/ent/actioncachestatistics"
	"github.com/buildbarn/bb-portal/ent/gen/ent/actiondata"
	"github.com/buildbarn/bb-portal/ent/gen/ent/actionsummary"
	"github.com/buildbarn/bb-portal/ent/gen/ent/bazelinvocation"
	"github.com/buildbarn/bb-portal/ent/gen/ent/bazelinvocationproblem"
	"github.com/buildbarn/bb-portal/ent/gen/ent/blob"
	"github.com/buildbarn/bb-portal/ent/gen/ent/build"
	"github.com/buildbarn/bb-portal/ent/gen/ent/buildgraphmetrics"
	"github.com/buildbarn/bb-portal/ent/gen/ent/cumulativemetrics"
	"github.com/buildbarn/bb-portal/ent/gen/ent/evaluationstat"
	"github.com/buildbarn/bb-portal/ent/gen/ent/exectioninfo"
	"github.com/buildbarn/bb-portal/ent/gen/ent/filesmetric"
	"github.com/buildbarn/bb-portal/ent/gen/ent/garbagemetrics"
	"github.com/buildbarn/bb-portal/ent/gen/ent/incompletebuildlog"
	"github.com/buildbarn/bb-portal/ent/gen/ent/invocationfiles"
	"github.com/buildbarn/bb-portal/ent/gen/ent/memorymetrics"
	"github.com/buildbarn/bb-portal/ent/gen/ent/missdetail"
	"github.com/buildbarn/bb-portal/ent/gen/ent/outputgroup"
	"github.com/buildbarn/bb-portal/ent/gen/ent/packageloadmetrics"
	"github.com/buildbarn/bb-portal/ent/gen/ent/packagemetrics"
	"github.com/buildbarn/bb-portal/ent/gen/ent/resourceusage"
	"github.com/buildbarn/bb-portal/ent/gen/ent/runnercount"
	"github.com/buildbarn/bb-portal/ent/gen/ent/sourcecontrol"
	"github.com/buildbarn/bb-portal/ent/gen/ent/systemnetworkstats"
	"github.com/buildbarn/bb-portal/ent/gen/ent/target"
	"github.com/buildbarn/bb-portal/ent/gen/ent/targetmetrics"
	"github.com/buildbarn/bb-portal/ent/gen/ent/testcollection"
	"github.com/buildbarn/bb-portal/ent/gen/ent/testfile"
	"github.com/buildbarn/bb-portal/ent/gen/ent/testresultbes"
	"github.com/buildbarn/bb-portal/ent/gen/ent/testsummary"
	"github.com/buildbarn/bb-portal/ent/gen/ent/timingbreakdown"
	"github.com/buildbarn/bb-portal/ent/gen/ent/timingchild"
	"github.com/buildbarn/bb-portal/ent/gen/ent/timingmetrics"
)

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (acs *ActionCacheStatisticsQuery) CollectFields(ctx context.Context, satisfies ...string) (*ActionCacheStatisticsQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return acs, nil
	}
	if err := acs.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return acs, nil
}

func (acs *ActionCacheStatisticsQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(actioncachestatistics.Columns))
		selectedFields = []string{actioncachestatistics.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "actionSummary":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ActionSummaryClient{config: acs.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, actionsummaryImplementors)...); err != nil {
				return err
			}
			acs.withActionSummary = query

		case "missDetails":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&MissDetailClient{config: acs.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, missdetailImplementors)...); err != nil {
				return err
			}
			acs.WithNamedMissDetails(alias, func(wq *MissDetailQuery) {
				*wq = *query
			})
		case "sizeInBytes":
			if _, ok := fieldSeen[actioncachestatistics.FieldSizeInBytes]; !ok {
				selectedFields = append(selectedFields, actioncachestatistics.FieldSizeInBytes)
				fieldSeen[actioncachestatistics.FieldSizeInBytes] = struct{}{}
			}
		case "saveTimeInMs":
			if _, ok := fieldSeen[actioncachestatistics.FieldSaveTimeInMs]; !ok {
				selectedFields = append(selectedFields, actioncachestatistics.FieldSaveTimeInMs)
				fieldSeen[actioncachestatistics.FieldSaveTimeInMs] = struct{}{}
			}
		case "loadTimeInMs":
			if _, ok := fieldSeen[actioncachestatistics.FieldLoadTimeInMs]; !ok {
				selectedFields = append(selectedFields, actioncachestatistics.FieldLoadTimeInMs)
				fieldSeen[actioncachestatistics.FieldLoadTimeInMs] = struct{}{}
			}
		case "hits":
			if _, ok := fieldSeen[actioncachestatistics.FieldHits]; !ok {
				selectedFields = append(selectedFields, actioncachestatistics.FieldHits)
				fieldSeen[actioncachestatistics.FieldHits] = struct{}{}
			}
		case "misses":
			if _, ok := fieldSeen[actioncachestatistics.FieldMisses]; !ok {
				selectedFields = append(selectedFields, actioncachestatistics.FieldMisses)
				fieldSeen[actioncachestatistics.FieldMisses] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		acs.Select(selectedFields...)
	}
	return nil
}

type actioncachestatisticsPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ActionCacheStatisticsPaginateOption
}

func newActionCacheStatisticsPaginateArgs(rv map[string]any) *actioncachestatisticsPaginateArgs {
	args := &actioncachestatisticsPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*ActionCacheStatisticsWhereInput); ok {
		args.opts = append(args.opts, WithActionCacheStatisticsFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ad *ActionDataQuery) CollectFields(ctx context.Context, satisfies ...string) (*ActionDataQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ad, nil
	}
	if err := ad.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ad, nil
}

func (ad *ActionDataQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(actiondata.Columns))
		selectedFields = []string{actiondata.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "actionSummary":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ActionSummaryClient{config: ad.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, actionsummaryImplementors)...); err != nil {
				return err
			}
			ad.withActionSummary = query
		case "mnemonic":
			if _, ok := fieldSeen[actiondata.FieldMnemonic]; !ok {
				selectedFields = append(selectedFields, actiondata.FieldMnemonic)
				fieldSeen[actiondata.FieldMnemonic] = struct{}{}
			}
		case "actionsExecuted":
			if _, ok := fieldSeen[actiondata.FieldActionsExecuted]; !ok {
				selectedFields = append(selectedFields, actiondata.FieldActionsExecuted)
				fieldSeen[actiondata.FieldActionsExecuted] = struct{}{}
			}
		case "actionsCreated":
			if _, ok := fieldSeen[actiondata.FieldActionsCreated]; !ok {
				selectedFields = append(selectedFields, actiondata.FieldActionsCreated)
				fieldSeen[actiondata.FieldActionsCreated] = struct{}{}
			}
		case "firstStartedMs":
			if _, ok := fieldSeen[actiondata.FieldFirstStartedMs]; !ok {
				selectedFields = append(selectedFields, actiondata.FieldFirstStartedMs)
				fieldSeen[actiondata.FieldFirstStartedMs] = struct{}{}
			}
		case "lastEndedMs":
			if _, ok := fieldSeen[actiondata.FieldLastEndedMs]; !ok {
				selectedFields = append(selectedFields, actiondata.FieldLastEndedMs)
				fieldSeen[actiondata.FieldLastEndedMs] = struct{}{}
			}
		case "systemTime":
			if _, ok := fieldSeen[actiondata.FieldSystemTime]; !ok {
				selectedFields = append(selectedFields, actiondata.FieldSystemTime)
				fieldSeen[actiondata.FieldSystemTime] = struct{}{}
			}
		case "userTime":
			if _, ok := fieldSeen[actiondata.FieldUserTime]; !ok {
				selectedFields = append(selectedFields, actiondata.FieldUserTime)
				fieldSeen[actiondata.FieldUserTime] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ad.Select(selectedFields...)
	}
	return nil
}

type actiondataPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ActionDataPaginateOption
}

func newActionDataPaginateArgs(rv map[string]any) *actiondataPaginateArgs {
	args := &actiondataPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*ActionDataWhereInput); ok {
		args.opts = append(args.opts, WithActionDataFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (as *ActionSummaryQuery) CollectFields(ctx context.Context, satisfies ...string) (*ActionSummaryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return as, nil
	}
	if err := as.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return as, nil
}

func (as *ActionSummaryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(actionsummary.Columns))
		selectedFields = []string{actionsummary.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "metrics":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&MetricsClient{config: as.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, metricsImplementors)...); err != nil {
				return err
			}
			as.withMetrics = query

		case "actionData":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ActionDataClient{config: as.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, actiondataImplementors)...); err != nil {
				return err
			}
			as.WithNamedActionData(alias, func(wq *ActionDataQuery) {
				*wq = *query
			})

		case "runnerCount":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&RunnerCountClient{config: as.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, runnercountImplementors)...); err != nil {
				return err
			}
			as.WithNamedRunnerCount(alias, func(wq *RunnerCountQuery) {
				*wq = *query
			})

		case "actionCacheStatistics":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ActionCacheStatisticsClient{config: as.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, actioncachestatisticsImplementors)...); err != nil {
				return err
			}
			as.withActionCacheStatistics = query
		case "actionsCreated":
			if _, ok := fieldSeen[actionsummary.FieldActionsCreated]; !ok {
				selectedFields = append(selectedFields, actionsummary.FieldActionsCreated)
				fieldSeen[actionsummary.FieldActionsCreated] = struct{}{}
			}
		case "actionsCreatedNotIncludingAspects":
			if _, ok := fieldSeen[actionsummary.FieldActionsCreatedNotIncludingAspects]; !ok {
				selectedFields = append(selectedFields, actionsummary.FieldActionsCreatedNotIncludingAspects)
				fieldSeen[actionsummary.FieldActionsCreatedNotIncludingAspects] = struct{}{}
			}
		case "actionsExecuted":
			if _, ok := fieldSeen[actionsummary.FieldActionsExecuted]; !ok {
				selectedFields = append(selectedFields, actionsummary.FieldActionsExecuted)
				fieldSeen[actionsummary.FieldActionsExecuted] = struct{}{}
			}
		case "remoteCacheHits":
			if _, ok := fieldSeen[actionsummary.FieldRemoteCacheHits]; !ok {
				selectedFields = append(selectedFields, actionsummary.FieldRemoteCacheHits)
				fieldSeen[actionsummary.FieldRemoteCacheHits] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		as.Select(selectedFields...)
	}
	return nil
}

type actionsummaryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ActionSummaryPaginateOption
}

func newActionSummaryPaginateArgs(rv map[string]any) *actionsummaryPaginateArgs {
	args := &actionsummaryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*ActionSummaryWhereInput); ok {
		args.opts = append(args.opts, WithActionSummaryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (am *ArtifactMetricsQuery) CollectFields(ctx context.Context, satisfies ...string) (*ArtifactMetricsQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return am, nil
	}
	if err := am.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return am, nil
}

func (am *ArtifactMetricsQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "metrics":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&MetricsClient{config: am.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, metricsImplementors)...); err != nil {
				return err
			}
			am.withMetrics = query

		case "sourceArtifactsRead":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&FilesMetricClient{config: am.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, filesmetricImplementors)...); err != nil {
				return err
			}
			am.withSourceArtifactsRead = query

		case "outputArtifactsSeen":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&FilesMetricClient{config: am.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, filesmetricImplementors)...); err != nil {
				return err
			}
			am.withOutputArtifactsSeen = query

		case "outputArtifactsFromActionCache":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&FilesMetricClient{config: am.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, filesmetricImplementors)...); err != nil {
				return err
			}
			am.withOutputArtifactsFromActionCache = query

		case "topLevelArtifacts":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&FilesMetricClient{config: am.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, filesmetricImplementors)...); err != nil {
				return err
			}
			am.withTopLevelArtifacts = query
		}
	}
	return nil
}

type artifactmetricsPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ArtifactMetricsPaginateOption
}

func newArtifactMetricsPaginateArgs(rv map[string]any) *artifactmetricsPaginateArgs {
	args := &artifactmetricsPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*ArtifactMetricsWhereInput); ok {
		args.opts = append(args.opts, WithArtifactMetricsFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (bi *BazelInvocationQuery) CollectFields(ctx context.Context, satisfies ...string) (*BazelInvocationQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return bi, nil
	}
	if err := bi.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return bi, nil
}

func (bi *BazelInvocationQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(bazelinvocation.Columns))
		selectedFields = []string{bazelinvocation.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "build":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BuildClient{config: bi.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, buildImplementors)...); err != nil {
				return err
			}
			bi.withBuild = query

		case "metrics":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&MetricsClient{config: bi.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, metricsImplementors)...); err != nil {
				return err
			}
			bi.withMetrics = query

		case "incompleteBuildLogs":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&IncompleteBuildLogClient{config: bi.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, incompletebuildlogImplementors)...); err != nil {
				return err
			}
			bi.WithNamedIncompleteBuildLogs(alias, func(wq *IncompleteBuildLogQuery) {
				*wq = *query
			})

		case "invocationFiles":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&InvocationFilesClient{config: bi.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, invocationfilesImplementors)...); err != nil {
				return err
			}
			bi.WithNamedInvocationFiles(alias, func(wq *InvocationFilesQuery) {
				*wq = *query
			})

		case "testCollection":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TestCollectionClient{config: bi.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, testcollectionImplementors)...); err != nil {
				return err
			}
			bi.WithNamedTestCollection(alias, func(wq *TestCollectionQuery) {
				*wq = *query
			})

		case "targets":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TargetClient{config: bi.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, targetImplementors)...); err != nil {
				return err
			}
			bi.WithNamedTargets(alias, func(wq *TargetQuery) {
				*wq = *query
			})

		case "sourceControl":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&SourceControlClient{config: bi.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, sourcecontrolImplementors)...); err != nil {
				return err
			}
			bi.withSourceControl = query
		case "invocationID":
			if _, ok := fieldSeen[bazelinvocation.FieldInvocationID]; !ok {
				selectedFields = append(selectedFields, bazelinvocation.FieldInvocationID)
				fieldSeen[bazelinvocation.FieldInvocationID] = struct{}{}
			}
		case "startedAt":
			if _, ok := fieldSeen[bazelinvocation.FieldStartedAt]; !ok {
				selectedFields = append(selectedFields, bazelinvocation.FieldStartedAt)
				fieldSeen[bazelinvocation.FieldStartedAt] = struct{}{}
			}
		case "endedAt":
			if _, ok := fieldSeen[bazelinvocation.FieldEndedAt]; !ok {
				selectedFields = append(selectedFields, bazelinvocation.FieldEndedAt)
				fieldSeen[bazelinvocation.FieldEndedAt] = struct{}{}
			}
		case "changeNumber":
			if _, ok := fieldSeen[bazelinvocation.FieldChangeNumber]; !ok {
				selectedFields = append(selectedFields, bazelinvocation.FieldChangeNumber)
				fieldSeen[bazelinvocation.FieldChangeNumber] = struct{}{}
			}
		case "patchsetNumber":
			if _, ok := fieldSeen[bazelinvocation.FieldPatchsetNumber]; !ok {
				selectedFields = append(selectedFields, bazelinvocation.FieldPatchsetNumber)
				fieldSeen[bazelinvocation.FieldPatchsetNumber] = struct{}{}
			}
		case "bepCompleted":
			if _, ok := fieldSeen[bazelinvocation.FieldBepCompleted]; !ok {
				selectedFields = append(selectedFields, bazelinvocation.FieldBepCompleted)
				fieldSeen[bazelinvocation.FieldBepCompleted] = struct{}{}
			}
		case "stepLabel":
			if _, ok := fieldSeen[bazelinvocation.FieldStepLabel]; !ok {
				selectedFields = append(selectedFields, bazelinvocation.FieldStepLabel)
				fieldSeen[bazelinvocation.FieldStepLabel] = struct{}{}
			}
		case "userEmail":
			if _, ok := fieldSeen[bazelinvocation.FieldUserEmail]; !ok {
				selectedFields = append(selectedFields, bazelinvocation.FieldUserEmail)
				fieldSeen[bazelinvocation.FieldUserEmail] = struct{}{}
			}
		case "userLdap":
			if _, ok := fieldSeen[bazelinvocation.FieldUserLdap]; !ok {
				selectedFields = append(selectedFields, bazelinvocation.FieldUserLdap)
				fieldSeen[bazelinvocation.FieldUserLdap] = struct{}{}
			}
		case "cpu":
			if _, ok := fieldSeen[bazelinvocation.FieldCPU]; !ok {
				selectedFields = append(selectedFields, bazelinvocation.FieldCPU)
				fieldSeen[bazelinvocation.FieldCPU] = struct{}{}
			}
		case "platformName":
			if _, ok := fieldSeen[bazelinvocation.FieldPlatformName]; !ok {
				selectedFields = append(selectedFields, bazelinvocation.FieldPlatformName)
				fieldSeen[bazelinvocation.FieldPlatformName] = struct{}{}
			}
		case "hostname":
			if _, ok := fieldSeen[bazelinvocation.FieldHostname]; !ok {
				selectedFields = append(selectedFields, bazelinvocation.FieldHostname)
				fieldSeen[bazelinvocation.FieldHostname] = struct{}{}
			}
		case "isCiWorker":
			if _, ok := fieldSeen[bazelinvocation.FieldIsCiWorker]; !ok {
				selectedFields = append(selectedFields, bazelinvocation.FieldIsCiWorker)
				fieldSeen[bazelinvocation.FieldIsCiWorker] = struct{}{}
			}
		case "configurationMnemonic":
			if _, ok := fieldSeen[bazelinvocation.FieldConfigurationMnemonic]; !ok {
				selectedFields = append(selectedFields, bazelinvocation.FieldConfigurationMnemonic)
				fieldSeen[bazelinvocation.FieldConfigurationMnemonic] = struct{}{}
			}
		case "numFetches":
			if _, ok := fieldSeen[bazelinvocation.FieldNumFetches]; !ok {
				selectedFields = append(selectedFields, bazelinvocation.FieldNumFetches)
				fieldSeen[bazelinvocation.FieldNumFetches] = struct{}{}
			}
		case "instanceName":
			if _, ok := fieldSeen[bazelinvocation.FieldInstanceName]; !ok {
				selectedFields = append(selectedFields, bazelinvocation.FieldInstanceName)
				fieldSeen[bazelinvocation.FieldInstanceName] = struct{}{}
			}
		case "bazelVersion":
			if _, ok := fieldSeen[bazelinvocation.FieldBazelVersion]; !ok {
				selectedFields = append(selectedFields, bazelinvocation.FieldBazelVersion)
				fieldSeen[bazelinvocation.FieldBazelVersion] = struct{}{}
			}
		case "exitCodeName":
			if _, ok := fieldSeen[bazelinvocation.FieldExitCodeName]; !ok {
				selectedFields = append(selectedFields, bazelinvocation.FieldExitCodeName)
				fieldSeen[bazelinvocation.FieldExitCodeName] = struct{}{}
			}
		case "exitCodeCode":
			if _, ok := fieldSeen[bazelinvocation.FieldExitCodeCode]; !ok {
				selectedFields = append(selectedFields, bazelinvocation.FieldExitCodeCode)
				fieldSeen[bazelinvocation.FieldExitCodeCode] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		bi.Select(selectedFields...)
	}
	return nil
}

type bazelinvocationPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []BazelInvocationPaginateOption
}

func newBazelInvocationPaginateArgs(rv map[string]any) *bazelinvocationPaginateArgs {
	args := &bazelinvocationPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &BazelInvocationOrder{Field: &BazelInvocationOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithBazelInvocationOrder(order))
			}
		case *BazelInvocationOrder:
			if v != nil {
				args.opts = append(args.opts, WithBazelInvocationOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*BazelInvocationWhereInput); ok {
		args.opts = append(args.opts, WithBazelInvocationFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (bip *BazelInvocationProblemQuery) CollectFields(ctx context.Context, satisfies ...string) (*BazelInvocationProblemQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return bip, nil
	}
	if err := bip.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return bip, nil
}

func (bip *BazelInvocationProblemQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(bazelinvocationproblem.Columns))
		selectedFields = []string{bazelinvocationproblem.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "bazelInvocation":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BazelInvocationClient{config: bip.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, bazelinvocationImplementors)...); err != nil {
				return err
			}
			bip.withBazelInvocation = query
		case "problemType":
			if _, ok := fieldSeen[bazelinvocationproblem.FieldProblemType]; !ok {
				selectedFields = append(selectedFields, bazelinvocationproblem.FieldProblemType)
				fieldSeen[bazelinvocationproblem.FieldProblemType] = struct{}{}
			}
		case "label":
			if _, ok := fieldSeen[bazelinvocationproblem.FieldLabel]; !ok {
				selectedFields = append(selectedFields, bazelinvocationproblem.FieldLabel)
				fieldSeen[bazelinvocationproblem.FieldLabel] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		bip.Select(selectedFields...)
	}
	return nil
}

type bazelinvocationproblemPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []BazelInvocationProblemPaginateOption
}

func newBazelInvocationProblemPaginateArgs(rv map[string]any) *bazelinvocationproblemPaginateArgs {
	args := &bazelinvocationproblemPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*BazelInvocationProblemWhereInput); ok {
		args.opts = append(args.opts, WithBazelInvocationProblemFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (b *BlobQuery) CollectFields(ctx context.Context, satisfies ...string) (*BlobQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return b, nil
	}
	if err := b.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return b, nil
}

func (b *BlobQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(blob.Columns))
		selectedFields = []string{blob.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "uri":
			if _, ok := fieldSeen[blob.FieldURI]; !ok {
				selectedFields = append(selectedFields, blob.FieldURI)
				fieldSeen[blob.FieldURI] = struct{}{}
			}
		case "sizeBytes":
			if _, ok := fieldSeen[blob.FieldSizeBytes]; !ok {
				selectedFields = append(selectedFields, blob.FieldSizeBytes)
				fieldSeen[blob.FieldSizeBytes] = struct{}{}
			}
		case "archivingStatus":
			if _, ok := fieldSeen[blob.FieldArchivingStatus]; !ok {
				selectedFields = append(selectedFields, blob.FieldArchivingStatus)
				fieldSeen[blob.FieldArchivingStatus] = struct{}{}
			}
		case "reason":
			if _, ok := fieldSeen[blob.FieldReason]; !ok {
				selectedFields = append(selectedFields, blob.FieldReason)
				fieldSeen[blob.FieldReason] = struct{}{}
			}
		case "archiveURL":
			if _, ok := fieldSeen[blob.FieldArchiveURL]; !ok {
				selectedFields = append(selectedFields, blob.FieldArchiveURL)
				fieldSeen[blob.FieldArchiveURL] = struct{}{}
			}
		case "instanceName":
			if _, ok := fieldSeen[blob.FieldInstanceName]; !ok {
				selectedFields = append(selectedFields, blob.FieldInstanceName)
				fieldSeen[blob.FieldInstanceName] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		b.Select(selectedFields...)
	}
	return nil
}

type blobPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []BlobPaginateOption
}

func newBlobPaginateArgs(rv map[string]any) *blobPaginateArgs {
	args := &blobPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*BlobWhereInput); ok {
		args.opts = append(args.opts, WithBlobFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (b *BuildQuery) CollectFields(ctx context.Context, satisfies ...string) (*BuildQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return b, nil
	}
	if err := b.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return b, nil
}

func (b *BuildQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(build.Columns))
		selectedFields = []string{build.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "invocations":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BazelInvocationClient{config: b.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, bazelinvocationImplementors)...); err != nil {
				return err
			}
			b.WithNamedInvocations(alias, func(wq *BazelInvocationQuery) {
				*wq = *query
			})
		case "buildURL":
			if _, ok := fieldSeen[build.FieldBuildURL]; !ok {
				selectedFields = append(selectedFields, build.FieldBuildURL)
				fieldSeen[build.FieldBuildURL] = struct{}{}
			}
		case "buildUUID":
			if _, ok := fieldSeen[build.FieldBuildUUID]; !ok {
				selectedFields = append(selectedFields, build.FieldBuildUUID)
				fieldSeen[build.FieldBuildUUID] = struct{}{}
			}
		case "instanceName":
			if _, ok := fieldSeen[build.FieldInstanceName]; !ok {
				selectedFields = append(selectedFields, build.FieldInstanceName)
				fieldSeen[build.FieldInstanceName] = struct{}{}
			}
		case "timestamp":
			if _, ok := fieldSeen[build.FieldTimestamp]; !ok {
				selectedFields = append(selectedFields, build.FieldTimestamp)
				fieldSeen[build.FieldTimestamp] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		b.Select(selectedFields...)
	}
	return nil
}

type buildPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []BuildPaginateOption
}

func newBuildPaginateArgs(rv map[string]any) *buildPaginateArgs {
	args := &buildPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*BuildWhereInput); ok {
		args.opts = append(args.opts, WithBuildFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (bgm *BuildGraphMetricsQuery) CollectFields(ctx context.Context, satisfies ...string) (*BuildGraphMetricsQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return bgm, nil
	}
	if err := bgm.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return bgm, nil
}

func (bgm *BuildGraphMetricsQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(buildgraphmetrics.Columns))
		selectedFields = []string{buildgraphmetrics.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "metrics":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&MetricsClient{config: bgm.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, metricsImplementors)...); err != nil {
				return err
			}
			bgm.withMetrics = query

		case "dirtiedValues":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EvaluationStatClient{config: bgm.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, evaluationstatImplementors)...); err != nil {
				return err
			}
			bgm.withDirtiedValues = query

		case "changedValues":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EvaluationStatClient{config: bgm.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, evaluationstatImplementors)...); err != nil {
				return err
			}
			bgm.withChangedValues = query

		case "builtValues":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EvaluationStatClient{config: bgm.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, evaluationstatImplementors)...); err != nil {
				return err
			}
			bgm.withBuiltValues = query

		case "cleanedValues":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EvaluationStatClient{config: bgm.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, evaluationstatImplementors)...); err != nil {
				return err
			}
			bgm.withCleanedValues = query

		case "evaluatedValues":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EvaluationStatClient{config: bgm.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, evaluationstatImplementors)...); err != nil {
				return err
			}
			bgm.withEvaluatedValues = query
		case "actionLookupValueCount":
			if _, ok := fieldSeen[buildgraphmetrics.FieldActionLookupValueCount]; !ok {
				selectedFields = append(selectedFields, buildgraphmetrics.FieldActionLookupValueCount)
				fieldSeen[buildgraphmetrics.FieldActionLookupValueCount] = struct{}{}
			}
		case "actionLookupValueCountNotIncludingAspects":
			if _, ok := fieldSeen[buildgraphmetrics.FieldActionLookupValueCountNotIncludingAspects]; !ok {
				selectedFields = append(selectedFields, buildgraphmetrics.FieldActionLookupValueCountNotIncludingAspects)
				fieldSeen[buildgraphmetrics.FieldActionLookupValueCountNotIncludingAspects] = struct{}{}
			}
		case "actionCount":
			if _, ok := fieldSeen[buildgraphmetrics.FieldActionCount]; !ok {
				selectedFields = append(selectedFields, buildgraphmetrics.FieldActionCount)
				fieldSeen[buildgraphmetrics.FieldActionCount] = struct{}{}
			}
		case "actionCountNotIncludingAspects":
			if _, ok := fieldSeen[buildgraphmetrics.FieldActionCountNotIncludingAspects]; !ok {
				selectedFields = append(selectedFields, buildgraphmetrics.FieldActionCountNotIncludingAspects)
				fieldSeen[buildgraphmetrics.FieldActionCountNotIncludingAspects] = struct{}{}
			}
		case "inputFileConfiguredTargetCount":
			if _, ok := fieldSeen[buildgraphmetrics.FieldInputFileConfiguredTargetCount]; !ok {
				selectedFields = append(selectedFields, buildgraphmetrics.FieldInputFileConfiguredTargetCount)
				fieldSeen[buildgraphmetrics.FieldInputFileConfiguredTargetCount] = struct{}{}
			}
		case "outputFileConfiguredTargetCount":
			if _, ok := fieldSeen[buildgraphmetrics.FieldOutputFileConfiguredTargetCount]; !ok {
				selectedFields = append(selectedFields, buildgraphmetrics.FieldOutputFileConfiguredTargetCount)
				fieldSeen[buildgraphmetrics.FieldOutputFileConfiguredTargetCount] = struct{}{}
			}
		case "otherConfiguredTargetCount":
			if _, ok := fieldSeen[buildgraphmetrics.FieldOtherConfiguredTargetCount]; !ok {
				selectedFields = append(selectedFields, buildgraphmetrics.FieldOtherConfiguredTargetCount)
				fieldSeen[buildgraphmetrics.FieldOtherConfiguredTargetCount] = struct{}{}
			}
		case "outputArtifactCount":
			if _, ok := fieldSeen[buildgraphmetrics.FieldOutputArtifactCount]; !ok {
				selectedFields = append(selectedFields, buildgraphmetrics.FieldOutputArtifactCount)
				fieldSeen[buildgraphmetrics.FieldOutputArtifactCount] = struct{}{}
			}
		case "postInvocationSkyframeNodeCount":
			if _, ok := fieldSeen[buildgraphmetrics.FieldPostInvocationSkyframeNodeCount]; !ok {
				selectedFields = append(selectedFields, buildgraphmetrics.FieldPostInvocationSkyframeNodeCount)
				fieldSeen[buildgraphmetrics.FieldPostInvocationSkyframeNodeCount] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		bgm.Select(selectedFields...)
	}
	return nil
}

type buildgraphmetricsPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []BuildGraphMetricsPaginateOption
}

func newBuildGraphMetricsPaginateArgs(rv map[string]any) *buildgraphmetricsPaginateArgs {
	args := &buildgraphmetricsPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*BuildGraphMetricsWhereInput); ok {
		args.opts = append(args.opts, WithBuildGraphMetricsFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (cm *CumulativeMetricsQuery) CollectFields(ctx context.Context, satisfies ...string) (*CumulativeMetricsQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return cm, nil
	}
	if err := cm.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return cm, nil
}

func (cm *CumulativeMetricsQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(cumulativemetrics.Columns))
		selectedFields = []string{cumulativemetrics.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "metrics":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&MetricsClient{config: cm.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, metricsImplementors)...); err != nil {
				return err
			}
			cm.withMetrics = query
		case "numAnalyses":
			if _, ok := fieldSeen[cumulativemetrics.FieldNumAnalyses]; !ok {
				selectedFields = append(selectedFields, cumulativemetrics.FieldNumAnalyses)
				fieldSeen[cumulativemetrics.FieldNumAnalyses] = struct{}{}
			}
		case "numBuilds":
			if _, ok := fieldSeen[cumulativemetrics.FieldNumBuilds]; !ok {
				selectedFields = append(selectedFields, cumulativemetrics.FieldNumBuilds)
				fieldSeen[cumulativemetrics.FieldNumBuilds] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		cm.Select(selectedFields...)
	}
	return nil
}

type cumulativemetricsPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CumulativeMetricsPaginateOption
}

func newCumulativeMetricsPaginateArgs(rv map[string]any) *cumulativemetricsPaginateArgs {
	args := &cumulativemetricsPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*CumulativeMetricsWhereInput); ok {
		args.opts = append(args.opts, WithCumulativeMetricsFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (es *EvaluationStatQuery) CollectFields(ctx context.Context, satisfies ...string) (*EvaluationStatQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return es, nil
	}
	if err := es.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return es, nil
}

func (es *EvaluationStatQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(evaluationstat.Columns))
		selectedFields = []string{evaluationstat.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "buildGraphMetrics":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BuildGraphMetricsClient{config: es.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, buildgraphmetricsImplementors)...); err != nil {
				return err
			}
			es.withBuildGraphMetrics = query
		case "skyfunctionName":
			if _, ok := fieldSeen[evaluationstat.FieldSkyfunctionName]; !ok {
				selectedFields = append(selectedFields, evaluationstat.FieldSkyfunctionName)
				fieldSeen[evaluationstat.FieldSkyfunctionName] = struct{}{}
			}
		case "count":
			if _, ok := fieldSeen[evaluationstat.FieldCount]; !ok {
				selectedFields = append(selectedFields, evaluationstat.FieldCount)
				fieldSeen[evaluationstat.FieldCount] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		es.Select(selectedFields...)
	}
	return nil
}

type evaluationstatPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []EvaluationStatPaginateOption
}

func newEvaluationStatPaginateArgs(rv map[string]any) *evaluationstatPaginateArgs {
	args := &evaluationstatPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*EvaluationStatWhereInput); ok {
		args.opts = append(args.opts, WithEvaluationStatFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ei *ExectionInfoQuery) CollectFields(ctx context.Context, satisfies ...string) (*ExectionInfoQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ei, nil
	}
	if err := ei.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ei, nil
}

func (ei *ExectionInfoQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(exectioninfo.Columns))
		selectedFields = []string{exectioninfo.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "testResult":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TestResultBESClient{config: ei.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, testresultbesImplementors)...); err != nil {
				return err
			}
			ei.withTestResult = query

		case "timingBreakdown":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TimingBreakdownClient{config: ei.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, timingbreakdownImplementors)...); err != nil {
				return err
			}
			ei.withTimingBreakdown = query

		case "resourceUsage":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ResourceUsageClient{config: ei.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, resourceusageImplementors)...); err != nil {
				return err
			}
			ei.WithNamedResourceUsage(alias, func(wq *ResourceUsageQuery) {
				*wq = *query
			})
		case "timeoutSeconds":
			if _, ok := fieldSeen[exectioninfo.FieldTimeoutSeconds]; !ok {
				selectedFields = append(selectedFields, exectioninfo.FieldTimeoutSeconds)
				fieldSeen[exectioninfo.FieldTimeoutSeconds] = struct{}{}
			}
		case "strategy":
			if _, ok := fieldSeen[exectioninfo.FieldStrategy]; !ok {
				selectedFields = append(selectedFields, exectioninfo.FieldStrategy)
				fieldSeen[exectioninfo.FieldStrategy] = struct{}{}
			}
		case "cachedRemotely":
			if _, ok := fieldSeen[exectioninfo.FieldCachedRemotely]; !ok {
				selectedFields = append(selectedFields, exectioninfo.FieldCachedRemotely)
				fieldSeen[exectioninfo.FieldCachedRemotely] = struct{}{}
			}
		case "exitCode":
			if _, ok := fieldSeen[exectioninfo.FieldExitCode]; !ok {
				selectedFields = append(selectedFields, exectioninfo.FieldExitCode)
				fieldSeen[exectioninfo.FieldExitCode] = struct{}{}
			}
		case "hostname":
			if _, ok := fieldSeen[exectioninfo.FieldHostname]; !ok {
				selectedFields = append(selectedFields, exectioninfo.FieldHostname)
				fieldSeen[exectioninfo.FieldHostname] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ei.Select(selectedFields...)
	}
	return nil
}

type exectioninfoPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ExectionInfoPaginateOption
}

func newExectionInfoPaginateArgs(rv map[string]any) *exectioninfoPaginateArgs {
	args := &exectioninfoPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*ExectionInfoWhereInput); ok {
		args.opts = append(args.opts, WithExectionInfoFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (fm *FilesMetricQuery) CollectFields(ctx context.Context, satisfies ...string) (*FilesMetricQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return fm, nil
	}
	if err := fm.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return fm, nil
}

func (fm *FilesMetricQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(filesmetric.Columns))
		selectedFields = []string{filesmetric.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "artifactMetrics":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ArtifactMetricsClient{config: fm.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, artifactmetricsImplementors)...); err != nil {
				return err
			}
			fm.withArtifactMetrics = query
		case "sizeInBytes":
			if _, ok := fieldSeen[filesmetric.FieldSizeInBytes]; !ok {
				selectedFields = append(selectedFields, filesmetric.FieldSizeInBytes)
				fieldSeen[filesmetric.FieldSizeInBytes] = struct{}{}
			}
		case "count":
			if _, ok := fieldSeen[filesmetric.FieldCount]; !ok {
				selectedFields = append(selectedFields, filesmetric.FieldCount)
				fieldSeen[filesmetric.FieldCount] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		fm.Select(selectedFields...)
	}
	return nil
}

type filesmetricPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []FilesMetricPaginateOption
}

func newFilesMetricPaginateArgs(rv map[string]any) *filesmetricPaginateArgs {
	args := &filesmetricPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*FilesMetricWhereInput); ok {
		args.opts = append(args.opts, WithFilesMetricFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (gm *GarbageMetricsQuery) CollectFields(ctx context.Context, satisfies ...string) (*GarbageMetricsQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return gm, nil
	}
	if err := gm.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return gm, nil
}

func (gm *GarbageMetricsQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(garbagemetrics.Columns))
		selectedFields = []string{garbagemetrics.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "memoryMetrics":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&MemoryMetricsClient{config: gm.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, memorymetricsImplementors)...); err != nil {
				return err
			}
			gm.withMemoryMetrics = query
		case "type":
			if _, ok := fieldSeen[garbagemetrics.FieldType]; !ok {
				selectedFields = append(selectedFields, garbagemetrics.FieldType)
				fieldSeen[garbagemetrics.FieldType] = struct{}{}
			}
		case "garbageCollected":
			if _, ok := fieldSeen[garbagemetrics.FieldGarbageCollected]; !ok {
				selectedFields = append(selectedFields, garbagemetrics.FieldGarbageCollected)
				fieldSeen[garbagemetrics.FieldGarbageCollected] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		gm.Select(selectedFields...)
	}
	return nil
}

type garbagemetricsPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []GarbageMetricsPaginateOption
}

func newGarbageMetricsPaginateArgs(rv map[string]any) *garbagemetricsPaginateArgs {
	args := &garbagemetricsPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*GarbageMetricsWhereInput); ok {
		args.opts = append(args.opts, WithGarbageMetricsFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ibl *IncompleteBuildLogQuery) CollectFields(ctx context.Context, satisfies ...string) (*IncompleteBuildLogQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ibl, nil
	}
	if err := ibl.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ibl, nil
}

func (ibl *IncompleteBuildLogQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(incompletebuildlog.Columns))
		selectedFields = []string{incompletebuildlog.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "bazelInvocation":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BazelInvocationClient{config: ibl.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, bazelinvocationImplementors)...); err != nil {
				return err
			}
			ibl.withBazelInvocation = query
		case "snippetID":
			if _, ok := fieldSeen[incompletebuildlog.FieldSnippetID]; !ok {
				selectedFields = append(selectedFields, incompletebuildlog.FieldSnippetID)
				fieldSeen[incompletebuildlog.FieldSnippetID] = struct{}{}
			}
		case "logSnippet":
			if _, ok := fieldSeen[incompletebuildlog.FieldLogSnippet]; !ok {
				selectedFields = append(selectedFields, incompletebuildlog.FieldLogSnippet)
				fieldSeen[incompletebuildlog.FieldLogSnippet] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ibl.Select(selectedFields...)
	}
	return nil
}

type incompletebuildlogPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []IncompleteBuildLogPaginateOption
}

func newIncompleteBuildLogPaginateArgs(rv map[string]any) *incompletebuildlogPaginateArgs {
	args := &incompletebuildlogPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*IncompleteBuildLogWhereInput); ok {
		args.opts = append(args.opts, WithIncompleteBuildLogFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (_if *InvocationFilesQuery) CollectFields(ctx context.Context, satisfies ...string) (*InvocationFilesQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return _if, nil
	}
	if err := _if.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return _if, nil
}

func (_if *InvocationFilesQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(invocationfiles.Columns))
		selectedFields = []string{invocationfiles.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "bazelInvocation":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BazelInvocationClient{config: _if.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, bazelinvocationImplementors)...); err != nil {
				return err
			}
			_if.withBazelInvocation = query
		case "name":
			if _, ok := fieldSeen[invocationfiles.FieldName]; !ok {
				selectedFields = append(selectedFields, invocationfiles.FieldName)
				fieldSeen[invocationfiles.FieldName] = struct{}{}
			}
		case "content":
			if _, ok := fieldSeen[invocationfiles.FieldContent]; !ok {
				selectedFields = append(selectedFields, invocationfiles.FieldContent)
				fieldSeen[invocationfiles.FieldContent] = struct{}{}
			}
		case "digest":
			if _, ok := fieldSeen[invocationfiles.FieldDigest]; !ok {
				selectedFields = append(selectedFields, invocationfiles.FieldDigest)
				fieldSeen[invocationfiles.FieldDigest] = struct{}{}
			}
		case "sizeBytes":
			if _, ok := fieldSeen[invocationfiles.FieldSizeBytes]; !ok {
				selectedFields = append(selectedFields, invocationfiles.FieldSizeBytes)
				fieldSeen[invocationfiles.FieldSizeBytes] = struct{}{}
			}
		case "digestFunction":
			if _, ok := fieldSeen[invocationfiles.FieldDigestFunction]; !ok {
				selectedFields = append(selectedFields, invocationfiles.FieldDigestFunction)
				fieldSeen[invocationfiles.FieldDigestFunction] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		_if.Select(selectedFields...)
	}
	return nil
}

type invocationfilesPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []InvocationFilesPaginateOption
}

func newInvocationFilesPaginateArgs(rv map[string]any) *invocationfilesPaginateArgs {
	args := &invocationfilesPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*InvocationFilesWhereInput); ok {
		args.opts = append(args.opts, WithInvocationFilesFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (mm *MemoryMetricsQuery) CollectFields(ctx context.Context, satisfies ...string) (*MemoryMetricsQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return mm, nil
	}
	if err := mm.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return mm, nil
}

func (mm *MemoryMetricsQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(memorymetrics.Columns))
		selectedFields = []string{memorymetrics.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "metrics":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&MetricsClient{config: mm.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, metricsImplementors)...); err != nil {
				return err
			}
			mm.withMetrics = query

		case "garbageMetrics":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GarbageMetricsClient{config: mm.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, garbagemetricsImplementors)...); err != nil {
				return err
			}
			mm.WithNamedGarbageMetrics(alias, func(wq *GarbageMetricsQuery) {
				*wq = *query
			})
		case "peakPostGcHeapSize":
			if _, ok := fieldSeen[memorymetrics.FieldPeakPostGcHeapSize]; !ok {
				selectedFields = append(selectedFields, memorymetrics.FieldPeakPostGcHeapSize)
				fieldSeen[memorymetrics.FieldPeakPostGcHeapSize] = struct{}{}
			}
		case "usedHeapSizePostBuild":
			if _, ok := fieldSeen[memorymetrics.FieldUsedHeapSizePostBuild]; !ok {
				selectedFields = append(selectedFields, memorymetrics.FieldUsedHeapSizePostBuild)
				fieldSeen[memorymetrics.FieldUsedHeapSizePostBuild] = struct{}{}
			}
		case "peakPostGcTenuredSpaceHeapSize":
			if _, ok := fieldSeen[memorymetrics.FieldPeakPostGcTenuredSpaceHeapSize]; !ok {
				selectedFields = append(selectedFields, memorymetrics.FieldPeakPostGcTenuredSpaceHeapSize)
				fieldSeen[memorymetrics.FieldPeakPostGcTenuredSpaceHeapSize] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		mm.Select(selectedFields...)
	}
	return nil
}

type memorymetricsPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []MemoryMetricsPaginateOption
}

func newMemoryMetricsPaginateArgs(rv map[string]any) *memorymetricsPaginateArgs {
	args := &memorymetricsPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*MemoryMetricsWhereInput); ok {
		args.opts = append(args.opts, WithMemoryMetricsFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (m *MetricsQuery) CollectFields(ctx context.Context, satisfies ...string) (*MetricsQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return m, nil
	}
	if err := m.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return m, nil
}

func (m *MetricsQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "bazelInvocation":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BazelInvocationClient{config: m.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, bazelinvocationImplementors)...); err != nil {
				return err
			}
			m.withBazelInvocation = query

		case "actionSummary":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ActionSummaryClient{config: m.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, actionsummaryImplementors)...); err != nil {
				return err
			}
			m.withActionSummary = query

		case "memoryMetrics":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&MemoryMetricsClient{config: m.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, memorymetricsImplementors)...); err != nil {
				return err
			}
			m.withMemoryMetrics = query

		case "targetMetrics":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TargetMetricsClient{config: m.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, targetmetricsImplementors)...); err != nil {
				return err
			}
			m.withTargetMetrics = query

		case "packageMetrics":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PackageMetricsClient{config: m.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, packagemetricsImplementors)...); err != nil {
				return err
			}
			m.withPackageMetrics = query

		case "timingMetrics":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TimingMetricsClient{config: m.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, timingmetricsImplementors)...); err != nil {
				return err
			}
			m.withTimingMetrics = query

		case "cumulativeMetrics":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CumulativeMetricsClient{config: m.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, cumulativemetricsImplementors)...); err != nil {
				return err
			}
			m.withCumulativeMetrics = query

		case "artifactMetrics":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ArtifactMetricsClient{config: m.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, artifactmetricsImplementors)...); err != nil {
				return err
			}
			m.withArtifactMetrics = query

		case "networkMetrics":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&NetworkMetricsClient{config: m.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, networkmetricsImplementors)...); err != nil {
				return err
			}
			m.withNetworkMetrics = query

		case "buildGraphMetrics":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BuildGraphMetricsClient{config: m.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, buildgraphmetricsImplementors)...); err != nil {
				return err
			}
			m.withBuildGraphMetrics = query
		}
	}
	return nil
}

type metricsPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []MetricsPaginateOption
}

func newMetricsPaginateArgs(rv map[string]any) *metricsPaginateArgs {
	args := &metricsPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*MetricsWhereInput); ok {
		args.opts = append(args.opts, WithMetricsFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (md *MissDetailQuery) CollectFields(ctx context.Context, satisfies ...string) (*MissDetailQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return md, nil
	}
	if err := md.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return md, nil
}

func (md *MissDetailQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(missdetail.Columns))
		selectedFields = []string{missdetail.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "actionCacheStatistics":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ActionCacheStatisticsClient{config: md.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, actioncachestatisticsImplementors)...); err != nil {
				return err
			}
			md.withActionCacheStatistics = query
		case "reason":
			if _, ok := fieldSeen[missdetail.FieldReason]; !ok {
				selectedFields = append(selectedFields, missdetail.FieldReason)
				fieldSeen[missdetail.FieldReason] = struct{}{}
			}
		case "count":
			if _, ok := fieldSeen[missdetail.FieldCount]; !ok {
				selectedFields = append(selectedFields, missdetail.FieldCount)
				fieldSeen[missdetail.FieldCount] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		md.Select(selectedFields...)
	}
	return nil
}

type missdetailPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []MissDetailPaginateOption
}

func newMissDetailPaginateArgs(rv map[string]any) *missdetailPaginateArgs {
	args := &missdetailPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*MissDetailWhereInput); ok {
		args.opts = append(args.opts, WithMissDetailFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (nsof *NamedSetOfFilesQuery) CollectFields(ctx context.Context, satisfies ...string) (*NamedSetOfFilesQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nsof, nil
	}
	if err := nsof.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return nsof, nil
}

func (nsof *NamedSetOfFilesQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "outputGroup":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OutputGroupClient{config: nsof.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, outputgroupImplementors)...); err != nil {
				return err
			}
			nsof.withOutputGroup = query

		case "files":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TestFileClient{config: nsof.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, testfileImplementors)...); err != nil {
				return err
			}
			nsof.WithNamedFiles(alias, func(wq *TestFileQuery) {
				*wq = *query
			})

		case "fileSets":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&NamedSetOfFilesClient{config: nsof.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, namedsetoffilesImplementors)...); err != nil {
				return err
			}
			nsof.withFileSets = query
		}
	}
	return nil
}

type namedsetoffilesPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []NamedSetOfFilesPaginateOption
}

func newNamedSetOfFilesPaginateArgs(rv map[string]any) *namedsetoffilesPaginateArgs {
	args := &namedsetoffilesPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*NamedSetOfFilesWhereInput); ok {
		args.opts = append(args.opts, WithNamedSetOfFilesFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (nm *NetworkMetricsQuery) CollectFields(ctx context.Context, satisfies ...string) (*NetworkMetricsQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nm, nil
	}
	if err := nm.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return nm, nil
}

func (nm *NetworkMetricsQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "metrics":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&MetricsClient{config: nm.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, metricsImplementors)...); err != nil {
				return err
			}
			nm.withMetrics = query

		case "systemNetworkStats":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&SystemNetworkStatsClient{config: nm.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, systemnetworkstatsImplementors)...); err != nil {
				return err
			}
			nm.withSystemNetworkStats = query
		}
	}
	return nil
}

type networkmetricsPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []NetworkMetricsPaginateOption
}

func newNetworkMetricsPaginateArgs(rv map[string]any) *networkmetricsPaginateArgs {
	args := &networkmetricsPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*NetworkMetricsWhereInput); ok {
		args.opts = append(args.opts, WithNetworkMetricsFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (og *OutputGroupQuery) CollectFields(ctx context.Context, satisfies ...string) (*OutputGroupQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return og, nil
	}
	if err := og.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return og, nil
}

func (og *OutputGroupQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(outputgroup.Columns))
		selectedFields = []string{outputgroup.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "inlineFiles":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TestFileClient{config: og.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, testfileImplementors)...); err != nil {
				return err
			}
			og.WithNamedInlineFiles(alias, func(wq *TestFileQuery) {
				*wq = *query
			})

		case "fileSets":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&NamedSetOfFilesClient{config: og.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, namedsetoffilesImplementors)...); err != nil {
				return err
			}
			og.withFileSets = query
		case "name":
			if _, ok := fieldSeen[outputgroup.FieldName]; !ok {
				selectedFields = append(selectedFields, outputgroup.FieldName)
				fieldSeen[outputgroup.FieldName] = struct{}{}
			}
		case "incomplete":
			if _, ok := fieldSeen[outputgroup.FieldIncomplete]; !ok {
				selectedFields = append(selectedFields, outputgroup.FieldIncomplete)
				fieldSeen[outputgroup.FieldIncomplete] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		og.Select(selectedFields...)
	}
	return nil
}

type outputgroupPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []OutputGroupPaginateOption
}

func newOutputGroupPaginateArgs(rv map[string]any) *outputgroupPaginateArgs {
	args := &outputgroupPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*OutputGroupWhereInput); ok {
		args.opts = append(args.opts, WithOutputGroupFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (plm *PackageLoadMetricsQuery) CollectFields(ctx context.Context, satisfies ...string) (*PackageLoadMetricsQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return plm, nil
	}
	if err := plm.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return plm, nil
}

func (plm *PackageLoadMetricsQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(packageloadmetrics.Columns))
		selectedFields = []string{packageloadmetrics.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "packageMetrics":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PackageMetricsClient{config: plm.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, packagemetricsImplementors)...); err != nil {
				return err
			}
			plm.withPackageMetrics = query
		case "name":
			if _, ok := fieldSeen[packageloadmetrics.FieldName]; !ok {
				selectedFields = append(selectedFields, packageloadmetrics.FieldName)
				fieldSeen[packageloadmetrics.FieldName] = struct{}{}
			}
		case "loadDuration":
			if _, ok := fieldSeen[packageloadmetrics.FieldLoadDuration]; !ok {
				selectedFields = append(selectedFields, packageloadmetrics.FieldLoadDuration)
				fieldSeen[packageloadmetrics.FieldLoadDuration] = struct{}{}
			}
		case "numTargets":
			if _, ok := fieldSeen[packageloadmetrics.FieldNumTargets]; !ok {
				selectedFields = append(selectedFields, packageloadmetrics.FieldNumTargets)
				fieldSeen[packageloadmetrics.FieldNumTargets] = struct{}{}
			}
		case "computationSteps":
			if _, ok := fieldSeen[packageloadmetrics.FieldComputationSteps]; !ok {
				selectedFields = append(selectedFields, packageloadmetrics.FieldComputationSteps)
				fieldSeen[packageloadmetrics.FieldComputationSteps] = struct{}{}
			}
		case "numTransitiveLoads":
			if _, ok := fieldSeen[packageloadmetrics.FieldNumTransitiveLoads]; !ok {
				selectedFields = append(selectedFields, packageloadmetrics.FieldNumTransitiveLoads)
				fieldSeen[packageloadmetrics.FieldNumTransitiveLoads] = struct{}{}
			}
		case "packageOverhead":
			if _, ok := fieldSeen[packageloadmetrics.FieldPackageOverhead]; !ok {
				selectedFields = append(selectedFields, packageloadmetrics.FieldPackageOverhead)
				fieldSeen[packageloadmetrics.FieldPackageOverhead] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		plm.Select(selectedFields...)
	}
	return nil
}

type packageloadmetricsPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []PackageLoadMetricsPaginateOption
}

func newPackageLoadMetricsPaginateArgs(rv map[string]any) *packageloadmetricsPaginateArgs {
	args := &packageloadmetricsPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*PackageLoadMetricsWhereInput); ok {
		args.opts = append(args.opts, WithPackageLoadMetricsFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pm *PackageMetricsQuery) CollectFields(ctx context.Context, satisfies ...string) (*PackageMetricsQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pm, nil
	}
	if err := pm.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pm, nil
}

func (pm *PackageMetricsQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(packagemetrics.Columns))
		selectedFields = []string{packagemetrics.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "metrics":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&MetricsClient{config: pm.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, metricsImplementors)...); err != nil {
				return err
			}
			pm.withMetrics = query

		case "packageLoadMetrics":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PackageLoadMetricsClient{config: pm.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, packageloadmetricsImplementors)...); err != nil {
				return err
			}
			pm.WithNamedPackageLoadMetrics(alias, func(wq *PackageLoadMetricsQuery) {
				*wq = *query
			})
		case "packagesLoaded":
			if _, ok := fieldSeen[packagemetrics.FieldPackagesLoaded]; !ok {
				selectedFields = append(selectedFields, packagemetrics.FieldPackagesLoaded)
				fieldSeen[packagemetrics.FieldPackagesLoaded] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pm.Select(selectedFields...)
	}
	return nil
}

type packagemetricsPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []PackageMetricsPaginateOption
}

func newPackageMetricsPaginateArgs(rv map[string]any) *packagemetricsPaginateArgs {
	args := &packagemetricsPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*PackageMetricsWhereInput); ok {
		args.opts = append(args.opts, WithPackageMetricsFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ru *ResourceUsageQuery) CollectFields(ctx context.Context, satisfies ...string) (*ResourceUsageQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ru, nil
	}
	if err := ru.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ru, nil
}

func (ru *ResourceUsageQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(resourceusage.Columns))
		selectedFields = []string{resourceusage.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "executionInfo":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ExectionInfoClient{config: ru.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, exectioninfoImplementors)...); err != nil {
				return err
			}
			ru.withExecutionInfo = query
		case "name":
			if _, ok := fieldSeen[resourceusage.FieldName]; !ok {
				selectedFields = append(selectedFields, resourceusage.FieldName)
				fieldSeen[resourceusage.FieldName] = struct{}{}
			}
		case "value":
			if _, ok := fieldSeen[resourceusage.FieldValue]; !ok {
				selectedFields = append(selectedFields, resourceusage.FieldValue)
				fieldSeen[resourceusage.FieldValue] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ru.Select(selectedFields...)
	}
	return nil
}

type resourceusagePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ResourceUsagePaginateOption
}

func newResourceUsagePaginateArgs(rv map[string]any) *resourceusagePaginateArgs {
	args := &resourceusagePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*ResourceUsageWhereInput); ok {
		args.opts = append(args.opts, WithResourceUsageFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (rc *RunnerCountQuery) CollectFields(ctx context.Context, satisfies ...string) (*RunnerCountQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return rc, nil
	}
	if err := rc.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return rc, nil
}

func (rc *RunnerCountQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(runnercount.Columns))
		selectedFields = []string{runnercount.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "actionSummary":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ActionSummaryClient{config: rc.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, actionsummaryImplementors)...); err != nil {
				return err
			}
			rc.withActionSummary = query
		case "name":
			if _, ok := fieldSeen[runnercount.FieldName]; !ok {
				selectedFields = append(selectedFields, runnercount.FieldName)
				fieldSeen[runnercount.FieldName] = struct{}{}
			}
		case "execKind":
			if _, ok := fieldSeen[runnercount.FieldExecKind]; !ok {
				selectedFields = append(selectedFields, runnercount.FieldExecKind)
				fieldSeen[runnercount.FieldExecKind] = struct{}{}
			}
		case "actionsExecuted":
			if _, ok := fieldSeen[runnercount.FieldActionsExecuted]; !ok {
				selectedFields = append(selectedFields, runnercount.FieldActionsExecuted)
				fieldSeen[runnercount.FieldActionsExecuted] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		rc.Select(selectedFields...)
	}
	return nil
}

type runnercountPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []RunnerCountPaginateOption
}

func newRunnerCountPaginateArgs(rv map[string]any) *runnercountPaginateArgs {
	args := &runnercountPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*RunnerCountWhereInput); ok {
		args.opts = append(args.opts, WithRunnerCountFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (sc *SourceControlQuery) CollectFields(ctx context.Context, satisfies ...string) (*SourceControlQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return sc, nil
	}
	if err := sc.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return sc, nil
}

func (sc *SourceControlQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(sourcecontrol.Columns))
		selectedFields = []string{sourcecontrol.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "bazelInvocation":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BazelInvocationClient{config: sc.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, bazelinvocationImplementors)...); err != nil {
				return err
			}
			sc.withBazelInvocation = query
		case "provider":
			if _, ok := fieldSeen[sourcecontrol.FieldProvider]; !ok {
				selectedFields = append(selectedFields, sourcecontrol.FieldProvider)
				fieldSeen[sourcecontrol.FieldProvider] = struct{}{}
			}
		case "instanceURL":
			if _, ok := fieldSeen[sourcecontrol.FieldInstanceURL]; !ok {
				selectedFields = append(selectedFields, sourcecontrol.FieldInstanceURL)
				fieldSeen[sourcecontrol.FieldInstanceURL] = struct{}{}
			}
		case "repo":
			if _, ok := fieldSeen[sourcecontrol.FieldRepo]; !ok {
				selectedFields = append(selectedFields, sourcecontrol.FieldRepo)
				fieldSeen[sourcecontrol.FieldRepo] = struct{}{}
			}
		case "refs":
			if _, ok := fieldSeen[sourcecontrol.FieldRefs]; !ok {
				selectedFields = append(selectedFields, sourcecontrol.FieldRefs)
				fieldSeen[sourcecontrol.FieldRefs] = struct{}{}
			}
		case "commitSha":
			if _, ok := fieldSeen[sourcecontrol.FieldCommitSha]; !ok {
				selectedFields = append(selectedFields, sourcecontrol.FieldCommitSha)
				fieldSeen[sourcecontrol.FieldCommitSha] = struct{}{}
			}
		case "actor":
			if _, ok := fieldSeen[sourcecontrol.FieldActor]; !ok {
				selectedFields = append(selectedFields, sourcecontrol.FieldActor)
				fieldSeen[sourcecontrol.FieldActor] = struct{}{}
			}
		case "eventName":
			if _, ok := fieldSeen[sourcecontrol.FieldEventName]; !ok {
				selectedFields = append(selectedFields, sourcecontrol.FieldEventName)
				fieldSeen[sourcecontrol.FieldEventName] = struct{}{}
			}
		case "workflow":
			if _, ok := fieldSeen[sourcecontrol.FieldWorkflow]; !ok {
				selectedFields = append(selectedFields, sourcecontrol.FieldWorkflow)
				fieldSeen[sourcecontrol.FieldWorkflow] = struct{}{}
			}
		case "runID":
			if _, ok := fieldSeen[sourcecontrol.FieldRunID]; !ok {
				selectedFields = append(selectedFields, sourcecontrol.FieldRunID)
				fieldSeen[sourcecontrol.FieldRunID] = struct{}{}
			}
		case "runNumber":
			if _, ok := fieldSeen[sourcecontrol.FieldRunNumber]; !ok {
				selectedFields = append(selectedFields, sourcecontrol.FieldRunNumber)
				fieldSeen[sourcecontrol.FieldRunNumber] = struct{}{}
			}
		case "job":
			if _, ok := fieldSeen[sourcecontrol.FieldJob]; !ok {
				selectedFields = append(selectedFields, sourcecontrol.FieldJob)
				fieldSeen[sourcecontrol.FieldJob] = struct{}{}
			}
		case "action":
			if _, ok := fieldSeen[sourcecontrol.FieldAction]; !ok {
				selectedFields = append(selectedFields, sourcecontrol.FieldAction)
				fieldSeen[sourcecontrol.FieldAction] = struct{}{}
			}
		case "runnerName":
			if _, ok := fieldSeen[sourcecontrol.FieldRunnerName]; !ok {
				selectedFields = append(selectedFields, sourcecontrol.FieldRunnerName)
				fieldSeen[sourcecontrol.FieldRunnerName] = struct{}{}
			}
		case "runnerArch":
			if _, ok := fieldSeen[sourcecontrol.FieldRunnerArch]; !ok {
				selectedFields = append(selectedFields, sourcecontrol.FieldRunnerArch)
				fieldSeen[sourcecontrol.FieldRunnerArch] = struct{}{}
			}
		case "runnerOs":
			if _, ok := fieldSeen[sourcecontrol.FieldRunnerOs]; !ok {
				selectedFields = append(selectedFields, sourcecontrol.FieldRunnerOs)
				fieldSeen[sourcecontrol.FieldRunnerOs] = struct{}{}
			}
		case "workspace":
			if _, ok := fieldSeen[sourcecontrol.FieldWorkspace]; !ok {
				selectedFields = append(selectedFields, sourcecontrol.FieldWorkspace)
				fieldSeen[sourcecontrol.FieldWorkspace] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		sc.Select(selectedFields...)
	}
	return nil
}

type sourcecontrolPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []SourceControlPaginateOption
}

func newSourceControlPaginateArgs(rv map[string]any) *sourcecontrolPaginateArgs {
	args := &sourcecontrolPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*SourceControlWhereInput); ok {
		args.opts = append(args.opts, WithSourceControlFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (sns *SystemNetworkStatsQuery) CollectFields(ctx context.Context, satisfies ...string) (*SystemNetworkStatsQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return sns, nil
	}
	if err := sns.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return sns, nil
}

func (sns *SystemNetworkStatsQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(systemnetworkstats.Columns))
		selectedFields = []string{systemnetworkstats.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "networkMetrics":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&NetworkMetricsClient{config: sns.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, networkmetricsImplementors)...); err != nil {
				return err
			}
			sns.withNetworkMetrics = query
		case "bytesSent":
			if _, ok := fieldSeen[systemnetworkstats.FieldBytesSent]; !ok {
				selectedFields = append(selectedFields, systemnetworkstats.FieldBytesSent)
				fieldSeen[systemnetworkstats.FieldBytesSent] = struct{}{}
			}
		case "bytesRecv":
			if _, ok := fieldSeen[systemnetworkstats.FieldBytesRecv]; !ok {
				selectedFields = append(selectedFields, systemnetworkstats.FieldBytesRecv)
				fieldSeen[systemnetworkstats.FieldBytesRecv] = struct{}{}
			}
		case "packetsSent":
			if _, ok := fieldSeen[systemnetworkstats.FieldPacketsSent]; !ok {
				selectedFields = append(selectedFields, systemnetworkstats.FieldPacketsSent)
				fieldSeen[systemnetworkstats.FieldPacketsSent] = struct{}{}
			}
		case "packetsRecv":
			if _, ok := fieldSeen[systemnetworkstats.FieldPacketsRecv]; !ok {
				selectedFields = append(selectedFields, systemnetworkstats.FieldPacketsRecv)
				fieldSeen[systemnetworkstats.FieldPacketsRecv] = struct{}{}
			}
		case "peakBytesSentPerSec":
			if _, ok := fieldSeen[systemnetworkstats.FieldPeakBytesSentPerSec]; !ok {
				selectedFields = append(selectedFields, systemnetworkstats.FieldPeakBytesSentPerSec)
				fieldSeen[systemnetworkstats.FieldPeakBytesSentPerSec] = struct{}{}
			}
		case "peakBytesRecvPerSec":
			if _, ok := fieldSeen[systemnetworkstats.FieldPeakBytesRecvPerSec]; !ok {
				selectedFields = append(selectedFields, systemnetworkstats.FieldPeakBytesRecvPerSec)
				fieldSeen[systemnetworkstats.FieldPeakBytesRecvPerSec] = struct{}{}
			}
		case "peakPacketsSentPerSec":
			if _, ok := fieldSeen[systemnetworkstats.FieldPeakPacketsSentPerSec]; !ok {
				selectedFields = append(selectedFields, systemnetworkstats.FieldPeakPacketsSentPerSec)
				fieldSeen[systemnetworkstats.FieldPeakPacketsSentPerSec] = struct{}{}
			}
		case "peakPacketsRecvPerSec":
			if _, ok := fieldSeen[systemnetworkstats.FieldPeakPacketsRecvPerSec]; !ok {
				selectedFields = append(selectedFields, systemnetworkstats.FieldPeakPacketsRecvPerSec)
				fieldSeen[systemnetworkstats.FieldPeakPacketsRecvPerSec] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		sns.Select(selectedFields...)
	}
	return nil
}

type systemnetworkstatsPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []SystemNetworkStatsPaginateOption
}

func newSystemNetworkStatsPaginateArgs(rv map[string]any) *systemnetworkstatsPaginateArgs {
	args := &systemnetworkstatsPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*SystemNetworkStatsWhereInput); ok {
		args.opts = append(args.opts, WithSystemNetworkStatsFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (t *TargetQuery) CollectFields(ctx context.Context, satisfies ...string) (*TargetQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return t, nil
	}
	if err := t.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return t, nil
}

func (t *TargetQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(target.Columns))
		selectedFields = []string{target.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "bazelInvocation":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BazelInvocationClient{config: t.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, bazelinvocationImplementors)...); err != nil {
				return err
			}
			t.withBazelInvocation = query
		case "label":
			if _, ok := fieldSeen[target.FieldLabel]; !ok {
				selectedFields = append(selectedFields, target.FieldLabel)
				fieldSeen[target.FieldLabel] = struct{}{}
			}
		case "tag":
			if _, ok := fieldSeen[target.FieldTag]; !ok {
				selectedFields = append(selectedFields, target.FieldTag)
				fieldSeen[target.FieldTag] = struct{}{}
			}
		case "targetKind":
			if _, ok := fieldSeen[target.FieldTargetKind]; !ok {
				selectedFields = append(selectedFields, target.FieldTargetKind)
				fieldSeen[target.FieldTargetKind] = struct{}{}
			}
		case "testSize":
			if _, ok := fieldSeen[target.FieldTestSize]; !ok {
				selectedFields = append(selectedFields, target.FieldTestSize)
				fieldSeen[target.FieldTestSize] = struct{}{}
			}
		case "success":
			if _, ok := fieldSeen[target.FieldSuccess]; !ok {
				selectedFields = append(selectedFields, target.FieldSuccess)
				fieldSeen[target.FieldSuccess] = struct{}{}
			}
		case "testTimeout":
			if _, ok := fieldSeen[target.FieldTestTimeout]; !ok {
				selectedFields = append(selectedFields, target.FieldTestTimeout)
				fieldSeen[target.FieldTestTimeout] = struct{}{}
			}
		case "startTimeInMs":
			if _, ok := fieldSeen[target.FieldStartTimeInMs]; !ok {
				selectedFields = append(selectedFields, target.FieldStartTimeInMs)
				fieldSeen[target.FieldStartTimeInMs] = struct{}{}
			}
		case "endTimeInMs":
			if _, ok := fieldSeen[target.FieldEndTimeInMs]; !ok {
				selectedFields = append(selectedFields, target.FieldEndTimeInMs)
				fieldSeen[target.FieldEndTimeInMs] = struct{}{}
			}
		case "durationInMs":
			if _, ok := fieldSeen[target.FieldDurationInMs]; !ok {
				selectedFields = append(selectedFields, target.FieldDurationInMs)
				fieldSeen[target.FieldDurationInMs] = struct{}{}
			}
		case "abortReason":
			if _, ok := fieldSeen[target.FieldAbortReason]; !ok {
				selectedFields = append(selectedFields, target.FieldAbortReason)
				fieldSeen[target.FieldAbortReason] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		t.Select(selectedFields...)
	}
	return nil
}

type targetPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []TargetPaginateOption
}

func newTargetPaginateArgs(rv map[string]any) *targetPaginateArgs {
	args := &targetPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &TargetOrder{Field: &TargetOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithTargetOrder(order))
			}
		case *TargetOrder:
			if v != nil {
				args.opts = append(args.opts, WithTargetOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*TargetWhereInput); ok {
		args.opts = append(args.opts, WithTargetFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (tm *TargetMetricsQuery) CollectFields(ctx context.Context, satisfies ...string) (*TargetMetricsQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return tm, nil
	}
	if err := tm.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return tm, nil
}

func (tm *TargetMetricsQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(targetmetrics.Columns))
		selectedFields = []string{targetmetrics.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "metrics":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&MetricsClient{config: tm.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, metricsImplementors)...); err != nil {
				return err
			}
			tm.withMetrics = query
		case "targetsLoaded":
			if _, ok := fieldSeen[targetmetrics.FieldTargetsLoaded]; !ok {
				selectedFields = append(selectedFields, targetmetrics.FieldTargetsLoaded)
				fieldSeen[targetmetrics.FieldTargetsLoaded] = struct{}{}
			}
		case "targetsConfigured":
			if _, ok := fieldSeen[targetmetrics.FieldTargetsConfigured]; !ok {
				selectedFields = append(selectedFields, targetmetrics.FieldTargetsConfigured)
				fieldSeen[targetmetrics.FieldTargetsConfigured] = struct{}{}
			}
		case "targetsConfiguredNotIncludingAspects":
			if _, ok := fieldSeen[targetmetrics.FieldTargetsConfiguredNotIncludingAspects]; !ok {
				selectedFields = append(selectedFields, targetmetrics.FieldTargetsConfiguredNotIncludingAspects)
				fieldSeen[targetmetrics.FieldTargetsConfiguredNotIncludingAspects] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		tm.Select(selectedFields...)
	}
	return nil
}

type targetmetricsPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []TargetMetricsPaginateOption
}

func newTargetMetricsPaginateArgs(rv map[string]any) *targetmetricsPaginateArgs {
	args := &targetmetricsPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*TargetMetricsWhereInput); ok {
		args.opts = append(args.opts, WithTargetMetricsFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (tc *TestCollectionQuery) CollectFields(ctx context.Context, satisfies ...string) (*TestCollectionQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return tc, nil
	}
	if err := tc.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return tc, nil
}

func (tc *TestCollectionQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(testcollection.Columns))
		selectedFields = []string{testcollection.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "bazelInvocation":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BazelInvocationClient{config: tc.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, bazelinvocationImplementors)...); err != nil {
				return err
			}
			tc.withBazelInvocation = query

		case "testSummary":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TestSummaryClient{config: tc.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, testsummaryImplementors)...); err != nil {
				return err
			}
			tc.withTestSummary = query

		case "testResults":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TestResultBESClient{config: tc.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, testresultbesImplementors)...); err != nil {
				return err
			}
			tc.WithNamedTestResults(alias, func(wq *TestResultBESQuery) {
				*wq = *query
			})
		case "label":
			if _, ok := fieldSeen[testcollection.FieldLabel]; !ok {
				selectedFields = append(selectedFields, testcollection.FieldLabel)
				fieldSeen[testcollection.FieldLabel] = struct{}{}
			}
		case "overallStatus":
			if _, ok := fieldSeen[testcollection.FieldOverallStatus]; !ok {
				selectedFields = append(selectedFields, testcollection.FieldOverallStatus)
				fieldSeen[testcollection.FieldOverallStatus] = struct{}{}
			}
		case "strategy":
			if _, ok := fieldSeen[testcollection.FieldStrategy]; !ok {
				selectedFields = append(selectedFields, testcollection.FieldStrategy)
				fieldSeen[testcollection.FieldStrategy] = struct{}{}
			}
		case "cachedLocally":
			if _, ok := fieldSeen[testcollection.FieldCachedLocally]; !ok {
				selectedFields = append(selectedFields, testcollection.FieldCachedLocally)
				fieldSeen[testcollection.FieldCachedLocally] = struct{}{}
			}
		case "cachedRemotely":
			if _, ok := fieldSeen[testcollection.FieldCachedRemotely]; !ok {
				selectedFields = append(selectedFields, testcollection.FieldCachedRemotely)
				fieldSeen[testcollection.FieldCachedRemotely] = struct{}{}
			}
		case "firstSeen":
			if _, ok := fieldSeen[testcollection.FieldFirstSeen]; !ok {
				selectedFields = append(selectedFields, testcollection.FieldFirstSeen)
				fieldSeen[testcollection.FieldFirstSeen] = struct{}{}
			}
		case "durationMs":
			if _, ok := fieldSeen[testcollection.FieldDurationMs]; !ok {
				selectedFields = append(selectedFields, testcollection.FieldDurationMs)
				fieldSeen[testcollection.FieldDurationMs] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		tc.Select(selectedFields...)
	}
	return nil
}

type testcollectionPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []TestCollectionPaginateOption
}

func newTestCollectionPaginateArgs(rv map[string]any) *testcollectionPaginateArgs {
	args := &testcollectionPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &TestCollectionOrder{Field: &TestCollectionOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithTestCollectionOrder(order))
			}
		case *TestCollectionOrder:
			if v != nil {
				args.opts = append(args.opts, WithTestCollectionOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*TestCollectionWhereInput); ok {
		args.opts = append(args.opts, WithTestCollectionFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (tf *TestFileQuery) CollectFields(ctx context.Context, satisfies ...string) (*TestFileQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return tf, nil
	}
	if err := tf.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return tf, nil
}

func (tf *TestFileQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(testfile.Columns))
		selectedFields = []string{testfile.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "testResult":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TestResultBESClient{config: tf.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, testresultbesImplementors)...); err != nil {
				return err
			}
			tf.withTestResult = query
		case "digest":
			if _, ok := fieldSeen[testfile.FieldDigest]; !ok {
				selectedFields = append(selectedFields, testfile.FieldDigest)
				fieldSeen[testfile.FieldDigest] = struct{}{}
			}
		case "file":
			if _, ok := fieldSeen[testfile.FieldFile]; !ok {
				selectedFields = append(selectedFields, testfile.FieldFile)
				fieldSeen[testfile.FieldFile] = struct{}{}
			}
		case "length":
			if _, ok := fieldSeen[testfile.FieldLength]; !ok {
				selectedFields = append(selectedFields, testfile.FieldLength)
				fieldSeen[testfile.FieldLength] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[testfile.FieldName]; !ok {
				selectedFields = append(selectedFields, testfile.FieldName)
				fieldSeen[testfile.FieldName] = struct{}{}
			}
		case "prefix":
			if _, ok := fieldSeen[testfile.FieldPrefix]; !ok {
				selectedFields = append(selectedFields, testfile.FieldPrefix)
				fieldSeen[testfile.FieldPrefix] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		tf.Select(selectedFields...)
	}
	return nil
}

type testfilePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []TestFilePaginateOption
}

func newTestFilePaginateArgs(rv map[string]any) *testfilePaginateArgs {
	args := &testfilePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*TestFileWhereInput); ok {
		args.opts = append(args.opts, WithTestFileFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (trb *TestResultBESQuery) CollectFields(ctx context.Context, satisfies ...string) (*TestResultBESQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return trb, nil
	}
	if err := trb.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return trb, nil
}

func (trb *TestResultBESQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(testresultbes.Columns))
		selectedFields = []string{testresultbes.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "testCollection":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TestCollectionClient{config: trb.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, testcollectionImplementors)...); err != nil {
				return err
			}
			trb.withTestCollection = query

		case "testActionOutput":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TestFileClient{config: trb.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, testfileImplementors)...); err != nil {
				return err
			}
			trb.WithNamedTestActionOutput(alias, func(wq *TestFileQuery) {
				*wq = *query
			})

		case "executionInfo":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ExectionInfoClient{config: trb.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, exectioninfoImplementors)...); err != nil {
				return err
			}
			trb.withExecutionInfo = query
		case "testStatus":
			if _, ok := fieldSeen[testresultbes.FieldTestStatus]; !ok {
				selectedFields = append(selectedFields, testresultbes.FieldTestStatus)
				fieldSeen[testresultbes.FieldTestStatus] = struct{}{}
			}
		case "statusDetails":
			if _, ok := fieldSeen[testresultbes.FieldStatusDetails]; !ok {
				selectedFields = append(selectedFields, testresultbes.FieldStatusDetails)
				fieldSeen[testresultbes.FieldStatusDetails] = struct{}{}
			}
		case "label":
			if _, ok := fieldSeen[testresultbes.FieldLabel]; !ok {
				selectedFields = append(selectedFields, testresultbes.FieldLabel)
				fieldSeen[testresultbes.FieldLabel] = struct{}{}
			}
		case "warning":
			if _, ok := fieldSeen[testresultbes.FieldWarning]; !ok {
				selectedFields = append(selectedFields, testresultbes.FieldWarning)
				fieldSeen[testresultbes.FieldWarning] = struct{}{}
			}
		case "cachedLocally":
			if _, ok := fieldSeen[testresultbes.FieldCachedLocally]; !ok {
				selectedFields = append(selectedFields, testresultbes.FieldCachedLocally)
				fieldSeen[testresultbes.FieldCachedLocally] = struct{}{}
			}
		case "testAttemptStartMillisEpoch":
			if _, ok := fieldSeen[testresultbes.FieldTestAttemptStartMillisEpoch]; !ok {
				selectedFields = append(selectedFields, testresultbes.FieldTestAttemptStartMillisEpoch)
				fieldSeen[testresultbes.FieldTestAttemptStartMillisEpoch] = struct{}{}
			}
		case "testAttemptStart":
			if _, ok := fieldSeen[testresultbes.FieldTestAttemptStart]; !ok {
				selectedFields = append(selectedFields, testresultbes.FieldTestAttemptStart)
				fieldSeen[testresultbes.FieldTestAttemptStart] = struct{}{}
			}
		case "testAttemptDurationMillis":
			if _, ok := fieldSeen[testresultbes.FieldTestAttemptDurationMillis]; !ok {
				selectedFields = append(selectedFields, testresultbes.FieldTestAttemptDurationMillis)
				fieldSeen[testresultbes.FieldTestAttemptDurationMillis] = struct{}{}
			}
		case "testAttemptDuration":
			if _, ok := fieldSeen[testresultbes.FieldTestAttemptDuration]; !ok {
				selectedFields = append(selectedFields, testresultbes.FieldTestAttemptDuration)
				fieldSeen[testresultbes.FieldTestAttemptDuration] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		trb.Select(selectedFields...)
	}
	return nil
}

type testresultbesPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []TestResultBESPaginateOption
}

func newTestResultBESPaginateArgs(rv map[string]any) *testresultbesPaginateArgs {
	args := &testresultbesPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*TestResultBESWhereInput); ok {
		args.opts = append(args.opts, WithTestResultBESFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ts *TestSummaryQuery) CollectFields(ctx context.Context, satisfies ...string) (*TestSummaryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ts, nil
	}
	if err := ts.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ts, nil
}

func (ts *TestSummaryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(testsummary.Columns))
		selectedFields = []string{testsummary.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "testCollection":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TestCollectionClient{config: ts.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, testcollectionImplementors)...); err != nil {
				return err
			}
			ts.withTestCollection = query

		case "passed":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TestFileClient{config: ts.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, testfileImplementors)...); err != nil {
				return err
			}
			ts.WithNamedPassed(alias, func(wq *TestFileQuery) {
				*wq = *query
			})

		case "failed":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TestFileClient{config: ts.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, testfileImplementors)...); err != nil {
				return err
			}
			ts.WithNamedFailed(alias, func(wq *TestFileQuery) {
				*wq = *query
			})
		case "overallStatus":
			if _, ok := fieldSeen[testsummary.FieldOverallStatus]; !ok {
				selectedFields = append(selectedFields, testsummary.FieldOverallStatus)
				fieldSeen[testsummary.FieldOverallStatus] = struct{}{}
			}
		case "totalRunCount":
			if _, ok := fieldSeen[testsummary.FieldTotalRunCount]; !ok {
				selectedFields = append(selectedFields, testsummary.FieldTotalRunCount)
				fieldSeen[testsummary.FieldTotalRunCount] = struct{}{}
			}
		case "runCount":
			if _, ok := fieldSeen[testsummary.FieldRunCount]; !ok {
				selectedFields = append(selectedFields, testsummary.FieldRunCount)
				fieldSeen[testsummary.FieldRunCount] = struct{}{}
			}
		case "attemptCount":
			if _, ok := fieldSeen[testsummary.FieldAttemptCount]; !ok {
				selectedFields = append(selectedFields, testsummary.FieldAttemptCount)
				fieldSeen[testsummary.FieldAttemptCount] = struct{}{}
			}
		case "shardCount":
			if _, ok := fieldSeen[testsummary.FieldShardCount]; !ok {
				selectedFields = append(selectedFields, testsummary.FieldShardCount)
				fieldSeen[testsummary.FieldShardCount] = struct{}{}
			}
		case "totalNumCached":
			if _, ok := fieldSeen[testsummary.FieldTotalNumCached]; !ok {
				selectedFields = append(selectedFields, testsummary.FieldTotalNumCached)
				fieldSeen[testsummary.FieldTotalNumCached] = struct{}{}
			}
		case "firstStartTime":
			if _, ok := fieldSeen[testsummary.FieldFirstStartTime]; !ok {
				selectedFields = append(selectedFields, testsummary.FieldFirstStartTime)
				fieldSeen[testsummary.FieldFirstStartTime] = struct{}{}
			}
		case "lastStopTime":
			if _, ok := fieldSeen[testsummary.FieldLastStopTime]; !ok {
				selectedFields = append(selectedFields, testsummary.FieldLastStopTime)
				fieldSeen[testsummary.FieldLastStopTime] = struct{}{}
			}
		case "totalRunDuration":
			if _, ok := fieldSeen[testsummary.FieldTotalRunDuration]; !ok {
				selectedFields = append(selectedFields, testsummary.FieldTotalRunDuration)
				fieldSeen[testsummary.FieldTotalRunDuration] = struct{}{}
			}
		case "label":
			if _, ok := fieldSeen[testsummary.FieldLabel]; !ok {
				selectedFields = append(selectedFields, testsummary.FieldLabel)
				fieldSeen[testsummary.FieldLabel] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ts.Select(selectedFields...)
	}
	return nil
}

type testsummaryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []TestSummaryPaginateOption
}

func newTestSummaryPaginateArgs(rv map[string]any) *testsummaryPaginateArgs {
	args := &testsummaryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*TestSummaryWhereInput); ok {
		args.opts = append(args.opts, WithTestSummaryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (tb *TimingBreakdownQuery) CollectFields(ctx context.Context, satisfies ...string) (*TimingBreakdownQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return tb, nil
	}
	if err := tb.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return tb, nil
}

func (tb *TimingBreakdownQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(timingbreakdown.Columns))
		selectedFields = []string{timingbreakdown.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "executionInfo":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ExectionInfoClient{config: tb.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, exectioninfoImplementors)...); err != nil {
				return err
			}
			tb.withExecutionInfo = query

		case "child":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TimingChildClient{config: tb.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, timingchildImplementors)...); err != nil {
				return err
			}
			tb.WithNamedChild(alias, func(wq *TimingChildQuery) {
				*wq = *query
			})
		case "name":
			if _, ok := fieldSeen[timingbreakdown.FieldName]; !ok {
				selectedFields = append(selectedFields, timingbreakdown.FieldName)
				fieldSeen[timingbreakdown.FieldName] = struct{}{}
			}
		case "time":
			if _, ok := fieldSeen[timingbreakdown.FieldTime]; !ok {
				selectedFields = append(selectedFields, timingbreakdown.FieldTime)
				fieldSeen[timingbreakdown.FieldTime] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		tb.Select(selectedFields...)
	}
	return nil
}

type timingbreakdownPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []TimingBreakdownPaginateOption
}

func newTimingBreakdownPaginateArgs(rv map[string]any) *timingbreakdownPaginateArgs {
	args := &timingbreakdownPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*TimingBreakdownWhereInput); ok {
		args.opts = append(args.opts, WithTimingBreakdownFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (tc *TimingChildQuery) CollectFields(ctx context.Context, satisfies ...string) (*TimingChildQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return tc, nil
	}
	if err := tc.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return tc, nil
}

func (tc *TimingChildQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(timingchild.Columns))
		selectedFields = []string{timingchild.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "timingBreakdown":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TimingBreakdownClient{config: tc.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, timingbreakdownImplementors)...); err != nil {
				return err
			}
			tc.withTimingBreakdown = query
		case "name":
			if _, ok := fieldSeen[timingchild.FieldName]; !ok {
				selectedFields = append(selectedFields, timingchild.FieldName)
				fieldSeen[timingchild.FieldName] = struct{}{}
			}
		case "time":
			if _, ok := fieldSeen[timingchild.FieldTime]; !ok {
				selectedFields = append(selectedFields, timingchild.FieldTime)
				fieldSeen[timingchild.FieldTime] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		tc.Select(selectedFields...)
	}
	return nil
}

type timingchildPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []TimingChildPaginateOption
}

func newTimingChildPaginateArgs(rv map[string]any) *timingchildPaginateArgs {
	args := &timingchildPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*TimingChildWhereInput); ok {
		args.opts = append(args.opts, WithTimingChildFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (tm *TimingMetricsQuery) CollectFields(ctx context.Context, satisfies ...string) (*TimingMetricsQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return tm, nil
	}
	if err := tm.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return tm, nil
}

func (tm *TimingMetricsQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(timingmetrics.Columns))
		selectedFields = []string{timingmetrics.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "metrics":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&MetricsClient{config: tm.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, metricsImplementors)...); err != nil {
				return err
			}
			tm.withMetrics = query
		case "cpuTimeInMs":
			if _, ok := fieldSeen[timingmetrics.FieldCPUTimeInMs]; !ok {
				selectedFields = append(selectedFields, timingmetrics.FieldCPUTimeInMs)
				fieldSeen[timingmetrics.FieldCPUTimeInMs] = struct{}{}
			}
		case "wallTimeInMs":
			if _, ok := fieldSeen[timingmetrics.FieldWallTimeInMs]; !ok {
				selectedFields = append(selectedFields, timingmetrics.FieldWallTimeInMs)
				fieldSeen[timingmetrics.FieldWallTimeInMs] = struct{}{}
			}
		case "analysisPhaseTimeInMs":
			if _, ok := fieldSeen[timingmetrics.FieldAnalysisPhaseTimeInMs]; !ok {
				selectedFields = append(selectedFields, timingmetrics.FieldAnalysisPhaseTimeInMs)
				fieldSeen[timingmetrics.FieldAnalysisPhaseTimeInMs] = struct{}{}
			}
		case "executionPhaseTimeInMs":
			if _, ok := fieldSeen[timingmetrics.FieldExecutionPhaseTimeInMs]; !ok {
				selectedFields = append(selectedFields, timingmetrics.FieldExecutionPhaseTimeInMs)
				fieldSeen[timingmetrics.FieldExecutionPhaseTimeInMs] = struct{}{}
			}
		case "actionsExecutionStartInMs":
			if _, ok := fieldSeen[timingmetrics.FieldActionsExecutionStartInMs]; !ok {
				selectedFields = append(selectedFields, timingmetrics.FieldActionsExecutionStartInMs)
				fieldSeen[timingmetrics.FieldActionsExecutionStartInMs] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		tm.Select(selectedFields...)
	}
	return nil
}

type timingmetricsPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []TimingMetricsPaginateOption
}

func newTimingMetricsPaginateArgs(rv map[string]any) *timingmetricsPaginateArgs {
	args := &timingmetricsPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*TimingMetricsWhereInput); ok {
		args.opts = append(args.opts, WithTimingMetricsFilter(v.Filter))
	}
	return args
}

const (
	afterField     = "after"
	firstField     = "first"
	beforeField    = "before"
	lastField      = "last"
	orderByField   = "orderBy"
	directionField = "direction"
	fieldField     = "field"
	whereField     = "where"
)

func fieldArgs(ctx context.Context, whereInput any, path ...string) map[string]any {
	field := collectedField(ctx, path...)
	if field == nil || field.Arguments == nil {
		return nil
	}
	oc := graphql.GetOperationContext(ctx)
	args := field.ArgumentMap(oc.Variables)
	return unmarshalArgs(ctx, whereInput, args)
}

// unmarshalArgs allows extracting the field arguments from their raw representation.
func unmarshalArgs(ctx context.Context, whereInput any, args map[string]any) map[string]any {
	for _, k := range []string{firstField, lastField} {
		v, ok := args[k]
		if !ok {
			continue
		}
		i, err := graphql.UnmarshalInt(v)
		if err == nil {
			args[k] = &i
		}
	}
	for _, k := range []string{beforeField, afterField} {
		v, ok := args[k]
		if !ok {
			continue
		}
		c := &Cursor{}
		if c.UnmarshalGQL(v) == nil {
			args[k] = c
		}
	}
	if v, ok := args[whereField]; ok && whereInput != nil {
		if err := graphql.UnmarshalInputFromContext(ctx, v, whereInput); err == nil {
			args[whereField] = whereInput
		}
	}

	return args
}

// mayAddCondition appends another type condition to the satisfies list
// if it does not exist in the list.
func mayAddCondition(satisfies []string, typeCond []string) []string {
Cond:
	for _, c := range typeCond {
		for _, s := range satisfies {
			if c == s {
				continue Cond
			}
		}
		satisfies = append(satisfies, c)
	}
	return satisfies
}
