// Code generated by ent, DO NOT EDIT.

package ent

import (
	"encoding/json"
	"fmt"
	"strings"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/buildbarn/bb-portal/ent/gen/ent/testfile"
)

// TestFile is the model entity for the TestFile schema.
type TestFile struct {
	config `json:"-"`
	// ID of the ent.
	ID int `json:"id,omitempty"`
	// Digest holds the value of the "digest" field.
	Digest string `json:"digest,omitempty"`
	// File holds the value of the "file" field.
	File string `json:"file,omitempty"`
	// Length holds the value of the "length" field.
	Length int64 `json:"length,omitempty"`
	// Name holds the value of the "name" field.
	Name string `json:"name,omitempty"`
	// Prefix holds the value of the "prefix" field.
	Prefix []string `json:"prefix,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the TestFileQuery when eager-loading is set.
	Edges                            TestFileEdges `json:"edges"`
	named_set_of_files_files         *int
	output_group_inline_files        *int
	target_complete_important_output *int
	target_complete_directory_output *int
	test_summary_passed              *int
	test_summary_failed              *int
	selectValues                     sql.SelectValues
}

// TestFileEdges holds the relations/edges for other nodes in the graph.
type TestFileEdges struct {
	// TestResult holds the value of the test_result edge.
	TestResult []*TestResultBES `json:"test_result,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [1]bool
	// totalCount holds the count of the edges above.
	totalCount [1]map[string]int

	namedTestResult map[string][]*TestResultBES
}

// TestResultOrErr returns the TestResult value or an error if the edge
// was not loaded in eager-loading.
func (e TestFileEdges) TestResultOrErr() ([]*TestResultBES, error) {
	if e.loadedTypes[0] {
		return e.TestResult, nil
	}
	return nil, &NotLoadedError{edge: "test_result"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*TestFile) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case testfile.FieldPrefix:
			values[i] = new([]byte)
		case testfile.FieldID, testfile.FieldLength:
			values[i] = new(sql.NullInt64)
		case testfile.FieldDigest, testfile.FieldFile, testfile.FieldName:
			values[i] = new(sql.NullString)
		case testfile.ForeignKeys[0]: // named_set_of_files_files
			values[i] = new(sql.NullInt64)
		case testfile.ForeignKeys[1]: // output_group_inline_files
			values[i] = new(sql.NullInt64)
		case testfile.ForeignKeys[2]: // target_complete_important_output
			values[i] = new(sql.NullInt64)
		case testfile.ForeignKeys[3]: // target_complete_directory_output
			values[i] = new(sql.NullInt64)
		case testfile.ForeignKeys[4]: // test_summary_passed
			values[i] = new(sql.NullInt64)
		case testfile.ForeignKeys[5]: // test_summary_failed
			values[i] = new(sql.NullInt64)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the TestFile fields.
func (tf *TestFile) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case testfile.FieldID:
			value, ok := values[i].(*sql.NullInt64)
			if !ok {
				return fmt.Errorf("unexpected type %T for field id", value)
			}
			tf.ID = int(value.Int64)
		case testfile.FieldDigest:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field digest", values[i])
			} else if value.Valid {
				tf.Digest = value.String
			}
		case testfile.FieldFile:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field file", values[i])
			} else if value.Valid {
				tf.File = value.String
			}
		case testfile.FieldLength:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field length", values[i])
			} else if value.Valid {
				tf.Length = value.Int64
			}
		case testfile.FieldName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field name", values[i])
			} else if value.Valid {
				tf.Name = value.String
			}
		case testfile.FieldPrefix:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field prefix", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &tf.Prefix); err != nil {
					return fmt.Errorf("unmarshal field prefix: %w", err)
				}
			}
		case testfile.ForeignKeys[0]:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for edge-field named_set_of_files_files", value)
			} else if value.Valid {
				tf.named_set_of_files_files = new(int)
				*tf.named_set_of_files_files = int(value.Int64)
			}
		case testfile.ForeignKeys[1]:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for edge-field output_group_inline_files", value)
			} else if value.Valid {
				tf.output_group_inline_files = new(int)
				*tf.output_group_inline_files = int(value.Int64)
			}
		case testfile.ForeignKeys[2]:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for edge-field target_complete_important_output", value)
			} else if value.Valid {
				tf.target_complete_important_output = new(int)
				*tf.target_complete_important_output = int(value.Int64)
			}
		case testfile.ForeignKeys[3]:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for edge-field target_complete_directory_output", value)
			} else if value.Valid {
				tf.target_complete_directory_output = new(int)
				*tf.target_complete_directory_output = int(value.Int64)
			}
		case testfile.ForeignKeys[4]:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for edge-field test_summary_passed", value)
			} else if value.Valid {
				tf.test_summary_passed = new(int)
				*tf.test_summary_passed = int(value.Int64)
			}
		case testfile.ForeignKeys[5]:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for edge-field test_summary_failed", value)
			} else if value.Valid {
				tf.test_summary_failed = new(int)
				*tf.test_summary_failed = int(value.Int64)
			}
		default:
			tf.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the TestFile.
// This includes values selected through modifiers, order, etc.
func (tf *TestFile) Value(name string) (ent.Value, error) {
	return tf.selectValues.Get(name)
}

// QueryTestResult queries the "test_result" edge of the TestFile entity.
func (tf *TestFile) QueryTestResult() *TestResultBESQuery {
	return NewTestFileClient(tf.config).QueryTestResult(tf)
}

// Update returns a builder for updating this TestFile.
// Note that you need to call TestFile.Unwrap() before calling this method if this TestFile
// was returned from a transaction, and the transaction was committed or rolled back.
func (tf *TestFile) Update() *TestFileUpdateOne {
	return NewTestFileClient(tf.config).UpdateOne(tf)
}

// Unwrap unwraps the TestFile entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (tf *TestFile) Unwrap() *TestFile {
	_tx, ok := tf.config.driver.(*txDriver)
	if !ok {
		panic("ent: TestFile is not a transactional entity")
	}
	tf.config.driver = _tx.drv
	return tf
}

// String implements the fmt.Stringer.
func (tf *TestFile) String() string {
	var builder strings.Builder
	builder.WriteString("TestFile(")
	builder.WriteString(fmt.Sprintf("id=%v, ", tf.ID))
	builder.WriteString("digest=")
	builder.WriteString(tf.Digest)
	builder.WriteString(", ")
	builder.WriteString("file=")
	builder.WriteString(tf.File)
	builder.WriteString(", ")
	builder.WriteString("length=")
	builder.WriteString(fmt.Sprintf("%v", tf.Length))
	builder.WriteString(", ")
	builder.WriteString("name=")
	builder.WriteString(tf.Name)
	builder.WriteString(", ")
	builder.WriteString("prefix=")
	builder.WriteString(fmt.Sprintf("%v", tf.Prefix))
	builder.WriteByte(')')
	return builder.String()
}

// NamedTestResult returns the TestResult named value or an error if the edge was not
// loaded in eager-loading with this name.
func (tf *TestFile) NamedTestResult(name string) ([]*TestResultBES, error) {
	if tf.Edges.namedTestResult == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := tf.Edges.namedTestResult[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (tf *TestFile) appendNamedTestResult(name string, edges ...*TestResultBES) {
	if tf.Edges.namedTestResult == nil {
		tf.Edges.namedTestResult = make(map[string][]*TestResultBES)
	}
	if len(edges) == 0 {
		tf.Edges.namedTestResult[name] = []*TestResultBES{}
	} else {
		tf.Edges.namedTestResult[name] = append(tf.Edges.namedTestResult[name], edges...)
	}
}

// TestFiles is a parsable slice of TestFile.
type TestFiles []*TestFile
