// Code generated by ent, DO NOT EDIT.

package ent

import (
	"fmt"
	"strings"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/buildbarn/bb-portal/ent/gen/ent/buildgraphmetrics"
)

// BuildGraphMetrics is the model entity for the BuildGraphMetrics schema.
type BuildGraphMetrics struct {
	config `json:"-"`
	// ID of the ent.
	ID int `json:"id,omitempty"`
	// ActionLookupValueCount holds the value of the "action_lookup_value_count" field.
	ActionLookupValueCount int32 `json:"action_lookup_value_count,omitempty"`
	// ActionLookupValueCountNotIncludingAspects holds the value of the "action_lookup_value_count_not_including_aspects" field.
	ActionLookupValueCountNotIncludingAspects int32 `json:"action_lookup_value_count_not_including_aspects,omitempty"`
	// ActionCount holds the value of the "action_count" field.
	ActionCount int32 `json:"action_count,omitempty"`
	// ActionCountNotIncludingAspects holds the value of the "action_count_not_including_aspects" field.
	ActionCountNotIncludingAspects int32 `json:"action_count_not_including_aspects,omitempty"`
	// InputFileConfiguredTargetCount holds the value of the "input_file_configured_target_count" field.
	InputFileConfiguredTargetCount int32 `json:"input_file_configured_target_count,omitempty"`
	// OutputFileConfiguredTargetCount holds the value of the "output_file_configured_target_count" field.
	OutputFileConfiguredTargetCount int32 `json:"output_file_configured_target_count,omitempty"`
	// OtherConfiguredTargetCount holds the value of the "other_configured_target_count" field.
	OtherConfiguredTargetCount int32 `json:"other_configured_target_count,omitempty"`
	// OutputArtifactCount holds the value of the "output_artifact_count" field.
	OutputArtifactCount int32 `json:"output_artifact_count,omitempty"`
	// PostInvocationSkyframeNodeCount holds the value of the "post_invocation_skyframe_node_count" field.
	PostInvocationSkyframeNodeCount int32 `json:"post_invocation_skyframe_node_count,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the BuildGraphMetricsQuery when eager-loading is set.
	Edges        BuildGraphMetricsEdges `json:"edges"`
	selectValues sql.SelectValues
}

// BuildGraphMetricsEdges holds the relations/edges for other nodes in the graph.
type BuildGraphMetricsEdges struct {
	// Metrics holds the value of the metrics edge.
	Metrics []*Metrics `json:"metrics,omitempty"`
	// DirtiedValues holds the value of the dirtied_values edge.
	DirtiedValues []*EvaluationStat `json:"dirtied_values,omitempty"`
	// ChangedValues holds the value of the changed_values edge.
	ChangedValues []*EvaluationStat `json:"changed_values,omitempty"`
	// BuiltValues holds the value of the built_values edge.
	BuiltValues []*EvaluationStat `json:"built_values,omitempty"`
	// CleanedValues holds the value of the cleaned_values edge.
	CleanedValues []*EvaluationStat `json:"cleaned_values,omitempty"`
	// EvaluatedValues holds the value of the evaluated_values edge.
	EvaluatedValues []*EvaluationStat `json:"evaluated_values,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [6]bool
	// totalCount holds the count of the edges above.
	totalCount [6]map[string]int

	namedMetrics         map[string][]*Metrics
	namedDirtiedValues   map[string][]*EvaluationStat
	namedChangedValues   map[string][]*EvaluationStat
	namedBuiltValues     map[string][]*EvaluationStat
	namedCleanedValues   map[string][]*EvaluationStat
	namedEvaluatedValues map[string][]*EvaluationStat
}

// MetricsOrErr returns the Metrics value or an error if the edge
// was not loaded in eager-loading.
func (e BuildGraphMetricsEdges) MetricsOrErr() ([]*Metrics, error) {
	if e.loadedTypes[0] {
		return e.Metrics, nil
	}
	return nil, &NotLoadedError{edge: "metrics"}
}

// DirtiedValuesOrErr returns the DirtiedValues value or an error if the edge
// was not loaded in eager-loading.
func (e BuildGraphMetricsEdges) DirtiedValuesOrErr() ([]*EvaluationStat, error) {
	if e.loadedTypes[1] {
		return e.DirtiedValues, nil
	}
	return nil, &NotLoadedError{edge: "dirtied_values"}
}

// ChangedValuesOrErr returns the ChangedValues value or an error if the edge
// was not loaded in eager-loading.
func (e BuildGraphMetricsEdges) ChangedValuesOrErr() ([]*EvaluationStat, error) {
	if e.loadedTypes[2] {
		return e.ChangedValues, nil
	}
	return nil, &NotLoadedError{edge: "changed_values"}
}

// BuiltValuesOrErr returns the BuiltValues value or an error if the edge
// was not loaded in eager-loading.
func (e BuildGraphMetricsEdges) BuiltValuesOrErr() ([]*EvaluationStat, error) {
	if e.loadedTypes[3] {
		return e.BuiltValues, nil
	}
	return nil, &NotLoadedError{edge: "built_values"}
}

// CleanedValuesOrErr returns the CleanedValues value or an error if the edge
// was not loaded in eager-loading.
func (e BuildGraphMetricsEdges) CleanedValuesOrErr() ([]*EvaluationStat, error) {
	if e.loadedTypes[4] {
		return e.CleanedValues, nil
	}
	return nil, &NotLoadedError{edge: "cleaned_values"}
}

// EvaluatedValuesOrErr returns the EvaluatedValues value or an error if the edge
// was not loaded in eager-loading.
func (e BuildGraphMetricsEdges) EvaluatedValuesOrErr() ([]*EvaluationStat, error) {
	if e.loadedTypes[5] {
		return e.EvaluatedValues, nil
	}
	return nil, &NotLoadedError{edge: "evaluated_values"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*BuildGraphMetrics) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case buildgraphmetrics.FieldID, buildgraphmetrics.FieldActionLookupValueCount, buildgraphmetrics.FieldActionLookupValueCountNotIncludingAspects, buildgraphmetrics.FieldActionCount, buildgraphmetrics.FieldActionCountNotIncludingAspects, buildgraphmetrics.FieldInputFileConfiguredTargetCount, buildgraphmetrics.FieldOutputFileConfiguredTargetCount, buildgraphmetrics.FieldOtherConfiguredTargetCount, buildgraphmetrics.FieldOutputArtifactCount, buildgraphmetrics.FieldPostInvocationSkyframeNodeCount:
			values[i] = new(sql.NullInt64)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the BuildGraphMetrics fields.
func (bgm *BuildGraphMetrics) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case buildgraphmetrics.FieldID:
			value, ok := values[i].(*sql.NullInt64)
			if !ok {
				return fmt.Errorf("unexpected type %T for field id", value)
			}
			bgm.ID = int(value.Int64)
		case buildgraphmetrics.FieldActionLookupValueCount:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field action_lookup_value_count", values[i])
			} else if value.Valid {
				bgm.ActionLookupValueCount = int32(value.Int64)
			}
		case buildgraphmetrics.FieldActionLookupValueCountNotIncludingAspects:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field action_lookup_value_count_not_including_aspects", values[i])
			} else if value.Valid {
				bgm.ActionLookupValueCountNotIncludingAspects = int32(value.Int64)
			}
		case buildgraphmetrics.FieldActionCount:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field action_count", values[i])
			} else if value.Valid {
				bgm.ActionCount = int32(value.Int64)
			}
		case buildgraphmetrics.FieldActionCountNotIncludingAspects:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field action_count_not_including_aspects", values[i])
			} else if value.Valid {
				bgm.ActionCountNotIncludingAspects = int32(value.Int64)
			}
		case buildgraphmetrics.FieldInputFileConfiguredTargetCount:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field input_file_configured_target_count", values[i])
			} else if value.Valid {
				bgm.InputFileConfiguredTargetCount = int32(value.Int64)
			}
		case buildgraphmetrics.FieldOutputFileConfiguredTargetCount:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field output_file_configured_target_count", values[i])
			} else if value.Valid {
				bgm.OutputFileConfiguredTargetCount = int32(value.Int64)
			}
		case buildgraphmetrics.FieldOtherConfiguredTargetCount:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field other_configured_target_count", values[i])
			} else if value.Valid {
				bgm.OtherConfiguredTargetCount = int32(value.Int64)
			}
		case buildgraphmetrics.FieldOutputArtifactCount:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field output_artifact_count", values[i])
			} else if value.Valid {
				bgm.OutputArtifactCount = int32(value.Int64)
			}
		case buildgraphmetrics.FieldPostInvocationSkyframeNodeCount:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field post_invocation_skyframe_node_count", values[i])
			} else if value.Valid {
				bgm.PostInvocationSkyframeNodeCount = int32(value.Int64)
			}
		default:
			bgm.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the BuildGraphMetrics.
// This includes values selected through modifiers, order, etc.
func (bgm *BuildGraphMetrics) Value(name string) (ent.Value, error) {
	return bgm.selectValues.Get(name)
}

// QueryMetrics queries the "metrics" edge of the BuildGraphMetrics entity.
func (bgm *BuildGraphMetrics) QueryMetrics() *MetricsQuery {
	return NewBuildGraphMetricsClient(bgm.config).QueryMetrics(bgm)
}

// QueryDirtiedValues queries the "dirtied_values" edge of the BuildGraphMetrics entity.
func (bgm *BuildGraphMetrics) QueryDirtiedValues() *EvaluationStatQuery {
	return NewBuildGraphMetricsClient(bgm.config).QueryDirtiedValues(bgm)
}

// QueryChangedValues queries the "changed_values" edge of the BuildGraphMetrics entity.
func (bgm *BuildGraphMetrics) QueryChangedValues() *EvaluationStatQuery {
	return NewBuildGraphMetricsClient(bgm.config).QueryChangedValues(bgm)
}

// QueryBuiltValues queries the "built_values" edge of the BuildGraphMetrics entity.
func (bgm *BuildGraphMetrics) QueryBuiltValues() *EvaluationStatQuery {
	return NewBuildGraphMetricsClient(bgm.config).QueryBuiltValues(bgm)
}

// QueryCleanedValues queries the "cleaned_values" edge of the BuildGraphMetrics entity.
func (bgm *BuildGraphMetrics) QueryCleanedValues() *EvaluationStatQuery {
	return NewBuildGraphMetricsClient(bgm.config).QueryCleanedValues(bgm)
}

// QueryEvaluatedValues queries the "evaluated_values" edge of the BuildGraphMetrics entity.
func (bgm *BuildGraphMetrics) QueryEvaluatedValues() *EvaluationStatQuery {
	return NewBuildGraphMetricsClient(bgm.config).QueryEvaluatedValues(bgm)
}

// Update returns a builder for updating this BuildGraphMetrics.
// Note that you need to call BuildGraphMetrics.Unwrap() before calling this method if this BuildGraphMetrics
// was returned from a transaction, and the transaction was committed or rolled back.
func (bgm *BuildGraphMetrics) Update() *BuildGraphMetricsUpdateOne {
	return NewBuildGraphMetricsClient(bgm.config).UpdateOne(bgm)
}

// Unwrap unwraps the BuildGraphMetrics entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (bgm *BuildGraphMetrics) Unwrap() *BuildGraphMetrics {
	_tx, ok := bgm.config.driver.(*txDriver)
	if !ok {
		panic("ent: BuildGraphMetrics is not a transactional entity")
	}
	bgm.config.driver = _tx.drv
	return bgm
}

// String implements the fmt.Stringer.
func (bgm *BuildGraphMetrics) String() string {
	var builder strings.Builder
	builder.WriteString("BuildGraphMetrics(")
	builder.WriteString(fmt.Sprintf("id=%v, ", bgm.ID))
	builder.WriteString("action_lookup_value_count=")
	builder.WriteString(fmt.Sprintf("%v", bgm.ActionLookupValueCount))
	builder.WriteString(", ")
	builder.WriteString("action_lookup_value_count_not_including_aspects=")
	builder.WriteString(fmt.Sprintf("%v", bgm.ActionLookupValueCountNotIncludingAspects))
	builder.WriteString(", ")
	builder.WriteString("action_count=")
	builder.WriteString(fmt.Sprintf("%v", bgm.ActionCount))
	builder.WriteString(", ")
	builder.WriteString("action_count_not_including_aspects=")
	builder.WriteString(fmt.Sprintf("%v", bgm.ActionCountNotIncludingAspects))
	builder.WriteString(", ")
	builder.WriteString("input_file_configured_target_count=")
	builder.WriteString(fmt.Sprintf("%v", bgm.InputFileConfiguredTargetCount))
	builder.WriteString(", ")
	builder.WriteString("output_file_configured_target_count=")
	builder.WriteString(fmt.Sprintf("%v", bgm.OutputFileConfiguredTargetCount))
	builder.WriteString(", ")
	builder.WriteString("other_configured_target_count=")
	builder.WriteString(fmt.Sprintf("%v", bgm.OtherConfiguredTargetCount))
	builder.WriteString(", ")
	builder.WriteString("output_artifact_count=")
	builder.WriteString(fmt.Sprintf("%v", bgm.OutputArtifactCount))
	builder.WriteString(", ")
	builder.WriteString("post_invocation_skyframe_node_count=")
	builder.WriteString(fmt.Sprintf("%v", bgm.PostInvocationSkyframeNodeCount))
	builder.WriteByte(')')
	return builder.String()
}

// NamedMetrics returns the Metrics named value or an error if the edge was not
// loaded in eager-loading with this name.
func (bgm *BuildGraphMetrics) NamedMetrics(name string) ([]*Metrics, error) {
	if bgm.Edges.namedMetrics == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := bgm.Edges.namedMetrics[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (bgm *BuildGraphMetrics) appendNamedMetrics(name string, edges ...*Metrics) {
	if bgm.Edges.namedMetrics == nil {
		bgm.Edges.namedMetrics = make(map[string][]*Metrics)
	}
	if len(edges) == 0 {
		bgm.Edges.namedMetrics[name] = []*Metrics{}
	} else {
		bgm.Edges.namedMetrics[name] = append(bgm.Edges.namedMetrics[name], edges...)
	}
}

// NamedDirtiedValues returns the DirtiedValues named value or an error if the edge was not
// loaded in eager-loading with this name.
func (bgm *BuildGraphMetrics) NamedDirtiedValues(name string) ([]*EvaluationStat, error) {
	if bgm.Edges.namedDirtiedValues == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := bgm.Edges.namedDirtiedValues[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (bgm *BuildGraphMetrics) appendNamedDirtiedValues(name string, edges ...*EvaluationStat) {
	if bgm.Edges.namedDirtiedValues == nil {
		bgm.Edges.namedDirtiedValues = make(map[string][]*EvaluationStat)
	}
	if len(edges) == 0 {
		bgm.Edges.namedDirtiedValues[name] = []*EvaluationStat{}
	} else {
		bgm.Edges.namedDirtiedValues[name] = append(bgm.Edges.namedDirtiedValues[name], edges...)
	}
}

// NamedChangedValues returns the ChangedValues named value or an error if the edge was not
// loaded in eager-loading with this name.
func (bgm *BuildGraphMetrics) NamedChangedValues(name string) ([]*EvaluationStat, error) {
	if bgm.Edges.namedChangedValues == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := bgm.Edges.namedChangedValues[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (bgm *BuildGraphMetrics) appendNamedChangedValues(name string, edges ...*EvaluationStat) {
	if bgm.Edges.namedChangedValues == nil {
		bgm.Edges.namedChangedValues = make(map[string][]*EvaluationStat)
	}
	if len(edges) == 0 {
		bgm.Edges.namedChangedValues[name] = []*EvaluationStat{}
	} else {
		bgm.Edges.namedChangedValues[name] = append(bgm.Edges.namedChangedValues[name], edges...)
	}
}

// NamedBuiltValues returns the BuiltValues named value or an error if the edge was not
// loaded in eager-loading with this name.
func (bgm *BuildGraphMetrics) NamedBuiltValues(name string) ([]*EvaluationStat, error) {
	if bgm.Edges.namedBuiltValues == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := bgm.Edges.namedBuiltValues[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (bgm *BuildGraphMetrics) appendNamedBuiltValues(name string, edges ...*EvaluationStat) {
	if bgm.Edges.namedBuiltValues == nil {
		bgm.Edges.namedBuiltValues = make(map[string][]*EvaluationStat)
	}
	if len(edges) == 0 {
		bgm.Edges.namedBuiltValues[name] = []*EvaluationStat{}
	} else {
		bgm.Edges.namedBuiltValues[name] = append(bgm.Edges.namedBuiltValues[name], edges...)
	}
}

// NamedCleanedValues returns the CleanedValues named value or an error if the edge was not
// loaded in eager-loading with this name.
func (bgm *BuildGraphMetrics) NamedCleanedValues(name string) ([]*EvaluationStat, error) {
	if bgm.Edges.namedCleanedValues == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := bgm.Edges.namedCleanedValues[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (bgm *BuildGraphMetrics) appendNamedCleanedValues(name string, edges ...*EvaluationStat) {
	if bgm.Edges.namedCleanedValues == nil {
		bgm.Edges.namedCleanedValues = make(map[string][]*EvaluationStat)
	}
	if len(edges) == 0 {
		bgm.Edges.namedCleanedValues[name] = []*EvaluationStat{}
	} else {
		bgm.Edges.namedCleanedValues[name] = append(bgm.Edges.namedCleanedValues[name], edges...)
	}
}

// NamedEvaluatedValues returns the EvaluatedValues named value or an error if the edge was not
// loaded in eager-loading with this name.
func (bgm *BuildGraphMetrics) NamedEvaluatedValues(name string) ([]*EvaluationStat, error) {
	if bgm.Edges.namedEvaluatedValues == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := bgm.Edges.namedEvaluatedValues[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (bgm *BuildGraphMetrics) appendNamedEvaluatedValues(name string, edges ...*EvaluationStat) {
	if bgm.Edges.namedEvaluatedValues == nil {
		bgm.Edges.namedEvaluatedValues = make(map[string][]*EvaluationStat)
	}
	if len(edges) == 0 {
		bgm.Edges.namedEvaluatedValues[name] = []*EvaluationStat{}
	} else {
		bgm.Edges.namedEvaluatedValues[name] = append(bgm.Edges.namedEvaluatedValues[name], edges...)
	}
}

// BuildGraphMetricsSlice is a parsable slice of BuildGraphMetrics.
type BuildGraphMetricsSlice []*BuildGraphMetrics
