// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/buildbarn/bb-portal/ent/gen/ent/namedsetoffiles"
	"github.com/buildbarn/bb-portal/ent/gen/ent/outputgroup"
	"github.com/buildbarn/bb-portal/ent/gen/ent/predicate"
	"github.com/buildbarn/bb-portal/ent/gen/ent/testfile"
)

// OutputGroupUpdate is the builder for updating OutputGroup entities.
type OutputGroupUpdate struct {
	config
	hooks    []Hook
	mutation *OutputGroupMutation
}

// Where appends a list predicates to the OutputGroupUpdate builder.
func (ogu *OutputGroupUpdate) Where(ps ...predicate.OutputGroup) *OutputGroupUpdate {
	ogu.mutation.Where(ps...)
	return ogu
}

// SetName sets the "name" field.
func (ogu *OutputGroupUpdate) SetName(s string) *OutputGroupUpdate {
	ogu.mutation.SetName(s)
	return ogu
}

// SetNillableName sets the "name" field if the given value is not nil.
func (ogu *OutputGroupUpdate) SetNillableName(s *string) *OutputGroupUpdate {
	if s != nil {
		ogu.SetName(*s)
	}
	return ogu
}

// ClearName clears the value of the "name" field.
func (ogu *OutputGroupUpdate) ClearName() *OutputGroupUpdate {
	ogu.mutation.ClearName()
	return ogu
}

// SetIncomplete sets the "incomplete" field.
func (ogu *OutputGroupUpdate) SetIncomplete(b bool) *OutputGroupUpdate {
	ogu.mutation.SetIncomplete(b)
	return ogu
}

// SetNillableIncomplete sets the "incomplete" field if the given value is not nil.
func (ogu *OutputGroupUpdate) SetNillableIncomplete(b *bool) *OutputGroupUpdate {
	if b != nil {
		ogu.SetIncomplete(*b)
	}
	return ogu
}

// ClearIncomplete clears the value of the "incomplete" field.
func (ogu *OutputGroupUpdate) ClearIncomplete() *OutputGroupUpdate {
	ogu.mutation.ClearIncomplete()
	return ogu
}

// AddInlineFileIDs adds the "inline_files" edge to the TestFile entity by IDs.
func (ogu *OutputGroupUpdate) AddInlineFileIDs(ids ...int) *OutputGroupUpdate {
	ogu.mutation.AddInlineFileIDs(ids...)
	return ogu
}

// AddInlineFiles adds the "inline_files" edges to the TestFile entity.
func (ogu *OutputGroupUpdate) AddInlineFiles(t ...*TestFile) *OutputGroupUpdate {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return ogu.AddInlineFileIDs(ids...)
}

// SetFileSetsID sets the "file_sets" edge to the NamedSetOfFiles entity by ID.
func (ogu *OutputGroupUpdate) SetFileSetsID(id int) *OutputGroupUpdate {
	ogu.mutation.SetFileSetsID(id)
	return ogu
}

// SetNillableFileSetsID sets the "file_sets" edge to the NamedSetOfFiles entity by ID if the given value is not nil.
func (ogu *OutputGroupUpdate) SetNillableFileSetsID(id *int) *OutputGroupUpdate {
	if id != nil {
		ogu = ogu.SetFileSetsID(*id)
	}
	return ogu
}

// SetFileSets sets the "file_sets" edge to the NamedSetOfFiles entity.
func (ogu *OutputGroupUpdate) SetFileSets(n *NamedSetOfFiles) *OutputGroupUpdate {
	return ogu.SetFileSetsID(n.ID)
}

// Mutation returns the OutputGroupMutation object of the builder.
func (ogu *OutputGroupUpdate) Mutation() *OutputGroupMutation {
	return ogu.mutation
}

// ClearInlineFiles clears all "inline_files" edges to the TestFile entity.
func (ogu *OutputGroupUpdate) ClearInlineFiles() *OutputGroupUpdate {
	ogu.mutation.ClearInlineFiles()
	return ogu
}

// RemoveInlineFileIDs removes the "inline_files" edge to TestFile entities by IDs.
func (ogu *OutputGroupUpdate) RemoveInlineFileIDs(ids ...int) *OutputGroupUpdate {
	ogu.mutation.RemoveInlineFileIDs(ids...)
	return ogu
}

// RemoveInlineFiles removes "inline_files" edges to TestFile entities.
func (ogu *OutputGroupUpdate) RemoveInlineFiles(t ...*TestFile) *OutputGroupUpdate {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return ogu.RemoveInlineFileIDs(ids...)
}

// ClearFileSets clears the "file_sets" edge to the NamedSetOfFiles entity.
func (ogu *OutputGroupUpdate) ClearFileSets() *OutputGroupUpdate {
	ogu.mutation.ClearFileSets()
	return ogu
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (ogu *OutputGroupUpdate) Save(ctx context.Context) (int, error) {
	return withHooks(ctx, ogu.sqlSave, ogu.mutation, ogu.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (ogu *OutputGroupUpdate) SaveX(ctx context.Context) int {
	affected, err := ogu.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (ogu *OutputGroupUpdate) Exec(ctx context.Context) error {
	_, err := ogu.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (ogu *OutputGroupUpdate) ExecX(ctx context.Context) {
	if err := ogu.Exec(ctx); err != nil {
		panic(err)
	}
}

func (ogu *OutputGroupUpdate) sqlSave(ctx context.Context) (n int, err error) {
	_spec := sqlgraph.NewUpdateSpec(outputgroup.Table, outputgroup.Columns, sqlgraph.NewFieldSpec(outputgroup.FieldID, field.TypeInt))
	if ps := ogu.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := ogu.mutation.Name(); ok {
		_spec.SetField(outputgroup.FieldName, field.TypeString, value)
	}
	if ogu.mutation.NameCleared() {
		_spec.ClearField(outputgroup.FieldName, field.TypeString)
	}
	if value, ok := ogu.mutation.Incomplete(); ok {
		_spec.SetField(outputgroup.FieldIncomplete, field.TypeBool, value)
	}
	if ogu.mutation.IncompleteCleared() {
		_spec.ClearField(outputgroup.FieldIncomplete, field.TypeBool)
	}
	if ogu.mutation.InlineFilesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   outputgroup.InlineFilesTable,
			Columns: []string{outputgroup.InlineFilesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(testfile.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := ogu.mutation.RemovedInlineFilesIDs(); len(nodes) > 0 && !ogu.mutation.InlineFilesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   outputgroup.InlineFilesTable,
			Columns: []string{outputgroup.InlineFilesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(testfile.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := ogu.mutation.InlineFilesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   outputgroup.InlineFilesTable,
			Columns: []string{outputgroup.InlineFilesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(testfile.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if ogu.mutation.FileSetsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: false,
			Table:   outputgroup.FileSetsTable,
			Columns: []string{outputgroup.FileSetsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(namedsetoffiles.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := ogu.mutation.FileSetsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: false,
			Table:   outputgroup.FileSetsTable,
			Columns: []string{outputgroup.FileSetsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(namedsetoffiles.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if n, err = sqlgraph.UpdateNodes(ctx, ogu.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{outputgroup.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return 0, err
	}
	ogu.mutation.done = true
	return n, nil
}

// OutputGroupUpdateOne is the builder for updating a single OutputGroup entity.
type OutputGroupUpdateOne struct {
	config
	fields   []string
	hooks    []Hook
	mutation *OutputGroupMutation
}

// SetName sets the "name" field.
func (oguo *OutputGroupUpdateOne) SetName(s string) *OutputGroupUpdateOne {
	oguo.mutation.SetName(s)
	return oguo
}

// SetNillableName sets the "name" field if the given value is not nil.
func (oguo *OutputGroupUpdateOne) SetNillableName(s *string) *OutputGroupUpdateOne {
	if s != nil {
		oguo.SetName(*s)
	}
	return oguo
}

// ClearName clears the value of the "name" field.
func (oguo *OutputGroupUpdateOne) ClearName() *OutputGroupUpdateOne {
	oguo.mutation.ClearName()
	return oguo
}

// SetIncomplete sets the "incomplete" field.
func (oguo *OutputGroupUpdateOne) SetIncomplete(b bool) *OutputGroupUpdateOne {
	oguo.mutation.SetIncomplete(b)
	return oguo
}

// SetNillableIncomplete sets the "incomplete" field if the given value is not nil.
func (oguo *OutputGroupUpdateOne) SetNillableIncomplete(b *bool) *OutputGroupUpdateOne {
	if b != nil {
		oguo.SetIncomplete(*b)
	}
	return oguo
}

// ClearIncomplete clears the value of the "incomplete" field.
func (oguo *OutputGroupUpdateOne) ClearIncomplete() *OutputGroupUpdateOne {
	oguo.mutation.ClearIncomplete()
	return oguo
}

// AddInlineFileIDs adds the "inline_files" edge to the TestFile entity by IDs.
func (oguo *OutputGroupUpdateOne) AddInlineFileIDs(ids ...int) *OutputGroupUpdateOne {
	oguo.mutation.AddInlineFileIDs(ids...)
	return oguo
}

// AddInlineFiles adds the "inline_files" edges to the TestFile entity.
func (oguo *OutputGroupUpdateOne) AddInlineFiles(t ...*TestFile) *OutputGroupUpdateOne {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return oguo.AddInlineFileIDs(ids...)
}

// SetFileSetsID sets the "file_sets" edge to the NamedSetOfFiles entity by ID.
func (oguo *OutputGroupUpdateOne) SetFileSetsID(id int) *OutputGroupUpdateOne {
	oguo.mutation.SetFileSetsID(id)
	return oguo
}

// SetNillableFileSetsID sets the "file_sets" edge to the NamedSetOfFiles entity by ID if the given value is not nil.
func (oguo *OutputGroupUpdateOne) SetNillableFileSetsID(id *int) *OutputGroupUpdateOne {
	if id != nil {
		oguo = oguo.SetFileSetsID(*id)
	}
	return oguo
}

// SetFileSets sets the "file_sets" edge to the NamedSetOfFiles entity.
func (oguo *OutputGroupUpdateOne) SetFileSets(n *NamedSetOfFiles) *OutputGroupUpdateOne {
	return oguo.SetFileSetsID(n.ID)
}

// Mutation returns the OutputGroupMutation object of the builder.
func (oguo *OutputGroupUpdateOne) Mutation() *OutputGroupMutation {
	return oguo.mutation
}

// ClearInlineFiles clears all "inline_files" edges to the TestFile entity.
func (oguo *OutputGroupUpdateOne) ClearInlineFiles() *OutputGroupUpdateOne {
	oguo.mutation.ClearInlineFiles()
	return oguo
}

// RemoveInlineFileIDs removes the "inline_files" edge to TestFile entities by IDs.
func (oguo *OutputGroupUpdateOne) RemoveInlineFileIDs(ids ...int) *OutputGroupUpdateOne {
	oguo.mutation.RemoveInlineFileIDs(ids...)
	return oguo
}

// RemoveInlineFiles removes "inline_files" edges to TestFile entities.
func (oguo *OutputGroupUpdateOne) RemoveInlineFiles(t ...*TestFile) *OutputGroupUpdateOne {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return oguo.RemoveInlineFileIDs(ids...)
}

// ClearFileSets clears the "file_sets" edge to the NamedSetOfFiles entity.
func (oguo *OutputGroupUpdateOne) ClearFileSets() *OutputGroupUpdateOne {
	oguo.mutation.ClearFileSets()
	return oguo
}

// Where appends a list predicates to the OutputGroupUpdate builder.
func (oguo *OutputGroupUpdateOne) Where(ps ...predicate.OutputGroup) *OutputGroupUpdateOne {
	oguo.mutation.Where(ps...)
	return oguo
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (oguo *OutputGroupUpdateOne) Select(field string, fields ...string) *OutputGroupUpdateOne {
	oguo.fields = append([]string{field}, fields...)
	return oguo
}

// Save executes the query and returns the updated OutputGroup entity.
func (oguo *OutputGroupUpdateOne) Save(ctx context.Context) (*OutputGroup, error) {
	return withHooks(ctx, oguo.sqlSave, oguo.mutation, oguo.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (oguo *OutputGroupUpdateOne) SaveX(ctx context.Context) *OutputGroup {
	node, err := oguo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (oguo *OutputGroupUpdateOne) Exec(ctx context.Context) error {
	_, err := oguo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (oguo *OutputGroupUpdateOne) ExecX(ctx context.Context) {
	if err := oguo.Exec(ctx); err != nil {
		panic(err)
	}
}

func (oguo *OutputGroupUpdateOne) sqlSave(ctx context.Context) (_node *OutputGroup, err error) {
	_spec := sqlgraph.NewUpdateSpec(outputgroup.Table, outputgroup.Columns, sqlgraph.NewFieldSpec(outputgroup.FieldID, field.TypeInt))
	id, ok := oguo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`ent: missing "OutputGroup.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := oguo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, outputgroup.FieldID)
		for _, f := range fields {
			if !outputgroup.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
			}
			if f != outputgroup.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := oguo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := oguo.mutation.Name(); ok {
		_spec.SetField(outputgroup.FieldName, field.TypeString, value)
	}
	if oguo.mutation.NameCleared() {
		_spec.ClearField(outputgroup.FieldName, field.TypeString)
	}
	if value, ok := oguo.mutation.Incomplete(); ok {
		_spec.SetField(outputgroup.FieldIncomplete, field.TypeBool, value)
	}
	if oguo.mutation.IncompleteCleared() {
		_spec.ClearField(outputgroup.FieldIncomplete, field.TypeBool)
	}
	if oguo.mutation.InlineFilesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   outputgroup.InlineFilesTable,
			Columns: []string{outputgroup.InlineFilesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(testfile.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := oguo.mutation.RemovedInlineFilesIDs(); len(nodes) > 0 && !oguo.mutation.InlineFilesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   outputgroup.InlineFilesTable,
			Columns: []string{outputgroup.InlineFilesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(testfile.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := oguo.mutation.InlineFilesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   outputgroup.InlineFilesTable,
			Columns: []string{outputgroup.InlineFilesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(testfile.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if oguo.mutation.FileSetsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: false,
			Table:   outputgroup.FileSetsTable,
			Columns: []string{outputgroup.FileSetsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(namedsetoffiles.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := oguo.mutation.FileSetsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: false,
			Table:   outputgroup.FileSetsTable,
			Columns: []string{outputgroup.FileSetsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(namedsetoffiles.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_node = &OutputGroup{config: oguo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, oguo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{outputgroup.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	oguo.mutation.done = true
	return _node, nil
}
