// Code generated by ent, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"
	"time"

	"github.com/buildbarn/bb-portal/ent/gen/ent/action"
	"github.com/buildbarn/bb-portal/ent/gen/ent/actioncachestatistics"
	"github.com/buildbarn/bb-portal/ent/gen/ent/actiondata"
	"github.com/buildbarn/bb-portal/ent/gen/ent/actionsummary"
	"github.com/buildbarn/bb-portal/ent/gen/ent/artifactmetrics"
	"github.com/buildbarn/bb-portal/ent/gen/ent/authenticateduser"
	"github.com/buildbarn/bb-portal/ent/gen/ent/bazelinvocation"
	"github.com/buildbarn/bb-portal/ent/gen/ent/build"
	"github.com/buildbarn/bb-portal/ent/gen/ent/buildgraphmetrics"
	"github.com/buildbarn/bb-portal/ent/gen/ent/configuration"
	"github.com/buildbarn/bb-portal/ent/gen/ent/cumulativemetrics"
	"github.com/buildbarn/bb-portal/ent/gen/ent/evaluationstat"
	"github.com/buildbarn/bb-portal/ent/gen/ent/garbagemetrics"
	"github.com/buildbarn/bb-portal/ent/gen/ent/instancename"
	"github.com/buildbarn/bb-portal/ent/gen/ent/invocationfiles"
	"github.com/buildbarn/bb-portal/ent/gen/ent/invocationtarget"
	"github.com/buildbarn/bb-portal/ent/gen/ent/memorymetrics"
	"github.com/buildbarn/bb-portal/ent/gen/ent/metrics"
	"github.com/buildbarn/bb-portal/ent/gen/ent/missdetail"
	"github.com/buildbarn/bb-portal/ent/gen/ent/networkmetrics"
	"github.com/buildbarn/bb-portal/ent/gen/ent/packageloadmetrics"
	"github.com/buildbarn/bb-portal/ent/gen/ent/packagemetrics"
	"github.com/buildbarn/bb-portal/ent/gen/ent/predicate"
	"github.com/buildbarn/bb-portal/ent/gen/ent/runnercount"
	"github.com/buildbarn/bb-portal/ent/gen/ent/sourcecontrol"
	"github.com/buildbarn/bb-portal/ent/gen/ent/systemnetworkstats"
	"github.com/buildbarn/bb-portal/ent/gen/ent/target"
	"github.com/buildbarn/bb-portal/ent/gen/ent/targetmetrics"
	"github.com/buildbarn/bb-portal/ent/gen/ent/testresult"
	"github.com/buildbarn/bb-portal/ent/gen/ent/testsummary"
	"github.com/buildbarn/bb-portal/ent/gen/ent/timingmetrics"
	"github.com/google/uuid"
)

// ActionWhereInput represents a where input for filtering Action queries.
type ActionWhereInput struct {
	Predicates []predicate.Action  `json:"-"`
	Not        *ActionWhereInput   `json:"not,omitempty"`
	Or         []*ActionWhereInput `json:"or,omitempty"`
	And        []*ActionWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int64  `json:"id,omitempty"`
	IDNEQ   *int64  `json:"idNEQ,omitempty"`
	IDIn    []int64 `json:"idIn,omitempty"`
	IDNotIn []int64 `json:"idNotIn,omitempty"`
	IDGT    *int64  `json:"idGT,omitempty"`
	IDGTE   *int64  `json:"idGTE,omitempty"`
	IDLT    *int64  `json:"idLT,omitempty"`
	IDLTE   *int64  `json:"idLTE,omitempty"`

	// "label" field predicates.
	Label             *string  `json:"label,omitempty"`
	LabelNEQ          *string  `json:"labelNEQ,omitempty"`
	LabelIn           []string `json:"labelIn,omitempty"`
	LabelNotIn        []string `json:"labelNotIn,omitempty"`
	LabelGT           *string  `json:"labelGT,omitempty"`
	LabelGTE          *string  `json:"labelGTE,omitempty"`
	LabelLT           *string  `json:"labelLT,omitempty"`
	LabelLTE          *string  `json:"labelLTE,omitempty"`
	LabelContains     *string  `json:"labelContains,omitempty"`
	LabelHasPrefix    *string  `json:"labelHasPrefix,omitempty"`
	LabelHasSuffix    *string  `json:"labelHasSuffix,omitempty"`
	LabelEqualFold    *string  `json:"labelEqualFold,omitempty"`
	LabelContainsFold *string  `json:"labelContainsFold,omitempty"`

	// "type" field predicates.
	Type             *string  `json:"type,omitempty"`
	TypeNEQ          *string  `json:"typeNEQ,omitempty"`
	TypeIn           []string `json:"typeIn,omitempty"`
	TypeNotIn        []string `json:"typeNotIn,omitempty"`
	TypeGT           *string  `json:"typeGT,omitempty"`
	TypeGTE          *string  `json:"typeGTE,omitempty"`
	TypeLT           *string  `json:"typeLT,omitempty"`
	TypeLTE          *string  `json:"typeLTE,omitempty"`
	TypeContains     *string  `json:"typeContains,omitempty"`
	TypeHasPrefix    *string  `json:"typeHasPrefix,omitempty"`
	TypeHasSuffix    *string  `json:"typeHasSuffix,omitempty"`
	TypeIsNil        bool     `json:"typeIsNil,omitempty"`
	TypeNotNil       bool     `json:"typeNotNil,omitempty"`
	TypeEqualFold    *string  `json:"typeEqualFold,omitempty"`
	TypeContainsFold *string  `json:"typeContainsFold,omitempty"`

	// "success" field predicates.
	Success       *bool `json:"success,omitempty"`
	SuccessNEQ    *bool `json:"successNEQ,omitempty"`
	SuccessIsNil  bool  `json:"successIsNil,omitempty"`
	SuccessNotNil bool  `json:"successNotNil,omitempty"`

	// "exit_code" field predicates.
	ExitCode       *int32  `json:"exitCode,omitempty"`
	ExitCodeNEQ    *int32  `json:"exitCodeNEQ,omitempty"`
	ExitCodeIn     []int32 `json:"exitCodeIn,omitempty"`
	ExitCodeNotIn  []int32 `json:"exitCodeNotIn,omitempty"`
	ExitCodeGT     *int32  `json:"exitCodeGT,omitempty"`
	ExitCodeGTE    *int32  `json:"exitCodeGTE,omitempty"`
	ExitCodeLT     *int32  `json:"exitCodeLT,omitempty"`
	ExitCodeLTE    *int32  `json:"exitCodeLTE,omitempty"`
	ExitCodeIsNil  bool    `json:"exitCodeIsNil,omitempty"`
	ExitCodeNotNil bool    `json:"exitCodeNotNil,omitempty"`

	// "start_time" field predicates.
	StartTime       *time.Time  `json:"startTime,omitempty"`
	StartTimeNEQ    *time.Time  `json:"startTimeNEQ,omitempty"`
	StartTimeIn     []time.Time `json:"startTimeIn,omitempty"`
	StartTimeNotIn  []time.Time `json:"startTimeNotIn,omitempty"`
	StartTimeGT     *time.Time  `json:"startTimeGT,omitempty"`
	StartTimeGTE    *time.Time  `json:"startTimeGTE,omitempty"`
	StartTimeLT     *time.Time  `json:"startTimeLT,omitempty"`
	StartTimeLTE    *time.Time  `json:"startTimeLTE,omitempty"`
	StartTimeIsNil  bool        `json:"startTimeIsNil,omitempty"`
	StartTimeNotNil bool        `json:"startTimeNotNil,omitempty"`

	// "end_time" field predicates.
	EndTime       *time.Time  `json:"endTime,omitempty"`
	EndTimeNEQ    *time.Time  `json:"endTimeNEQ,omitempty"`
	EndTimeIn     []time.Time `json:"endTimeIn,omitempty"`
	EndTimeNotIn  []time.Time `json:"endTimeNotIn,omitempty"`
	EndTimeGT     *time.Time  `json:"endTimeGT,omitempty"`
	EndTimeGTE    *time.Time  `json:"endTimeGTE,omitempty"`
	EndTimeLT     *time.Time  `json:"endTimeLT,omitempty"`
	EndTimeLTE    *time.Time  `json:"endTimeLTE,omitempty"`
	EndTimeIsNil  bool        `json:"endTimeIsNil,omitempty"`
	EndTimeNotNil bool        `json:"endTimeNotNil,omitempty"`

	// "failure_code" field predicates.
	FailureCode             *string  `json:"failureCode,omitempty"`
	FailureCodeNEQ          *string  `json:"failureCodeNEQ,omitempty"`
	FailureCodeIn           []string `json:"failureCodeIn,omitempty"`
	FailureCodeNotIn        []string `json:"failureCodeNotIn,omitempty"`
	FailureCodeGT           *string  `json:"failureCodeGT,omitempty"`
	FailureCodeGTE          *string  `json:"failureCodeGTE,omitempty"`
	FailureCodeLT           *string  `json:"failureCodeLT,omitempty"`
	FailureCodeLTE          *string  `json:"failureCodeLTE,omitempty"`
	FailureCodeContains     *string  `json:"failureCodeContains,omitempty"`
	FailureCodeHasPrefix    *string  `json:"failureCodeHasPrefix,omitempty"`
	FailureCodeHasSuffix    *string  `json:"failureCodeHasSuffix,omitempty"`
	FailureCodeIsNil        bool     `json:"failureCodeIsNil,omitempty"`
	FailureCodeNotNil       bool     `json:"failureCodeNotNil,omitempty"`
	FailureCodeEqualFold    *string  `json:"failureCodeEqualFold,omitempty"`
	FailureCodeContainsFold *string  `json:"failureCodeContainsFold,omitempty"`

	// "failure_message" field predicates.
	FailureMessage             *string  `json:"failureMessage,omitempty"`
	FailureMessageNEQ          *string  `json:"failureMessageNEQ,omitempty"`
	FailureMessageIn           []string `json:"failureMessageIn,omitempty"`
	FailureMessageNotIn        []string `json:"failureMessageNotIn,omitempty"`
	FailureMessageGT           *string  `json:"failureMessageGT,omitempty"`
	FailureMessageGTE          *string  `json:"failureMessageGTE,omitempty"`
	FailureMessageLT           *string  `json:"failureMessageLT,omitempty"`
	FailureMessageLTE          *string  `json:"failureMessageLTE,omitempty"`
	FailureMessageContains     *string  `json:"failureMessageContains,omitempty"`
	FailureMessageHasPrefix    *string  `json:"failureMessageHasPrefix,omitempty"`
	FailureMessageHasSuffix    *string  `json:"failureMessageHasSuffix,omitempty"`
	FailureMessageIsNil        bool     `json:"failureMessageIsNil,omitempty"`
	FailureMessageNotNil       bool     `json:"failureMessageNotNil,omitempty"`
	FailureMessageEqualFold    *string  `json:"failureMessageEqualFold,omitempty"`
	FailureMessageContainsFold *string  `json:"failureMessageContainsFold,omitempty"`

	// "stdout_hash" field predicates.
	StdoutHash             *string  `json:"stdoutHash,omitempty"`
	StdoutHashNEQ          *string  `json:"stdoutHashNEQ,omitempty"`
	StdoutHashIn           []string `json:"stdoutHashIn,omitempty"`
	StdoutHashNotIn        []string `json:"stdoutHashNotIn,omitempty"`
	StdoutHashGT           *string  `json:"stdoutHashGT,omitempty"`
	StdoutHashGTE          *string  `json:"stdoutHashGTE,omitempty"`
	StdoutHashLT           *string  `json:"stdoutHashLT,omitempty"`
	StdoutHashLTE          *string  `json:"stdoutHashLTE,omitempty"`
	StdoutHashContains     *string  `json:"stdoutHashContains,omitempty"`
	StdoutHashHasPrefix    *string  `json:"stdoutHashHasPrefix,omitempty"`
	StdoutHashHasSuffix    *string  `json:"stdoutHashHasSuffix,omitempty"`
	StdoutHashIsNil        bool     `json:"stdoutHashIsNil,omitempty"`
	StdoutHashNotNil       bool     `json:"stdoutHashNotNil,omitempty"`
	StdoutHashEqualFold    *string  `json:"stdoutHashEqualFold,omitempty"`
	StdoutHashContainsFold *string  `json:"stdoutHashContainsFold,omitempty"`

	// "stdout_size_bytes" field predicates.
	StdoutSizeBytes       *int64  `json:"stdoutSizeBytes,omitempty"`
	StdoutSizeBytesNEQ    *int64  `json:"stdoutSizeBytesNEQ,omitempty"`
	StdoutSizeBytesIn     []int64 `json:"stdoutSizeBytesIn,omitempty"`
	StdoutSizeBytesNotIn  []int64 `json:"stdoutSizeBytesNotIn,omitempty"`
	StdoutSizeBytesGT     *int64  `json:"stdoutSizeBytesGT,omitempty"`
	StdoutSizeBytesGTE    *int64  `json:"stdoutSizeBytesGTE,omitempty"`
	StdoutSizeBytesLT     *int64  `json:"stdoutSizeBytesLT,omitempty"`
	StdoutSizeBytesLTE    *int64  `json:"stdoutSizeBytesLTE,omitempty"`
	StdoutSizeBytesIsNil  bool    `json:"stdoutSizeBytesIsNil,omitempty"`
	StdoutSizeBytesNotNil bool    `json:"stdoutSizeBytesNotNil,omitempty"`

	// "stdout_hash_function" field predicates.
	StdoutHashFunction             *string  `json:"stdoutHashFunction,omitempty"`
	StdoutHashFunctionNEQ          *string  `json:"stdoutHashFunctionNEQ,omitempty"`
	StdoutHashFunctionIn           []string `json:"stdoutHashFunctionIn,omitempty"`
	StdoutHashFunctionNotIn        []string `json:"stdoutHashFunctionNotIn,omitempty"`
	StdoutHashFunctionGT           *string  `json:"stdoutHashFunctionGT,omitempty"`
	StdoutHashFunctionGTE          *string  `json:"stdoutHashFunctionGTE,omitempty"`
	StdoutHashFunctionLT           *string  `json:"stdoutHashFunctionLT,omitempty"`
	StdoutHashFunctionLTE          *string  `json:"stdoutHashFunctionLTE,omitempty"`
	StdoutHashFunctionContains     *string  `json:"stdoutHashFunctionContains,omitempty"`
	StdoutHashFunctionHasPrefix    *string  `json:"stdoutHashFunctionHasPrefix,omitempty"`
	StdoutHashFunctionHasSuffix    *string  `json:"stdoutHashFunctionHasSuffix,omitempty"`
	StdoutHashFunctionIsNil        bool     `json:"stdoutHashFunctionIsNil,omitempty"`
	StdoutHashFunctionNotNil       bool     `json:"stdoutHashFunctionNotNil,omitempty"`
	StdoutHashFunctionEqualFold    *string  `json:"stdoutHashFunctionEqualFold,omitempty"`
	StdoutHashFunctionContainsFold *string  `json:"stdoutHashFunctionContainsFold,omitempty"`

	// "stderr_hash" field predicates.
	StderrHash             *string  `json:"stderrHash,omitempty"`
	StderrHashNEQ          *string  `json:"stderrHashNEQ,omitempty"`
	StderrHashIn           []string `json:"stderrHashIn,omitempty"`
	StderrHashNotIn        []string `json:"stderrHashNotIn,omitempty"`
	StderrHashGT           *string  `json:"stderrHashGT,omitempty"`
	StderrHashGTE          *string  `json:"stderrHashGTE,omitempty"`
	StderrHashLT           *string  `json:"stderrHashLT,omitempty"`
	StderrHashLTE          *string  `json:"stderrHashLTE,omitempty"`
	StderrHashContains     *string  `json:"stderrHashContains,omitempty"`
	StderrHashHasPrefix    *string  `json:"stderrHashHasPrefix,omitempty"`
	StderrHashHasSuffix    *string  `json:"stderrHashHasSuffix,omitempty"`
	StderrHashIsNil        bool     `json:"stderrHashIsNil,omitempty"`
	StderrHashNotNil       bool     `json:"stderrHashNotNil,omitempty"`
	StderrHashEqualFold    *string  `json:"stderrHashEqualFold,omitempty"`
	StderrHashContainsFold *string  `json:"stderrHashContainsFold,omitempty"`

	// "stderr_size_bytes" field predicates.
	StderrSizeBytes       *int64  `json:"stderrSizeBytes,omitempty"`
	StderrSizeBytesNEQ    *int64  `json:"stderrSizeBytesNEQ,omitempty"`
	StderrSizeBytesIn     []int64 `json:"stderrSizeBytesIn,omitempty"`
	StderrSizeBytesNotIn  []int64 `json:"stderrSizeBytesNotIn,omitempty"`
	StderrSizeBytesGT     *int64  `json:"stderrSizeBytesGT,omitempty"`
	StderrSizeBytesGTE    *int64  `json:"stderrSizeBytesGTE,omitempty"`
	StderrSizeBytesLT     *int64  `json:"stderrSizeBytesLT,omitempty"`
	StderrSizeBytesLTE    *int64  `json:"stderrSizeBytesLTE,omitempty"`
	StderrSizeBytesIsNil  bool    `json:"stderrSizeBytesIsNil,omitempty"`
	StderrSizeBytesNotNil bool    `json:"stderrSizeBytesNotNil,omitempty"`

	// "stderr_hash_function" field predicates.
	StderrHashFunction             *string  `json:"stderrHashFunction,omitempty"`
	StderrHashFunctionNEQ          *string  `json:"stderrHashFunctionNEQ,omitempty"`
	StderrHashFunctionIn           []string `json:"stderrHashFunctionIn,omitempty"`
	StderrHashFunctionNotIn        []string `json:"stderrHashFunctionNotIn,omitempty"`
	StderrHashFunctionGT           *string  `json:"stderrHashFunctionGT,omitempty"`
	StderrHashFunctionGTE          *string  `json:"stderrHashFunctionGTE,omitempty"`
	StderrHashFunctionLT           *string  `json:"stderrHashFunctionLT,omitempty"`
	StderrHashFunctionLTE          *string  `json:"stderrHashFunctionLTE,omitempty"`
	StderrHashFunctionContains     *string  `json:"stderrHashFunctionContains,omitempty"`
	StderrHashFunctionHasPrefix    *string  `json:"stderrHashFunctionHasPrefix,omitempty"`
	StderrHashFunctionHasSuffix    *string  `json:"stderrHashFunctionHasSuffix,omitempty"`
	StderrHashFunctionIsNil        bool     `json:"stderrHashFunctionIsNil,omitempty"`
	StderrHashFunctionNotNil       bool     `json:"stderrHashFunctionNotNil,omitempty"`
	StderrHashFunctionEqualFold    *string  `json:"stderrHashFunctionEqualFold,omitempty"`
	StderrHashFunctionContainsFold *string  `json:"stderrHashFunctionContainsFold,omitempty"`

	// "bazel_invocation" edge predicates.
	HasBazelInvocation     *bool                        `json:"hasBazelInvocation,omitempty"`
	HasBazelInvocationWith []*BazelInvocationWhereInput `json:"hasBazelInvocationWith,omitempty"`

	// "configuration" edge predicates.
	HasConfiguration     *bool                      `json:"hasConfiguration,omitempty"`
	HasConfigurationWith []*ConfigurationWhereInput `json:"hasConfigurationWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ActionWhereInput) AddPredicates(predicates ...predicate.Action) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ActionWhereInput filter on the ActionQuery builder.
func (i *ActionWhereInput) Filter(q *ActionQuery) (*ActionQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyActionWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyActionWhereInput is returned in case the ActionWhereInput is empty.
var ErrEmptyActionWhereInput = errors.New("ent: empty predicate ActionWhereInput")

// P returns a predicate for filtering actions.
// An error is returned if the input is empty or invalid.
func (i *ActionWhereInput) P() (predicate.Action, error) {
	var predicates []predicate.Action
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, action.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Action, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, action.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Action, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, action.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, action.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, action.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, action.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, action.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, action.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, action.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, action.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, action.IDLTE(*i.IDLTE))
	}
	if i.Label != nil {
		predicates = append(predicates, action.LabelEQ(*i.Label))
	}
	if i.LabelNEQ != nil {
		predicates = append(predicates, action.LabelNEQ(*i.LabelNEQ))
	}
	if len(i.LabelIn) > 0 {
		predicates = append(predicates, action.LabelIn(i.LabelIn...))
	}
	if len(i.LabelNotIn) > 0 {
		predicates = append(predicates, action.LabelNotIn(i.LabelNotIn...))
	}
	if i.LabelGT != nil {
		predicates = append(predicates, action.LabelGT(*i.LabelGT))
	}
	if i.LabelGTE != nil {
		predicates = append(predicates, action.LabelGTE(*i.LabelGTE))
	}
	if i.LabelLT != nil {
		predicates = append(predicates, action.LabelLT(*i.LabelLT))
	}
	if i.LabelLTE != nil {
		predicates = append(predicates, action.LabelLTE(*i.LabelLTE))
	}
	if i.LabelContains != nil {
		predicates = append(predicates, action.LabelContains(*i.LabelContains))
	}
	if i.LabelHasPrefix != nil {
		predicates = append(predicates, action.LabelHasPrefix(*i.LabelHasPrefix))
	}
	if i.LabelHasSuffix != nil {
		predicates = append(predicates, action.LabelHasSuffix(*i.LabelHasSuffix))
	}
	if i.LabelEqualFold != nil {
		predicates = append(predicates, action.LabelEqualFold(*i.LabelEqualFold))
	}
	if i.LabelContainsFold != nil {
		predicates = append(predicates, action.LabelContainsFold(*i.LabelContainsFold))
	}
	if i.Type != nil {
		predicates = append(predicates, action.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, action.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, action.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, action.TypeNotIn(i.TypeNotIn...))
	}
	if i.TypeGT != nil {
		predicates = append(predicates, action.TypeGT(*i.TypeGT))
	}
	if i.TypeGTE != nil {
		predicates = append(predicates, action.TypeGTE(*i.TypeGTE))
	}
	if i.TypeLT != nil {
		predicates = append(predicates, action.TypeLT(*i.TypeLT))
	}
	if i.TypeLTE != nil {
		predicates = append(predicates, action.TypeLTE(*i.TypeLTE))
	}
	if i.TypeContains != nil {
		predicates = append(predicates, action.TypeContains(*i.TypeContains))
	}
	if i.TypeHasPrefix != nil {
		predicates = append(predicates, action.TypeHasPrefix(*i.TypeHasPrefix))
	}
	if i.TypeHasSuffix != nil {
		predicates = append(predicates, action.TypeHasSuffix(*i.TypeHasSuffix))
	}
	if i.TypeIsNil {
		predicates = append(predicates, action.TypeIsNil())
	}
	if i.TypeNotNil {
		predicates = append(predicates, action.TypeNotNil())
	}
	if i.TypeEqualFold != nil {
		predicates = append(predicates, action.TypeEqualFold(*i.TypeEqualFold))
	}
	if i.TypeContainsFold != nil {
		predicates = append(predicates, action.TypeContainsFold(*i.TypeContainsFold))
	}
	if i.Success != nil {
		predicates = append(predicates, action.SuccessEQ(*i.Success))
	}
	if i.SuccessNEQ != nil {
		predicates = append(predicates, action.SuccessNEQ(*i.SuccessNEQ))
	}
	if i.SuccessIsNil {
		predicates = append(predicates, action.SuccessIsNil())
	}
	if i.SuccessNotNil {
		predicates = append(predicates, action.SuccessNotNil())
	}
	if i.ExitCode != nil {
		predicates = append(predicates, action.ExitCodeEQ(*i.ExitCode))
	}
	if i.ExitCodeNEQ != nil {
		predicates = append(predicates, action.ExitCodeNEQ(*i.ExitCodeNEQ))
	}
	if len(i.ExitCodeIn) > 0 {
		predicates = append(predicates, action.ExitCodeIn(i.ExitCodeIn...))
	}
	if len(i.ExitCodeNotIn) > 0 {
		predicates = append(predicates, action.ExitCodeNotIn(i.ExitCodeNotIn...))
	}
	if i.ExitCodeGT != nil {
		predicates = append(predicates, action.ExitCodeGT(*i.ExitCodeGT))
	}
	if i.ExitCodeGTE != nil {
		predicates = append(predicates, action.ExitCodeGTE(*i.ExitCodeGTE))
	}
	if i.ExitCodeLT != nil {
		predicates = append(predicates, action.ExitCodeLT(*i.ExitCodeLT))
	}
	if i.ExitCodeLTE != nil {
		predicates = append(predicates, action.ExitCodeLTE(*i.ExitCodeLTE))
	}
	if i.ExitCodeIsNil {
		predicates = append(predicates, action.ExitCodeIsNil())
	}
	if i.ExitCodeNotNil {
		predicates = append(predicates, action.ExitCodeNotNil())
	}
	if i.StartTime != nil {
		predicates = append(predicates, action.StartTimeEQ(*i.StartTime))
	}
	if i.StartTimeNEQ != nil {
		predicates = append(predicates, action.StartTimeNEQ(*i.StartTimeNEQ))
	}
	if len(i.StartTimeIn) > 0 {
		predicates = append(predicates, action.StartTimeIn(i.StartTimeIn...))
	}
	if len(i.StartTimeNotIn) > 0 {
		predicates = append(predicates, action.StartTimeNotIn(i.StartTimeNotIn...))
	}
	if i.StartTimeGT != nil {
		predicates = append(predicates, action.StartTimeGT(*i.StartTimeGT))
	}
	if i.StartTimeGTE != nil {
		predicates = append(predicates, action.StartTimeGTE(*i.StartTimeGTE))
	}
	if i.StartTimeLT != nil {
		predicates = append(predicates, action.StartTimeLT(*i.StartTimeLT))
	}
	if i.StartTimeLTE != nil {
		predicates = append(predicates, action.StartTimeLTE(*i.StartTimeLTE))
	}
	if i.StartTimeIsNil {
		predicates = append(predicates, action.StartTimeIsNil())
	}
	if i.StartTimeNotNil {
		predicates = append(predicates, action.StartTimeNotNil())
	}
	if i.EndTime != nil {
		predicates = append(predicates, action.EndTimeEQ(*i.EndTime))
	}
	if i.EndTimeNEQ != nil {
		predicates = append(predicates, action.EndTimeNEQ(*i.EndTimeNEQ))
	}
	if len(i.EndTimeIn) > 0 {
		predicates = append(predicates, action.EndTimeIn(i.EndTimeIn...))
	}
	if len(i.EndTimeNotIn) > 0 {
		predicates = append(predicates, action.EndTimeNotIn(i.EndTimeNotIn...))
	}
	if i.EndTimeGT != nil {
		predicates = append(predicates, action.EndTimeGT(*i.EndTimeGT))
	}
	if i.EndTimeGTE != nil {
		predicates = append(predicates, action.EndTimeGTE(*i.EndTimeGTE))
	}
	if i.EndTimeLT != nil {
		predicates = append(predicates, action.EndTimeLT(*i.EndTimeLT))
	}
	if i.EndTimeLTE != nil {
		predicates = append(predicates, action.EndTimeLTE(*i.EndTimeLTE))
	}
	if i.EndTimeIsNil {
		predicates = append(predicates, action.EndTimeIsNil())
	}
	if i.EndTimeNotNil {
		predicates = append(predicates, action.EndTimeNotNil())
	}
	if i.FailureCode != nil {
		predicates = append(predicates, action.FailureCodeEQ(*i.FailureCode))
	}
	if i.FailureCodeNEQ != nil {
		predicates = append(predicates, action.FailureCodeNEQ(*i.FailureCodeNEQ))
	}
	if len(i.FailureCodeIn) > 0 {
		predicates = append(predicates, action.FailureCodeIn(i.FailureCodeIn...))
	}
	if len(i.FailureCodeNotIn) > 0 {
		predicates = append(predicates, action.FailureCodeNotIn(i.FailureCodeNotIn...))
	}
	if i.FailureCodeGT != nil {
		predicates = append(predicates, action.FailureCodeGT(*i.FailureCodeGT))
	}
	if i.FailureCodeGTE != nil {
		predicates = append(predicates, action.FailureCodeGTE(*i.FailureCodeGTE))
	}
	if i.FailureCodeLT != nil {
		predicates = append(predicates, action.FailureCodeLT(*i.FailureCodeLT))
	}
	if i.FailureCodeLTE != nil {
		predicates = append(predicates, action.FailureCodeLTE(*i.FailureCodeLTE))
	}
	if i.FailureCodeContains != nil {
		predicates = append(predicates, action.FailureCodeContains(*i.FailureCodeContains))
	}
	if i.FailureCodeHasPrefix != nil {
		predicates = append(predicates, action.FailureCodeHasPrefix(*i.FailureCodeHasPrefix))
	}
	if i.FailureCodeHasSuffix != nil {
		predicates = append(predicates, action.FailureCodeHasSuffix(*i.FailureCodeHasSuffix))
	}
	if i.FailureCodeIsNil {
		predicates = append(predicates, action.FailureCodeIsNil())
	}
	if i.FailureCodeNotNil {
		predicates = append(predicates, action.FailureCodeNotNil())
	}
	if i.FailureCodeEqualFold != nil {
		predicates = append(predicates, action.FailureCodeEqualFold(*i.FailureCodeEqualFold))
	}
	if i.FailureCodeContainsFold != nil {
		predicates = append(predicates, action.FailureCodeContainsFold(*i.FailureCodeContainsFold))
	}
	if i.FailureMessage != nil {
		predicates = append(predicates, action.FailureMessageEQ(*i.FailureMessage))
	}
	if i.FailureMessageNEQ != nil {
		predicates = append(predicates, action.FailureMessageNEQ(*i.FailureMessageNEQ))
	}
	if len(i.FailureMessageIn) > 0 {
		predicates = append(predicates, action.FailureMessageIn(i.FailureMessageIn...))
	}
	if len(i.FailureMessageNotIn) > 0 {
		predicates = append(predicates, action.FailureMessageNotIn(i.FailureMessageNotIn...))
	}
	if i.FailureMessageGT != nil {
		predicates = append(predicates, action.FailureMessageGT(*i.FailureMessageGT))
	}
	if i.FailureMessageGTE != nil {
		predicates = append(predicates, action.FailureMessageGTE(*i.FailureMessageGTE))
	}
	if i.FailureMessageLT != nil {
		predicates = append(predicates, action.FailureMessageLT(*i.FailureMessageLT))
	}
	if i.FailureMessageLTE != nil {
		predicates = append(predicates, action.FailureMessageLTE(*i.FailureMessageLTE))
	}
	if i.FailureMessageContains != nil {
		predicates = append(predicates, action.FailureMessageContains(*i.FailureMessageContains))
	}
	if i.FailureMessageHasPrefix != nil {
		predicates = append(predicates, action.FailureMessageHasPrefix(*i.FailureMessageHasPrefix))
	}
	if i.FailureMessageHasSuffix != nil {
		predicates = append(predicates, action.FailureMessageHasSuffix(*i.FailureMessageHasSuffix))
	}
	if i.FailureMessageIsNil {
		predicates = append(predicates, action.FailureMessageIsNil())
	}
	if i.FailureMessageNotNil {
		predicates = append(predicates, action.FailureMessageNotNil())
	}
	if i.FailureMessageEqualFold != nil {
		predicates = append(predicates, action.FailureMessageEqualFold(*i.FailureMessageEqualFold))
	}
	if i.FailureMessageContainsFold != nil {
		predicates = append(predicates, action.FailureMessageContainsFold(*i.FailureMessageContainsFold))
	}
	if i.StdoutHash != nil {
		predicates = append(predicates, action.StdoutHashEQ(*i.StdoutHash))
	}
	if i.StdoutHashNEQ != nil {
		predicates = append(predicates, action.StdoutHashNEQ(*i.StdoutHashNEQ))
	}
	if len(i.StdoutHashIn) > 0 {
		predicates = append(predicates, action.StdoutHashIn(i.StdoutHashIn...))
	}
	if len(i.StdoutHashNotIn) > 0 {
		predicates = append(predicates, action.StdoutHashNotIn(i.StdoutHashNotIn...))
	}
	if i.StdoutHashGT != nil {
		predicates = append(predicates, action.StdoutHashGT(*i.StdoutHashGT))
	}
	if i.StdoutHashGTE != nil {
		predicates = append(predicates, action.StdoutHashGTE(*i.StdoutHashGTE))
	}
	if i.StdoutHashLT != nil {
		predicates = append(predicates, action.StdoutHashLT(*i.StdoutHashLT))
	}
	if i.StdoutHashLTE != nil {
		predicates = append(predicates, action.StdoutHashLTE(*i.StdoutHashLTE))
	}
	if i.StdoutHashContains != nil {
		predicates = append(predicates, action.StdoutHashContains(*i.StdoutHashContains))
	}
	if i.StdoutHashHasPrefix != nil {
		predicates = append(predicates, action.StdoutHashHasPrefix(*i.StdoutHashHasPrefix))
	}
	if i.StdoutHashHasSuffix != nil {
		predicates = append(predicates, action.StdoutHashHasSuffix(*i.StdoutHashHasSuffix))
	}
	if i.StdoutHashIsNil {
		predicates = append(predicates, action.StdoutHashIsNil())
	}
	if i.StdoutHashNotNil {
		predicates = append(predicates, action.StdoutHashNotNil())
	}
	if i.StdoutHashEqualFold != nil {
		predicates = append(predicates, action.StdoutHashEqualFold(*i.StdoutHashEqualFold))
	}
	if i.StdoutHashContainsFold != nil {
		predicates = append(predicates, action.StdoutHashContainsFold(*i.StdoutHashContainsFold))
	}
	if i.StdoutSizeBytes != nil {
		predicates = append(predicates, action.StdoutSizeBytesEQ(*i.StdoutSizeBytes))
	}
	if i.StdoutSizeBytesNEQ != nil {
		predicates = append(predicates, action.StdoutSizeBytesNEQ(*i.StdoutSizeBytesNEQ))
	}
	if len(i.StdoutSizeBytesIn) > 0 {
		predicates = append(predicates, action.StdoutSizeBytesIn(i.StdoutSizeBytesIn...))
	}
	if len(i.StdoutSizeBytesNotIn) > 0 {
		predicates = append(predicates, action.StdoutSizeBytesNotIn(i.StdoutSizeBytesNotIn...))
	}
	if i.StdoutSizeBytesGT != nil {
		predicates = append(predicates, action.StdoutSizeBytesGT(*i.StdoutSizeBytesGT))
	}
	if i.StdoutSizeBytesGTE != nil {
		predicates = append(predicates, action.StdoutSizeBytesGTE(*i.StdoutSizeBytesGTE))
	}
	if i.StdoutSizeBytesLT != nil {
		predicates = append(predicates, action.StdoutSizeBytesLT(*i.StdoutSizeBytesLT))
	}
	if i.StdoutSizeBytesLTE != nil {
		predicates = append(predicates, action.StdoutSizeBytesLTE(*i.StdoutSizeBytesLTE))
	}
	if i.StdoutSizeBytesIsNil {
		predicates = append(predicates, action.StdoutSizeBytesIsNil())
	}
	if i.StdoutSizeBytesNotNil {
		predicates = append(predicates, action.StdoutSizeBytesNotNil())
	}
	if i.StdoutHashFunction != nil {
		predicates = append(predicates, action.StdoutHashFunctionEQ(*i.StdoutHashFunction))
	}
	if i.StdoutHashFunctionNEQ != nil {
		predicates = append(predicates, action.StdoutHashFunctionNEQ(*i.StdoutHashFunctionNEQ))
	}
	if len(i.StdoutHashFunctionIn) > 0 {
		predicates = append(predicates, action.StdoutHashFunctionIn(i.StdoutHashFunctionIn...))
	}
	if len(i.StdoutHashFunctionNotIn) > 0 {
		predicates = append(predicates, action.StdoutHashFunctionNotIn(i.StdoutHashFunctionNotIn...))
	}
	if i.StdoutHashFunctionGT != nil {
		predicates = append(predicates, action.StdoutHashFunctionGT(*i.StdoutHashFunctionGT))
	}
	if i.StdoutHashFunctionGTE != nil {
		predicates = append(predicates, action.StdoutHashFunctionGTE(*i.StdoutHashFunctionGTE))
	}
	if i.StdoutHashFunctionLT != nil {
		predicates = append(predicates, action.StdoutHashFunctionLT(*i.StdoutHashFunctionLT))
	}
	if i.StdoutHashFunctionLTE != nil {
		predicates = append(predicates, action.StdoutHashFunctionLTE(*i.StdoutHashFunctionLTE))
	}
	if i.StdoutHashFunctionContains != nil {
		predicates = append(predicates, action.StdoutHashFunctionContains(*i.StdoutHashFunctionContains))
	}
	if i.StdoutHashFunctionHasPrefix != nil {
		predicates = append(predicates, action.StdoutHashFunctionHasPrefix(*i.StdoutHashFunctionHasPrefix))
	}
	if i.StdoutHashFunctionHasSuffix != nil {
		predicates = append(predicates, action.StdoutHashFunctionHasSuffix(*i.StdoutHashFunctionHasSuffix))
	}
	if i.StdoutHashFunctionIsNil {
		predicates = append(predicates, action.StdoutHashFunctionIsNil())
	}
	if i.StdoutHashFunctionNotNil {
		predicates = append(predicates, action.StdoutHashFunctionNotNil())
	}
	if i.StdoutHashFunctionEqualFold != nil {
		predicates = append(predicates, action.StdoutHashFunctionEqualFold(*i.StdoutHashFunctionEqualFold))
	}
	if i.StdoutHashFunctionContainsFold != nil {
		predicates = append(predicates, action.StdoutHashFunctionContainsFold(*i.StdoutHashFunctionContainsFold))
	}
	if i.StderrHash != nil {
		predicates = append(predicates, action.StderrHashEQ(*i.StderrHash))
	}
	if i.StderrHashNEQ != nil {
		predicates = append(predicates, action.StderrHashNEQ(*i.StderrHashNEQ))
	}
	if len(i.StderrHashIn) > 0 {
		predicates = append(predicates, action.StderrHashIn(i.StderrHashIn...))
	}
	if len(i.StderrHashNotIn) > 0 {
		predicates = append(predicates, action.StderrHashNotIn(i.StderrHashNotIn...))
	}
	if i.StderrHashGT != nil {
		predicates = append(predicates, action.StderrHashGT(*i.StderrHashGT))
	}
	if i.StderrHashGTE != nil {
		predicates = append(predicates, action.StderrHashGTE(*i.StderrHashGTE))
	}
	if i.StderrHashLT != nil {
		predicates = append(predicates, action.StderrHashLT(*i.StderrHashLT))
	}
	if i.StderrHashLTE != nil {
		predicates = append(predicates, action.StderrHashLTE(*i.StderrHashLTE))
	}
	if i.StderrHashContains != nil {
		predicates = append(predicates, action.StderrHashContains(*i.StderrHashContains))
	}
	if i.StderrHashHasPrefix != nil {
		predicates = append(predicates, action.StderrHashHasPrefix(*i.StderrHashHasPrefix))
	}
	if i.StderrHashHasSuffix != nil {
		predicates = append(predicates, action.StderrHashHasSuffix(*i.StderrHashHasSuffix))
	}
	if i.StderrHashIsNil {
		predicates = append(predicates, action.StderrHashIsNil())
	}
	if i.StderrHashNotNil {
		predicates = append(predicates, action.StderrHashNotNil())
	}
	if i.StderrHashEqualFold != nil {
		predicates = append(predicates, action.StderrHashEqualFold(*i.StderrHashEqualFold))
	}
	if i.StderrHashContainsFold != nil {
		predicates = append(predicates, action.StderrHashContainsFold(*i.StderrHashContainsFold))
	}
	if i.StderrSizeBytes != nil {
		predicates = append(predicates, action.StderrSizeBytesEQ(*i.StderrSizeBytes))
	}
	if i.StderrSizeBytesNEQ != nil {
		predicates = append(predicates, action.StderrSizeBytesNEQ(*i.StderrSizeBytesNEQ))
	}
	if len(i.StderrSizeBytesIn) > 0 {
		predicates = append(predicates, action.StderrSizeBytesIn(i.StderrSizeBytesIn...))
	}
	if len(i.StderrSizeBytesNotIn) > 0 {
		predicates = append(predicates, action.StderrSizeBytesNotIn(i.StderrSizeBytesNotIn...))
	}
	if i.StderrSizeBytesGT != nil {
		predicates = append(predicates, action.StderrSizeBytesGT(*i.StderrSizeBytesGT))
	}
	if i.StderrSizeBytesGTE != nil {
		predicates = append(predicates, action.StderrSizeBytesGTE(*i.StderrSizeBytesGTE))
	}
	if i.StderrSizeBytesLT != nil {
		predicates = append(predicates, action.StderrSizeBytesLT(*i.StderrSizeBytesLT))
	}
	if i.StderrSizeBytesLTE != nil {
		predicates = append(predicates, action.StderrSizeBytesLTE(*i.StderrSizeBytesLTE))
	}
	if i.StderrSizeBytesIsNil {
		predicates = append(predicates, action.StderrSizeBytesIsNil())
	}
	if i.StderrSizeBytesNotNil {
		predicates = append(predicates, action.StderrSizeBytesNotNil())
	}
	if i.StderrHashFunction != nil {
		predicates = append(predicates, action.StderrHashFunctionEQ(*i.StderrHashFunction))
	}
	if i.StderrHashFunctionNEQ != nil {
		predicates = append(predicates, action.StderrHashFunctionNEQ(*i.StderrHashFunctionNEQ))
	}
	if len(i.StderrHashFunctionIn) > 0 {
		predicates = append(predicates, action.StderrHashFunctionIn(i.StderrHashFunctionIn...))
	}
	if len(i.StderrHashFunctionNotIn) > 0 {
		predicates = append(predicates, action.StderrHashFunctionNotIn(i.StderrHashFunctionNotIn...))
	}
	if i.StderrHashFunctionGT != nil {
		predicates = append(predicates, action.StderrHashFunctionGT(*i.StderrHashFunctionGT))
	}
	if i.StderrHashFunctionGTE != nil {
		predicates = append(predicates, action.StderrHashFunctionGTE(*i.StderrHashFunctionGTE))
	}
	if i.StderrHashFunctionLT != nil {
		predicates = append(predicates, action.StderrHashFunctionLT(*i.StderrHashFunctionLT))
	}
	if i.StderrHashFunctionLTE != nil {
		predicates = append(predicates, action.StderrHashFunctionLTE(*i.StderrHashFunctionLTE))
	}
	if i.StderrHashFunctionContains != nil {
		predicates = append(predicates, action.StderrHashFunctionContains(*i.StderrHashFunctionContains))
	}
	if i.StderrHashFunctionHasPrefix != nil {
		predicates = append(predicates, action.StderrHashFunctionHasPrefix(*i.StderrHashFunctionHasPrefix))
	}
	if i.StderrHashFunctionHasSuffix != nil {
		predicates = append(predicates, action.StderrHashFunctionHasSuffix(*i.StderrHashFunctionHasSuffix))
	}
	if i.StderrHashFunctionIsNil {
		predicates = append(predicates, action.StderrHashFunctionIsNil())
	}
	if i.StderrHashFunctionNotNil {
		predicates = append(predicates, action.StderrHashFunctionNotNil())
	}
	if i.StderrHashFunctionEqualFold != nil {
		predicates = append(predicates, action.StderrHashFunctionEqualFold(*i.StderrHashFunctionEqualFold))
	}
	if i.StderrHashFunctionContainsFold != nil {
		predicates = append(predicates, action.StderrHashFunctionContainsFold(*i.StderrHashFunctionContainsFold))
	}

	if i.HasBazelInvocation != nil {
		p := action.HasBazelInvocation()
		if !*i.HasBazelInvocation {
			p = action.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBazelInvocationWith) > 0 {
		with := make([]predicate.BazelInvocation, 0, len(i.HasBazelInvocationWith))
		for _, w := range i.HasBazelInvocationWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBazelInvocationWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, action.HasBazelInvocationWith(with...))
	}
	if i.HasConfiguration != nil {
		p := action.HasConfiguration()
		if !*i.HasConfiguration {
			p = action.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasConfigurationWith) > 0 {
		with := make([]predicate.Configuration, 0, len(i.HasConfigurationWith))
		for _, w := range i.HasConfigurationWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasConfigurationWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, action.HasConfigurationWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyActionWhereInput
	case 1:
		return predicates[0], nil
	default:
		return action.And(predicates...), nil
	}
}

// ActionCacheStatisticsWhereInput represents a where input for filtering ActionCacheStatistics queries.
type ActionCacheStatisticsWhereInput struct {
	Predicates []predicate.ActionCacheStatistics  `json:"-"`
	Not        *ActionCacheStatisticsWhereInput   `json:"not,omitempty"`
	Or         []*ActionCacheStatisticsWhereInput `json:"or,omitempty"`
	And        []*ActionCacheStatisticsWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int64  `json:"id,omitempty"`
	IDNEQ   *int64  `json:"idNEQ,omitempty"`
	IDIn    []int64 `json:"idIn,omitempty"`
	IDNotIn []int64 `json:"idNotIn,omitempty"`
	IDGT    *int64  `json:"idGT,omitempty"`
	IDGTE   *int64  `json:"idGTE,omitempty"`
	IDLT    *int64  `json:"idLT,omitempty"`
	IDLTE   *int64  `json:"idLTE,omitempty"`

	// "size_in_bytes" field predicates.
	SizeInBytes       *uint64  `json:"sizeInBytes,omitempty"`
	SizeInBytesNEQ    *uint64  `json:"sizeInBytesNEQ,omitempty"`
	SizeInBytesIn     []uint64 `json:"sizeInBytesIn,omitempty"`
	SizeInBytesNotIn  []uint64 `json:"sizeInBytesNotIn,omitempty"`
	SizeInBytesGT     *uint64  `json:"sizeInBytesGT,omitempty"`
	SizeInBytesGTE    *uint64  `json:"sizeInBytesGTE,omitempty"`
	SizeInBytesLT     *uint64  `json:"sizeInBytesLT,omitempty"`
	SizeInBytesLTE    *uint64  `json:"sizeInBytesLTE,omitempty"`
	SizeInBytesIsNil  bool     `json:"sizeInBytesIsNil,omitempty"`
	SizeInBytesNotNil bool     `json:"sizeInBytesNotNil,omitempty"`

	// "save_time_in_ms" field predicates.
	SaveTimeInMs       *uint64  `json:"saveTimeInMs,omitempty"`
	SaveTimeInMsNEQ    *uint64  `json:"saveTimeInMsNEQ,omitempty"`
	SaveTimeInMsIn     []uint64 `json:"saveTimeInMsIn,omitempty"`
	SaveTimeInMsNotIn  []uint64 `json:"saveTimeInMsNotIn,omitempty"`
	SaveTimeInMsGT     *uint64  `json:"saveTimeInMsGT,omitempty"`
	SaveTimeInMsGTE    *uint64  `json:"saveTimeInMsGTE,omitempty"`
	SaveTimeInMsLT     *uint64  `json:"saveTimeInMsLT,omitempty"`
	SaveTimeInMsLTE    *uint64  `json:"saveTimeInMsLTE,omitempty"`
	SaveTimeInMsIsNil  bool     `json:"saveTimeInMsIsNil,omitempty"`
	SaveTimeInMsNotNil bool     `json:"saveTimeInMsNotNil,omitempty"`

	// "load_time_in_ms" field predicates.
	LoadTimeInMs       *int64  `json:"loadTimeInMs,omitempty"`
	LoadTimeInMsNEQ    *int64  `json:"loadTimeInMsNEQ,omitempty"`
	LoadTimeInMsIn     []int64 `json:"loadTimeInMsIn,omitempty"`
	LoadTimeInMsNotIn  []int64 `json:"loadTimeInMsNotIn,omitempty"`
	LoadTimeInMsGT     *int64  `json:"loadTimeInMsGT,omitempty"`
	LoadTimeInMsGTE    *int64  `json:"loadTimeInMsGTE,omitempty"`
	LoadTimeInMsLT     *int64  `json:"loadTimeInMsLT,omitempty"`
	LoadTimeInMsLTE    *int64  `json:"loadTimeInMsLTE,omitempty"`
	LoadTimeInMsIsNil  bool    `json:"loadTimeInMsIsNil,omitempty"`
	LoadTimeInMsNotNil bool    `json:"loadTimeInMsNotNil,omitempty"`

	// "hits" field predicates.
	Hits       *int32  `json:"hits,omitempty"`
	HitsNEQ    *int32  `json:"hitsNEQ,omitempty"`
	HitsIn     []int32 `json:"hitsIn,omitempty"`
	HitsNotIn  []int32 `json:"hitsNotIn,omitempty"`
	HitsGT     *int32  `json:"hitsGT,omitempty"`
	HitsGTE    *int32  `json:"hitsGTE,omitempty"`
	HitsLT     *int32  `json:"hitsLT,omitempty"`
	HitsLTE    *int32  `json:"hitsLTE,omitempty"`
	HitsIsNil  bool    `json:"hitsIsNil,omitempty"`
	HitsNotNil bool    `json:"hitsNotNil,omitempty"`

	// "misses" field predicates.
	Misses       *int32  `json:"misses,omitempty"`
	MissesNEQ    *int32  `json:"missesNEQ,omitempty"`
	MissesIn     []int32 `json:"missesIn,omitempty"`
	MissesNotIn  []int32 `json:"missesNotIn,omitempty"`
	MissesGT     *int32  `json:"missesGT,omitempty"`
	MissesGTE    *int32  `json:"missesGTE,omitempty"`
	MissesLT     *int32  `json:"missesLT,omitempty"`
	MissesLTE    *int32  `json:"missesLTE,omitempty"`
	MissesIsNil  bool    `json:"missesIsNil,omitempty"`
	MissesNotNil bool    `json:"missesNotNil,omitempty"`

	// "action_summary" edge predicates.
	HasActionSummary     *bool                      `json:"hasActionSummary,omitempty"`
	HasActionSummaryWith []*ActionSummaryWhereInput `json:"hasActionSummaryWith,omitempty"`

	// "miss_details" edge predicates.
	HasMissDetails     *bool                   `json:"hasMissDetails,omitempty"`
	HasMissDetailsWith []*MissDetailWhereInput `json:"hasMissDetailsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ActionCacheStatisticsWhereInput) AddPredicates(predicates ...predicate.ActionCacheStatistics) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ActionCacheStatisticsWhereInput filter on the ActionCacheStatisticsQuery builder.
func (i *ActionCacheStatisticsWhereInput) Filter(q *ActionCacheStatisticsQuery) (*ActionCacheStatisticsQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyActionCacheStatisticsWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyActionCacheStatisticsWhereInput is returned in case the ActionCacheStatisticsWhereInput is empty.
var ErrEmptyActionCacheStatisticsWhereInput = errors.New("ent: empty predicate ActionCacheStatisticsWhereInput")

// P returns a predicate for filtering actioncachestatisticsslice.
// An error is returned if the input is empty or invalid.
func (i *ActionCacheStatisticsWhereInput) P() (predicate.ActionCacheStatistics, error) {
	var predicates []predicate.ActionCacheStatistics
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, actioncachestatistics.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ActionCacheStatistics, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, actioncachestatistics.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ActionCacheStatistics, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, actioncachestatistics.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, actioncachestatistics.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, actioncachestatistics.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, actioncachestatistics.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, actioncachestatistics.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, actioncachestatistics.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, actioncachestatistics.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, actioncachestatistics.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, actioncachestatistics.IDLTE(*i.IDLTE))
	}
	if i.SizeInBytes != nil {
		predicates = append(predicates, actioncachestatistics.SizeInBytesEQ(*i.SizeInBytes))
	}
	if i.SizeInBytesNEQ != nil {
		predicates = append(predicates, actioncachestatistics.SizeInBytesNEQ(*i.SizeInBytesNEQ))
	}
	if len(i.SizeInBytesIn) > 0 {
		predicates = append(predicates, actioncachestatistics.SizeInBytesIn(i.SizeInBytesIn...))
	}
	if len(i.SizeInBytesNotIn) > 0 {
		predicates = append(predicates, actioncachestatistics.SizeInBytesNotIn(i.SizeInBytesNotIn...))
	}
	if i.SizeInBytesGT != nil {
		predicates = append(predicates, actioncachestatistics.SizeInBytesGT(*i.SizeInBytesGT))
	}
	if i.SizeInBytesGTE != nil {
		predicates = append(predicates, actioncachestatistics.SizeInBytesGTE(*i.SizeInBytesGTE))
	}
	if i.SizeInBytesLT != nil {
		predicates = append(predicates, actioncachestatistics.SizeInBytesLT(*i.SizeInBytesLT))
	}
	if i.SizeInBytesLTE != nil {
		predicates = append(predicates, actioncachestatistics.SizeInBytesLTE(*i.SizeInBytesLTE))
	}
	if i.SizeInBytesIsNil {
		predicates = append(predicates, actioncachestatistics.SizeInBytesIsNil())
	}
	if i.SizeInBytesNotNil {
		predicates = append(predicates, actioncachestatistics.SizeInBytesNotNil())
	}
	if i.SaveTimeInMs != nil {
		predicates = append(predicates, actioncachestatistics.SaveTimeInMsEQ(*i.SaveTimeInMs))
	}
	if i.SaveTimeInMsNEQ != nil {
		predicates = append(predicates, actioncachestatistics.SaveTimeInMsNEQ(*i.SaveTimeInMsNEQ))
	}
	if len(i.SaveTimeInMsIn) > 0 {
		predicates = append(predicates, actioncachestatistics.SaveTimeInMsIn(i.SaveTimeInMsIn...))
	}
	if len(i.SaveTimeInMsNotIn) > 0 {
		predicates = append(predicates, actioncachestatistics.SaveTimeInMsNotIn(i.SaveTimeInMsNotIn...))
	}
	if i.SaveTimeInMsGT != nil {
		predicates = append(predicates, actioncachestatistics.SaveTimeInMsGT(*i.SaveTimeInMsGT))
	}
	if i.SaveTimeInMsGTE != nil {
		predicates = append(predicates, actioncachestatistics.SaveTimeInMsGTE(*i.SaveTimeInMsGTE))
	}
	if i.SaveTimeInMsLT != nil {
		predicates = append(predicates, actioncachestatistics.SaveTimeInMsLT(*i.SaveTimeInMsLT))
	}
	if i.SaveTimeInMsLTE != nil {
		predicates = append(predicates, actioncachestatistics.SaveTimeInMsLTE(*i.SaveTimeInMsLTE))
	}
	if i.SaveTimeInMsIsNil {
		predicates = append(predicates, actioncachestatistics.SaveTimeInMsIsNil())
	}
	if i.SaveTimeInMsNotNil {
		predicates = append(predicates, actioncachestatistics.SaveTimeInMsNotNil())
	}
	if i.LoadTimeInMs != nil {
		predicates = append(predicates, actioncachestatistics.LoadTimeInMsEQ(*i.LoadTimeInMs))
	}
	if i.LoadTimeInMsNEQ != nil {
		predicates = append(predicates, actioncachestatistics.LoadTimeInMsNEQ(*i.LoadTimeInMsNEQ))
	}
	if len(i.LoadTimeInMsIn) > 0 {
		predicates = append(predicates, actioncachestatistics.LoadTimeInMsIn(i.LoadTimeInMsIn...))
	}
	if len(i.LoadTimeInMsNotIn) > 0 {
		predicates = append(predicates, actioncachestatistics.LoadTimeInMsNotIn(i.LoadTimeInMsNotIn...))
	}
	if i.LoadTimeInMsGT != nil {
		predicates = append(predicates, actioncachestatistics.LoadTimeInMsGT(*i.LoadTimeInMsGT))
	}
	if i.LoadTimeInMsGTE != nil {
		predicates = append(predicates, actioncachestatistics.LoadTimeInMsGTE(*i.LoadTimeInMsGTE))
	}
	if i.LoadTimeInMsLT != nil {
		predicates = append(predicates, actioncachestatistics.LoadTimeInMsLT(*i.LoadTimeInMsLT))
	}
	if i.LoadTimeInMsLTE != nil {
		predicates = append(predicates, actioncachestatistics.LoadTimeInMsLTE(*i.LoadTimeInMsLTE))
	}
	if i.LoadTimeInMsIsNil {
		predicates = append(predicates, actioncachestatistics.LoadTimeInMsIsNil())
	}
	if i.LoadTimeInMsNotNil {
		predicates = append(predicates, actioncachestatistics.LoadTimeInMsNotNil())
	}
	if i.Hits != nil {
		predicates = append(predicates, actioncachestatistics.HitsEQ(*i.Hits))
	}
	if i.HitsNEQ != nil {
		predicates = append(predicates, actioncachestatistics.HitsNEQ(*i.HitsNEQ))
	}
	if len(i.HitsIn) > 0 {
		predicates = append(predicates, actioncachestatistics.HitsIn(i.HitsIn...))
	}
	if len(i.HitsNotIn) > 0 {
		predicates = append(predicates, actioncachestatistics.HitsNotIn(i.HitsNotIn...))
	}
	if i.HitsGT != nil {
		predicates = append(predicates, actioncachestatistics.HitsGT(*i.HitsGT))
	}
	if i.HitsGTE != nil {
		predicates = append(predicates, actioncachestatistics.HitsGTE(*i.HitsGTE))
	}
	if i.HitsLT != nil {
		predicates = append(predicates, actioncachestatistics.HitsLT(*i.HitsLT))
	}
	if i.HitsLTE != nil {
		predicates = append(predicates, actioncachestatistics.HitsLTE(*i.HitsLTE))
	}
	if i.HitsIsNil {
		predicates = append(predicates, actioncachestatistics.HitsIsNil())
	}
	if i.HitsNotNil {
		predicates = append(predicates, actioncachestatistics.HitsNotNil())
	}
	if i.Misses != nil {
		predicates = append(predicates, actioncachestatistics.MissesEQ(*i.Misses))
	}
	if i.MissesNEQ != nil {
		predicates = append(predicates, actioncachestatistics.MissesNEQ(*i.MissesNEQ))
	}
	if len(i.MissesIn) > 0 {
		predicates = append(predicates, actioncachestatistics.MissesIn(i.MissesIn...))
	}
	if len(i.MissesNotIn) > 0 {
		predicates = append(predicates, actioncachestatistics.MissesNotIn(i.MissesNotIn...))
	}
	if i.MissesGT != nil {
		predicates = append(predicates, actioncachestatistics.MissesGT(*i.MissesGT))
	}
	if i.MissesGTE != nil {
		predicates = append(predicates, actioncachestatistics.MissesGTE(*i.MissesGTE))
	}
	if i.MissesLT != nil {
		predicates = append(predicates, actioncachestatistics.MissesLT(*i.MissesLT))
	}
	if i.MissesLTE != nil {
		predicates = append(predicates, actioncachestatistics.MissesLTE(*i.MissesLTE))
	}
	if i.MissesIsNil {
		predicates = append(predicates, actioncachestatistics.MissesIsNil())
	}
	if i.MissesNotNil {
		predicates = append(predicates, actioncachestatistics.MissesNotNil())
	}

	if i.HasActionSummary != nil {
		p := actioncachestatistics.HasActionSummary()
		if !*i.HasActionSummary {
			p = actioncachestatistics.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasActionSummaryWith) > 0 {
		with := make([]predicate.ActionSummary, 0, len(i.HasActionSummaryWith))
		for _, w := range i.HasActionSummaryWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasActionSummaryWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, actioncachestatistics.HasActionSummaryWith(with...))
	}
	if i.HasMissDetails != nil {
		p := actioncachestatistics.HasMissDetails()
		if !*i.HasMissDetails {
			p = actioncachestatistics.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMissDetailsWith) > 0 {
		with := make([]predicate.MissDetail, 0, len(i.HasMissDetailsWith))
		for _, w := range i.HasMissDetailsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMissDetailsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, actioncachestatistics.HasMissDetailsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyActionCacheStatisticsWhereInput
	case 1:
		return predicates[0], nil
	default:
		return actioncachestatistics.And(predicates...), nil
	}
}

// ActionDataWhereInput represents a where input for filtering ActionData queries.
type ActionDataWhereInput struct {
	Predicates []predicate.ActionData  `json:"-"`
	Not        *ActionDataWhereInput   `json:"not,omitempty"`
	Or         []*ActionDataWhereInput `json:"or,omitempty"`
	And        []*ActionDataWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int64  `json:"id,omitempty"`
	IDNEQ   *int64  `json:"idNEQ,omitempty"`
	IDIn    []int64 `json:"idIn,omitempty"`
	IDNotIn []int64 `json:"idNotIn,omitempty"`
	IDGT    *int64  `json:"idGT,omitempty"`
	IDGTE   *int64  `json:"idGTE,omitempty"`
	IDLT    *int64  `json:"idLT,omitempty"`
	IDLTE   *int64  `json:"idLTE,omitempty"`

	// "mnemonic" field predicates.
	Mnemonic             *string  `json:"mnemonic,omitempty"`
	MnemonicNEQ          *string  `json:"mnemonicNEQ,omitempty"`
	MnemonicIn           []string `json:"mnemonicIn,omitempty"`
	MnemonicNotIn        []string `json:"mnemonicNotIn,omitempty"`
	MnemonicGT           *string  `json:"mnemonicGT,omitempty"`
	MnemonicGTE          *string  `json:"mnemonicGTE,omitempty"`
	MnemonicLT           *string  `json:"mnemonicLT,omitempty"`
	MnemonicLTE          *string  `json:"mnemonicLTE,omitempty"`
	MnemonicContains     *string  `json:"mnemonicContains,omitempty"`
	MnemonicHasPrefix    *string  `json:"mnemonicHasPrefix,omitempty"`
	MnemonicHasSuffix    *string  `json:"mnemonicHasSuffix,omitempty"`
	MnemonicIsNil        bool     `json:"mnemonicIsNil,omitempty"`
	MnemonicNotNil       bool     `json:"mnemonicNotNil,omitempty"`
	MnemonicEqualFold    *string  `json:"mnemonicEqualFold,omitempty"`
	MnemonicContainsFold *string  `json:"mnemonicContainsFold,omitempty"`

	// "actions_executed" field predicates.
	ActionsExecuted       *int64  `json:"actionsExecuted,omitempty"`
	ActionsExecutedNEQ    *int64  `json:"actionsExecutedNEQ,omitempty"`
	ActionsExecutedIn     []int64 `json:"actionsExecutedIn,omitempty"`
	ActionsExecutedNotIn  []int64 `json:"actionsExecutedNotIn,omitempty"`
	ActionsExecutedGT     *int64  `json:"actionsExecutedGT,omitempty"`
	ActionsExecutedGTE    *int64  `json:"actionsExecutedGTE,omitempty"`
	ActionsExecutedLT     *int64  `json:"actionsExecutedLT,omitempty"`
	ActionsExecutedLTE    *int64  `json:"actionsExecutedLTE,omitempty"`
	ActionsExecutedIsNil  bool    `json:"actionsExecutedIsNil,omitempty"`
	ActionsExecutedNotNil bool    `json:"actionsExecutedNotNil,omitempty"`

	// "actions_created" field predicates.
	ActionsCreated       *int64  `json:"actionsCreated,omitempty"`
	ActionsCreatedNEQ    *int64  `json:"actionsCreatedNEQ,omitempty"`
	ActionsCreatedIn     []int64 `json:"actionsCreatedIn,omitempty"`
	ActionsCreatedNotIn  []int64 `json:"actionsCreatedNotIn,omitempty"`
	ActionsCreatedGT     *int64  `json:"actionsCreatedGT,omitempty"`
	ActionsCreatedGTE    *int64  `json:"actionsCreatedGTE,omitempty"`
	ActionsCreatedLT     *int64  `json:"actionsCreatedLT,omitempty"`
	ActionsCreatedLTE    *int64  `json:"actionsCreatedLTE,omitempty"`
	ActionsCreatedIsNil  bool    `json:"actionsCreatedIsNil,omitempty"`
	ActionsCreatedNotNil bool    `json:"actionsCreatedNotNil,omitempty"`

	// "first_started_ms" field predicates.
	FirstStartedMs       *int64  `json:"firstStartedMs,omitempty"`
	FirstStartedMsNEQ    *int64  `json:"firstStartedMsNEQ,omitempty"`
	FirstStartedMsIn     []int64 `json:"firstStartedMsIn,omitempty"`
	FirstStartedMsNotIn  []int64 `json:"firstStartedMsNotIn,omitempty"`
	FirstStartedMsGT     *int64  `json:"firstStartedMsGT,omitempty"`
	FirstStartedMsGTE    *int64  `json:"firstStartedMsGTE,omitempty"`
	FirstStartedMsLT     *int64  `json:"firstStartedMsLT,omitempty"`
	FirstStartedMsLTE    *int64  `json:"firstStartedMsLTE,omitempty"`
	FirstStartedMsIsNil  bool    `json:"firstStartedMsIsNil,omitempty"`
	FirstStartedMsNotNil bool    `json:"firstStartedMsNotNil,omitempty"`

	// "last_ended_ms" field predicates.
	LastEndedMs       *int64  `json:"lastEndedMs,omitempty"`
	LastEndedMsNEQ    *int64  `json:"lastEndedMsNEQ,omitempty"`
	LastEndedMsIn     []int64 `json:"lastEndedMsIn,omitempty"`
	LastEndedMsNotIn  []int64 `json:"lastEndedMsNotIn,omitempty"`
	LastEndedMsGT     *int64  `json:"lastEndedMsGT,omitempty"`
	LastEndedMsGTE    *int64  `json:"lastEndedMsGTE,omitempty"`
	LastEndedMsLT     *int64  `json:"lastEndedMsLT,omitempty"`
	LastEndedMsLTE    *int64  `json:"lastEndedMsLTE,omitempty"`
	LastEndedMsIsNil  bool    `json:"lastEndedMsIsNil,omitempty"`
	LastEndedMsNotNil bool    `json:"lastEndedMsNotNil,omitempty"`

	// "system_time" field predicates.
	SystemTime       *int64  `json:"systemTime,omitempty"`
	SystemTimeNEQ    *int64  `json:"systemTimeNEQ,omitempty"`
	SystemTimeIn     []int64 `json:"systemTimeIn,omitempty"`
	SystemTimeNotIn  []int64 `json:"systemTimeNotIn,omitempty"`
	SystemTimeGT     *int64  `json:"systemTimeGT,omitempty"`
	SystemTimeGTE    *int64  `json:"systemTimeGTE,omitempty"`
	SystemTimeLT     *int64  `json:"systemTimeLT,omitempty"`
	SystemTimeLTE    *int64  `json:"systemTimeLTE,omitempty"`
	SystemTimeIsNil  bool    `json:"systemTimeIsNil,omitempty"`
	SystemTimeNotNil bool    `json:"systemTimeNotNil,omitempty"`

	// "user_time" field predicates.
	UserTime       *int64  `json:"userTime,omitempty"`
	UserTimeNEQ    *int64  `json:"userTimeNEQ,omitempty"`
	UserTimeIn     []int64 `json:"userTimeIn,omitempty"`
	UserTimeNotIn  []int64 `json:"userTimeNotIn,omitempty"`
	UserTimeGT     *int64  `json:"userTimeGT,omitempty"`
	UserTimeGTE    *int64  `json:"userTimeGTE,omitempty"`
	UserTimeLT     *int64  `json:"userTimeLT,omitempty"`
	UserTimeLTE    *int64  `json:"userTimeLTE,omitempty"`
	UserTimeIsNil  bool    `json:"userTimeIsNil,omitempty"`
	UserTimeNotNil bool    `json:"userTimeNotNil,omitempty"`

	// "action_summary" edge predicates.
	HasActionSummary     *bool                      `json:"hasActionSummary,omitempty"`
	HasActionSummaryWith []*ActionSummaryWhereInput `json:"hasActionSummaryWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ActionDataWhereInput) AddPredicates(predicates ...predicate.ActionData) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ActionDataWhereInput filter on the ActionDataQuery builder.
func (i *ActionDataWhereInput) Filter(q *ActionDataQuery) (*ActionDataQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyActionDataWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyActionDataWhereInput is returned in case the ActionDataWhereInput is empty.
var ErrEmptyActionDataWhereInput = errors.New("ent: empty predicate ActionDataWhereInput")

// P returns a predicate for filtering actiondataslice.
// An error is returned if the input is empty or invalid.
func (i *ActionDataWhereInput) P() (predicate.ActionData, error) {
	var predicates []predicate.ActionData
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, actiondata.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ActionData, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, actiondata.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ActionData, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, actiondata.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, actiondata.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, actiondata.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, actiondata.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, actiondata.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, actiondata.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, actiondata.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, actiondata.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, actiondata.IDLTE(*i.IDLTE))
	}
	if i.Mnemonic != nil {
		predicates = append(predicates, actiondata.MnemonicEQ(*i.Mnemonic))
	}
	if i.MnemonicNEQ != nil {
		predicates = append(predicates, actiondata.MnemonicNEQ(*i.MnemonicNEQ))
	}
	if len(i.MnemonicIn) > 0 {
		predicates = append(predicates, actiondata.MnemonicIn(i.MnemonicIn...))
	}
	if len(i.MnemonicNotIn) > 0 {
		predicates = append(predicates, actiondata.MnemonicNotIn(i.MnemonicNotIn...))
	}
	if i.MnemonicGT != nil {
		predicates = append(predicates, actiondata.MnemonicGT(*i.MnemonicGT))
	}
	if i.MnemonicGTE != nil {
		predicates = append(predicates, actiondata.MnemonicGTE(*i.MnemonicGTE))
	}
	if i.MnemonicLT != nil {
		predicates = append(predicates, actiondata.MnemonicLT(*i.MnemonicLT))
	}
	if i.MnemonicLTE != nil {
		predicates = append(predicates, actiondata.MnemonicLTE(*i.MnemonicLTE))
	}
	if i.MnemonicContains != nil {
		predicates = append(predicates, actiondata.MnemonicContains(*i.MnemonicContains))
	}
	if i.MnemonicHasPrefix != nil {
		predicates = append(predicates, actiondata.MnemonicHasPrefix(*i.MnemonicHasPrefix))
	}
	if i.MnemonicHasSuffix != nil {
		predicates = append(predicates, actiondata.MnemonicHasSuffix(*i.MnemonicHasSuffix))
	}
	if i.MnemonicIsNil {
		predicates = append(predicates, actiondata.MnemonicIsNil())
	}
	if i.MnemonicNotNil {
		predicates = append(predicates, actiondata.MnemonicNotNil())
	}
	if i.MnemonicEqualFold != nil {
		predicates = append(predicates, actiondata.MnemonicEqualFold(*i.MnemonicEqualFold))
	}
	if i.MnemonicContainsFold != nil {
		predicates = append(predicates, actiondata.MnemonicContainsFold(*i.MnemonicContainsFold))
	}
	if i.ActionsExecuted != nil {
		predicates = append(predicates, actiondata.ActionsExecutedEQ(*i.ActionsExecuted))
	}
	if i.ActionsExecutedNEQ != nil {
		predicates = append(predicates, actiondata.ActionsExecutedNEQ(*i.ActionsExecutedNEQ))
	}
	if len(i.ActionsExecutedIn) > 0 {
		predicates = append(predicates, actiondata.ActionsExecutedIn(i.ActionsExecutedIn...))
	}
	if len(i.ActionsExecutedNotIn) > 0 {
		predicates = append(predicates, actiondata.ActionsExecutedNotIn(i.ActionsExecutedNotIn...))
	}
	if i.ActionsExecutedGT != nil {
		predicates = append(predicates, actiondata.ActionsExecutedGT(*i.ActionsExecutedGT))
	}
	if i.ActionsExecutedGTE != nil {
		predicates = append(predicates, actiondata.ActionsExecutedGTE(*i.ActionsExecutedGTE))
	}
	if i.ActionsExecutedLT != nil {
		predicates = append(predicates, actiondata.ActionsExecutedLT(*i.ActionsExecutedLT))
	}
	if i.ActionsExecutedLTE != nil {
		predicates = append(predicates, actiondata.ActionsExecutedLTE(*i.ActionsExecutedLTE))
	}
	if i.ActionsExecutedIsNil {
		predicates = append(predicates, actiondata.ActionsExecutedIsNil())
	}
	if i.ActionsExecutedNotNil {
		predicates = append(predicates, actiondata.ActionsExecutedNotNil())
	}
	if i.ActionsCreated != nil {
		predicates = append(predicates, actiondata.ActionsCreatedEQ(*i.ActionsCreated))
	}
	if i.ActionsCreatedNEQ != nil {
		predicates = append(predicates, actiondata.ActionsCreatedNEQ(*i.ActionsCreatedNEQ))
	}
	if len(i.ActionsCreatedIn) > 0 {
		predicates = append(predicates, actiondata.ActionsCreatedIn(i.ActionsCreatedIn...))
	}
	if len(i.ActionsCreatedNotIn) > 0 {
		predicates = append(predicates, actiondata.ActionsCreatedNotIn(i.ActionsCreatedNotIn...))
	}
	if i.ActionsCreatedGT != nil {
		predicates = append(predicates, actiondata.ActionsCreatedGT(*i.ActionsCreatedGT))
	}
	if i.ActionsCreatedGTE != nil {
		predicates = append(predicates, actiondata.ActionsCreatedGTE(*i.ActionsCreatedGTE))
	}
	if i.ActionsCreatedLT != nil {
		predicates = append(predicates, actiondata.ActionsCreatedLT(*i.ActionsCreatedLT))
	}
	if i.ActionsCreatedLTE != nil {
		predicates = append(predicates, actiondata.ActionsCreatedLTE(*i.ActionsCreatedLTE))
	}
	if i.ActionsCreatedIsNil {
		predicates = append(predicates, actiondata.ActionsCreatedIsNil())
	}
	if i.ActionsCreatedNotNil {
		predicates = append(predicates, actiondata.ActionsCreatedNotNil())
	}
	if i.FirstStartedMs != nil {
		predicates = append(predicates, actiondata.FirstStartedMsEQ(*i.FirstStartedMs))
	}
	if i.FirstStartedMsNEQ != nil {
		predicates = append(predicates, actiondata.FirstStartedMsNEQ(*i.FirstStartedMsNEQ))
	}
	if len(i.FirstStartedMsIn) > 0 {
		predicates = append(predicates, actiondata.FirstStartedMsIn(i.FirstStartedMsIn...))
	}
	if len(i.FirstStartedMsNotIn) > 0 {
		predicates = append(predicates, actiondata.FirstStartedMsNotIn(i.FirstStartedMsNotIn...))
	}
	if i.FirstStartedMsGT != nil {
		predicates = append(predicates, actiondata.FirstStartedMsGT(*i.FirstStartedMsGT))
	}
	if i.FirstStartedMsGTE != nil {
		predicates = append(predicates, actiondata.FirstStartedMsGTE(*i.FirstStartedMsGTE))
	}
	if i.FirstStartedMsLT != nil {
		predicates = append(predicates, actiondata.FirstStartedMsLT(*i.FirstStartedMsLT))
	}
	if i.FirstStartedMsLTE != nil {
		predicates = append(predicates, actiondata.FirstStartedMsLTE(*i.FirstStartedMsLTE))
	}
	if i.FirstStartedMsIsNil {
		predicates = append(predicates, actiondata.FirstStartedMsIsNil())
	}
	if i.FirstStartedMsNotNil {
		predicates = append(predicates, actiondata.FirstStartedMsNotNil())
	}
	if i.LastEndedMs != nil {
		predicates = append(predicates, actiondata.LastEndedMsEQ(*i.LastEndedMs))
	}
	if i.LastEndedMsNEQ != nil {
		predicates = append(predicates, actiondata.LastEndedMsNEQ(*i.LastEndedMsNEQ))
	}
	if len(i.LastEndedMsIn) > 0 {
		predicates = append(predicates, actiondata.LastEndedMsIn(i.LastEndedMsIn...))
	}
	if len(i.LastEndedMsNotIn) > 0 {
		predicates = append(predicates, actiondata.LastEndedMsNotIn(i.LastEndedMsNotIn...))
	}
	if i.LastEndedMsGT != nil {
		predicates = append(predicates, actiondata.LastEndedMsGT(*i.LastEndedMsGT))
	}
	if i.LastEndedMsGTE != nil {
		predicates = append(predicates, actiondata.LastEndedMsGTE(*i.LastEndedMsGTE))
	}
	if i.LastEndedMsLT != nil {
		predicates = append(predicates, actiondata.LastEndedMsLT(*i.LastEndedMsLT))
	}
	if i.LastEndedMsLTE != nil {
		predicates = append(predicates, actiondata.LastEndedMsLTE(*i.LastEndedMsLTE))
	}
	if i.LastEndedMsIsNil {
		predicates = append(predicates, actiondata.LastEndedMsIsNil())
	}
	if i.LastEndedMsNotNil {
		predicates = append(predicates, actiondata.LastEndedMsNotNil())
	}
	if i.SystemTime != nil {
		predicates = append(predicates, actiondata.SystemTimeEQ(*i.SystemTime))
	}
	if i.SystemTimeNEQ != nil {
		predicates = append(predicates, actiondata.SystemTimeNEQ(*i.SystemTimeNEQ))
	}
	if len(i.SystemTimeIn) > 0 {
		predicates = append(predicates, actiondata.SystemTimeIn(i.SystemTimeIn...))
	}
	if len(i.SystemTimeNotIn) > 0 {
		predicates = append(predicates, actiondata.SystemTimeNotIn(i.SystemTimeNotIn...))
	}
	if i.SystemTimeGT != nil {
		predicates = append(predicates, actiondata.SystemTimeGT(*i.SystemTimeGT))
	}
	if i.SystemTimeGTE != nil {
		predicates = append(predicates, actiondata.SystemTimeGTE(*i.SystemTimeGTE))
	}
	if i.SystemTimeLT != nil {
		predicates = append(predicates, actiondata.SystemTimeLT(*i.SystemTimeLT))
	}
	if i.SystemTimeLTE != nil {
		predicates = append(predicates, actiondata.SystemTimeLTE(*i.SystemTimeLTE))
	}
	if i.SystemTimeIsNil {
		predicates = append(predicates, actiondata.SystemTimeIsNil())
	}
	if i.SystemTimeNotNil {
		predicates = append(predicates, actiondata.SystemTimeNotNil())
	}
	if i.UserTime != nil {
		predicates = append(predicates, actiondata.UserTimeEQ(*i.UserTime))
	}
	if i.UserTimeNEQ != nil {
		predicates = append(predicates, actiondata.UserTimeNEQ(*i.UserTimeNEQ))
	}
	if len(i.UserTimeIn) > 0 {
		predicates = append(predicates, actiondata.UserTimeIn(i.UserTimeIn...))
	}
	if len(i.UserTimeNotIn) > 0 {
		predicates = append(predicates, actiondata.UserTimeNotIn(i.UserTimeNotIn...))
	}
	if i.UserTimeGT != nil {
		predicates = append(predicates, actiondata.UserTimeGT(*i.UserTimeGT))
	}
	if i.UserTimeGTE != nil {
		predicates = append(predicates, actiondata.UserTimeGTE(*i.UserTimeGTE))
	}
	if i.UserTimeLT != nil {
		predicates = append(predicates, actiondata.UserTimeLT(*i.UserTimeLT))
	}
	if i.UserTimeLTE != nil {
		predicates = append(predicates, actiondata.UserTimeLTE(*i.UserTimeLTE))
	}
	if i.UserTimeIsNil {
		predicates = append(predicates, actiondata.UserTimeIsNil())
	}
	if i.UserTimeNotNil {
		predicates = append(predicates, actiondata.UserTimeNotNil())
	}

	if i.HasActionSummary != nil {
		p := actiondata.HasActionSummary()
		if !*i.HasActionSummary {
			p = actiondata.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasActionSummaryWith) > 0 {
		with := make([]predicate.ActionSummary, 0, len(i.HasActionSummaryWith))
		for _, w := range i.HasActionSummaryWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasActionSummaryWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, actiondata.HasActionSummaryWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyActionDataWhereInput
	case 1:
		return predicates[0], nil
	default:
		return actiondata.And(predicates...), nil
	}
}

// ActionSummaryWhereInput represents a where input for filtering ActionSummary queries.
type ActionSummaryWhereInput struct {
	Predicates []predicate.ActionSummary  `json:"-"`
	Not        *ActionSummaryWhereInput   `json:"not,omitempty"`
	Or         []*ActionSummaryWhereInput `json:"or,omitempty"`
	And        []*ActionSummaryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int64  `json:"id,omitempty"`
	IDNEQ   *int64  `json:"idNEQ,omitempty"`
	IDIn    []int64 `json:"idIn,omitempty"`
	IDNotIn []int64 `json:"idNotIn,omitempty"`
	IDGT    *int64  `json:"idGT,omitempty"`
	IDGTE   *int64  `json:"idGTE,omitempty"`
	IDLT    *int64  `json:"idLT,omitempty"`
	IDLTE   *int64  `json:"idLTE,omitempty"`

	// "actions_created" field predicates.
	ActionsCreated       *int64  `json:"actionsCreated,omitempty"`
	ActionsCreatedNEQ    *int64  `json:"actionsCreatedNEQ,omitempty"`
	ActionsCreatedIn     []int64 `json:"actionsCreatedIn,omitempty"`
	ActionsCreatedNotIn  []int64 `json:"actionsCreatedNotIn,omitempty"`
	ActionsCreatedGT     *int64  `json:"actionsCreatedGT,omitempty"`
	ActionsCreatedGTE    *int64  `json:"actionsCreatedGTE,omitempty"`
	ActionsCreatedLT     *int64  `json:"actionsCreatedLT,omitempty"`
	ActionsCreatedLTE    *int64  `json:"actionsCreatedLTE,omitempty"`
	ActionsCreatedIsNil  bool    `json:"actionsCreatedIsNil,omitempty"`
	ActionsCreatedNotNil bool    `json:"actionsCreatedNotNil,omitempty"`

	// "actions_created_not_including_aspects" field predicates.
	ActionsCreatedNotIncludingAspects       *int64  `json:"actionsCreatedNotIncludingAspects,omitempty"`
	ActionsCreatedNotIncludingAspectsNEQ    *int64  `json:"actionsCreatedNotIncludingAspectsNEQ,omitempty"`
	ActionsCreatedNotIncludingAspectsIn     []int64 `json:"actionsCreatedNotIncludingAspectsIn,omitempty"`
	ActionsCreatedNotIncludingAspectsNotIn  []int64 `json:"actionsCreatedNotIncludingAspectsNotIn,omitempty"`
	ActionsCreatedNotIncludingAspectsGT     *int64  `json:"actionsCreatedNotIncludingAspectsGT,omitempty"`
	ActionsCreatedNotIncludingAspectsGTE    *int64  `json:"actionsCreatedNotIncludingAspectsGTE,omitempty"`
	ActionsCreatedNotIncludingAspectsLT     *int64  `json:"actionsCreatedNotIncludingAspectsLT,omitempty"`
	ActionsCreatedNotIncludingAspectsLTE    *int64  `json:"actionsCreatedNotIncludingAspectsLTE,omitempty"`
	ActionsCreatedNotIncludingAspectsIsNil  bool    `json:"actionsCreatedNotIncludingAspectsIsNil,omitempty"`
	ActionsCreatedNotIncludingAspectsNotNil bool    `json:"actionsCreatedNotIncludingAspectsNotNil,omitempty"`

	// "actions_executed" field predicates.
	ActionsExecuted       *int64  `json:"actionsExecuted,omitempty"`
	ActionsExecutedNEQ    *int64  `json:"actionsExecutedNEQ,omitempty"`
	ActionsExecutedIn     []int64 `json:"actionsExecutedIn,omitempty"`
	ActionsExecutedNotIn  []int64 `json:"actionsExecutedNotIn,omitempty"`
	ActionsExecutedGT     *int64  `json:"actionsExecutedGT,omitempty"`
	ActionsExecutedGTE    *int64  `json:"actionsExecutedGTE,omitempty"`
	ActionsExecutedLT     *int64  `json:"actionsExecutedLT,omitempty"`
	ActionsExecutedLTE    *int64  `json:"actionsExecutedLTE,omitempty"`
	ActionsExecutedIsNil  bool    `json:"actionsExecutedIsNil,omitempty"`
	ActionsExecutedNotNil bool    `json:"actionsExecutedNotNil,omitempty"`

	// "remote_cache_hits" field predicates.
	RemoteCacheHits       *int64  `json:"remoteCacheHits,omitempty"`
	RemoteCacheHitsNEQ    *int64  `json:"remoteCacheHitsNEQ,omitempty"`
	RemoteCacheHitsIn     []int64 `json:"remoteCacheHitsIn,omitempty"`
	RemoteCacheHitsNotIn  []int64 `json:"remoteCacheHitsNotIn,omitempty"`
	RemoteCacheHitsGT     *int64  `json:"remoteCacheHitsGT,omitempty"`
	RemoteCacheHitsGTE    *int64  `json:"remoteCacheHitsGTE,omitempty"`
	RemoteCacheHitsLT     *int64  `json:"remoteCacheHitsLT,omitempty"`
	RemoteCacheHitsLTE    *int64  `json:"remoteCacheHitsLTE,omitempty"`
	RemoteCacheHitsIsNil  bool    `json:"remoteCacheHitsIsNil,omitempty"`
	RemoteCacheHitsNotNil bool    `json:"remoteCacheHitsNotNil,omitempty"`

	// "metrics" edge predicates.
	HasMetrics     *bool                `json:"hasMetrics,omitempty"`
	HasMetricsWith []*MetricsWhereInput `json:"hasMetricsWith,omitempty"`

	// "action_data" edge predicates.
	HasActionData     *bool                   `json:"hasActionData,omitempty"`
	HasActionDataWith []*ActionDataWhereInput `json:"hasActionDataWith,omitempty"`

	// "runner_count" edge predicates.
	HasRunnerCount     *bool                    `json:"hasRunnerCount,omitempty"`
	HasRunnerCountWith []*RunnerCountWhereInput `json:"hasRunnerCountWith,omitempty"`

	// "action_cache_statistics" edge predicates.
	HasActionCacheStatistics     *bool                              `json:"hasActionCacheStatistics,omitempty"`
	HasActionCacheStatisticsWith []*ActionCacheStatisticsWhereInput `json:"hasActionCacheStatisticsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ActionSummaryWhereInput) AddPredicates(predicates ...predicate.ActionSummary) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ActionSummaryWhereInput filter on the ActionSummaryQuery builder.
func (i *ActionSummaryWhereInput) Filter(q *ActionSummaryQuery) (*ActionSummaryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyActionSummaryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyActionSummaryWhereInput is returned in case the ActionSummaryWhereInput is empty.
var ErrEmptyActionSummaryWhereInput = errors.New("ent: empty predicate ActionSummaryWhereInput")

// P returns a predicate for filtering actionsummaries.
// An error is returned if the input is empty or invalid.
func (i *ActionSummaryWhereInput) P() (predicate.ActionSummary, error) {
	var predicates []predicate.ActionSummary
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, actionsummary.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ActionSummary, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, actionsummary.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ActionSummary, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, actionsummary.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, actionsummary.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, actionsummary.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, actionsummary.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, actionsummary.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, actionsummary.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, actionsummary.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, actionsummary.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, actionsummary.IDLTE(*i.IDLTE))
	}
	if i.ActionsCreated != nil {
		predicates = append(predicates, actionsummary.ActionsCreatedEQ(*i.ActionsCreated))
	}
	if i.ActionsCreatedNEQ != nil {
		predicates = append(predicates, actionsummary.ActionsCreatedNEQ(*i.ActionsCreatedNEQ))
	}
	if len(i.ActionsCreatedIn) > 0 {
		predicates = append(predicates, actionsummary.ActionsCreatedIn(i.ActionsCreatedIn...))
	}
	if len(i.ActionsCreatedNotIn) > 0 {
		predicates = append(predicates, actionsummary.ActionsCreatedNotIn(i.ActionsCreatedNotIn...))
	}
	if i.ActionsCreatedGT != nil {
		predicates = append(predicates, actionsummary.ActionsCreatedGT(*i.ActionsCreatedGT))
	}
	if i.ActionsCreatedGTE != nil {
		predicates = append(predicates, actionsummary.ActionsCreatedGTE(*i.ActionsCreatedGTE))
	}
	if i.ActionsCreatedLT != nil {
		predicates = append(predicates, actionsummary.ActionsCreatedLT(*i.ActionsCreatedLT))
	}
	if i.ActionsCreatedLTE != nil {
		predicates = append(predicates, actionsummary.ActionsCreatedLTE(*i.ActionsCreatedLTE))
	}
	if i.ActionsCreatedIsNil {
		predicates = append(predicates, actionsummary.ActionsCreatedIsNil())
	}
	if i.ActionsCreatedNotNil {
		predicates = append(predicates, actionsummary.ActionsCreatedNotNil())
	}
	if i.ActionsCreatedNotIncludingAspects != nil {
		predicates = append(predicates, actionsummary.ActionsCreatedNotIncludingAspectsEQ(*i.ActionsCreatedNotIncludingAspects))
	}
	if i.ActionsCreatedNotIncludingAspectsNEQ != nil {
		predicates = append(predicates, actionsummary.ActionsCreatedNotIncludingAspectsNEQ(*i.ActionsCreatedNotIncludingAspectsNEQ))
	}
	if len(i.ActionsCreatedNotIncludingAspectsIn) > 0 {
		predicates = append(predicates, actionsummary.ActionsCreatedNotIncludingAspectsIn(i.ActionsCreatedNotIncludingAspectsIn...))
	}
	if len(i.ActionsCreatedNotIncludingAspectsNotIn) > 0 {
		predicates = append(predicates, actionsummary.ActionsCreatedNotIncludingAspectsNotIn(i.ActionsCreatedNotIncludingAspectsNotIn...))
	}
	if i.ActionsCreatedNotIncludingAspectsGT != nil {
		predicates = append(predicates, actionsummary.ActionsCreatedNotIncludingAspectsGT(*i.ActionsCreatedNotIncludingAspectsGT))
	}
	if i.ActionsCreatedNotIncludingAspectsGTE != nil {
		predicates = append(predicates, actionsummary.ActionsCreatedNotIncludingAspectsGTE(*i.ActionsCreatedNotIncludingAspectsGTE))
	}
	if i.ActionsCreatedNotIncludingAspectsLT != nil {
		predicates = append(predicates, actionsummary.ActionsCreatedNotIncludingAspectsLT(*i.ActionsCreatedNotIncludingAspectsLT))
	}
	if i.ActionsCreatedNotIncludingAspectsLTE != nil {
		predicates = append(predicates, actionsummary.ActionsCreatedNotIncludingAspectsLTE(*i.ActionsCreatedNotIncludingAspectsLTE))
	}
	if i.ActionsCreatedNotIncludingAspectsIsNil {
		predicates = append(predicates, actionsummary.ActionsCreatedNotIncludingAspectsIsNil())
	}
	if i.ActionsCreatedNotIncludingAspectsNotNil {
		predicates = append(predicates, actionsummary.ActionsCreatedNotIncludingAspectsNotNil())
	}
	if i.ActionsExecuted != nil {
		predicates = append(predicates, actionsummary.ActionsExecutedEQ(*i.ActionsExecuted))
	}
	if i.ActionsExecutedNEQ != nil {
		predicates = append(predicates, actionsummary.ActionsExecutedNEQ(*i.ActionsExecutedNEQ))
	}
	if len(i.ActionsExecutedIn) > 0 {
		predicates = append(predicates, actionsummary.ActionsExecutedIn(i.ActionsExecutedIn...))
	}
	if len(i.ActionsExecutedNotIn) > 0 {
		predicates = append(predicates, actionsummary.ActionsExecutedNotIn(i.ActionsExecutedNotIn...))
	}
	if i.ActionsExecutedGT != nil {
		predicates = append(predicates, actionsummary.ActionsExecutedGT(*i.ActionsExecutedGT))
	}
	if i.ActionsExecutedGTE != nil {
		predicates = append(predicates, actionsummary.ActionsExecutedGTE(*i.ActionsExecutedGTE))
	}
	if i.ActionsExecutedLT != nil {
		predicates = append(predicates, actionsummary.ActionsExecutedLT(*i.ActionsExecutedLT))
	}
	if i.ActionsExecutedLTE != nil {
		predicates = append(predicates, actionsummary.ActionsExecutedLTE(*i.ActionsExecutedLTE))
	}
	if i.ActionsExecutedIsNil {
		predicates = append(predicates, actionsummary.ActionsExecutedIsNil())
	}
	if i.ActionsExecutedNotNil {
		predicates = append(predicates, actionsummary.ActionsExecutedNotNil())
	}
	if i.RemoteCacheHits != nil {
		predicates = append(predicates, actionsummary.RemoteCacheHitsEQ(*i.RemoteCacheHits))
	}
	if i.RemoteCacheHitsNEQ != nil {
		predicates = append(predicates, actionsummary.RemoteCacheHitsNEQ(*i.RemoteCacheHitsNEQ))
	}
	if len(i.RemoteCacheHitsIn) > 0 {
		predicates = append(predicates, actionsummary.RemoteCacheHitsIn(i.RemoteCacheHitsIn...))
	}
	if len(i.RemoteCacheHitsNotIn) > 0 {
		predicates = append(predicates, actionsummary.RemoteCacheHitsNotIn(i.RemoteCacheHitsNotIn...))
	}
	if i.RemoteCacheHitsGT != nil {
		predicates = append(predicates, actionsummary.RemoteCacheHitsGT(*i.RemoteCacheHitsGT))
	}
	if i.RemoteCacheHitsGTE != nil {
		predicates = append(predicates, actionsummary.RemoteCacheHitsGTE(*i.RemoteCacheHitsGTE))
	}
	if i.RemoteCacheHitsLT != nil {
		predicates = append(predicates, actionsummary.RemoteCacheHitsLT(*i.RemoteCacheHitsLT))
	}
	if i.RemoteCacheHitsLTE != nil {
		predicates = append(predicates, actionsummary.RemoteCacheHitsLTE(*i.RemoteCacheHitsLTE))
	}
	if i.RemoteCacheHitsIsNil {
		predicates = append(predicates, actionsummary.RemoteCacheHitsIsNil())
	}
	if i.RemoteCacheHitsNotNil {
		predicates = append(predicates, actionsummary.RemoteCacheHitsNotNil())
	}

	if i.HasMetrics != nil {
		p := actionsummary.HasMetrics()
		if !*i.HasMetrics {
			p = actionsummary.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMetricsWith) > 0 {
		with := make([]predicate.Metrics, 0, len(i.HasMetricsWith))
		for _, w := range i.HasMetricsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMetricsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, actionsummary.HasMetricsWith(with...))
	}
	if i.HasActionData != nil {
		p := actionsummary.HasActionData()
		if !*i.HasActionData {
			p = actionsummary.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasActionDataWith) > 0 {
		with := make([]predicate.ActionData, 0, len(i.HasActionDataWith))
		for _, w := range i.HasActionDataWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasActionDataWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, actionsummary.HasActionDataWith(with...))
	}
	if i.HasRunnerCount != nil {
		p := actionsummary.HasRunnerCount()
		if !*i.HasRunnerCount {
			p = actionsummary.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRunnerCountWith) > 0 {
		with := make([]predicate.RunnerCount, 0, len(i.HasRunnerCountWith))
		for _, w := range i.HasRunnerCountWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRunnerCountWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, actionsummary.HasRunnerCountWith(with...))
	}
	if i.HasActionCacheStatistics != nil {
		p := actionsummary.HasActionCacheStatistics()
		if !*i.HasActionCacheStatistics {
			p = actionsummary.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasActionCacheStatisticsWith) > 0 {
		with := make([]predicate.ActionCacheStatistics, 0, len(i.HasActionCacheStatisticsWith))
		for _, w := range i.HasActionCacheStatisticsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasActionCacheStatisticsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, actionsummary.HasActionCacheStatisticsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyActionSummaryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return actionsummary.And(predicates...), nil
	}
}

// ArtifactMetricsWhereInput represents a where input for filtering ArtifactMetrics queries.
type ArtifactMetricsWhereInput struct {
	Predicates []predicate.ArtifactMetrics  `json:"-"`
	Not        *ArtifactMetricsWhereInput   `json:"not,omitempty"`
	Or         []*ArtifactMetricsWhereInput `json:"or,omitempty"`
	And        []*ArtifactMetricsWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int64  `json:"id,omitempty"`
	IDNEQ   *int64  `json:"idNEQ,omitempty"`
	IDIn    []int64 `json:"idIn,omitempty"`
	IDNotIn []int64 `json:"idNotIn,omitempty"`
	IDGT    *int64  `json:"idGT,omitempty"`
	IDGTE   *int64  `json:"idGTE,omitempty"`
	IDLT    *int64  `json:"idLT,omitempty"`
	IDLTE   *int64  `json:"idLTE,omitempty"`

	// "source_artifacts_read_size_in_bytes" field predicates.
	SourceArtifactsReadSizeInBytes       *int64  `json:"sourceArtifactsReadSizeInBytes,omitempty"`
	SourceArtifactsReadSizeInBytesNEQ    *int64  `json:"sourceArtifactsReadSizeInBytesNEQ,omitempty"`
	SourceArtifactsReadSizeInBytesIn     []int64 `json:"sourceArtifactsReadSizeInBytesIn,omitempty"`
	SourceArtifactsReadSizeInBytesNotIn  []int64 `json:"sourceArtifactsReadSizeInBytesNotIn,omitempty"`
	SourceArtifactsReadSizeInBytesGT     *int64  `json:"sourceArtifactsReadSizeInBytesGT,omitempty"`
	SourceArtifactsReadSizeInBytesGTE    *int64  `json:"sourceArtifactsReadSizeInBytesGTE,omitempty"`
	SourceArtifactsReadSizeInBytesLT     *int64  `json:"sourceArtifactsReadSizeInBytesLT,omitempty"`
	SourceArtifactsReadSizeInBytesLTE    *int64  `json:"sourceArtifactsReadSizeInBytesLTE,omitempty"`
	SourceArtifactsReadSizeInBytesIsNil  bool    `json:"sourceArtifactsReadSizeInBytesIsNil,omitempty"`
	SourceArtifactsReadSizeInBytesNotNil bool    `json:"sourceArtifactsReadSizeInBytesNotNil,omitempty"`

	// "source_artifacts_read_count" field predicates.
	SourceArtifactsReadCount       *int32  `json:"sourceArtifactsReadCount,omitempty"`
	SourceArtifactsReadCountNEQ    *int32  `json:"sourceArtifactsReadCountNEQ,omitempty"`
	SourceArtifactsReadCountIn     []int32 `json:"sourceArtifactsReadCountIn,omitempty"`
	SourceArtifactsReadCountNotIn  []int32 `json:"sourceArtifactsReadCountNotIn,omitempty"`
	SourceArtifactsReadCountGT     *int32  `json:"sourceArtifactsReadCountGT,omitempty"`
	SourceArtifactsReadCountGTE    *int32  `json:"sourceArtifactsReadCountGTE,omitempty"`
	SourceArtifactsReadCountLT     *int32  `json:"sourceArtifactsReadCountLT,omitempty"`
	SourceArtifactsReadCountLTE    *int32  `json:"sourceArtifactsReadCountLTE,omitempty"`
	SourceArtifactsReadCountIsNil  bool    `json:"sourceArtifactsReadCountIsNil,omitempty"`
	SourceArtifactsReadCountNotNil bool    `json:"sourceArtifactsReadCountNotNil,omitempty"`

	// "output_artifacts_seen_size_in_bytes" field predicates.
	OutputArtifactsSeenSizeInBytes       *int64  `json:"outputArtifactsSeenSizeInBytes,omitempty"`
	OutputArtifactsSeenSizeInBytesNEQ    *int64  `json:"outputArtifactsSeenSizeInBytesNEQ,omitempty"`
	OutputArtifactsSeenSizeInBytesIn     []int64 `json:"outputArtifactsSeenSizeInBytesIn,omitempty"`
	OutputArtifactsSeenSizeInBytesNotIn  []int64 `json:"outputArtifactsSeenSizeInBytesNotIn,omitempty"`
	OutputArtifactsSeenSizeInBytesGT     *int64  `json:"outputArtifactsSeenSizeInBytesGT,omitempty"`
	OutputArtifactsSeenSizeInBytesGTE    *int64  `json:"outputArtifactsSeenSizeInBytesGTE,omitempty"`
	OutputArtifactsSeenSizeInBytesLT     *int64  `json:"outputArtifactsSeenSizeInBytesLT,omitempty"`
	OutputArtifactsSeenSizeInBytesLTE    *int64  `json:"outputArtifactsSeenSizeInBytesLTE,omitempty"`
	OutputArtifactsSeenSizeInBytesIsNil  bool    `json:"outputArtifactsSeenSizeInBytesIsNil,omitempty"`
	OutputArtifactsSeenSizeInBytesNotNil bool    `json:"outputArtifactsSeenSizeInBytesNotNil,omitempty"`

	// "output_artifacts_seen_count" field predicates.
	OutputArtifactsSeenCount       *int32  `json:"outputArtifactsSeenCount,omitempty"`
	OutputArtifactsSeenCountNEQ    *int32  `json:"outputArtifactsSeenCountNEQ,omitempty"`
	OutputArtifactsSeenCountIn     []int32 `json:"outputArtifactsSeenCountIn,omitempty"`
	OutputArtifactsSeenCountNotIn  []int32 `json:"outputArtifactsSeenCountNotIn,omitempty"`
	OutputArtifactsSeenCountGT     *int32  `json:"outputArtifactsSeenCountGT,omitempty"`
	OutputArtifactsSeenCountGTE    *int32  `json:"outputArtifactsSeenCountGTE,omitempty"`
	OutputArtifactsSeenCountLT     *int32  `json:"outputArtifactsSeenCountLT,omitempty"`
	OutputArtifactsSeenCountLTE    *int32  `json:"outputArtifactsSeenCountLTE,omitempty"`
	OutputArtifactsSeenCountIsNil  bool    `json:"outputArtifactsSeenCountIsNil,omitempty"`
	OutputArtifactsSeenCountNotNil bool    `json:"outputArtifactsSeenCountNotNil,omitempty"`

	// "output_artifacts_from_action_cache_size_in_bytes" field predicates.
	OutputArtifactsFromActionCacheSizeInBytes       *int64  `json:"outputArtifactsFromActionCacheSizeInBytes,omitempty"`
	OutputArtifactsFromActionCacheSizeInBytesNEQ    *int64  `json:"outputArtifactsFromActionCacheSizeInBytesNEQ,omitempty"`
	OutputArtifactsFromActionCacheSizeInBytesIn     []int64 `json:"outputArtifactsFromActionCacheSizeInBytesIn,omitempty"`
	OutputArtifactsFromActionCacheSizeInBytesNotIn  []int64 `json:"outputArtifactsFromActionCacheSizeInBytesNotIn,omitempty"`
	OutputArtifactsFromActionCacheSizeInBytesGT     *int64  `json:"outputArtifactsFromActionCacheSizeInBytesGT,omitempty"`
	OutputArtifactsFromActionCacheSizeInBytesGTE    *int64  `json:"outputArtifactsFromActionCacheSizeInBytesGTE,omitempty"`
	OutputArtifactsFromActionCacheSizeInBytesLT     *int64  `json:"outputArtifactsFromActionCacheSizeInBytesLT,omitempty"`
	OutputArtifactsFromActionCacheSizeInBytesLTE    *int64  `json:"outputArtifactsFromActionCacheSizeInBytesLTE,omitempty"`
	OutputArtifactsFromActionCacheSizeInBytesIsNil  bool    `json:"outputArtifactsFromActionCacheSizeInBytesIsNil,omitempty"`
	OutputArtifactsFromActionCacheSizeInBytesNotNil bool    `json:"outputArtifactsFromActionCacheSizeInBytesNotNil,omitempty"`

	// "output_artifacts_from_action_cache_count" field predicates.
	OutputArtifactsFromActionCacheCount       *int32  `json:"outputArtifactsFromActionCacheCount,omitempty"`
	OutputArtifactsFromActionCacheCountNEQ    *int32  `json:"outputArtifactsFromActionCacheCountNEQ,omitempty"`
	OutputArtifactsFromActionCacheCountIn     []int32 `json:"outputArtifactsFromActionCacheCountIn,omitempty"`
	OutputArtifactsFromActionCacheCountNotIn  []int32 `json:"outputArtifactsFromActionCacheCountNotIn,omitempty"`
	OutputArtifactsFromActionCacheCountGT     *int32  `json:"outputArtifactsFromActionCacheCountGT,omitempty"`
	OutputArtifactsFromActionCacheCountGTE    *int32  `json:"outputArtifactsFromActionCacheCountGTE,omitempty"`
	OutputArtifactsFromActionCacheCountLT     *int32  `json:"outputArtifactsFromActionCacheCountLT,omitempty"`
	OutputArtifactsFromActionCacheCountLTE    *int32  `json:"outputArtifactsFromActionCacheCountLTE,omitempty"`
	OutputArtifactsFromActionCacheCountIsNil  bool    `json:"outputArtifactsFromActionCacheCountIsNil,omitempty"`
	OutputArtifactsFromActionCacheCountNotNil bool    `json:"outputArtifactsFromActionCacheCountNotNil,omitempty"`

	// "top_level_artifacts_size_in_bytes" field predicates.
	TopLevelArtifactsSizeInBytes       *int64  `json:"topLevelArtifactsSizeInBytes,omitempty"`
	TopLevelArtifactsSizeInBytesNEQ    *int64  `json:"topLevelArtifactsSizeInBytesNEQ,omitempty"`
	TopLevelArtifactsSizeInBytesIn     []int64 `json:"topLevelArtifactsSizeInBytesIn,omitempty"`
	TopLevelArtifactsSizeInBytesNotIn  []int64 `json:"topLevelArtifactsSizeInBytesNotIn,omitempty"`
	TopLevelArtifactsSizeInBytesGT     *int64  `json:"topLevelArtifactsSizeInBytesGT,omitempty"`
	TopLevelArtifactsSizeInBytesGTE    *int64  `json:"topLevelArtifactsSizeInBytesGTE,omitempty"`
	TopLevelArtifactsSizeInBytesLT     *int64  `json:"topLevelArtifactsSizeInBytesLT,omitempty"`
	TopLevelArtifactsSizeInBytesLTE    *int64  `json:"topLevelArtifactsSizeInBytesLTE,omitempty"`
	TopLevelArtifactsSizeInBytesIsNil  bool    `json:"topLevelArtifactsSizeInBytesIsNil,omitempty"`
	TopLevelArtifactsSizeInBytesNotNil bool    `json:"topLevelArtifactsSizeInBytesNotNil,omitempty"`

	// "top_level_artifacts_count" field predicates.
	TopLevelArtifactsCount       *int32  `json:"topLevelArtifactsCount,omitempty"`
	TopLevelArtifactsCountNEQ    *int32  `json:"topLevelArtifactsCountNEQ,omitempty"`
	TopLevelArtifactsCountIn     []int32 `json:"topLevelArtifactsCountIn,omitempty"`
	TopLevelArtifactsCountNotIn  []int32 `json:"topLevelArtifactsCountNotIn,omitempty"`
	TopLevelArtifactsCountGT     *int32  `json:"topLevelArtifactsCountGT,omitempty"`
	TopLevelArtifactsCountGTE    *int32  `json:"topLevelArtifactsCountGTE,omitempty"`
	TopLevelArtifactsCountLT     *int32  `json:"topLevelArtifactsCountLT,omitempty"`
	TopLevelArtifactsCountLTE    *int32  `json:"topLevelArtifactsCountLTE,omitempty"`
	TopLevelArtifactsCountIsNil  bool    `json:"topLevelArtifactsCountIsNil,omitempty"`
	TopLevelArtifactsCountNotNil bool    `json:"topLevelArtifactsCountNotNil,omitempty"`

	// "metrics" edge predicates.
	HasMetrics     *bool                `json:"hasMetrics,omitempty"`
	HasMetricsWith []*MetricsWhereInput `json:"hasMetricsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ArtifactMetricsWhereInput) AddPredicates(predicates ...predicate.ArtifactMetrics) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ArtifactMetricsWhereInput filter on the ArtifactMetricsQuery builder.
func (i *ArtifactMetricsWhereInput) Filter(q *ArtifactMetricsQuery) (*ArtifactMetricsQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyArtifactMetricsWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyArtifactMetricsWhereInput is returned in case the ArtifactMetricsWhereInput is empty.
var ErrEmptyArtifactMetricsWhereInput = errors.New("ent: empty predicate ArtifactMetricsWhereInput")

// P returns a predicate for filtering artifactmetricsslice.
// An error is returned if the input is empty or invalid.
func (i *ArtifactMetricsWhereInput) P() (predicate.ArtifactMetrics, error) {
	var predicates []predicate.ArtifactMetrics
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, artifactmetrics.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ArtifactMetrics, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, artifactmetrics.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ArtifactMetrics, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, artifactmetrics.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, artifactmetrics.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, artifactmetrics.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, artifactmetrics.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, artifactmetrics.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, artifactmetrics.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, artifactmetrics.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, artifactmetrics.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, artifactmetrics.IDLTE(*i.IDLTE))
	}
	if i.SourceArtifactsReadSizeInBytes != nil {
		predicates = append(predicates, artifactmetrics.SourceArtifactsReadSizeInBytesEQ(*i.SourceArtifactsReadSizeInBytes))
	}
	if i.SourceArtifactsReadSizeInBytesNEQ != nil {
		predicates = append(predicates, artifactmetrics.SourceArtifactsReadSizeInBytesNEQ(*i.SourceArtifactsReadSizeInBytesNEQ))
	}
	if len(i.SourceArtifactsReadSizeInBytesIn) > 0 {
		predicates = append(predicates, artifactmetrics.SourceArtifactsReadSizeInBytesIn(i.SourceArtifactsReadSizeInBytesIn...))
	}
	if len(i.SourceArtifactsReadSizeInBytesNotIn) > 0 {
		predicates = append(predicates, artifactmetrics.SourceArtifactsReadSizeInBytesNotIn(i.SourceArtifactsReadSizeInBytesNotIn...))
	}
	if i.SourceArtifactsReadSizeInBytesGT != nil {
		predicates = append(predicates, artifactmetrics.SourceArtifactsReadSizeInBytesGT(*i.SourceArtifactsReadSizeInBytesGT))
	}
	if i.SourceArtifactsReadSizeInBytesGTE != nil {
		predicates = append(predicates, artifactmetrics.SourceArtifactsReadSizeInBytesGTE(*i.SourceArtifactsReadSizeInBytesGTE))
	}
	if i.SourceArtifactsReadSizeInBytesLT != nil {
		predicates = append(predicates, artifactmetrics.SourceArtifactsReadSizeInBytesLT(*i.SourceArtifactsReadSizeInBytesLT))
	}
	if i.SourceArtifactsReadSizeInBytesLTE != nil {
		predicates = append(predicates, artifactmetrics.SourceArtifactsReadSizeInBytesLTE(*i.SourceArtifactsReadSizeInBytesLTE))
	}
	if i.SourceArtifactsReadSizeInBytesIsNil {
		predicates = append(predicates, artifactmetrics.SourceArtifactsReadSizeInBytesIsNil())
	}
	if i.SourceArtifactsReadSizeInBytesNotNil {
		predicates = append(predicates, artifactmetrics.SourceArtifactsReadSizeInBytesNotNil())
	}
	if i.SourceArtifactsReadCount != nil {
		predicates = append(predicates, artifactmetrics.SourceArtifactsReadCountEQ(*i.SourceArtifactsReadCount))
	}
	if i.SourceArtifactsReadCountNEQ != nil {
		predicates = append(predicates, artifactmetrics.SourceArtifactsReadCountNEQ(*i.SourceArtifactsReadCountNEQ))
	}
	if len(i.SourceArtifactsReadCountIn) > 0 {
		predicates = append(predicates, artifactmetrics.SourceArtifactsReadCountIn(i.SourceArtifactsReadCountIn...))
	}
	if len(i.SourceArtifactsReadCountNotIn) > 0 {
		predicates = append(predicates, artifactmetrics.SourceArtifactsReadCountNotIn(i.SourceArtifactsReadCountNotIn...))
	}
	if i.SourceArtifactsReadCountGT != nil {
		predicates = append(predicates, artifactmetrics.SourceArtifactsReadCountGT(*i.SourceArtifactsReadCountGT))
	}
	if i.SourceArtifactsReadCountGTE != nil {
		predicates = append(predicates, artifactmetrics.SourceArtifactsReadCountGTE(*i.SourceArtifactsReadCountGTE))
	}
	if i.SourceArtifactsReadCountLT != nil {
		predicates = append(predicates, artifactmetrics.SourceArtifactsReadCountLT(*i.SourceArtifactsReadCountLT))
	}
	if i.SourceArtifactsReadCountLTE != nil {
		predicates = append(predicates, artifactmetrics.SourceArtifactsReadCountLTE(*i.SourceArtifactsReadCountLTE))
	}
	if i.SourceArtifactsReadCountIsNil {
		predicates = append(predicates, artifactmetrics.SourceArtifactsReadCountIsNil())
	}
	if i.SourceArtifactsReadCountNotNil {
		predicates = append(predicates, artifactmetrics.SourceArtifactsReadCountNotNil())
	}
	if i.OutputArtifactsSeenSizeInBytes != nil {
		predicates = append(predicates, artifactmetrics.OutputArtifactsSeenSizeInBytesEQ(*i.OutputArtifactsSeenSizeInBytes))
	}
	if i.OutputArtifactsSeenSizeInBytesNEQ != nil {
		predicates = append(predicates, artifactmetrics.OutputArtifactsSeenSizeInBytesNEQ(*i.OutputArtifactsSeenSizeInBytesNEQ))
	}
	if len(i.OutputArtifactsSeenSizeInBytesIn) > 0 {
		predicates = append(predicates, artifactmetrics.OutputArtifactsSeenSizeInBytesIn(i.OutputArtifactsSeenSizeInBytesIn...))
	}
	if len(i.OutputArtifactsSeenSizeInBytesNotIn) > 0 {
		predicates = append(predicates, artifactmetrics.OutputArtifactsSeenSizeInBytesNotIn(i.OutputArtifactsSeenSizeInBytesNotIn...))
	}
	if i.OutputArtifactsSeenSizeInBytesGT != nil {
		predicates = append(predicates, artifactmetrics.OutputArtifactsSeenSizeInBytesGT(*i.OutputArtifactsSeenSizeInBytesGT))
	}
	if i.OutputArtifactsSeenSizeInBytesGTE != nil {
		predicates = append(predicates, artifactmetrics.OutputArtifactsSeenSizeInBytesGTE(*i.OutputArtifactsSeenSizeInBytesGTE))
	}
	if i.OutputArtifactsSeenSizeInBytesLT != nil {
		predicates = append(predicates, artifactmetrics.OutputArtifactsSeenSizeInBytesLT(*i.OutputArtifactsSeenSizeInBytesLT))
	}
	if i.OutputArtifactsSeenSizeInBytesLTE != nil {
		predicates = append(predicates, artifactmetrics.OutputArtifactsSeenSizeInBytesLTE(*i.OutputArtifactsSeenSizeInBytesLTE))
	}
	if i.OutputArtifactsSeenSizeInBytesIsNil {
		predicates = append(predicates, artifactmetrics.OutputArtifactsSeenSizeInBytesIsNil())
	}
	if i.OutputArtifactsSeenSizeInBytesNotNil {
		predicates = append(predicates, artifactmetrics.OutputArtifactsSeenSizeInBytesNotNil())
	}
	if i.OutputArtifactsSeenCount != nil {
		predicates = append(predicates, artifactmetrics.OutputArtifactsSeenCountEQ(*i.OutputArtifactsSeenCount))
	}
	if i.OutputArtifactsSeenCountNEQ != nil {
		predicates = append(predicates, artifactmetrics.OutputArtifactsSeenCountNEQ(*i.OutputArtifactsSeenCountNEQ))
	}
	if len(i.OutputArtifactsSeenCountIn) > 0 {
		predicates = append(predicates, artifactmetrics.OutputArtifactsSeenCountIn(i.OutputArtifactsSeenCountIn...))
	}
	if len(i.OutputArtifactsSeenCountNotIn) > 0 {
		predicates = append(predicates, artifactmetrics.OutputArtifactsSeenCountNotIn(i.OutputArtifactsSeenCountNotIn...))
	}
	if i.OutputArtifactsSeenCountGT != nil {
		predicates = append(predicates, artifactmetrics.OutputArtifactsSeenCountGT(*i.OutputArtifactsSeenCountGT))
	}
	if i.OutputArtifactsSeenCountGTE != nil {
		predicates = append(predicates, artifactmetrics.OutputArtifactsSeenCountGTE(*i.OutputArtifactsSeenCountGTE))
	}
	if i.OutputArtifactsSeenCountLT != nil {
		predicates = append(predicates, artifactmetrics.OutputArtifactsSeenCountLT(*i.OutputArtifactsSeenCountLT))
	}
	if i.OutputArtifactsSeenCountLTE != nil {
		predicates = append(predicates, artifactmetrics.OutputArtifactsSeenCountLTE(*i.OutputArtifactsSeenCountLTE))
	}
	if i.OutputArtifactsSeenCountIsNil {
		predicates = append(predicates, artifactmetrics.OutputArtifactsSeenCountIsNil())
	}
	if i.OutputArtifactsSeenCountNotNil {
		predicates = append(predicates, artifactmetrics.OutputArtifactsSeenCountNotNil())
	}
	if i.OutputArtifactsFromActionCacheSizeInBytes != nil {
		predicates = append(predicates, artifactmetrics.OutputArtifactsFromActionCacheSizeInBytesEQ(*i.OutputArtifactsFromActionCacheSizeInBytes))
	}
	if i.OutputArtifactsFromActionCacheSizeInBytesNEQ != nil {
		predicates = append(predicates, artifactmetrics.OutputArtifactsFromActionCacheSizeInBytesNEQ(*i.OutputArtifactsFromActionCacheSizeInBytesNEQ))
	}
	if len(i.OutputArtifactsFromActionCacheSizeInBytesIn) > 0 {
		predicates = append(predicates, artifactmetrics.OutputArtifactsFromActionCacheSizeInBytesIn(i.OutputArtifactsFromActionCacheSizeInBytesIn...))
	}
	if len(i.OutputArtifactsFromActionCacheSizeInBytesNotIn) > 0 {
		predicates = append(predicates, artifactmetrics.OutputArtifactsFromActionCacheSizeInBytesNotIn(i.OutputArtifactsFromActionCacheSizeInBytesNotIn...))
	}
	if i.OutputArtifactsFromActionCacheSizeInBytesGT != nil {
		predicates = append(predicates, artifactmetrics.OutputArtifactsFromActionCacheSizeInBytesGT(*i.OutputArtifactsFromActionCacheSizeInBytesGT))
	}
	if i.OutputArtifactsFromActionCacheSizeInBytesGTE != nil {
		predicates = append(predicates, artifactmetrics.OutputArtifactsFromActionCacheSizeInBytesGTE(*i.OutputArtifactsFromActionCacheSizeInBytesGTE))
	}
	if i.OutputArtifactsFromActionCacheSizeInBytesLT != nil {
		predicates = append(predicates, artifactmetrics.OutputArtifactsFromActionCacheSizeInBytesLT(*i.OutputArtifactsFromActionCacheSizeInBytesLT))
	}
	if i.OutputArtifactsFromActionCacheSizeInBytesLTE != nil {
		predicates = append(predicates, artifactmetrics.OutputArtifactsFromActionCacheSizeInBytesLTE(*i.OutputArtifactsFromActionCacheSizeInBytesLTE))
	}
	if i.OutputArtifactsFromActionCacheSizeInBytesIsNil {
		predicates = append(predicates, artifactmetrics.OutputArtifactsFromActionCacheSizeInBytesIsNil())
	}
	if i.OutputArtifactsFromActionCacheSizeInBytesNotNil {
		predicates = append(predicates, artifactmetrics.OutputArtifactsFromActionCacheSizeInBytesNotNil())
	}
	if i.OutputArtifactsFromActionCacheCount != nil {
		predicates = append(predicates, artifactmetrics.OutputArtifactsFromActionCacheCountEQ(*i.OutputArtifactsFromActionCacheCount))
	}
	if i.OutputArtifactsFromActionCacheCountNEQ != nil {
		predicates = append(predicates, artifactmetrics.OutputArtifactsFromActionCacheCountNEQ(*i.OutputArtifactsFromActionCacheCountNEQ))
	}
	if len(i.OutputArtifactsFromActionCacheCountIn) > 0 {
		predicates = append(predicates, artifactmetrics.OutputArtifactsFromActionCacheCountIn(i.OutputArtifactsFromActionCacheCountIn...))
	}
	if len(i.OutputArtifactsFromActionCacheCountNotIn) > 0 {
		predicates = append(predicates, artifactmetrics.OutputArtifactsFromActionCacheCountNotIn(i.OutputArtifactsFromActionCacheCountNotIn...))
	}
	if i.OutputArtifactsFromActionCacheCountGT != nil {
		predicates = append(predicates, artifactmetrics.OutputArtifactsFromActionCacheCountGT(*i.OutputArtifactsFromActionCacheCountGT))
	}
	if i.OutputArtifactsFromActionCacheCountGTE != nil {
		predicates = append(predicates, artifactmetrics.OutputArtifactsFromActionCacheCountGTE(*i.OutputArtifactsFromActionCacheCountGTE))
	}
	if i.OutputArtifactsFromActionCacheCountLT != nil {
		predicates = append(predicates, artifactmetrics.OutputArtifactsFromActionCacheCountLT(*i.OutputArtifactsFromActionCacheCountLT))
	}
	if i.OutputArtifactsFromActionCacheCountLTE != nil {
		predicates = append(predicates, artifactmetrics.OutputArtifactsFromActionCacheCountLTE(*i.OutputArtifactsFromActionCacheCountLTE))
	}
	if i.OutputArtifactsFromActionCacheCountIsNil {
		predicates = append(predicates, artifactmetrics.OutputArtifactsFromActionCacheCountIsNil())
	}
	if i.OutputArtifactsFromActionCacheCountNotNil {
		predicates = append(predicates, artifactmetrics.OutputArtifactsFromActionCacheCountNotNil())
	}
	if i.TopLevelArtifactsSizeInBytes != nil {
		predicates = append(predicates, artifactmetrics.TopLevelArtifactsSizeInBytesEQ(*i.TopLevelArtifactsSizeInBytes))
	}
	if i.TopLevelArtifactsSizeInBytesNEQ != nil {
		predicates = append(predicates, artifactmetrics.TopLevelArtifactsSizeInBytesNEQ(*i.TopLevelArtifactsSizeInBytesNEQ))
	}
	if len(i.TopLevelArtifactsSizeInBytesIn) > 0 {
		predicates = append(predicates, artifactmetrics.TopLevelArtifactsSizeInBytesIn(i.TopLevelArtifactsSizeInBytesIn...))
	}
	if len(i.TopLevelArtifactsSizeInBytesNotIn) > 0 {
		predicates = append(predicates, artifactmetrics.TopLevelArtifactsSizeInBytesNotIn(i.TopLevelArtifactsSizeInBytesNotIn...))
	}
	if i.TopLevelArtifactsSizeInBytesGT != nil {
		predicates = append(predicates, artifactmetrics.TopLevelArtifactsSizeInBytesGT(*i.TopLevelArtifactsSizeInBytesGT))
	}
	if i.TopLevelArtifactsSizeInBytesGTE != nil {
		predicates = append(predicates, artifactmetrics.TopLevelArtifactsSizeInBytesGTE(*i.TopLevelArtifactsSizeInBytesGTE))
	}
	if i.TopLevelArtifactsSizeInBytesLT != nil {
		predicates = append(predicates, artifactmetrics.TopLevelArtifactsSizeInBytesLT(*i.TopLevelArtifactsSizeInBytesLT))
	}
	if i.TopLevelArtifactsSizeInBytesLTE != nil {
		predicates = append(predicates, artifactmetrics.TopLevelArtifactsSizeInBytesLTE(*i.TopLevelArtifactsSizeInBytesLTE))
	}
	if i.TopLevelArtifactsSizeInBytesIsNil {
		predicates = append(predicates, artifactmetrics.TopLevelArtifactsSizeInBytesIsNil())
	}
	if i.TopLevelArtifactsSizeInBytesNotNil {
		predicates = append(predicates, artifactmetrics.TopLevelArtifactsSizeInBytesNotNil())
	}
	if i.TopLevelArtifactsCount != nil {
		predicates = append(predicates, artifactmetrics.TopLevelArtifactsCountEQ(*i.TopLevelArtifactsCount))
	}
	if i.TopLevelArtifactsCountNEQ != nil {
		predicates = append(predicates, artifactmetrics.TopLevelArtifactsCountNEQ(*i.TopLevelArtifactsCountNEQ))
	}
	if len(i.TopLevelArtifactsCountIn) > 0 {
		predicates = append(predicates, artifactmetrics.TopLevelArtifactsCountIn(i.TopLevelArtifactsCountIn...))
	}
	if len(i.TopLevelArtifactsCountNotIn) > 0 {
		predicates = append(predicates, artifactmetrics.TopLevelArtifactsCountNotIn(i.TopLevelArtifactsCountNotIn...))
	}
	if i.TopLevelArtifactsCountGT != nil {
		predicates = append(predicates, artifactmetrics.TopLevelArtifactsCountGT(*i.TopLevelArtifactsCountGT))
	}
	if i.TopLevelArtifactsCountGTE != nil {
		predicates = append(predicates, artifactmetrics.TopLevelArtifactsCountGTE(*i.TopLevelArtifactsCountGTE))
	}
	if i.TopLevelArtifactsCountLT != nil {
		predicates = append(predicates, artifactmetrics.TopLevelArtifactsCountLT(*i.TopLevelArtifactsCountLT))
	}
	if i.TopLevelArtifactsCountLTE != nil {
		predicates = append(predicates, artifactmetrics.TopLevelArtifactsCountLTE(*i.TopLevelArtifactsCountLTE))
	}
	if i.TopLevelArtifactsCountIsNil {
		predicates = append(predicates, artifactmetrics.TopLevelArtifactsCountIsNil())
	}
	if i.TopLevelArtifactsCountNotNil {
		predicates = append(predicates, artifactmetrics.TopLevelArtifactsCountNotNil())
	}

	if i.HasMetrics != nil {
		p := artifactmetrics.HasMetrics()
		if !*i.HasMetrics {
			p = artifactmetrics.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMetricsWith) > 0 {
		with := make([]predicate.Metrics, 0, len(i.HasMetricsWith))
		for _, w := range i.HasMetricsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMetricsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, artifactmetrics.HasMetricsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyArtifactMetricsWhereInput
	case 1:
		return predicates[0], nil
	default:
		return artifactmetrics.And(predicates...), nil
	}
}

// AuthenticatedUserWhereInput represents a where input for filtering AuthenticatedUser queries.
type AuthenticatedUserWhereInput struct {
	Predicates []predicate.AuthenticatedUser  `json:"-"`
	Not        *AuthenticatedUserWhereInput   `json:"not,omitempty"`
	Or         []*AuthenticatedUserWhereInput `json:"or,omitempty"`
	And        []*AuthenticatedUserWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int64  `json:"id,omitempty"`
	IDNEQ   *int64  `json:"idNEQ,omitempty"`
	IDIn    []int64 `json:"idIn,omitempty"`
	IDNotIn []int64 `json:"idNotIn,omitempty"`
	IDGT    *int64  `json:"idGT,omitempty"`
	IDGTE   *int64  `json:"idGTE,omitempty"`
	IDLT    *int64  `json:"idLT,omitempty"`
	IDLTE   *int64  `json:"idLTE,omitempty"`

	// "user_uuid" field predicates.
	UserUUID      *uuid.UUID  `json:"userUUID,omitempty"`
	UserUUIDNEQ   *uuid.UUID  `json:"userUUIDNEQ,omitempty"`
	UserUUIDIn    []uuid.UUID `json:"userUUIDIn,omitempty"`
	UserUUIDNotIn []uuid.UUID `json:"userUUIDNotIn,omitempty"`
	UserUUIDGT    *uuid.UUID  `json:"userUUIDGT,omitempty"`
	UserUUIDGTE   *uuid.UUID  `json:"userUUIDGTE,omitempty"`
	UserUUIDLT    *uuid.UUID  `json:"userUUIDLT,omitempty"`
	UserUUIDLTE   *uuid.UUID  `json:"userUUIDLTE,omitempty"`

	// "external_id" field predicates.
	ExternalID             *string  `json:"externalID,omitempty"`
	ExternalIDNEQ          *string  `json:"externalIDNEQ,omitempty"`
	ExternalIDIn           []string `json:"externalIDIn,omitempty"`
	ExternalIDNotIn        []string `json:"externalIDNotIn,omitempty"`
	ExternalIDGT           *string  `json:"externalIDGT,omitempty"`
	ExternalIDGTE          *string  `json:"externalIDGTE,omitempty"`
	ExternalIDLT           *string  `json:"externalIDLT,omitempty"`
	ExternalIDLTE          *string  `json:"externalIDLTE,omitempty"`
	ExternalIDContains     *string  `json:"externalIDContains,omitempty"`
	ExternalIDHasPrefix    *string  `json:"externalIDHasPrefix,omitempty"`
	ExternalIDHasSuffix    *string  `json:"externalIDHasSuffix,omitempty"`
	ExternalIDEqualFold    *string  `json:"externalIDEqualFold,omitempty"`
	ExternalIDContainsFold *string  `json:"externalIDContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        bool     `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       bool     `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "bazel_invocations" edge predicates.
	HasBazelInvocations     *bool                        `json:"hasBazelInvocations,omitempty"`
	HasBazelInvocationsWith []*BazelInvocationWhereInput `json:"hasBazelInvocationsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *AuthenticatedUserWhereInput) AddPredicates(predicates ...predicate.AuthenticatedUser) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the AuthenticatedUserWhereInput filter on the AuthenticatedUserQuery builder.
func (i *AuthenticatedUserWhereInput) Filter(q *AuthenticatedUserQuery) (*AuthenticatedUserQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyAuthenticatedUserWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyAuthenticatedUserWhereInput is returned in case the AuthenticatedUserWhereInput is empty.
var ErrEmptyAuthenticatedUserWhereInput = errors.New("ent: empty predicate AuthenticatedUserWhereInput")

// P returns a predicate for filtering authenticatedusers.
// An error is returned if the input is empty or invalid.
func (i *AuthenticatedUserWhereInput) P() (predicate.AuthenticatedUser, error) {
	var predicates []predicate.AuthenticatedUser
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, authenticateduser.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.AuthenticatedUser, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, authenticateduser.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.AuthenticatedUser, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, authenticateduser.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, authenticateduser.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, authenticateduser.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, authenticateduser.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, authenticateduser.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, authenticateduser.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, authenticateduser.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, authenticateduser.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, authenticateduser.IDLTE(*i.IDLTE))
	}
	if i.UserUUID != nil {
		predicates = append(predicates, authenticateduser.UserUUIDEQ(*i.UserUUID))
	}
	if i.UserUUIDNEQ != nil {
		predicates = append(predicates, authenticateduser.UserUUIDNEQ(*i.UserUUIDNEQ))
	}
	if len(i.UserUUIDIn) > 0 {
		predicates = append(predicates, authenticateduser.UserUUIDIn(i.UserUUIDIn...))
	}
	if len(i.UserUUIDNotIn) > 0 {
		predicates = append(predicates, authenticateduser.UserUUIDNotIn(i.UserUUIDNotIn...))
	}
	if i.UserUUIDGT != nil {
		predicates = append(predicates, authenticateduser.UserUUIDGT(*i.UserUUIDGT))
	}
	if i.UserUUIDGTE != nil {
		predicates = append(predicates, authenticateduser.UserUUIDGTE(*i.UserUUIDGTE))
	}
	if i.UserUUIDLT != nil {
		predicates = append(predicates, authenticateduser.UserUUIDLT(*i.UserUUIDLT))
	}
	if i.UserUUIDLTE != nil {
		predicates = append(predicates, authenticateduser.UserUUIDLTE(*i.UserUUIDLTE))
	}
	if i.ExternalID != nil {
		predicates = append(predicates, authenticateduser.ExternalIDEQ(*i.ExternalID))
	}
	if i.ExternalIDNEQ != nil {
		predicates = append(predicates, authenticateduser.ExternalIDNEQ(*i.ExternalIDNEQ))
	}
	if len(i.ExternalIDIn) > 0 {
		predicates = append(predicates, authenticateduser.ExternalIDIn(i.ExternalIDIn...))
	}
	if len(i.ExternalIDNotIn) > 0 {
		predicates = append(predicates, authenticateduser.ExternalIDNotIn(i.ExternalIDNotIn...))
	}
	if i.ExternalIDGT != nil {
		predicates = append(predicates, authenticateduser.ExternalIDGT(*i.ExternalIDGT))
	}
	if i.ExternalIDGTE != nil {
		predicates = append(predicates, authenticateduser.ExternalIDGTE(*i.ExternalIDGTE))
	}
	if i.ExternalIDLT != nil {
		predicates = append(predicates, authenticateduser.ExternalIDLT(*i.ExternalIDLT))
	}
	if i.ExternalIDLTE != nil {
		predicates = append(predicates, authenticateduser.ExternalIDLTE(*i.ExternalIDLTE))
	}
	if i.ExternalIDContains != nil {
		predicates = append(predicates, authenticateduser.ExternalIDContains(*i.ExternalIDContains))
	}
	if i.ExternalIDHasPrefix != nil {
		predicates = append(predicates, authenticateduser.ExternalIDHasPrefix(*i.ExternalIDHasPrefix))
	}
	if i.ExternalIDHasSuffix != nil {
		predicates = append(predicates, authenticateduser.ExternalIDHasSuffix(*i.ExternalIDHasSuffix))
	}
	if i.ExternalIDEqualFold != nil {
		predicates = append(predicates, authenticateduser.ExternalIDEqualFold(*i.ExternalIDEqualFold))
	}
	if i.ExternalIDContainsFold != nil {
		predicates = append(predicates, authenticateduser.ExternalIDContainsFold(*i.ExternalIDContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, authenticateduser.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, authenticateduser.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, authenticateduser.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, authenticateduser.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, authenticateduser.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, authenticateduser.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, authenticateduser.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, authenticateduser.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, authenticateduser.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, authenticateduser.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, authenticateduser.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameIsNil {
		predicates = append(predicates, authenticateduser.DisplayNameIsNil())
	}
	if i.DisplayNameNotNil {
		predicates = append(predicates, authenticateduser.DisplayNameNotNil())
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, authenticateduser.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, authenticateduser.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}

	if i.HasBazelInvocations != nil {
		p := authenticateduser.HasBazelInvocations()
		if !*i.HasBazelInvocations {
			p = authenticateduser.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBazelInvocationsWith) > 0 {
		with := make([]predicate.BazelInvocation, 0, len(i.HasBazelInvocationsWith))
		for _, w := range i.HasBazelInvocationsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBazelInvocationsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, authenticateduser.HasBazelInvocationsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyAuthenticatedUserWhereInput
	case 1:
		return predicates[0], nil
	default:
		return authenticateduser.And(predicates...), nil
	}
}

// BazelInvocationWhereInput represents a where input for filtering BazelInvocation queries.
type BazelInvocationWhereInput struct {
	Predicates []predicate.BazelInvocation  `json:"-"`
	Not        *BazelInvocationWhereInput   `json:"not,omitempty"`
	Or         []*BazelInvocationWhereInput `json:"or,omitempty"`
	And        []*BazelInvocationWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int64  `json:"id,omitempty"`
	IDNEQ   *int64  `json:"idNEQ,omitempty"`
	IDIn    []int64 `json:"idIn,omitempty"`
	IDNotIn []int64 `json:"idNotIn,omitempty"`
	IDGT    *int64  `json:"idGT,omitempty"`
	IDGTE   *int64  `json:"idGTE,omitempty"`
	IDLT    *int64  `json:"idLT,omitempty"`
	IDLTE   *int64  `json:"idLTE,omitempty"`

	// "invocation_id" field predicates.
	InvocationID      *uuid.UUID  `json:"invocationID,omitempty"`
	InvocationIDNEQ   *uuid.UUID  `json:"invocationIDNEQ,omitempty"`
	InvocationIDIn    []uuid.UUID `json:"invocationIDIn,omitempty"`
	InvocationIDNotIn []uuid.UUID `json:"invocationIDNotIn,omitempty"`
	InvocationIDGT    *uuid.UUID  `json:"invocationIDGT,omitempty"`
	InvocationIDGTE   *uuid.UUID  `json:"invocationIDGTE,omitempty"`
	InvocationIDLT    *uuid.UUID  `json:"invocationIDLT,omitempty"`
	InvocationIDLTE   *uuid.UUID  `json:"invocationIDLTE,omitempty"`

	// "started_at" field predicates.
	StartedAt       *time.Time  `json:"startedAt,omitempty"`
	StartedAtNEQ    *time.Time  `json:"startedAtNEQ,omitempty"`
	StartedAtIn     []time.Time `json:"startedAtIn,omitempty"`
	StartedAtNotIn  []time.Time `json:"startedAtNotIn,omitempty"`
	StartedAtGT     *time.Time  `json:"startedAtGT,omitempty"`
	StartedAtGTE    *time.Time  `json:"startedAtGTE,omitempty"`
	StartedAtLT     *time.Time  `json:"startedAtLT,omitempty"`
	StartedAtLTE    *time.Time  `json:"startedAtLTE,omitempty"`
	StartedAtIsNil  bool        `json:"startedAtIsNil,omitempty"`
	StartedAtNotNil bool        `json:"startedAtNotNil,omitempty"`

	// "ended_at" field predicates.
	EndedAt       *time.Time  `json:"endedAt,omitempty"`
	EndedAtNEQ    *time.Time  `json:"endedAtNEQ,omitempty"`
	EndedAtIn     []time.Time `json:"endedAtIn,omitempty"`
	EndedAtNotIn  []time.Time `json:"endedAtNotIn,omitempty"`
	EndedAtGT     *time.Time  `json:"endedAtGT,omitempty"`
	EndedAtGTE    *time.Time  `json:"endedAtGTE,omitempty"`
	EndedAtLT     *time.Time  `json:"endedAtLT,omitempty"`
	EndedAtLTE    *time.Time  `json:"endedAtLTE,omitempty"`
	EndedAtIsNil  bool        `json:"endedAtIsNil,omitempty"`
	EndedAtNotNil bool        `json:"endedAtNotNil,omitempty"`

	// "change_number" field predicates.
	ChangeNumber       *int  `json:"changeNumber,omitempty"`
	ChangeNumberNEQ    *int  `json:"changeNumberNEQ,omitempty"`
	ChangeNumberIn     []int `json:"changeNumberIn,omitempty"`
	ChangeNumberNotIn  []int `json:"changeNumberNotIn,omitempty"`
	ChangeNumberGT     *int  `json:"changeNumberGT,omitempty"`
	ChangeNumberGTE    *int  `json:"changeNumberGTE,omitempty"`
	ChangeNumberLT     *int  `json:"changeNumberLT,omitempty"`
	ChangeNumberLTE    *int  `json:"changeNumberLTE,omitempty"`
	ChangeNumberIsNil  bool  `json:"changeNumberIsNil,omitempty"`
	ChangeNumberNotNil bool  `json:"changeNumberNotNil,omitempty"`

	// "patchset_number" field predicates.
	PatchsetNumber       *int  `json:"patchsetNumber,omitempty"`
	PatchsetNumberNEQ    *int  `json:"patchsetNumberNEQ,omitempty"`
	PatchsetNumberIn     []int `json:"patchsetNumberIn,omitempty"`
	PatchsetNumberNotIn  []int `json:"patchsetNumberNotIn,omitempty"`
	PatchsetNumberGT     *int  `json:"patchsetNumberGT,omitempty"`
	PatchsetNumberGTE    *int  `json:"patchsetNumberGTE,omitempty"`
	PatchsetNumberLT     *int  `json:"patchsetNumberLT,omitempty"`
	PatchsetNumberLTE    *int  `json:"patchsetNumberLTE,omitempty"`
	PatchsetNumberIsNil  bool  `json:"patchsetNumberIsNil,omitempty"`
	PatchsetNumberNotNil bool  `json:"patchsetNumberNotNil,omitempty"`

	// "bep_completed" field predicates.
	BepCompleted    *bool `json:"bepCompleted,omitempty"`
	BepCompletedNEQ *bool `json:"bepCompletedNEQ,omitempty"`

	// "step_label" field predicates.
	StepLabel             *string  `json:"stepLabel,omitempty"`
	StepLabelNEQ          *string  `json:"stepLabelNEQ,omitempty"`
	StepLabelIn           []string `json:"stepLabelIn,omitempty"`
	StepLabelNotIn        []string `json:"stepLabelNotIn,omitempty"`
	StepLabelGT           *string  `json:"stepLabelGT,omitempty"`
	StepLabelGTE          *string  `json:"stepLabelGTE,omitempty"`
	StepLabelLT           *string  `json:"stepLabelLT,omitempty"`
	StepLabelLTE          *string  `json:"stepLabelLTE,omitempty"`
	StepLabelContains     *string  `json:"stepLabelContains,omitempty"`
	StepLabelHasPrefix    *string  `json:"stepLabelHasPrefix,omitempty"`
	StepLabelHasSuffix    *string  `json:"stepLabelHasSuffix,omitempty"`
	StepLabelIsNil        bool     `json:"stepLabelIsNil,omitempty"`
	StepLabelNotNil       bool     `json:"stepLabelNotNil,omitempty"`
	StepLabelEqualFold    *string  `json:"stepLabelEqualFold,omitempty"`
	StepLabelContainsFold *string  `json:"stepLabelContainsFold,omitempty"`

	// "user_email" field predicates.
	UserEmail             *string  `json:"userEmail,omitempty"`
	UserEmailNEQ          *string  `json:"userEmailNEQ,omitempty"`
	UserEmailIn           []string `json:"userEmailIn,omitempty"`
	UserEmailNotIn        []string `json:"userEmailNotIn,omitempty"`
	UserEmailGT           *string  `json:"userEmailGT,omitempty"`
	UserEmailGTE          *string  `json:"userEmailGTE,omitempty"`
	UserEmailLT           *string  `json:"userEmailLT,omitempty"`
	UserEmailLTE          *string  `json:"userEmailLTE,omitempty"`
	UserEmailContains     *string  `json:"userEmailContains,omitempty"`
	UserEmailHasPrefix    *string  `json:"userEmailHasPrefix,omitempty"`
	UserEmailHasSuffix    *string  `json:"userEmailHasSuffix,omitempty"`
	UserEmailIsNil        bool     `json:"userEmailIsNil,omitempty"`
	UserEmailNotNil       bool     `json:"userEmailNotNil,omitempty"`
	UserEmailEqualFold    *string  `json:"userEmailEqualFold,omitempty"`
	UserEmailContainsFold *string  `json:"userEmailContainsFold,omitempty"`

	// "user_ldap" field predicates.
	UserLdap             *string  `json:"userLdap,omitempty"`
	UserLdapNEQ          *string  `json:"userLdapNEQ,omitempty"`
	UserLdapIn           []string `json:"userLdapIn,omitempty"`
	UserLdapNotIn        []string `json:"userLdapNotIn,omitempty"`
	UserLdapGT           *string  `json:"userLdapGT,omitempty"`
	UserLdapGTE          *string  `json:"userLdapGTE,omitempty"`
	UserLdapLT           *string  `json:"userLdapLT,omitempty"`
	UserLdapLTE          *string  `json:"userLdapLTE,omitempty"`
	UserLdapContains     *string  `json:"userLdapContains,omitempty"`
	UserLdapHasPrefix    *string  `json:"userLdapHasPrefix,omitempty"`
	UserLdapHasSuffix    *string  `json:"userLdapHasSuffix,omitempty"`
	UserLdapIsNil        bool     `json:"userLdapIsNil,omitempty"`
	UserLdapNotNil       bool     `json:"userLdapNotNil,omitempty"`
	UserLdapEqualFold    *string  `json:"userLdapEqualFold,omitempty"`
	UserLdapContainsFold *string  `json:"userLdapContainsFold,omitempty"`

	// "hostname" field predicates.
	Hostname             *string  `json:"hostname,omitempty"`
	HostnameNEQ          *string  `json:"hostnameNEQ,omitempty"`
	HostnameIn           []string `json:"hostnameIn,omitempty"`
	HostnameNotIn        []string `json:"hostnameNotIn,omitempty"`
	HostnameGT           *string  `json:"hostnameGT,omitempty"`
	HostnameGTE          *string  `json:"hostnameGTE,omitempty"`
	HostnameLT           *string  `json:"hostnameLT,omitempty"`
	HostnameLTE          *string  `json:"hostnameLTE,omitempty"`
	HostnameContains     *string  `json:"hostnameContains,omitempty"`
	HostnameHasPrefix    *string  `json:"hostnameHasPrefix,omitempty"`
	HostnameHasSuffix    *string  `json:"hostnameHasSuffix,omitempty"`
	HostnameIsNil        bool     `json:"hostnameIsNil,omitempty"`
	HostnameNotNil       bool     `json:"hostnameNotNil,omitempty"`
	HostnameEqualFold    *string  `json:"hostnameEqualFold,omitempty"`
	HostnameContainsFold *string  `json:"hostnameContainsFold,omitempty"`

	// "is_ci_worker" field predicates.
	IsCiWorker       *bool `json:"isCiWorker,omitempty"`
	IsCiWorkerNEQ    *bool `json:"isCiWorkerNEQ,omitempty"`
	IsCiWorkerIsNil  bool  `json:"isCiWorkerIsNil,omitempty"`
	IsCiWorkerNotNil bool  `json:"isCiWorkerNotNil,omitempty"`

	// "num_fetches" field predicates.
	NumFetches       *int64  `json:"numFetches,omitempty"`
	NumFetchesNEQ    *int64  `json:"numFetchesNEQ,omitempty"`
	NumFetchesIn     []int64 `json:"numFetchesIn,omitempty"`
	NumFetchesNotIn  []int64 `json:"numFetchesNotIn,omitempty"`
	NumFetchesGT     *int64  `json:"numFetchesGT,omitempty"`
	NumFetchesGTE    *int64  `json:"numFetchesGTE,omitempty"`
	NumFetchesLT     *int64  `json:"numFetchesLT,omitempty"`
	NumFetchesLTE    *int64  `json:"numFetchesLTE,omitempty"`
	NumFetchesIsNil  bool    `json:"numFetchesIsNil,omitempty"`
	NumFetchesNotNil bool    `json:"numFetchesNotNil,omitempty"`

	// "profile_name" field predicates.
	ProfileName             *string  `json:"profileName,omitempty"`
	ProfileNameNEQ          *string  `json:"profileNameNEQ,omitempty"`
	ProfileNameIn           []string `json:"profileNameIn,omitempty"`
	ProfileNameNotIn        []string `json:"profileNameNotIn,omitempty"`
	ProfileNameGT           *string  `json:"profileNameGT,omitempty"`
	ProfileNameGTE          *string  `json:"profileNameGTE,omitempty"`
	ProfileNameLT           *string  `json:"profileNameLT,omitempty"`
	ProfileNameLTE          *string  `json:"profileNameLTE,omitempty"`
	ProfileNameContains     *string  `json:"profileNameContains,omitempty"`
	ProfileNameHasPrefix    *string  `json:"profileNameHasPrefix,omitempty"`
	ProfileNameHasSuffix    *string  `json:"profileNameHasSuffix,omitempty"`
	ProfileNameIsNil        bool     `json:"profileNameIsNil,omitempty"`
	ProfileNameNotNil       bool     `json:"profileNameNotNil,omitempty"`
	ProfileNameEqualFold    *string  `json:"profileNameEqualFold,omitempty"`
	ProfileNameContainsFold *string  `json:"profileNameContainsFold,omitempty"`

	// "bazel_version" field predicates.
	BazelVersion             *string  `json:"bazelVersion,omitempty"`
	BazelVersionNEQ          *string  `json:"bazelVersionNEQ,omitempty"`
	BazelVersionIn           []string `json:"bazelVersionIn,omitempty"`
	BazelVersionNotIn        []string `json:"bazelVersionNotIn,omitempty"`
	BazelVersionGT           *string  `json:"bazelVersionGT,omitempty"`
	BazelVersionGTE          *string  `json:"bazelVersionGTE,omitempty"`
	BazelVersionLT           *string  `json:"bazelVersionLT,omitempty"`
	BazelVersionLTE          *string  `json:"bazelVersionLTE,omitempty"`
	BazelVersionContains     *string  `json:"bazelVersionContains,omitempty"`
	BazelVersionHasPrefix    *string  `json:"bazelVersionHasPrefix,omitempty"`
	BazelVersionHasSuffix    *string  `json:"bazelVersionHasSuffix,omitempty"`
	BazelVersionIsNil        bool     `json:"bazelVersionIsNil,omitempty"`
	BazelVersionNotNil       bool     `json:"bazelVersionNotNil,omitempty"`
	BazelVersionEqualFold    *string  `json:"bazelVersionEqualFold,omitempty"`
	BazelVersionContainsFold *string  `json:"bazelVersionContainsFold,omitempty"`

	// "exit_code_name" field predicates.
	ExitCodeName             *string  `json:"exitCodeName,omitempty"`
	ExitCodeNameNEQ          *string  `json:"exitCodeNameNEQ,omitempty"`
	ExitCodeNameIn           []string `json:"exitCodeNameIn,omitempty"`
	ExitCodeNameNotIn        []string `json:"exitCodeNameNotIn,omitempty"`
	ExitCodeNameGT           *string  `json:"exitCodeNameGT,omitempty"`
	ExitCodeNameGTE          *string  `json:"exitCodeNameGTE,omitempty"`
	ExitCodeNameLT           *string  `json:"exitCodeNameLT,omitempty"`
	ExitCodeNameLTE          *string  `json:"exitCodeNameLTE,omitempty"`
	ExitCodeNameContains     *string  `json:"exitCodeNameContains,omitempty"`
	ExitCodeNameHasPrefix    *string  `json:"exitCodeNameHasPrefix,omitempty"`
	ExitCodeNameHasSuffix    *string  `json:"exitCodeNameHasSuffix,omitempty"`
	ExitCodeNameIsNil        bool     `json:"exitCodeNameIsNil,omitempty"`
	ExitCodeNameNotNil       bool     `json:"exitCodeNameNotNil,omitempty"`
	ExitCodeNameEqualFold    *string  `json:"exitCodeNameEqualFold,omitempty"`
	ExitCodeNameContainsFold *string  `json:"exitCodeNameContainsFold,omitempty"`

	// "exit_code_code" field predicates.
	ExitCodeCode       *int32  `json:"exitCodeCode,omitempty"`
	ExitCodeCodeNEQ    *int32  `json:"exitCodeCodeNEQ,omitempty"`
	ExitCodeCodeIn     []int32 `json:"exitCodeCodeIn,omitempty"`
	ExitCodeCodeNotIn  []int32 `json:"exitCodeCodeNotIn,omitempty"`
	ExitCodeCodeGT     *int32  `json:"exitCodeCodeGT,omitempty"`
	ExitCodeCodeGTE    *int32  `json:"exitCodeCodeGTE,omitempty"`
	ExitCodeCodeLT     *int32  `json:"exitCodeCodeLT,omitempty"`
	ExitCodeCodeLTE    *int32  `json:"exitCodeCodeLTE,omitempty"`
	ExitCodeCodeIsNil  bool    `json:"exitCodeCodeIsNil,omitempty"`
	ExitCodeCodeNotNil bool    `json:"exitCodeCodeNotNil,omitempty"`

	// "instance_name" edge predicates.
	HasInstanceName     *bool                     `json:"hasInstanceName,omitempty"`
	HasInstanceNameWith []*InstanceNameWhereInput `json:"hasInstanceNameWith,omitempty"`

	// "build" edge predicates.
	HasBuild     *bool              `json:"hasBuild,omitempty"`
	HasBuildWith []*BuildWhereInput `json:"hasBuildWith,omitempty"`

	// "authenticated_user" edge predicates.
	HasAuthenticatedUser     *bool                          `json:"hasAuthenticatedUser,omitempty"`
	HasAuthenticatedUserWith []*AuthenticatedUserWhereInput `json:"hasAuthenticatedUserWith,omitempty"`

	// "configurations" edge predicates.
	HasConfigurations     *bool                      `json:"hasConfigurations,omitempty"`
	HasConfigurationsWith []*ConfigurationWhereInput `json:"hasConfigurationsWith,omitempty"`

	// "actions" edge predicates.
	HasActions     *bool               `json:"hasActions,omitempty"`
	HasActionsWith []*ActionWhereInput `json:"hasActionsWith,omitempty"`

	// "metrics" edge predicates.
	HasMetrics     *bool                `json:"hasMetrics,omitempty"`
	HasMetricsWith []*MetricsWhereInput `json:"hasMetricsWith,omitempty"`

	// "invocation_files" edge predicates.
	HasInvocationFiles     *bool                        `json:"hasInvocationFiles,omitempty"`
	HasInvocationFilesWith []*InvocationFilesWhereInput `json:"hasInvocationFilesWith,omitempty"`

	// "invocation_targets" edge predicates.
	HasInvocationTargets     *bool                         `json:"hasInvocationTargets,omitempty"`
	HasInvocationTargetsWith []*InvocationTargetWhereInput `json:"hasInvocationTargetsWith,omitempty"`

	// "source_control" edge predicates.
	HasSourceControl     *bool                      `json:"hasSourceControl,omitempty"`
	HasSourceControlWith []*SourceControlWhereInput `json:"hasSourceControlWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *BazelInvocationWhereInput) AddPredicates(predicates ...predicate.BazelInvocation) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the BazelInvocationWhereInput filter on the BazelInvocationQuery builder.
func (i *BazelInvocationWhereInput) Filter(q *BazelInvocationQuery) (*BazelInvocationQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyBazelInvocationWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyBazelInvocationWhereInput is returned in case the BazelInvocationWhereInput is empty.
var ErrEmptyBazelInvocationWhereInput = errors.New("ent: empty predicate BazelInvocationWhereInput")

// P returns a predicate for filtering bazelinvocations.
// An error is returned if the input is empty or invalid.
func (i *BazelInvocationWhereInput) P() (predicate.BazelInvocation, error) {
	var predicates []predicate.BazelInvocation
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, bazelinvocation.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.BazelInvocation, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, bazelinvocation.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.BazelInvocation, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, bazelinvocation.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, bazelinvocation.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, bazelinvocation.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, bazelinvocation.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, bazelinvocation.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, bazelinvocation.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, bazelinvocation.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, bazelinvocation.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, bazelinvocation.IDLTE(*i.IDLTE))
	}
	if i.InvocationID != nil {
		predicates = append(predicates, bazelinvocation.InvocationIDEQ(*i.InvocationID))
	}
	if i.InvocationIDNEQ != nil {
		predicates = append(predicates, bazelinvocation.InvocationIDNEQ(*i.InvocationIDNEQ))
	}
	if len(i.InvocationIDIn) > 0 {
		predicates = append(predicates, bazelinvocation.InvocationIDIn(i.InvocationIDIn...))
	}
	if len(i.InvocationIDNotIn) > 0 {
		predicates = append(predicates, bazelinvocation.InvocationIDNotIn(i.InvocationIDNotIn...))
	}
	if i.InvocationIDGT != nil {
		predicates = append(predicates, bazelinvocation.InvocationIDGT(*i.InvocationIDGT))
	}
	if i.InvocationIDGTE != nil {
		predicates = append(predicates, bazelinvocation.InvocationIDGTE(*i.InvocationIDGTE))
	}
	if i.InvocationIDLT != nil {
		predicates = append(predicates, bazelinvocation.InvocationIDLT(*i.InvocationIDLT))
	}
	if i.InvocationIDLTE != nil {
		predicates = append(predicates, bazelinvocation.InvocationIDLTE(*i.InvocationIDLTE))
	}
	if i.StartedAt != nil {
		predicates = append(predicates, bazelinvocation.StartedAtEQ(*i.StartedAt))
	}
	if i.StartedAtNEQ != nil {
		predicates = append(predicates, bazelinvocation.StartedAtNEQ(*i.StartedAtNEQ))
	}
	if len(i.StartedAtIn) > 0 {
		predicates = append(predicates, bazelinvocation.StartedAtIn(i.StartedAtIn...))
	}
	if len(i.StartedAtNotIn) > 0 {
		predicates = append(predicates, bazelinvocation.StartedAtNotIn(i.StartedAtNotIn...))
	}
	if i.StartedAtGT != nil {
		predicates = append(predicates, bazelinvocation.StartedAtGT(*i.StartedAtGT))
	}
	if i.StartedAtGTE != nil {
		predicates = append(predicates, bazelinvocation.StartedAtGTE(*i.StartedAtGTE))
	}
	if i.StartedAtLT != nil {
		predicates = append(predicates, bazelinvocation.StartedAtLT(*i.StartedAtLT))
	}
	if i.StartedAtLTE != nil {
		predicates = append(predicates, bazelinvocation.StartedAtLTE(*i.StartedAtLTE))
	}
	if i.StartedAtIsNil {
		predicates = append(predicates, bazelinvocation.StartedAtIsNil())
	}
	if i.StartedAtNotNil {
		predicates = append(predicates, bazelinvocation.StartedAtNotNil())
	}
	if i.EndedAt != nil {
		predicates = append(predicates, bazelinvocation.EndedAtEQ(*i.EndedAt))
	}
	if i.EndedAtNEQ != nil {
		predicates = append(predicates, bazelinvocation.EndedAtNEQ(*i.EndedAtNEQ))
	}
	if len(i.EndedAtIn) > 0 {
		predicates = append(predicates, bazelinvocation.EndedAtIn(i.EndedAtIn...))
	}
	if len(i.EndedAtNotIn) > 0 {
		predicates = append(predicates, bazelinvocation.EndedAtNotIn(i.EndedAtNotIn...))
	}
	if i.EndedAtGT != nil {
		predicates = append(predicates, bazelinvocation.EndedAtGT(*i.EndedAtGT))
	}
	if i.EndedAtGTE != nil {
		predicates = append(predicates, bazelinvocation.EndedAtGTE(*i.EndedAtGTE))
	}
	if i.EndedAtLT != nil {
		predicates = append(predicates, bazelinvocation.EndedAtLT(*i.EndedAtLT))
	}
	if i.EndedAtLTE != nil {
		predicates = append(predicates, bazelinvocation.EndedAtLTE(*i.EndedAtLTE))
	}
	if i.EndedAtIsNil {
		predicates = append(predicates, bazelinvocation.EndedAtIsNil())
	}
	if i.EndedAtNotNil {
		predicates = append(predicates, bazelinvocation.EndedAtNotNil())
	}
	if i.ChangeNumber != nil {
		predicates = append(predicates, bazelinvocation.ChangeNumberEQ(*i.ChangeNumber))
	}
	if i.ChangeNumberNEQ != nil {
		predicates = append(predicates, bazelinvocation.ChangeNumberNEQ(*i.ChangeNumberNEQ))
	}
	if len(i.ChangeNumberIn) > 0 {
		predicates = append(predicates, bazelinvocation.ChangeNumberIn(i.ChangeNumberIn...))
	}
	if len(i.ChangeNumberNotIn) > 0 {
		predicates = append(predicates, bazelinvocation.ChangeNumberNotIn(i.ChangeNumberNotIn...))
	}
	if i.ChangeNumberGT != nil {
		predicates = append(predicates, bazelinvocation.ChangeNumberGT(*i.ChangeNumberGT))
	}
	if i.ChangeNumberGTE != nil {
		predicates = append(predicates, bazelinvocation.ChangeNumberGTE(*i.ChangeNumberGTE))
	}
	if i.ChangeNumberLT != nil {
		predicates = append(predicates, bazelinvocation.ChangeNumberLT(*i.ChangeNumberLT))
	}
	if i.ChangeNumberLTE != nil {
		predicates = append(predicates, bazelinvocation.ChangeNumberLTE(*i.ChangeNumberLTE))
	}
	if i.ChangeNumberIsNil {
		predicates = append(predicates, bazelinvocation.ChangeNumberIsNil())
	}
	if i.ChangeNumberNotNil {
		predicates = append(predicates, bazelinvocation.ChangeNumberNotNil())
	}
	if i.PatchsetNumber != nil {
		predicates = append(predicates, bazelinvocation.PatchsetNumberEQ(*i.PatchsetNumber))
	}
	if i.PatchsetNumberNEQ != nil {
		predicates = append(predicates, bazelinvocation.PatchsetNumberNEQ(*i.PatchsetNumberNEQ))
	}
	if len(i.PatchsetNumberIn) > 0 {
		predicates = append(predicates, bazelinvocation.PatchsetNumberIn(i.PatchsetNumberIn...))
	}
	if len(i.PatchsetNumberNotIn) > 0 {
		predicates = append(predicates, bazelinvocation.PatchsetNumberNotIn(i.PatchsetNumberNotIn...))
	}
	if i.PatchsetNumberGT != nil {
		predicates = append(predicates, bazelinvocation.PatchsetNumberGT(*i.PatchsetNumberGT))
	}
	if i.PatchsetNumberGTE != nil {
		predicates = append(predicates, bazelinvocation.PatchsetNumberGTE(*i.PatchsetNumberGTE))
	}
	if i.PatchsetNumberLT != nil {
		predicates = append(predicates, bazelinvocation.PatchsetNumberLT(*i.PatchsetNumberLT))
	}
	if i.PatchsetNumberLTE != nil {
		predicates = append(predicates, bazelinvocation.PatchsetNumberLTE(*i.PatchsetNumberLTE))
	}
	if i.PatchsetNumberIsNil {
		predicates = append(predicates, bazelinvocation.PatchsetNumberIsNil())
	}
	if i.PatchsetNumberNotNil {
		predicates = append(predicates, bazelinvocation.PatchsetNumberNotNil())
	}
	if i.BepCompleted != nil {
		predicates = append(predicates, bazelinvocation.BepCompletedEQ(*i.BepCompleted))
	}
	if i.BepCompletedNEQ != nil {
		predicates = append(predicates, bazelinvocation.BepCompletedNEQ(*i.BepCompletedNEQ))
	}
	if i.StepLabel != nil {
		predicates = append(predicates, bazelinvocation.StepLabelEQ(*i.StepLabel))
	}
	if i.StepLabelNEQ != nil {
		predicates = append(predicates, bazelinvocation.StepLabelNEQ(*i.StepLabelNEQ))
	}
	if len(i.StepLabelIn) > 0 {
		predicates = append(predicates, bazelinvocation.StepLabelIn(i.StepLabelIn...))
	}
	if len(i.StepLabelNotIn) > 0 {
		predicates = append(predicates, bazelinvocation.StepLabelNotIn(i.StepLabelNotIn...))
	}
	if i.StepLabelGT != nil {
		predicates = append(predicates, bazelinvocation.StepLabelGT(*i.StepLabelGT))
	}
	if i.StepLabelGTE != nil {
		predicates = append(predicates, bazelinvocation.StepLabelGTE(*i.StepLabelGTE))
	}
	if i.StepLabelLT != nil {
		predicates = append(predicates, bazelinvocation.StepLabelLT(*i.StepLabelLT))
	}
	if i.StepLabelLTE != nil {
		predicates = append(predicates, bazelinvocation.StepLabelLTE(*i.StepLabelLTE))
	}
	if i.StepLabelContains != nil {
		predicates = append(predicates, bazelinvocation.StepLabelContains(*i.StepLabelContains))
	}
	if i.StepLabelHasPrefix != nil {
		predicates = append(predicates, bazelinvocation.StepLabelHasPrefix(*i.StepLabelHasPrefix))
	}
	if i.StepLabelHasSuffix != nil {
		predicates = append(predicates, bazelinvocation.StepLabelHasSuffix(*i.StepLabelHasSuffix))
	}
	if i.StepLabelIsNil {
		predicates = append(predicates, bazelinvocation.StepLabelIsNil())
	}
	if i.StepLabelNotNil {
		predicates = append(predicates, bazelinvocation.StepLabelNotNil())
	}
	if i.StepLabelEqualFold != nil {
		predicates = append(predicates, bazelinvocation.StepLabelEqualFold(*i.StepLabelEqualFold))
	}
	if i.StepLabelContainsFold != nil {
		predicates = append(predicates, bazelinvocation.StepLabelContainsFold(*i.StepLabelContainsFold))
	}
	if i.UserEmail != nil {
		predicates = append(predicates, bazelinvocation.UserEmailEQ(*i.UserEmail))
	}
	if i.UserEmailNEQ != nil {
		predicates = append(predicates, bazelinvocation.UserEmailNEQ(*i.UserEmailNEQ))
	}
	if len(i.UserEmailIn) > 0 {
		predicates = append(predicates, bazelinvocation.UserEmailIn(i.UserEmailIn...))
	}
	if len(i.UserEmailNotIn) > 0 {
		predicates = append(predicates, bazelinvocation.UserEmailNotIn(i.UserEmailNotIn...))
	}
	if i.UserEmailGT != nil {
		predicates = append(predicates, bazelinvocation.UserEmailGT(*i.UserEmailGT))
	}
	if i.UserEmailGTE != nil {
		predicates = append(predicates, bazelinvocation.UserEmailGTE(*i.UserEmailGTE))
	}
	if i.UserEmailLT != nil {
		predicates = append(predicates, bazelinvocation.UserEmailLT(*i.UserEmailLT))
	}
	if i.UserEmailLTE != nil {
		predicates = append(predicates, bazelinvocation.UserEmailLTE(*i.UserEmailLTE))
	}
	if i.UserEmailContains != nil {
		predicates = append(predicates, bazelinvocation.UserEmailContains(*i.UserEmailContains))
	}
	if i.UserEmailHasPrefix != nil {
		predicates = append(predicates, bazelinvocation.UserEmailHasPrefix(*i.UserEmailHasPrefix))
	}
	if i.UserEmailHasSuffix != nil {
		predicates = append(predicates, bazelinvocation.UserEmailHasSuffix(*i.UserEmailHasSuffix))
	}
	if i.UserEmailIsNil {
		predicates = append(predicates, bazelinvocation.UserEmailIsNil())
	}
	if i.UserEmailNotNil {
		predicates = append(predicates, bazelinvocation.UserEmailNotNil())
	}
	if i.UserEmailEqualFold != nil {
		predicates = append(predicates, bazelinvocation.UserEmailEqualFold(*i.UserEmailEqualFold))
	}
	if i.UserEmailContainsFold != nil {
		predicates = append(predicates, bazelinvocation.UserEmailContainsFold(*i.UserEmailContainsFold))
	}
	if i.UserLdap != nil {
		predicates = append(predicates, bazelinvocation.UserLdapEQ(*i.UserLdap))
	}
	if i.UserLdapNEQ != nil {
		predicates = append(predicates, bazelinvocation.UserLdapNEQ(*i.UserLdapNEQ))
	}
	if len(i.UserLdapIn) > 0 {
		predicates = append(predicates, bazelinvocation.UserLdapIn(i.UserLdapIn...))
	}
	if len(i.UserLdapNotIn) > 0 {
		predicates = append(predicates, bazelinvocation.UserLdapNotIn(i.UserLdapNotIn...))
	}
	if i.UserLdapGT != nil {
		predicates = append(predicates, bazelinvocation.UserLdapGT(*i.UserLdapGT))
	}
	if i.UserLdapGTE != nil {
		predicates = append(predicates, bazelinvocation.UserLdapGTE(*i.UserLdapGTE))
	}
	if i.UserLdapLT != nil {
		predicates = append(predicates, bazelinvocation.UserLdapLT(*i.UserLdapLT))
	}
	if i.UserLdapLTE != nil {
		predicates = append(predicates, bazelinvocation.UserLdapLTE(*i.UserLdapLTE))
	}
	if i.UserLdapContains != nil {
		predicates = append(predicates, bazelinvocation.UserLdapContains(*i.UserLdapContains))
	}
	if i.UserLdapHasPrefix != nil {
		predicates = append(predicates, bazelinvocation.UserLdapHasPrefix(*i.UserLdapHasPrefix))
	}
	if i.UserLdapHasSuffix != nil {
		predicates = append(predicates, bazelinvocation.UserLdapHasSuffix(*i.UserLdapHasSuffix))
	}
	if i.UserLdapIsNil {
		predicates = append(predicates, bazelinvocation.UserLdapIsNil())
	}
	if i.UserLdapNotNil {
		predicates = append(predicates, bazelinvocation.UserLdapNotNil())
	}
	if i.UserLdapEqualFold != nil {
		predicates = append(predicates, bazelinvocation.UserLdapEqualFold(*i.UserLdapEqualFold))
	}
	if i.UserLdapContainsFold != nil {
		predicates = append(predicates, bazelinvocation.UserLdapContainsFold(*i.UserLdapContainsFold))
	}
	if i.Hostname != nil {
		predicates = append(predicates, bazelinvocation.HostnameEQ(*i.Hostname))
	}
	if i.HostnameNEQ != nil {
		predicates = append(predicates, bazelinvocation.HostnameNEQ(*i.HostnameNEQ))
	}
	if len(i.HostnameIn) > 0 {
		predicates = append(predicates, bazelinvocation.HostnameIn(i.HostnameIn...))
	}
	if len(i.HostnameNotIn) > 0 {
		predicates = append(predicates, bazelinvocation.HostnameNotIn(i.HostnameNotIn...))
	}
	if i.HostnameGT != nil {
		predicates = append(predicates, bazelinvocation.HostnameGT(*i.HostnameGT))
	}
	if i.HostnameGTE != nil {
		predicates = append(predicates, bazelinvocation.HostnameGTE(*i.HostnameGTE))
	}
	if i.HostnameLT != nil {
		predicates = append(predicates, bazelinvocation.HostnameLT(*i.HostnameLT))
	}
	if i.HostnameLTE != nil {
		predicates = append(predicates, bazelinvocation.HostnameLTE(*i.HostnameLTE))
	}
	if i.HostnameContains != nil {
		predicates = append(predicates, bazelinvocation.HostnameContains(*i.HostnameContains))
	}
	if i.HostnameHasPrefix != nil {
		predicates = append(predicates, bazelinvocation.HostnameHasPrefix(*i.HostnameHasPrefix))
	}
	if i.HostnameHasSuffix != nil {
		predicates = append(predicates, bazelinvocation.HostnameHasSuffix(*i.HostnameHasSuffix))
	}
	if i.HostnameIsNil {
		predicates = append(predicates, bazelinvocation.HostnameIsNil())
	}
	if i.HostnameNotNil {
		predicates = append(predicates, bazelinvocation.HostnameNotNil())
	}
	if i.HostnameEqualFold != nil {
		predicates = append(predicates, bazelinvocation.HostnameEqualFold(*i.HostnameEqualFold))
	}
	if i.HostnameContainsFold != nil {
		predicates = append(predicates, bazelinvocation.HostnameContainsFold(*i.HostnameContainsFold))
	}
	if i.IsCiWorker != nil {
		predicates = append(predicates, bazelinvocation.IsCiWorkerEQ(*i.IsCiWorker))
	}
	if i.IsCiWorkerNEQ != nil {
		predicates = append(predicates, bazelinvocation.IsCiWorkerNEQ(*i.IsCiWorkerNEQ))
	}
	if i.IsCiWorkerIsNil {
		predicates = append(predicates, bazelinvocation.IsCiWorkerIsNil())
	}
	if i.IsCiWorkerNotNil {
		predicates = append(predicates, bazelinvocation.IsCiWorkerNotNil())
	}
	if i.NumFetches != nil {
		predicates = append(predicates, bazelinvocation.NumFetchesEQ(*i.NumFetches))
	}
	if i.NumFetchesNEQ != nil {
		predicates = append(predicates, bazelinvocation.NumFetchesNEQ(*i.NumFetchesNEQ))
	}
	if len(i.NumFetchesIn) > 0 {
		predicates = append(predicates, bazelinvocation.NumFetchesIn(i.NumFetchesIn...))
	}
	if len(i.NumFetchesNotIn) > 0 {
		predicates = append(predicates, bazelinvocation.NumFetchesNotIn(i.NumFetchesNotIn...))
	}
	if i.NumFetchesGT != nil {
		predicates = append(predicates, bazelinvocation.NumFetchesGT(*i.NumFetchesGT))
	}
	if i.NumFetchesGTE != nil {
		predicates = append(predicates, bazelinvocation.NumFetchesGTE(*i.NumFetchesGTE))
	}
	if i.NumFetchesLT != nil {
		predicates = append(predicates, bazelinvocation.NumFetchesLT(*i.NumFetchesLT))
	}
	if i.NumFetchesLTE != nil {
		predicates = append(predicates, bazelinvocation.NumFetchesLTE(*i.NumFetchesLTE))
	}
	if i.NumFetchesIsNil {
		predicates = append(predicates, bazelinvocation.NumFetchesIsNil())
	}
	if i.NumFetchesNotNil {
		predicates = append(predicates, bazelinvocation.NumFetchesNotNil())
	}
	if i.ProfileName != nil {
		predicates = append(predicates, bazelinvocation.ProfileNameEQ(*i.ProfileName))
	}
	if i.ProfileNameNEQ != nil {
		predicates = append(predicates, bazelinvocation.ProfileNameNEQ(*i.ProfileNameNEQ))
	}
	if len(i.ProfileNameIn) > 0 {
		predicates = append(predicates, bazelinvocation.ProfileNameIn(i.ProfileNameIn...))
	}
	if len(i.ProfileNameNotIn) > 0 {
		predicates = append(predicates, bazelinvocation.ProfileNameNotIn(i.ProfileNameNotIn...))
	}
	if i.ProfileNameGT != nil {
		predicates = append(predicates, bazelinvocation.ProfileNameGT(*i.ProfileNameGT))
	}
	if i.ProfileNameGTE != nil {
		predicates = append(predicates, bazelinvocation.ProfileNameGTE(*i.ProfileNameGTE))
	}
	if i.ProfileNameLT != nil {
		predicates = append(predicates, bazelinvocation.ProfileNameLT(*i.ProfileNameLT))
	}
	if i.ProfileNameLTE != nil {
		predicates = append(predicates, bazelinvocation.ProfileNameLTE(*i.ProfileNameLTE))
	}
	if i.ProfileNameContains != nil {
		predicates = append(predicates, bazelinvocation.ProfileNameContains(*i.ProfileNameContains))
	}
	if i.ProfileNameHasPrefix != nil {
		predicates = append(predicates, bazelinvocation.ProfileNameHasPrefix(*i.ProfileNameHasPrefix))
	}
	if i.ProfileNameHasSuffix != nil {
		predicates = append(predicates, bazelinvocation.ProfileNameHasSuffix(*i.ProfileNameHasSuffix))
	}
	if i.ProfileNameIsNil {
		predicates = append(predicates, bazelinvocation.ProfileNameIsNil())
	}
	if i.ProfileNameNotNil {
		predicates = append(predicates, bazelinvocation.ProfileNameNotNil())
	}
	if i.ProfileNameEqualFold != nil {
		predicates = append(predicates, bazelinvocation.ProfileNameEqualFold(*i.ProfileNameEqualFold))
	}
	if i.ProfileNameContainsFold != nil {
		predicates = append(predicates, bazelinvocation.ProfileNameContainsFold(*i.ProfileNameContainsFold))
	}
	if i.BazelVersion != nil {
		predicates = append(predicates, bazelinvocation.BazelVersionEQ(*i.BazelVersion))
	}
	if i.BazelVersionNEQ != nil {
		predicates = append(predicates, bazelinvocation.BazelVersionNEQ(*i.BazelVersionNEQ))
	}
	if len(i.BazelVersionIn) > 0 {
		predicates = append(predicates, bazelinvocation.BazelVersionIn(i.BazelVersionIn...))
	}
	if len(i.BazelVersionNotIn) > 0 {
		predicates = append(predicates, bazelinvocation.BazelVersionNotIn(i.BazelVersionNotIn...))
	}
	if i.BazelVersionGT != nil {
		predicates = append(predicates, bazelinvocation.BazelVersionGT(*i.BazelVersionGT))
	}
	if i.BazelVersionGTE != nil {
		predicates = append(predicates, bazelinvocation.BazelVersionGTE(*i.BazelVersionGTE))
	}
	if i.BazelVersionLT != nil {
		predicates = append(predicates, bazelinvocation.BazelVersionLT(*i.BazelVersionLT))
	}
	if i.BazelVersionLTE != nil {
		predicates = append(predicates, bazelinvocation.BazelVersionLTE(*i.BazelVersionLTE))
	}
	if i.BazelVersionContains != nil {
		predicates = append(predicates, bazelinvocation.BazelVersionContains(*i.BazelVersionContains))
	}
	if i.BazelVersionHasPrefix != nil {
		predicates = append(predicates, bazelinvocation.BazelVersionHasPrefix(*i.BazelVersionHasPrefix))
	}
	if i.BazelVersionHasSuffix != nil {
		predicates = append(predicates, bazelinvocation.BazelVersionHasSuffix(*i.BazelVersionHasSuffix))
	}
	if i.BazelVersionIsNil {
		predicates = append(predicates, bazelinvocation.BazelVersionIsNil())
	}
	if i.BazelVersionNotNil {
		predicates = append(predicates, bazelinvocation.BazelVersionNotNil())
	}
	if i.BazelVersionEqualFold != nil {
		predicates = append(predicates, bazelinvocation.BazelVersionEqualFold(*i.BazelVersionEqualFold))
	}
	if i.BazelVersionContainsFold != nil {
		predicates = append(predicates, bazelinvocation.BazelVersionContainsFold(*i.BazelVersionContainsFold))
	}
	if i.ExitCodeName != nil {
		predicates = append(predicates, bazelinvocation.ExitCodeNameEQ(*i.ExitCodeName))
	}
	if i.ExitCodeNameNEQ != nil {
		predicates = append(predicates, bazelinvocation.ExitCodeNameNEQ(*i.ExitCodeNameNEQ))
	}
	if len(i.ExitCodeNameIn) > 0 {
		predicates = append(predicates, bazelinvocation.ExitCodeNameIn(i.ExitCodeNameIn...))
	}
	if len(i.ExitCodeNameNotIn) > 0 {
		predicates = append(predicates, bazelinvocation.ExitCodeNameNotIn(i.ExitCodeNameNotIn...))
	}
	if i.ExitCodeNameGT != nil {
		predicates = append(predicates, bazelinvocation.ExitCodeNameGT(*i.ExitCodeNameGT))
	}
	if i.ExitCodeNameGTE != nil {
		predicates = append(predicates, bazelinvocation.ExitCodeNameGTE(*i.ExitCodeNameGTE))
	}
	if i.ExitCodeNameLT != nil {
		predicates = append(predicates, bazelinvocation.ExitCodeNameLT(*i.ExitCodeNameLT))
	}
	if i.ExitCodeNameLTE != nil {
		predicates = append(predicates, bazelinvocation.ExitCodeNameLTE(*i.ExitCodeNameLTE))
	}
	if i.ExitCodeNameContains != nil {
		predicates = append(predicates, bazelinvocation.ExitCodeNameContains(*i.ExitCodeNameContains))
	}
	if i.ExitCodeNameHasPrefix != nil {
		predicates = append(predicates, bazelinvocation.ExitCodeNameHasPrefix(*i.ExitCodeNameHasPrefix))
	}
	if i.ExitCodeNameHasSuffix != nil {
		predicates = append(predicates, bazelinvocation.ExitCodeNameHasSuffix(*i.ExitCodeNameHasSuffix))
	}
	if i.ExitCodeNameIsNil {
		predicates = append(predicates, bazelinvocation.ExitCodeNameIsNil())
	}
	if i.ExitCodeNameNotNil {
		predicates = append(predicates, bazelinvocation.ExitCodeNameNotNil())
	}
	if i.ExitCodeNameEqualFold != nil {
		predicates = append(predicates, bazelinvocation.ExitCodeNameEqualFold(*i.ExitCodeNameEqualFold))
	}
	if i.ExitCodeNameContainsFold != nil {
		predicates = append(predicates, bazelinvocation.ExitCodeNameContainsFold(*i.ExitCodeNameContainsFold))
	}
	if i.ExitCodeCode != nil {
		predicates = append(predicates, bazelinvocation.ExitCodeCodeEQ(*i.ExitCodeCode))
	}
	if i.ExitCodeCodeNEQ != nil {
		predicates = append(predicates, bazelinvocation.ExitCodeCodeNEQ(*i.ExitCodeCodeNEQ))
	}
	if len(i.ExitCodeCodeIn) > 0 {
		predicates = append(predicates, bazelinvocation.ExitCodeCodeIn(i.ExitCodeCodeIn...))
	}
	if len(i.ExitCodeCodeNotIn) > 0 {
		predicates = append(predicates, bazelinvocation.ExitCodeCodeNotIn(i.ExitCodeCodeNotIn...))
	}
	if i.ExitCodeCodeGT != nil {
		predicates = append(predicates, bazelinvocation.ExitCodeCodeGT(*i.ExitCodeCodeGT))
	}
	if i.ExitCodeCodeGTE != nil {
		predicates = append(predicates, bazelinvocation.ExitCodeCodeGTE(*i.ExitCodeCodeGTE))
	}
	if i.ExitCodeCodeLT != nil {
		predicates = append(predicates, bazelinvocation.ExitCodeCodeLT(*i.ExitCodeCodeLT))
	}
	if i.ExitCodeCodeLTE != nil {
		predicates = append(predicates, bazelinvocation.ExitCodeCodeLTE(*i.ExitCodeCodeLTE))
	}
	if i.ExitCodeCodeIsNil {
		predicates = append(predicates, bazelinvocation.ExitCodeCodeIsNil())
	}
	if i.ExitCodeCodeNotNil {
		predicates = append(predicates, bazelinvocation.ExitCodeCodeNotNil())
	}

	if i.HasInstanceName != nil {
		p := bazelinvocation.HasInstanceName()
		if !*i.HasInstanceName {
			p = bazelinvocation.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasInstanceNameWith) > 0 {
		with := make([]predicate.InstanceName, 0, len(i.HasInstanceNameWith))
		for _, w := range i.HasInstanceNameWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasInstanceNameWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, bazelinvocation.HasInstanceNameWith(with...))
	}
	if i.HasBuild != nil {
		p := bazelinvocation.HasBuild()
		if !*i.HasBuild {
			p = bazelinvocation.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBuildWith) > 0 {
		with := make([]predicate.Build, 0, len(i.HasBuildWith))
		for _, w := range i.HasBuildWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBuildWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, bazelinvocation.HasBuildWith(with...))
	}
	if i.HasAuthenticatedUser != nil {
		p := bazelinvocation.HasAuthenticatedUser()
		if !*i.HasAuthenticatedUser {
			p = bazelinvocation.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAuthenticatedUserWith) > 0 {
		with := make([]predicate.AuthenticatedUser, 0, len(i.HasAuthenticatedUserWith))
		for _, w := range i.HasAuthenticatedUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAuthenticatedUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, bazelinvocation.HasAuthenticatedUserWith(with...))
	}
	if i.HasConfigurations != nil {
		p := bazelinvocation.HasConfigurations()
		if !*i.HasConfigurations {
			p = bazelinvocation.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasConfigurationsWith) > 0 {
		with := make([]predicate.Configuration, 0, len(i.HasConfigurationsWith))
		for _, w := range i.HasConfigurationsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasConfigurationsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, bazelinvocation.HasConfigurationsWith(with...))
	}
	if i.HasActions != nil {
		p := bazelinvocation.HasActions()
		if !*i.HasActions {
			p = bazelinvocation.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasActionsWith) > 0 {
		with := make([]predicate.Action, 0, len(i.HasActionsWith))
		for _, w := range i.HasActionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasActionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, bazelinvocation.HasActionsWith(with...))
	}
	if i.HasMetrics != nil {
		p := bazelinvocation.HasMetrics()
		if !*i.HasMetrics {
			p = bazelinvocation.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMetricsWith) > 0 {
		with := make([]predicate.Metrics, 0, len(i.HasMetricsWith))
		for _, w := range i.HasMetricsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMetricsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, bazelinvocation.HasMetricsWith(with...))
	}
	if i.HasInvocationFiles != nil {
		p := bazelinvocation.HasInvocationFiles()
		if !*i.HasInvocationFiles {
			p = bazelinvocation.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasInvocationFilesWith) > 0 {
		with := make([]predicate.InvocationFiles, 0, len(i.HasInvocationFilesWith))
		for _, w := range i.HasInvocationFilesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasInvocationFilesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, bazelinvocation.HasInvocationFilesWith(with...))
	}
	if i.HasInvocationTargets != nil {
		p := bazelinvocation.HasInvocationTargets()
		if !*i.HasInvocationTargets {
			p = bazelinvocation.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasInvocationTargetsWith) > 0 {
		with := make([]predicate.InvocationTarget, 0, len(i.HasInvocationTargetsWith))
		for _, w := range i.HasInvocationTargetsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasInvocationTargetsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, bazelinvocation.HasInvocationTargetsWith(with...))
	}
	if i.HasSourceControl != nil {
		p := bazelinvocation.HasSourceControl()
		if !*i.HasSourceControl {
			p = bazelinvocation.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSourceControlWith) > 0 {
		with := make([]predicate.SourceControl, 0, len(i.HasSourceControlWith))
		for _, w := range i.HasSourceControlWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSourceControlWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, bazelinvocation.HasSourceControlWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyBazelInvocationWhereInput
	case 1:
		return predicates[0], nil
	default:
		return bazelinvocation.And(predicates...), nil
	}
}

// BuildWhereInput represents a where input for filtering Build queries.
type BuildWhereInput struct {
	Predicates []predicate.Build  `json:"-"`
	Not        *BuildWhereInput   `json:"not,omitempty"`
	Or         []*BuildWhereInput `json:"or,omitempty"`
	And        []*BuildWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int64  `json:"id,omitempty"`
	IDNEQ   *int64  `json:"idNEQ,omitempty"`
	IDIn    []int64 `json:"idIn,omitempty"`
	IDNotIn []int64 `json:"idNotIn,omitempty"`
	IDGT    *int64  `json:"idGT,omitempty"`
	IDGTE   *int64  `json:"idGTE,omitempty"`
	IDLT    *int64  `json:"idLT,omitempty"`
	IDLTE   *int64  `json:"idLTE,omitempty"`

	// "build_url" field predicates.
	BuildURL             *string  `json:"buildURL,omitempty"`
	BuildURLNEQ          *string  `json:"buildURLNEQ,omitempty"`
	BuildURLIn           []string `json:"buildURLIn,omitempty"`
	BuildURLNotIn        []string `json:"buildURLNotIn,omitempty"`
	BuildURLGT           *string  `json:"buildURLGT,omitempty"`
	BuildURLGTE          *string  `json:"buildURLGTE,omitempty"`
	BuildURLLT           *string  `json:"buildURLLT,omitempty"`
	BuildURLLTE          *string  `json:"buildURLLTE,omitempty"`
	BuildURLContains     *string  `json:"buildURLContains,omitempty"`
	BuildURLHasPrefix    *string  `json:"buildURLHasPrefix,omitempty"`
	BuildURLHasSuffix    *string  `json:"buildURLHasSuffix,omitempty"`
	BuildURLEqualFold    *string  `json:"buildURLEqualFold,omitempty"`
	BuildURLContainsFold *string  `json:"buildURLContainsFold,omitempty"`

	// "build_uuid" field predicates.
	BuildUUID      *uuid.UUID  `json:"buildUUID,omitempty"`
	BuildUUIDNEQ   *uuid.UUID  `json:"buildUUIDNEQ,omitempty"`
	BuildUUIDIn    []uuid.UUID `json:"buildUUIDIn,omitempty"`
	BuildUUIDNotIn []uuid.UUID `json:"buildUUIDNotIn,omitempty"`
	BuildUUIDGT    *uuid.UUID  `json:"buildUUIDGT,omitempty"`
	BuildUUIDGTE   *uuid.UUID  `json:"buildUUIDGTE,omitempty"`
	BuildUUIDLT    *uuid.UUID  `json:"buildUUIDLT,omitempty"`
	BuildUUIDLTE   *uuid.UUID  `json:"buildUUIDLTE,omitempty"`

	// "timestamp" field predicates.
	Timestamp      *time.Time  `json:"timestamp,omitempty"`
	TimestampNEQ   *time.Time  `json:"timestampNEQ,omitempty"`
	TimestampIn    []time.Time `json:"timestampIn,omitempty"`
	TimestampNotIn []time.Time `json:"timestampNotIn,omitempty"`
	TimestampGT    *time.Time  `json:"timestampGT,omitempty"`
	TimestampGTE   *time.Time  `json:"timestampGTE,omitempty"`
	TimestampLT    *time.Time  `json:"timestampLT,omitempty"`
	TimestampLTE   *time.Time  `json:"timestampLTE,omitempty"`

	// "instance_name" edge predicates.
	HasInstanceName     *bool                     `json:"hasInstanceName,omitempty"`
	HasInstanceNameWith []*InstanceNameWhereInput `json:"hasInstanceNameWith,omitempty"`

	// "invocations" edge predicates.
	HasInvocations     *bool                        `json:"hasInvocations,omitempty"`
	HasInvocationsWith []*BazelInvocationWhereInput `json:"hasInvocationsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *BuildWhereInput) AddPredicates(predicates ...predicate.Build) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the BuildWhereInput filter on the BuildQuery builder.
func (i *BuildWhereInput) Filter(q *BuildQuery) (*BuildQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyBuildWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyBuildWhereInput is returned in case the BuildWhereInput is empty.
var ErrEmptyBuildWhereInput = errors.New("ent: empty predicate BuildWhereInput")

// P returns a predicate for filtering builds.
// An error is returned if the input is empty or invalid.
func (i *BuildWhereInput) P() (predicate.Build, error) {
	var predicates []predicate.Build
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, build.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Build, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, build.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Build, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, build.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, build.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, build.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, build.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, build.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, build.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, build.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, build.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, build.IDLTE(*i.IDLTE))
	}
	if i.BuildURL != nil {
		predicates = append(predicates, build.BuildURLEQ(*i.BuildURL))
	}
	if i.BuildURLNEQ != nil {
		predicates = append(predicates, build.BuildURLNEQ(*i.BuildURLNEQ))
	}
	if len(i.BuildURLIn) > 0 {
		predicates = append(predicates, build.BuildURLIn(i.BuildURLIn...))
	}
	if len(i.BuildURLNotIn) > 0 {
		predicates = append(predicates, build.BuildURLNotIn(i.BuildURLNotIn...))
	}
	if i.BuildURLGT != nil {
		predicates = append(predicates, build.BuildURLGT(*i.BuildURLGT))
	}
	if i.BuildURLGTE != nil {
		predicates = append(predicates, build.BuildURLGTE(*i.BuildURLGTE))
	}
	if i.BuildURLLT != nil {
		predicates = append(predicates, build.BuildURLLT(*i.BuildURLLT))
	}
	if i.BuildURLLTE != nil {
		predicates = append(predicates, build.BuildURLLTE(*i.BuildURLLTE))
	}
	if i.BuildURLContains != nil {
		predicates = append(predicates, build.BuildURLContains(*i.BuildURLContains))
	}
	if i.BuildURLHasPrefix != nil {
		predicates = append(predicates, build.BuildURLHasPrefix(*i.BuildURLHasPrefix))
	}
	if i.BuildURLHasSuffix != nil {
		predicates = append(predicates, build.BuildURLHasSuffix(*i.BuildURLHasSuffix))
	}
	if i.BuildURLEqualFold != nil {
		predicates = append(predicates, build.BuildURLEqualFold(*i.BuildURLEqualFold))
	}
	if i.BuildURLContainsFold != nil {
		predicates = append(predicates, build.BuildURLContainsFold(*i.BuildURLContainsFold))
	}
	if i.BuildUUID != nil {
		predicates = append(predicates, build.BuildUUIDEQ(*i.BuildUUID))
	}
	if i.BuildUUIDNEQ != nil {
		predicates = append(predicates, build.BuildUUIDNEQ(*i.BuildUUIDNEQ))
	}
	if len(i.BuildUUIDIn) > 0 {
		predicates = append(predicates, build.BuildUUIDIn(i.BuildUUIDIn...))
	}
	if len(i.BuildUUIDNotIn) > 0 {
		predicates = append(predicates, build.BuildUUIDNotIn(i.BuildUUIDNotIn...))
	}
	if i.BuildUUIDGT != nil {
		predicates = append(predicates, build.BuildUUIDGT(*i.BuildUUIDGT))
	}
	if i.BuildUUIDGTE != nil {
		predicates = append(predicates, build.BuildUUIDGTE(*i.BuildUUIDGTE))
	}
	if i.BuildUUIDLT != nil {
		predicates = append(predicates, build.BuildUUIDLT(*i.BuildUUIDLT))
	}
	if i.BuildUUIDLTE != nil {
		predicates = append(predicates, build.BuildUUIDLTE(*i.BuildUUIDLTE))
	}
	if i.Timestamp != nil {
		predicates = append(predicates, build.TimestampEQ(*i.Timestamp))
	}
	if i.TimestampNEQ != nil {
		predicates = append(predicates, build.TimestampNEQ(*i.TimestampNEQ))
	}
	if len(i.TimestampIn) > 0 {
		predicates = append(predicates, build.TimestampIn(i.TimestampIn...))
	}
	if len(i.TimestampNotIn) > 0 {
		predicates = append(predicates, build.TimestampNotIn(i.TimestampNotIn...))
	}
	if i.TimestampGT != nil {
		predicates = append(predicates, build.TimestampGT(*i.TimestampGT))
	}
	if i.TimestampGTE != nil {
		predicates = append(predicates, build.TimestampGTE(*i.TimestampGTE))
	}
	if i.TimestampLT != nil {
		predicates = append(predicates, build.TimestampLT(*i.TimestampLT))
	}
	if i.TimestampLTE != nil {
		predicates = append(predicates, build.TimestampLTE(*i.TimestampLTE))
	}

	if i.HasInstanceName != nil {
		p := build.HasInstanceName()
		if !*i.HasInstanceName {
			p = build.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasInstanceNameWith) > 0 {
		with := make([]predicate.InstanceName, 0, len(i.HasInstanceNameWith))
		for _, w := range i.HasInstanceNameWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasInstanceNameWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, build.HasInstanceNameWith(with...))
	}
	if i.HasInvocations != nil {
		p := build.HasInvocations()
		if !*i.HasInvocations {
			p = build.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasInvocationsWith) > 0 {
		with := make([]predicate.BazelInvocation, 0, len(i.HasInvocationsWith))
		for _, w := range i.HasInvocationsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasInvocationsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, build.HasInvocationsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyBuildWhereInput
	case 1:
		return predicates[0], nil
	default:
		return build.And(predicates...), nil
	}
}

// BuildGraphMetricsWhereInput represents a where input for filtering BuildGraphMetrics queries.
type BuildGraphMetricsWhereInput struct {
	Predicates []predicate.BuildGraphMetrics  `json:"-"`
	Not        *BuildGraphMetricsWhereInput   `json:"not,omitempty"`
	Or         []*BuildGraphMetricsWhereInput `json:"or,omitempty"`
	And        []*BuildGraphMetricsWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int64  `json:"id,omitempty"`
	IDNEQ   *int64  `json:"idNEQ,omitempty"`
	IDIn    []int64 `json:"idIn,omitempty"`
	IDNotIn []int64 `json:"idNotIn,omitempty"`
	IDGT    *int64  `json:"idGT,omitempty"`
	IDGTE   *int64  `json:"idGTE,omitempty"`
	IDLT    *int64  `json:"idLT,omitempty"`
	IDLTE   *int64  `json:"idLTE,omitempty"`

	// "action_lookup_value_count" field predicates.
	ActionLookupValueCount       *int32  `json:"actionLookupValueCount,omitempty"`
	ActionLookupValueCountNEQ    *int32  `json:"actionLookupValueCountNEQ,omitempty"`
	ActionLookupValueCountIn     []int32 `json:"actionLookupValueCountIn,omitempty"`
	ActionLookupValueCountNotIn  []int32 `json:"actionLookupValueCountNotIn,omitempty"`
	ActionLookupValueCountGT     *int32  `json:"actionLookupValueCountGT,omitempty"`
	ActionLookupValueCountGTE    *int32  `json:"actionLookupValueCountGTE,omitempty"`
	ActionLookupValueCountLT     *int32  `json:"actionLookupValueCountLT,omitempty"`
	ActionLookupValueCountLTE    *int32  `json:"actionLookupValueCountLTE,omitempty"`
	ActionLookupValueCountIsNil  bool    `json:"actionLookupValueCountIsNil,omitempty"`
	ActionLookupValueCountNotNil bool    `json:"actionLookupValueCountNotNil,omitempty"`

	// "action_lookup_value_count_not_including_aspects" field predicates.
	ActionLookupValueCountNotIncludingAspects       *int32  `json:"actionLookupValueCountNotIncludingAspects,omitempty"`
	ActionLookupValueCountNotIncludingAspectsNEQ    *int32  `json:"actionLookupValueCountNotIncludingAspectsNEQ,omitempty"`
	ActionLookupValueCountNotIncludingAspectsIn     []int32 `json:"actionLookupValueCountNotIncludingAspectsIn,omitempty"`
	ActionLookupValueCountNotIncludingAspectsNotIn  []int32 `json:"actionLookupValueCountNotIncludingAspectsNotIn,omitempty"`
	ActionLookupValueCountNotIncludingAspectsGT     *int32  `json:"actionLookupValueCountNotIncludingAspectsGT,omitempty"`
	ActionLookupValueCountNotIncludingAspectsGTE    *int32  `json:"actionLookupValueCountNotIncludingAspectsGTE,omitempty"`
	ActionLookupValueCountNotIncludingAspectsLT     *int32  `json:"actionLookupValueCountNotIncludingAspectsLT,omitempty"`
	ActionLookupValueCountNotIncludingAspectsLTE    *int32  `json:"actionLookupValueCountNotIncludingAspectsLTE,omitempty"`
	ActionLookupValueCountNotIncludingAspectsIsNil  bool    `json:"actionLookupValueCountNotIncludingAspectsIsNil,omitempty"`
	ActionLookupValueCountNotIncludingAspectsNotNil bool    `json:"actionLookupValueCountNotIncludingAspectsNotNil,omitempty"`

	// "action_count" field predicates.
	ActionCount       *int32  `json:"actionCount,omitempty"`
	ActionCountNEQ    *int32  `json:"actionCountNEQ,omitempty"`
	ActionCountIn     []int32 `json:"actionCountIn,omitempty"`
	ActionCountNotIn  []int32 `json:"actionCountNotIn,omitempty"`
	ActionCountGT     *int32  `json:"actionCountGT,omitempty"`
	ActionCountGTE    *int32  `json:"actionCountGTE,omitempty"`
	ActionCountLT     *int32  `json:"actionCountLT,omitempty"`
	ActionCountLTE    *int32  `json:"actionCountLTE,omitempty"`
	ActionCountIsNil  bool    `json:"actionCountIsNil,omitempty"`
	ActionCountNotNil bool    `json:"actionCountNotNil,omitempty"`

	// "action_count_not_including_aspects" field predicates.
	ActionCountNotIncludingAspects       *int32  `json:"actionCountNotIncludingAspects,omitempty"`
	ActionCountNotIncludingAspectsNEQ    *int32  `json:"actionCountNotIncludingAspectsNEQ,omitempty"`
	ActionCountNotIncludingAspectsIn     []int32 `json:"actionCountNotIncludingAspectsIn,omitempty"`
	ActionCountNotIncludingAspectsNotIn  []int32 `json:"actionCountNotIncludingAspectsNotIn,omitempty"`
	ActionCountNotIncludingAspectsGT     *int32  `json:"actionCountNotIncludingAspectsGT,omitempty"`
	ActionCountNotIncludingAspectsGTE    *int32  `json:"actionCountNotIncludingAspectsGTE,omitempty"`
	ActionCountNotIncludingAspectsLT     *int32  `json:"actionCountNotIncludingAspectsLT,omitempty"`
	ActionCountNotIncludingAspectsLTE    *int32  `json:"actionCountNotIncludingAspectsLTE,omitempty"`
	ActionCountNotIncludingAspectsIsNil  bool    `json:"actionCountNotIncludingAspectsIsNil,omitempty"`
	ActionCountNotIncludingAspectsNotNil bool    `json:"actionCountNotIncludingAspectsNotNil,omitempty"`

	// "input_file_configured_target_count" field predicates.
	InputFileConfiguredTargetCount       *int32  `json:"inputFileConfiguredTargetCount,omitempty"`
	InputFileConfiguredTargetCountNEQ    *int32  `json:"inputFileConfiguredTargetCountNEQ,omitempty"`
	InputFileConfiguredTargetCountIn     []int32 `json:"inputFileConfiguredTargetCountIn,omitempty"`
	InputFileConfiguredTargetCountNotIn  []int32 `json:"inputFileConfiguredTargetCountNotIn,omitempty"`
	InputFileConfiguredTargetCountGT     *int32  `json:"inputFileConfiguredTargetCountGT,omitempty"`
	InputFileConfiguredTargetCountGTE    *int32  `json:"inputFileConfiguredTargetCountGTE,omitempty"`
	InputFileConfiguredTargetCountLT     *int32  `json:"inputFileConfiguredTargetCountLT,omitempty"`
	InputFileConfiguredTargetCountLTE    *int32  `json:"inputFileConfiguredTargetCountLTE,omitempty"`
	InputFileConfiguredTargetCountIsNil  bool    `json:"inputFileConfiguredTargetCountIsNil,omitempty"`
	InputFileConfiguredTargetCountNotNil bool    `json:"inputFileConfiguredTargetCountNotNil,omitempty"`

	// "output_file_configured_target_count" field predicates.
	OutputFileConfiguredTargetCount       *int32  `json:"outputFileConfiguredTargetCount,omitempty"`
	OutputFileConfiguredTargetCountNEQ    *int32  `json:"outputFileConfiguredTargetCountNEQ,omitempty"`
	OutputFileConfiguredTargetCountIn     []int32 `json:"outputFileConfiguredTargetCountIn,omitempty"`
	OutputFileConfiguredTargetCountNotIn  []int32 `json:"outputFileConfiguredTargetCountNotIn,omitempty"`
	OutputFileConfiguredTargetCountGT     *int32  `json:"outputFileConfiguredTargetCountGT,omitempty"`
	OutputFileConfiguredTargetCountGTE    *int32  `json:"outputFileConfiguredTargetCountGTE,omitempty"`
	OutputFileConfiguredTargetCountLT     *int32  `json:"outputFileConfiguredTargetCountLT,omitempty"`
	OutputFileConfiguredTargetCountLTE    *int32  `json:"outputFileConfiguredTargetCountLTE,omitempty"`
	OutputFileConfiguredTargetCountIsNil  bool    `json:"outputFileConfiguredTargetCountIsNil,omitempty"`
	OutputFileConfiguredTargetCountNotNil bool    `json:"outputFileConfiguredTargetCountNotNil,omitempty"`

	// "other_configured_target_count" field predicates.
	OtherConfiguredTargetCount       *int32  `json:"otherConfiguredTargetCount,omitempty"`
	OtherConfiguredTargetCountNEQ    *int32  `json:"otherConfiguredTargetCountNEQ,omitempty"`
	OtherConfiguredTargetCountIn     []int32 `json:"otherConfiguredTargetCountIn,omitempty"`
	OtherConfiguredTargetCountNotIn  []int32 `json:"otherConfiguredTargetCountNotIn,omitempty"`
	OtherConfiguredTargetCountGT     *int32  `json:"otherConfiguredTargetCountGT,omitempty"`
	OtherConfiguredTargetCountGTE    *int32  `json:"otherConfiguredTargetCountGTE,omitempty"`
	OtherConfiguredTargetCountLT     *int32  `json:"otherConfiguredTargetCountLT,omitempty"`
	OtherConfiguredTargetCountLTE    *int32  `json:"otherConfiguredTargetCountLTE,omitempty"`
	OtherConfiguredTargetCountIsNil  bool    `json:"otherConfiguredTargetCountIsNil,omitempty"`
	OtherConfiguredTargetCountNotNil bool    `json:"otherConfiguredTargetCountNotNil,omitempty"`

	// "output_artifact_count" field predicates.
	OutputArtifactCount       *int32  `json:"outputArtifactCount,omitempty"`
	OutputArtifactCountNEQ    *int32  `json:"outputArtifactCountNEQ,omitempty"`
	OutputArtifactCountIn     []int32 `json:"outputArtifactCountIn,omitempty"`
	OutputArtifactCountNotIn  []int32 `json:"outputArtifactCountNotIn,omitempty"`
	OutputArtifactCountGT     *int32  `json:"outputArtifactCountGT,omitempty"`
	OutputArtifactCountGTE    *int32  `json:"outputArtifactCountGTE,omitempty"`
	OutputArtifactCountLT     *int32  `json:"outputArtifactCountLT,omitempty"`
	OutputArtifactCountLTE    *int32  `json:"outputArtifactCountLTE,omitempty"`
	OutputArtifactCountIsNil  bool    `json:"outputArtifactCountIsNil,omitempty"`
	OutputArtifactCountNotNil bool    `json:"outputArtifactCountNotNil,omitempty"`

	// "post_invocation_skyframe_node_count" field predicates.
	PostInvocationSkyframeNodeCount       *int32  `json:"postInvocationSkyframeNodeCount,omitempty"`
	PostInvocationSkyframeNodeCountNEQ    *int32  `json:"postInvocationSkyframeNodeCountNEQ,omitempty"`
	PostInvocationSkyframeNodeCountIn     []int32 `json:"postInvocationSkyframeNodeCountIn,omitempty"`
	PostInvocationSkyframeNodeCountNotIn  []int32 `json:"postInvocationSkyframeNodeCountNotIn,omitempty"`
	PostInvocationSkyframeNodeCountGT     *int32  `json:"postInvocationSkyframeNodeCountGT,omitempty"`
	PostInvocationSkyframeNodeCountGTE    *int32  `json:"postInvocationSkyframeNodeCountGTE,omitempty"`
	PostInvocationSkyframeNodeCountLT     *int32  `json:"postInvocationSkyframeNodeCountLT,omitempty"`
	PostInvocationSkyframeNodeCountLTE    *int32  `json:"postInvocationSkyframeNodeCountLTE,omitempty"`
	PostInvocationSkyframeNodeCountIsNil  bool    `json:"postInvocationSkyframeNodeCountIsNil,omitempty"`
	PostInvocationSkyframeNodeCountNotNil bool    `json:"postInvocationSkyframeNodeCountNotNil,omitempty"`

	// "metrics" edge predicates.
	HasMetrics     *bool                `json:"hasMetrics,omitempty"`
	HasMetricsWith []*MetricsWhereInput `json:"hasMetricsWith,omitempty"`

	// "dirtied_values" edge predicates.
	HasDirtiedValues     *bool                       `json:"hasDirtiedValues,omitempty"`
	HasDirtiedValuesWith []*EvaluationStatWhereInput `json:"hasDirtiedValuesWith,omitempty"`

	// "changed_values" edge predicates.
	HasChangedValues     *bool                       `json:"hasChangedValues,omitempty"`
	HasChangedValuesWith []*EvaluationStatWhereInput `json:"hasChangedValuesWith,omitempty"`

	// "built_values" edge predicates.
	HasBuiltValues     *bool                       `json:"hasBuiltValues,omitempty"`
	HasBuiltValuesWith []*EvaluationStatWhereInput `json:"hasBuiltValuesWith,omitempty"`

	// "cleaned_values" edge predicates.
	HasCleanedValues     *bool                       `json:"hasCleanedValues,omitempty"`
	HasCleanedValuesWith []*EvaluationStatWhereInput `json:"hasCleanedValuesWith,omitempty"`

	// "evaluated_values" edge predicates.
	HasEvaluatedValues     *bool                       `json:"hasEvaluatedValues,omitempty"`
	HasEvaluatedValuesWith []*EvaluationStatWhereInput `json:"hasEvaluatedValuesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *BuildGraphMetricsWhereInput) AddPredicates(predicates ...predicate.BuildGraphMetrics) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the BuildGraphMetricsWhereInput filter on the BuildGraphMetricsQuery builder.
func (i *BuildGraphMetricsWhereInput) Filter(q *BuildGraphMetricsQuery) (*BuildGraphMetricsQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyBuildGraphMetricsWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyBuildGraphMetricsWhereInput is returned in case the BuildGraphMetricsWhereInput is empty.
var ErrEmptyBuildGraphMetricsWhereInput = errors.New("ent: empty predicate BuildGraphMetricsWhereInput")

// P returns a predicate for filtering buildgraphmetricsslice.
// An error is returned if the input is empty or invalid.
func (i *BuildGraphMetricsWhereInput) P() (predicate.BuildGraphMetrics, error) {
	var predicates []predicate.BuildGraphMetrics
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, buildgraphmetrics.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.BuildGraphMetrics, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, buildgraphmetrics.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.BuildGraphMetrics, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, buildgraphmetrics.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, buildgraphmetrics.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, buildgraphmetrics.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, buildgraphmetrics.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, buildgraphmetrics.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, buildgraphmetrics.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, buildgraphmetrics.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, buildgraphmetrics.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, buildgraphmetrics.IDLTE(*i.IDLTE))
	}
	if i.ActionLookupValueCount != nil {
		predicates = append(predicates, buildgraphmetrics.ActionLookupValueCountEQ(*i.ActionLookupValueCount))
	}
	if i.ActionLookupValueCountNEQ != nil {
		predicates = append(predicates, buildgraphmetrics.ActionLookupValueCountNEQ(*i.ActionLookupValueCountNEQ))
	}
	if len(i.ActionLookupValueCountIn) > 0 {
		predicates = append(predicates, buildgraphmetrics.ActionLookupValueCountIn(i.ActionLookupValueCountIn...))
	}
	if len(i.ActionLookupValueCountNotIn) > 0 {
		predicates = append(predicates, buildgraphmetrics.ActionLookupValueCountNotIn(i.ActionLookupValueCountNotIn...))
	}
	if i.ActionLookupValueCountGT != nil {
		predicates = append(predicates, buildgraphmetrics.ActionLookupValueCountGT(*i.ActionLookupValueCountGT))
	}
	if i.ActionLookupValueCountGTE != nil {
		predicates = append(predicates, buildgraphmetrics.ActionLookupValueCountGTE(*i.ActionLookupValueCountGTE))
	}
	if i.ActionLookupValueCountLT != nil {
		predicates = append(predicates, buildgraphmetrics.ActionLookupValueCountLT(*i.ActionLookupValueCountLT))
	}
	if i.ActionLookupValueCountLTE != nil {
		predicates = append(predicates, buildgraphmetrics.ActionLookupValueCountLTE(*i.ActionLookupValueCountLTE))
	}
	if i.ActionLookupValueCountIsNil {
		predicates = append(predicates, buildgraphmetrics.ActionLookupValueCountIsNil())
	}
	if i.ActionLookupValueCountNotNil {
		predicates = append(predicates, buildgraphmetrics.ActionLookupValueCountNotNil())
	}
	if i.ActionLookupValueCountNotIncludingAspects != nil {
		predicates = append(predicates, buildgraphmetrics.ActionLookupValueCountNotIncludingAspectsEQ(*i.ActionLookupValueCountNotIncludingAspects))
	}
	if i.ActionLookupValueCountNotIncludingAspectsNEQ != nil {
		predicates = append(predicates, buildgraphmetrics.ActionLookupValueCountNotIncludingAspectsNEQ(*i.ActionLookupValueCountNotIncludingAspectsNEQ))
	}
	if len(i.ActionLookupValueCountNotIncludingAspectsIn) > 0 {
		predicates = append(predicates, buildgraphmetrics.ActionLookupValueCountNotIncludingAspectsIn(i.ActionLookupValueCountNotIncludingAspectsIn...))
	}
	if len(i.ActionLookupValueCountNotIncludingAspectsNotIn) > 0 {
		predicates = append(predicates, buildgraphmetrics.ActionLookupValueCountNotIncludingAspectsNotIn(i.ActionLookupValueCountNotIncludingAspectsNotIn...))
	}
	if i.ActionLookupValueCountNotIncludingAspectsGT != nil {
		predicates = append(predicates, buildgraphmetrics.ActionLookupValueCountNotIncludingAspectsGT(*i.ActionLookupValueCountNotIncludingAspectsGT))
	}
	if i.ActionLookupValueCountNotIncludingAspectsGTE != nil {
		predicates = append(predicates, buildgraphmetrics.ActionLookupValueCountNotIncludingAspectsGTE(*i.ActionLookupValueCountNotIncludingAspectsGTE))
	}
	if i.ActionLookupValueCountNotIncludingAspectsLT != nil {
		predicates = append(predicates, buildgraphmetrics.ActionLookupValueCountNotIncludingAspectsLT(*i.ActionLookupValueCountNotIncludingAspectsLT))
	}
	if i.ActionLookupValueCountNotIncludingAspectsLTE != nil {
		predicates = append(predicates, buildgraphmetrics.ActionLookupValueCountNotIncludingAspectsLTE(*i.ActionLookupValueCountNotIncludingAspectsLTE))
	}
	if i.ActionLookupValueCountNotIncludingAspectsIsNil {
		predicates = append(predicates, buildgraphmetrics.ActionLookupValueCountNotIncludingAspectsIsNil())
	}
	if i.ActionLookupValueCountNotIncludingAspectsNotNil {
		predicates = append(predicates, buildgraphmetrics.ActionLookupValueCountNotIncludingAspectsNotNil())
	}
	if i.ActionCount != nil {
		predicates = append(predicates, buildgraphmetrics.ActionCountEQ(*i.ActionCount))
	}
	if i.ActionCountNEQ != nil {
		predicates = append(predicates, buildgraphmetrics.ActionCountNEQ(*i.ActionCountNEQ))
	}
	if len(i.ActionCountIn) > 0 {
		predicates = append(predicates, buildgraphmetrics.ActionCountIn(i.ActionCountIn...))
	}
	if len(i.ActionCountNotIn) > 0 {
		predicates = append(predicates, buildgraphmetrics.ActionCountNotIn(i.ActionCountNotIn...))
	}
	if i.ActionCountGT != nil {
		predicates = append(predicates, buildgraphmetrics.ActionCountGT(*i.ActionCountGT))
	}
	if i.ActionCountGTE != nil {
		predicates = append(predicates, buildgraphmetrics.ActionCountGTE(*i.ActionCountGTE))
	}
	if i.ActionCountLT != nil {
		predicates = append(predicates, buildgraphmetrics.ActionCountLT(*i.ActionCountLT))
	}
	if i.ActionCountLTE != nil {
		predicates = append(predicates, buildgraphmetrics.ActionCountLTE(*i.ActionCountLTE))
	}
	if i.ActionCountIsNil {
		predicates = append(predicates, buildgraphmetrics.ActionCountIsNil())
	}
	if i.ActionCountNotNil {
		predicates = append(predicates, buildgraphmetrics.ActionCountNotNil())
	}
	if i.ActionCountNotIncludingAspects != nil {
		predicates = append(predicates, buildgraphmetrics.ActionCountNotIncludingAspectsEQ(*i.ActionCountNotIncludingAspects))
	}
	if i.ActionCountNotIncludingAspectsNEQ != nil {
		predicates = append(predicates, buildgraphmetrics.ActionCountNotIncludingAspectsNEQ(*i.ActionCountNotIncludingAspectsNEQ))
	}
	if len(i.ActionCountNotIncludingAspectsIn) > 0 {
		predicates = append(predicates, buildgraphmetrics.ActionCountNotIncludingAspectsIn(i.ActionCountNotIncludingAspectsIn...))
	}
	if len(i.ActionCountNotIncludingAspectsNotIn) > 0 {
		predicates = append(predicates, buildgraphmetrics.ActionCountNotIncludingAspectsNotIn(i.ActionCountNotIncludingAspectsNotIn...))
	}
	if i.ActionCountNotIncludingAspectsGT != nil {
		predicates = append(predicates, buildgraphmetrics.ActionCountNotIncludingAspectsGT(*i.ActionCountNotIncludingAspectsGT))
	}
	if i.ActionCountNotIncludingAspectsGTE != nil {
		predicates = append(predicates, buildgraphmetrics.ActionCountNotIncludingAspectsGTE(*i.ActionCountNotIncludingAspectsGTE))
	}
	if i.ActionCountNotIncludingAspectsLT != nil {
		predicates = append(predicates, buildgraphmetrics.ActionCountNotIncludingAspectsLT(*i.ActionCountNotIncludingAspectsLT))
	}
	if i.ActionCountNotIncludingAspectsLTE != nil {
		predicates = append(predicates, buildgraphmetrics.ActionCountNotIncludingAspectsLTE(*i.ActionCountNotIncludingAspectsLTE))
	}
	if i.ActionCountNotIncludingAspectsIsNil {
		predicates = append(predicates, buildgraphmetrics.ActionCountNotIncludingAspectsIsNil())
	}
	if i.ActionCountNotIncludingAspectsNotNil {
		predicates = append(predicates, buildgraphmetrics.ActionCountNotIncludingAspectsNotNil())
	}
	if i.InputFileConfiguredTargetCount != nil {
		predicates = append(predicates, buildgraphmetrics.InputFileConfiguredTargetCountEQ(*i.InputFileConfiguredTargetCount))
	}
	if i.InputFileConfiguredTargetCountNEQ != nil {
		predicates = append(predicates, buildgraphmetrics.InputFileConfiguredTargetCountNEQ(*i.InputFileConfiguredTargetCountNEQ))
	}
	if len(i.InputFileConfiguredTargetCountIn) > 0 {
		predicates = append(predicates, buildgraphmetrics.InputFileConfiguredTargetCountIn(i.InputFileConfiguredTargetCountIn...))
	}
	if len(i.InputFileConfiguredTargetCountNotIn) > 0 {
		predicates = append(predicates, buildgraphmetrics.InputFileConfiguredTargetCountNotIn(i.InputFileConfiguredTargetCountNotIn...))
	}
	if i.InputFileConfiguredTargetCountGT != nil {
		predicates = append(predicates, buildgraphmetrics.InputFileConfiguredTargetCountGT(*i.InputFileConfiguredTargetCountGT))
	}
	if i.InputFileConfiguredTargetCountGTE != nil {
		predicates = append(predicates, buildgraphmetrics.InputFileConfiguredTargetCountGTE(*i.InputFileConfiguredTargetCountGTE))
	}
	if i.InputFileConfiguredTargetCountLT != nil {
		predicates = append(predicates, buildgraphmetrics.InputFileConfiguredTargetCountLT(*i.InputFileConfiguredTargetCountLT))
	}
	if i.InputFileConfiguredTargetCountLTE != nil {
		predicates = append(predicates, buildgraphmetrics.InputFileConfiguredTargetCountLTE(*i.InputFileConfiguredTargetCountLTE))
	}
	if i.InputFileConfiguredTargetCountIsNil {
		predicates = append(predicates, buildgraphmetrics.InputFileConfiguredTargetCountIsNil())
	}
	if i.InputFileConfiguredTargetCountNotNil {
		predicates = append(predicates, buildgraphmetrics.InputFileConfiguredTargetCountNotNil())
	}
	if i.OutputFileConfiguredTargetCount != nil {
		predicates = append(predicates, buildgraphmetrics.OutputFileConfiguredTargetCountEQ(*i.OutputFileConfiguredTargetCount))
	}
	if i.OutputFileConfiguredTargetCountNEQ != nil {
		predicates = append(predicates, buildgraphmetrics.OutputFileConfiguredTargetCountNEQ(*i.OutputFileConfiguredTargetCountNEQ))
	}
	if len(i.OutputFileConfiguredTargetCountIn) > 0 {
		predicates = append(predicates, buildgraphmetrics.OutputFileConfiguredTargetCountIn(i.OutputFileConfiguredTargetCountIn...))
	}
	if len(i.OutputFileConfiguredTargetCountNotIn) > 0 {
		predicates = append(predicates, buildgraphmetrics.OutputFileConfiguredTargetCountNotIn(i.OutputFileConfiguredTargetCountNotIn...))
	}
	if i.OutputFileConfiguredTargetCountGT != nil {
		predicates = append(predicates, buildgraphmetrics.OutputFileConfiguredTargetCountGT(*i.OutputFileConfiguredTargetCountGT))
	}
	if i.OutputFileConfiguredTargetCountGTE != nil {
		predicates = append(predicates, buildgraphmetrics.OutputFileConfiguredTargetCountGTE(*i.OutputFileConfiguredTargetCountGTE))
	}
	if i.OutputFileConfiguredTargetCountLT != nil {
		predicates = append(predicates, buildgraphmetrics.OutputFileConfiguredTargetCountLT(*i.OutputFileConfiguredTargetCountLT))
	}
	if i.OutputFileConfiguredTargetCountLTE != nil {
		predicates = append(predicates, buildgraphmetrics.OutputFileConfiguredTargetCountLTE(*i.OutputFileConfiguredTargetCountLTE))
	}
	if i.OutputFileConfiguredTargetCountIsNil {
		predicates = append(predicates, buildgraphmetrics.OutputFileConfiguredTargetCountIsNil())
	}
	if i.OutputFileConfiguredTargetCountNotNil {
		predicates = append(predicates, buildgraphmetrics.OutputFileConfiguredTargetCountNotNil())
	}
	if i.OtherConfiguredTargetCount != nil {
		predicates = append(predicates, buildgraphmetrics.OtherConfiguredTargetCountEQ(*i.OtherConfiguredTargetCount))
	}
	if i.OtherConfiguredTargetCountNEQ != nil {
		predicates = append(predicates, buildgraphmetrics.OtherConfiguredTargetCountNEQ(*i.OtherConfiguredTargetCountNEQ))
	}
	if len(i.OtherConfiguredTargetCountIn) > 0 {
		predicates = append(predicates, buildgraphmetrics.OtherConfiguredTargetCountIn(i.OtherConfiguredTargetCountIn...))
	}
	if len(i.OtherConfiguredTargetCountNotIn) > 0 {
		predicates = append(predicates, buildgraphmetrics.OtherConfiguredTargetCountNotIn(i.OtherConfiguredTargetCountNotIn...))
	}
	if i.OtherConfiguredTargetCountGT != nil {
		predicates = append(predicates, buildgraphmetrics.OtherConfiguredTargetCountGT(*i.OtherConfiguredTargetCountGT))
	}
	if i.OtherConfiguredTargetCountGTE != nil {
		predicates = append(predicates, buildgraphmetrics.OtherConfiguredTargetCountGTE(*i.OtherConfiguredTargetCountGTE))
	}
	if i.OtherConfiguredTargetCountLT != nil {
		predicates = append(predicates, buildgraphmetrics.OtherConfiguredTargetCountLT(*i.OtherConfiguredTargetCountLT))
	}
	if i.OtherConfiguredTargetCountLTE != nil {
		predicates = append(predicates, buildgraphmetrics.OtherConfiguredTargetCountLTE(*i.OtherConfiguredTargetCountLTE))
	}
	if i.OtherConfiguredTargetCountIsNil {
		predicates = append(predicates, buildgraphmetrics.OtherConfiguredTargetCountIsNil())
	}
	if i.OtherConfiguredTargetCountNotNil {
		predicates = append(predicates, buildgraphmetrics.OtherConfiguredTargetCountNotNil())
	}
	if i.OutputArtifactCount != nil {
		predicates = append(predicates, buildgraphmetrics.OutputArtifactCountEQ(*i.OutputArtifactCount))
	}
	if i.OutputArtifactCountNEQ != nil {
		predicates = append(predicates, buildgraphmetrics.OutputArtifactCountNEQ(*i.OutputArtifactCountNEQ))
	}
	if len(i.OutputArtifactCountIn) > 0 {
		predicates = append(predicates, buildgraphmetrics.OutputArtifactCountIn(i.OutputArtifactCountIn...))
	}
	if len(i.OutputArtifactCountNotIn) > 0 {
		predicates = append(predicates, buildgraphmetrics.OutputArtifactCountNotIn(i.OutputArtifactCountNotIn...))
	}
	if i.OutputArtifactCountGT != nil {
		predicates = append(predicates, buildgraphmetrics.OutputArtifactCountGT(*i.OutputArtifactCountGT))
	}
	if i.OutputArtifactCountGTE != nil {
		predicates = append(predicates, buildgraphmetrics.OutputArtifactCountGTE(*i.OutputArtifactCountGTE))
	}
	if i.OutputArtifactCountLT != nil {
		predicates = append(predicates, buildgraphmetrics.OutputArtifactCountLT(*i.OutputArtifactCountLT))
	}
	if i.OutputArtifactCountLTE != nil {
		predicates = append(predicates, buildgraphmetrics.OutputArtifactCountLTE(*i.OutputArtifactCountLTE))
	}
	if i.OutputArtifactCountIsNil {
		predicates = append(predicates, buildgraphmetrics.OutputArtifactCountIsNil())
	}
	if i.OutputArtifactCountNotNil {
		predicates = append(predicates, buildgraphmetrics.OutputArtifactCountNotNil())
	}
	if i.PostInvocationSkyframeNodeCount != nil {
		predicates = append(predicates, buildgraphmetrics.PostInvocationSkyframeNodeCountEQ(*i.PostInvocationSkyframeNodeCount))
	}
	if i.PostInvocationSkyframeNodeCountNEQ != nil {
		predicates = append(predicates, buildgraphmetrics.PostInvocationSkyframeNodeCountNEQ(*i.PostInvocationSkyframeNodeCountNEQ))
	}
	if len(i.PostInvocationSkyframeNodeCountIn) > 0 {
		predicates = append(predicates, buildgraphmetrics.PostInvocationSkyframeNodeCountIn(i.PostInvocationSkyframeNodeCountIn...))
	}
	if len(i.PostInvocationSkyframeNodeCountNotIn) > 0 {
		predicates = append(predicates, buildgraphmetrics.PostInvocationSkyframeNodeCountNotIn(i.PostInvocationSkyframeNodeCountNotIn...))
	}
	if i.PostInvocationSkyframeNodeCountGT != nil {
		predicates = append(predicates, buildgraphmetrics.PostInvocationSkyframeNodeCountGT(*i.PostInvocationSkyframeNodeCountGT))
	}
	if i.PostInvocationSkyframeNodeCountGTE != nil {
		predicates = append(predicates, buildgraphmetrics.PostInvocationSkyframeNodeCountGTE(*i.PostInvocationSkyframeNodeCountGTE))
	}
	if i.PostInvocationSkyframeNodeCountLT != nil {
		predicates = append(predicates, buildgraphmetrics.PostInvocationSkyframeNodeCountLT(*i.PostInvocationSkyframeNodeCountLT))
	}
	if i.PostInvocationSkyframeNodeCountLTE != nil {
		predicates = append(predicates, buildgraphmetrics.PostInvocationSkyframeNodeCountLTE(*i.PostInvocationSkyframeNodeCountLTE))
	}
	if i.PostInvocationSkyframeNodeCountIsNil {
		predicates = append(predicates, buildgraphmetrics.PostInvocationSkyframeNodeCountIsNil())
	}
	if i.PostInvocationSkyframeNodeCountNotNil {
		predicates = append(predicates, buildgraphmetrics.PostInvocationSkyframeNodeCountNotNil())
	}

	if i.HasMetrics != nil {
		p := buildgraphmetrics.HasMetrics()
		if !*i.HasMetrics {
			p = buildgraphmetrics.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMetricsWith) > 0 {
		with := make([]predicate.Metrics, 0, len(i.HasMetricsWith))
		for _, w := range i.HasMetricsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMetricsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, buildgraphmetrics.HasMetricsWith(with...))
	}
	if i.HasDirtiedValues != nil {
		p := buildgraphmetrics.HasDirtiedValues()
		if !*i.HasDirtiedValues {
			p = buildgraphmetrics.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDirtiedValuesWith) > 0 {
		with := make([]predicate.EvaluationStat, 0, len(i.HasDirtiedValuesWith))
		for _, w := range i.HasDirtiedValuesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDirtiedValuesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, buildgraphmetrics.HasDirtiedValuesWith(with...))
	}
	if i.HasChangedValues != nil {
		p := buildgraphmetrics.HasChangedValues()
		if !*i.HasChangedValues {
			p = buildgraphmetrics.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasChangedValuesWith) > 0 {
		with := make([]predicate.EvaluationStat, 0, len(i.HasChangedValuesWith))
		for _, w := range i.HasChangedValuesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasChangedValuesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, buildgraphmetrics.HasChangedValuesWith(with...))
	}
	if i.HasBuiltValues != nil {
		p := buildgraphmetrics.HasBuiltValues()
		if !*i.HasBuiltValues {
			p = buildgraphmetrics.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBuiltValuesWith) > 0 {
		with := make([]predicate.EvaluationStat, 0, len(i.HasBuiltValuesWith))
		for _, w := range i.HasBuiltValuesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBuiltValuesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, buildgraphmetrics.HasBuiltValuesWith(with...))
	}
	if i.HasCleanedValues != nil {
		p := buildgraphmetrics.HasCleanedValues()
		if !*i.HasCleanedValues {
			p = buildgraphmetrics.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCleanedValuesWith) > 0 {
		with := make([]predicate.EvaluationStat, 0, len(i.HasCleanedValuesWith))
		for _, w := range i.HasCleanedValuesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCleanedValuesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, buildgraphmetrics.HasCleanedValuesWith(with...))
	}
	if i.HasEvaluatedValues != nil {
		p := buildgraphmetrics.HasEvaluatedValues()
		if !*i.HasEvaluatedValues {
			p = buildgraphmetrics.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEvaluatedValuesWith) > 0 {
		with := make([]predicate.EvaluationStat, 0, len(i.HasEvaluatedValuesWith))
		for _, w := range i.HasEvaluatedValuesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEvaluatedValuesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, buildgraphmetrics.HasEvaluatedValuesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyBuildGraphMetricsWhereInput
	case 1:
		return predicates[0], nil
	default:
		return buildgraphmetrics.And(predicates...), nil
	}
}

// ConfigurationWhereInput represents a where input for filtering Configuration queries.
type ConfigurationWhereInput struct {
	Predicates []predicate.Configuration  `json:"-"`
	Not        *ConfigurationWhereInput   `json:"not,omitempty"`
	Or         []*ConfigurationWhereInput `json:"or,omitempty"`
	And        []*ConfigurationWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int64  `json:"id,omitempty"`
	IDNEQ   *int64  `json:"idNEQ,omitempty"`
	IDIn    []int64 `json:"idIn,omitempty"`
	IDNotIn []int64 `json:"idNotIn,omitempty"`
	IDGT    *int64  `json:"idGT,omitempty"`
	IDGTE   *int64  `json:"idGTE,omitempty"`
	IDLT    *int64  `json:"idLT,omitempty"`
	IDLTE   *int64  `json:"idLTE,omitempty"`

	// "configuration_id" field predicates.
	ConfigurationID             *string  `json:"configurationID,omitempty"`
	ConfigurationIDNEQ          *string  `json:"configurationIDNEQ,omitempty"`
	ConfigurationIDIn           []string `json:"configurationIDIn,omitempty"`
	ConfigurationIDNotIn        []string `json:"configurationIDNotIn,omitempty"`
	ConfigurationIDGT           *string  `json:"configurationIDGT,omitempty"`
	ConfigurationIDGTE          *string  `json:"configurationIDGTE,omitempty"`
	ConfigurationIDLT           *string  `json:"configurationIDLT,omitempty"`
	ConfigurationIDLTE          *string  `json:"configurationIDLTE,omitempty"`
	ConfigurationIDContains     *string  `json:"configurationIDContains,omitempty"`
	ConfigurationIDHasPrefix    *string  `json:"configurationIDHasPrefix,omitempty"`
	ConfigurationIDHasSuffix    *string  `json:"configurationIDHasSuffix,omitempty"`
	ConfigurationIDEqualFold    *string  `json:"configurationIDEqualFold,omitempty"`
	ConfigurationIDContainsFold *string  `json:"configurationIDContainsFold,omitempty"`

	// "mnemonic" field predicates.
	Mnemonic             *string  `json:"mnemonic,omitempty"`
	MnemonicNEQ          *string  `json:"mnemonicNEQ,omitempty"`
	MnemonicIn           []string `json:"mnemonicIn,omitempty"`
	MnemonicNotIn        []string `json:"mnemonicNotIn,omitempty"`
	MnemonicGT           *string  `json:"mnemonicGT,omitempty"`
	MnemonicGTE          *string  `json:"mnemonicGTE,omitempty"`
	MnemonicLT           *string  `json:"mnemonicLT,omitempty"`
	MnemonicLTE          *string  `json:"mnemonicLTE,omitempty"`
	MnemonicContains     *string  `json:"mnemonicContains,omitempty"`
	MnemonicHasPrefix    *string  `json:"mnemonicHasPrefix,omitempty"`
	MnemonicHasSuffix    *string  `json:"mnemonicHasSuffix,omitempty"`
	MnemonicIsNil        bool     `json:"mnemonicIsNil,omitempty"`
	MnemonicNotNil       bool     `json:"mnemonicNotNil,omitempty"`
	MnemonicEqualFold    *string  `json:"mnemonicEqualFold,omitempty"`
	MnemonicContainsFold *string  `json:"mnemonicContainsFold,omitempty"`

	// "platform_name" field predicates.
	PlatformName             *string  `json:"platformName,omitempty"`
	PlatformNameNEQ          *string  `json:"platformNameNEQ,omitempty"`
	PlatformNameIn           []string `json:"platformNameIn,omitempty"`
	PlatformNameNotIn        []string `json:"platformNameNotIn,omitempty"`
	PlatformNameGT           *string  `json:"platformNameGT,omitempty"`
	PlatformNameGTE          *string  `json:"platformNameGTE,omitempty"`
	PlatformNameLT           *string  `json:"platformNameLT,omitempty"`
	PlatformNameLTE          *string  `json:"platformNameLTE,omitempty"`
	PlatformNameContains     *string  `json:"platformNameContains,omitempty"`
	PlatformNameHasPrefix    *string  `json:"platformNameHasPrefix,omitempty"`
	PlatformNameHasSuffix    *string  `json:"platformNameHasSuffix,omitempty"`
	PlatformNameIsNil        bool     `json:"platformNameIsNil,omitempty"`
	PlatformNameNotNil       bool     `json:"platformNameNotNil,omitempty"`
	PlatformNameEqualFold    *string  `json:"platformNameEqualFold,omitempty"`
	PlatformNameContainsFold *string  `json:"platformNameContainsFold,omitempty"`

	// "cpu" field predicates.
	CPU             *string  `json:"cpu,omitempty"`
	CPUNEQ          *string  `json:"cpuNEQ,omitempty"`
	CPUIn           []string `json:"cpuIn,omitempty"`
	CPUNotIn        []string `json:"cpuNotIn,omitempty"`
	CPUGT           *string  `json:"cpuGT,omitempty"`
	CPUGTE          *string  `json:"cpuGTE,omitempty"`
	CPULT           *string  `json:"cpuLT,omitempty"`
	CPULTE          *string  `json:"cpuLTE,omitempty"`
	CPUContains     *string  `json:"cpuContains,omitempty"`
	CPUHasPrefix    *string  `json:"cpuHasPrefix,omitempty"`
	CPUHasSuffix    *string  `json:"cpuHasSuffix,omitempty"`
	CPUIsNil        bool     `json:"cpuIsNil,omitempty"`
	CPUNotNil       bool     `json:"cpuNotNil,omitempty"`
	CPUEqualFold    *string  `json:"cpuEqualFold,omitempty"`
	CPUContainsFold *string  `json:"cpuContainsFold,omitempty"`

	// "is_tool" field predicates.
	IsTool       *bool `json:"isTool,omitempty"`
	IsToolNEQ    *bool `json:"isToolNEQ,omitempty"`
	IsToolIsNil  bool  `json:"isToolIsNil,omitempty"`
	IsToolNotNil bool  `json:"isToolNotNil,omitempty"`

	// "bazel_invocation" edge predicates.
	HasBazelInvocation     *bool                        `json:"hasBazelInvocation,omitempty"`
	HasBazelInvocationWith []*BazelInvocationWhereInput `json:"hasBazelInvocationWith,omitempty"`

	// "invocation_targets" edge predicates.
	HasInvocationTargets     *bool                         `json:"hasInvocationTargets,omitempty"`
	HasInvocationTargetsWith []*InvocationTargetWhereInput `json:"hasInvocationTargetsWith,omitempty"`

	// "actions" edge predicates.
	HasActions     *bool               `json:"hasActions,omitempty"`
	HasActionsWith []*ActionWhereInput `json:"hasActionsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ConfigurationWhereInput) AddPredicates(predicates ...predicate.Configuration) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ConfigurationWhereInput filter on the ConfigurationQuery builder.
func (i *ConfigurationWhereInput) Filter(q *ConfigurationQuery) (*ConfigurationQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyConfigurationWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyConfigurationWhereInput is returned in case the ConfigurationWhereInput is empty.
var ErrEmptyConfigurationWhereInput = errors.New("ent: empty predicate ConfigurationWhereInput")

// P returns a predicate for filtering configurations.
// An error is returned if the input is empty or invalid.
func (i *ConfigurationWhereInput) P() (predicate.Configuration, error) {
	var predicates []predicate.Configuration
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, configuration.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Configuration, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, configuration.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Configuration, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, configuration.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, configuration.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, configuration.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, configuration.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, configuration.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, configuration.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, configuration.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, configuration.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, configuration.IDLTE(*i.IDLTE))
	}
	if i.ConfigurationID != nil {
		predicates = append(predicates, configuration.ConfigurationIDEQ(*i.ConfigurationID))
	}
	if i.ConfigurationIDNEQ != nil {
		predicates = append(predicates, configuration.ConfigurationIDNEQ(*i.ConfigurationIDNEQ))
	}
	if len(i.ConfigurationIDIn) > 0 {
		predicates = append(predicates, configuration.ConfigurationIDIn(i.ConfigurationIDIn...))
	}
	if len(i.ConfigurationIDNotIn) > 0 {
		predicates = append(predicates, configuration.ConfigurationIDNotIn(i.ConfigurationIDNotIn...))
	}
	if i.ConfigurationIDGT != nil {
		predicates = append(predicates, configuration.ConfigurationIDGT(*i.ConfigurationIDGT))
	}
	if i.ConfigurationIDGTE != nil {
		predicates = append(predicates, configuration.ConfigurationIDGTE(*i.ConfigurationIDGTE))
	}
	if i.ConfigurationIDLT != nil {
		predicates = append(predicates, configuration.ConfigurationIDLT(*i.ConfigurationIDLT))
	}
	if i.ConfigurationIDLTE != nil {
		predicates = append(predicates, configuration.ConfigurationIDLTE(*i.ConfigurationIDLTE))
	}
	if i.ConfigurationIDContains != nil {
		predicates = append(predicates, configuration.ConfigurationIDContains(*i.ConfigurationIDContains))
	}
	if i.ConfigurationIDHasPrefix != nil {
		predicates = append(predicates, configuration.ConfigurationIDHasPrefix(*i.ConfigurationIDHasPrefix))
	}
	if i.ConfigurationIDHasSuffix != nil {
		predicates = append(predicates, configuration.ConfigurationIDHasSuffix(*i.ConfigurationIDHasSuffix))
	}
	if i.ConfigurationIDEqualFold != nil {
		predicates = append(predicates, configuration.ConfigurationIDEqualFold(*i.ConfigurationIDEqualFold))
	}
	if i.ConfigurationIDContainsFold != nil {
		predicates = append(predicates, configuration.ConfigurationIDContainsFold(*i.ConfigurationIDContainsFold))
	}
	if i.Mnemonic != nil {
		predicates = append(predicates, configuration.MnemonicEQ(*i.Mnemonic))
	}
	if i.MnemonicNEQ != nil {
		predicates = append(predicates, configuration.MnemonicNEQ(*i.MnemonicNEQ))
	}
	if len(i.MnemonicIn) > 0 {
		predicates = append(predicates, configuration.MnemonicIn(i.MnemonicIn...))
	}
	if len(i.MnemonicNotIn) > 0 {
		predicates = append(predicates, configuration.MnemonicNotIn(i.MnemonicNotIn...))
	}
	if i.MnemonicGT != nil {
		predicates = append(predicates, configuration.MnemonicGT(*i.MnemonicGT))
	}
	if i.MnemonicGTE != nil {
		predicates = append(predicates, configuration.MnemonicGTE(*i.MnemonicGTE))
	}
	if i.MnemonicLT != nil {
		predicates = append(predicates, configuration.MnemonicLT(*i.MnemonicLT))
	}
	if i.MnemonicLTE != nil {
		predicates = append(predicates, configuration.MnemonicLTE(*i.MnemonicLTE))
	}
	if i.MnemonicContains != nil {
		predicates = append(predicates, configuration.MnemonicContains(*i.MnemonicContains))
	}
	if i.MnemonicHasPrefix != nil {
		predicates = append(predicates, configuration.MnemonicHasPrefix(*i.MnemonicHasPrefix))
	}
	if i.MnemonicHasSuffix != nil {
		predicates = append(predicates, configuration.MnemonicHasSuffix(*i.MnemonicHasSuffix))
	}
	if i.MnemonicIsNil {
		predicates = append(predicates, configuration.MnemonicIsNil())
	}
	if i.MnemonicNotNil {
		predicates = append(predicates, configuration.MnemonicNotNil())
	}
	if i.MnemonicEqualFold != nil {
		predicates = append(predicates, configuration.MnemonicEqualFold(*i.MnemonicEqualFold))
	}
	if i.MnemonicContainsFold != nil {
		predicates = append(predicates, configuration.MnemonicContainsFold(*i.MnemonicContainsFold))
	}
	if i.PlatformName != nil {
		predicates = append(predicates, configuration.PlatformNameEQ(*i.PlatformName))
	}
	if i.PlatformNameNEQ != nil {
		predicates = append(predicates, configuration.PlatformNameNEQ(*i.PlatformNameNEQ))
	}
	if len(i.PlatformNameIn) > 0 {
		predicates = append(predicates, configuration.PlatformNameIn(i.PlatformNameIn...))
	}
	if len(i.PlatformNameNotIn) > 0 {
		predicates = append(predicates, configuration.PlatformNameNotIn(i.PlatformNameNotIn...))
	}
	if i.PlatformNameGT != nil {
		predicates = append(predicates, configuration.PlatformNameGT(*i.PlatformNameGT))
	}
	if i.PlatformNameGTE != nil {
		predicates = append(predicates, configuration.PlatformNameGTE(*i.PlatformNameGTE))
	}
	if i.PlatformNameLT != nil {
		predicates = append(predicates, configuration.PlatformNameLT(*i.PlatformNameLT))
	}
	if i.PlatformNameLTE != nil {
		predicates = append(predicates, configuration.PlatformNameLTE(*i.PlatformNameLTE))
	}
	if i.PlatformNameContains != nil {
		predicates = append(predicates, configuration.PlatformNameContains(*i.PlatformNameContains))
	}
	if i.PlatformNameHasPrefix != nil {
		predicates = append(predicates, configuration.PlatformNameHasPrefix(*i.PlatformNameHasPrefix))
	}
	if i.PlatformNameHasSuffix != nil {
		predicates = append(predicates, configuration.PlatformNameHasSuffix(*i.PlatformNameHasSuffix))
	}
	if i.PlatformNameIsNil {
		predicates = append(predicates, configuration.PlatformNameIsNil())
	}
	if i.PlatformNameNotNil {
		predicates = append(predicates, configuration.PlatformNameNotNil())
	}
	if i.PlatformNameEqualFold != nil {
		predicates = append(predicates, configuration.PlatformNameEqualFold(*i.PlatformNameEqualFold))
	}
	if i.PlatformNameContainsFold != nil {
		predicates = append(predicates, configuration.PlatformNameContainsFold(*i.PlatformNameContainsFold))
	}
	if i.CPU != nil {
		predicates = append(predicates, configuration.CPUEQ(*i.CPU))
	}
	if i.CPUNEQ != nil {
		predicates = append(predicates, configuration.CPUNEQ(*i.CPUNEQ))
	}
	if len(i.CPUIn) > 0 {
		predicates = append(predicates, configuration.CPUIn(i.CPUIn...))
	}
	if len(i.CPUNotIn) > 0 {
		predicates = append(predicates, configuration.CPUNotIn(i.CPUNotIn...))
	}
	if i.CPUGT != nil {
		predicates = append(predicates, configuration.CPUGT(*i.CPUGT))
	}
	if i.CPUGTE != nil {
		predicates = append(predicates, configuration.CPUGTE(*i.CPUGTE))
	}
	if i.CPULT != nil {
		predicates = append(predicates, configuration.CPULT(*i.CPULT))
	}
	if i.CPULTE != nil {
		predicates = append(predicates, configuration.CPULTE(*i.CPULTE))
	}
	if i.CPUContains != nil {
		predicates = append(predicates, configuration.CPUContains(*i.CPUContains))
	}
	if i.CPUHasPrefix != nil {
		predicates = append(predicates, configuration.CPUHasPrefix(*i.CPUHasPrefix))
	}
	if i.CPUHasSuffix != nil {
		predicates = append(predicates, configuration.CPUHasSuffix(*i.CPUHasSuffix))
	}
	if i.CPUIsNil {
		predicates = append(predicates, configuration.CPUIsNil())
	}
	if i.CPUNotNil {
		predicates = append(predicates, configuration.CPUNotNil())
	}
	if i.CPUEqualFold != nil {
		predicates = append(predicates, configuration.CPUEqualFold(*i.CPUEqualFold))
	}
	if i.CPUContainsFold != nil {
		predicates = append(predicates, configuration.CPUContainsFold(*i.CPUContainsFold))
	}
	if i.IsTool != nil {
		predicates = append(predicates, configuration.IsToolEQ(*i.IsTool))
	}
	if i.IsToolNEQ != nil {
		predicates = append(predicates, configuration.IsToolNEQ(*i.IsToolNEQ))
	}
	if i.IsToolIsNil {
		predicates = append(predicates, configuration.IsToolIsNil())
	}
	if i.IsToolNotNil {
		predicates = append(predicates, configuration.IsToolNotNil())
	}

	if i.HasBazelInvocation != nil {
		p := configuration.HasBazelInvocation()
		if !*i.HasBazelInvocation {
			p = configuration.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBazelInvocationWith) > 0 {
		with := make([]predicate.BazelInvocation, 0, len(i.HasBazelInvocationWith))
		for _, w := range i.HasBazelInvocationWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBazelInvocationWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, configuration.HasBazelInvocationWith(with...))
	}
	if i.HasInvocationTargets != nil {
		p := configuration.HasInvocationTargets()
		if !*i.HasInvocationTargets {
			p = configuration.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasInvocationTargetsWith) > 0 {
		with := make([]predicate.InvocationTarget, 0, len(i.HasInvocationTargetsWith))
		for _, w := range i.HasInvocationTargetsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasInvocationTargetsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, configuration.HasInvocationTargetsWith(with...))
	}
	if i.HasActions != nil {
		p := configuration.HasActions()
		if !*i.HasActions {
			p = configuration.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasActionsWith) > 0 {
		with := make([]predicate.Action, 0, len(i.HasActionsWith))
		for _, w := range i.HasActionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasActionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, configuration.HasActionsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyConfigurationWhereInput
	case 1:
		return predicates[0], nil
	default:
		return configuration.And(predicates...), nil
	}
}

// CumulativeMetricsWhereInput represents a where input for filtering CumulativeMetrics queries.
type CumulativeMetricsWhereInput struct {
	Predicates []predicate.CumulativeMetrics  `json:"-"`
	Not        *CumulativeMetricsWhereInput   `json:"not,omitempty"`
	Or         []*CumulativeMetricsWhereInput `json:"or,omitempty"`
	And        []*CumulativeMetricsWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int64  `json:"id,omitempty"`
	IDNEQ   *int64  `json:"idNEQ,omitempty"`
	IDIn    []int64 `json:"idIn,omitempty"`
	IDNotIn []int64 `json:"idNotIn,omitempty"`
	IDGT    *int64  `json:"idGT,omitempty"`
	IDGTE   *int64  `json:"idGTE,omitempty"`
	IDLT    *int64  `json:"idLT,omitempty"`
	IDLTE   *int64  `json:"idLTE,omitempty"`

	// "num_analyses" field predicates.
	NumAnalyses       *int32  `json:"numAnalyses,omitempty"`
	NumAnalysesNEQ    *int32  `json:"numAnalysesNEQ,omitempty"`
	NumAnalysesIn     []int32 `json:"numAnalysesIn,omitempty"`
	NumAnalysesNotIn  []int32 `json:"numAnalysesNotIn,omitempty"`
	NumAnalysesGT     *int32  `json:"numAnalysesGT,omitempty"`
	NumAnalysesGTE    *int32  `json:"numAnalysesGTE,omitempty"`
	NumAnalysesLT     *int32  `json:"numAnalysesLT,omitempty"`
	NumAnalysesLTE    *int32  `json:"numAnalysesLTE,omitempty"`
	NumAnalysesIsNil  bool    `json:"numAnalysesIsNil,omitempty"`
	NumAnalysesNotNil bool    `json:"numAnalysesNotNil,omitempty"`

	// "num_builds" field predicates.
	NumBuilds       *int32  `json:"numBuilds,omitempty"`
	NumBuildsNEQ    *int32  `json:"numBuildsNEQ,omitempty"`
	NumBuildsIn     []int32 `json:"numBuildsIn,omitempty"`
	NumBuildsNotIn  []int32 `json:"numBuildsNotIn,omitempty"`
	NumBuildsGT     *int32  `json:"numBuildsGT,omitempty"`
	NumBuildsGTE    *int32  `json:"numBuildsGTE,omitempty"`
	NumBuildsLT     *int32  `json:"numBuildsLT,omitempty"`
	NumBuildsLTE    *int32  `json:"numBuildsLTE,omitempty"`
	NumBuildsIsNil  bool    `json:"numBuildsIsNil,omitempty"`
	NumBuildsNotNil bool    `json:"numBuildsNotNil,omitempty"`

	// "metrics" edge predicates.
	HasMetrics     *bool                `json:"hasMetrics,omitempty"`
	HasMetricsWith []*MetricsWhereInput `json:"hasMetricsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CumulativeMetricsWhereInput) AddPredicates(predicates ...predicate.CumulativeMetrics) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CumulativeMetricsWhereInput filter on the CumulativeMetricsQuery builder.
func (i *CumulativeMetricsWhereInput) Filter(q *CumulativeMetricsQuery) (*CumulativeMetricsQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCumulativeMetricsWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCumulativeMetricsWhereInput is returned in case the CumulativeMetricsWhereInput is empty.
var ErrEmptyCumulativeMetricsWhereInput = errors.New("ent: empty predicate CumulativeMetricsWhereInput")

// P returns a predicate for filtering cumulativemetricsslice.
// An error is returned if the input is empty or invalid.
func (i *CumulativeMetricsWhereInput) P() (predicate.CumulativeMetrics, error) {
	var predicates []predicate.CumulativeMetrics
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, cumulativemetrics.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.CumulativeMetrics, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, cumulativemetrics.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.CumulativeMetrics, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, cumulativemetrics.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, cumulativemetrics.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, cumulativemetrics.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, cumulativemetrics.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, cumulativemetrics.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, cumulativemetrics.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, cumulativemetrics.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, cumulativemetrics.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, cumulativemetrics.IDLTE(*i.IDLTE))
	}
	if i.NumAnalyses != nil {
		predicates = append(predicates, cumulativemetrics.NumAnalysesEQ(*i.NumAnalyses))
	}
	if i.NumAnalysesNEQ != nil {
		predicates = append(predicates, cumulativemetrics.NumAnalysesNEQ(*i.NumAnalysesNEQ))
	}
	if len(i.NumAnalysesIn) > 0 {
		predicates = append(predicates, cumulativemetrics.NumAnalysesIn(i.NumAnalysesIn...))
	}
	if len(i.NumAnalysesNotIn) > 0 {
		predicates = append(predicates, cumulativemetrics.NumAnalysesNotIn(i.NumAnalysesNotIn...))
	}
	if i.NumAnalysesGT != nil {
		predicates = append(predicates, cumulativemetrics.NumAnalysesGT(*i.NumAnalysesGT))
	}
	if i.NumAnalysesGTE != nil {
		predicates = append(predicates, cumulativemetrics.NumAnalysesGTE(*i.NumAnalysesGTE))
	}
	if i.NumAnalysesLT != nil {
		predicates = append(predicates, cumulativemetrics.NumAnalysesLT(*i.NumAnalysesLT))
	}
	if i.NumAnalysesLTE != nil {
		predicates = append(predicates, cumulativemetrics.NumAnalysesLTE(*i.NumAnalysesLTE))
	}
	if i.NumAnalysesIsNil {
		predicates = append(predicates, cumulativemetrics.NumAnalysesIsNil())
	}
	if i.NumAnalysesNotNil {
		predicates = append(predicates, cumulativemetrics.NumAnalysesNotNil())
	}
	if i.NumBuilds != nil {
		predicates = append(predicates, cumulativemetrics.NumBuildsEQ(*i.NumBuilds))
	}
	if i.NumBuildsNEQ != nil {
		predicates = append(predicates, cumulativemetrics.NumBuildsNEQ(*i.NumBuildsNEQ))
	}
	if len(i.NumBuildsIn) > 0 {
		predicates = append(predicates, cumulativemetrics.NumBuildsIn(i.NumBuildsIn...))
	}
	if len(i.NumBuildsNotIn) > 0 {
		predicates = append(predicates, cumulativemetrics.NumBuildsNotIn(i.NumBuildsNotIn...))
	}
	if i.NumBuildsGT != nil {
		predicates = append(predicates, cumulativemetrics.NumBuildsGT(*i.NumBuildsGT))
	}
	if i.NumBuildsGTE != nil {
		predicates = append(predicates, cumulativemetrics.NumBuildsGTE(*i.NumBuildsGTE))
	}
	if i.NumBuildsLT != nil {
		predicates = append(predicates, cumulativemetrics.NumBuildsLT(*i.NumBuildsLT))
	}
	if i.NumBuildsLTE != nil {
		predicates = append(predicates, cumulativemetrics.NumBuildsLTE(*i.NumBuildsLTE))
	}
	if i.NumBuildsIsNil {
		predicates = append(predicates, cumulativemetrics.NumBuildsIsNil())
	}
	if i.NumBuildsNotNil {
		predicates = append(predicates, cumulativemetrics.NumBuildsNotNil())
	}

	if i.HasMetrics != nil {
		p := cumulativemetrics.HasMetrics()
		if !*i.HasMetrics {
			p = cumulativemetrics.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMetricsWith) > 0 {
		with := make([]predicate.Metrics, 0, len(i.HasMetricsWith))
		for _, w := range i.HasMetricsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMetricsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, cumulativemetrics.HasMetricsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCumulativeMetricsWhereInput
	case 1:
		return predicates[0], nil
	default:
		return cumulativemetrics.And(predicates...), nil
	}
}

// EvaluationStatWhereInput represents a where input for filtering EvaluationStat queries.
type EvaluationStatWhereInput struct {
	Predicates []predicate.EvaluationStat  `json:"-"`
	Not        *EvaluationStatWhereInput   `json:"not,omitempty"`
	Or         []*EvaluationStatWhereInput `json:"or,omitempty"`
	And        []*EvaluationStatWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int64  `json:"id,omitempty"`
	IDNEQ   *int64  `json:"idNEQ,omitempty"`
	IDIn    []int64 `json:"idIn,omitempty"`
	IDNotIn []int64 `json:"idNotIn,omitempty"`
	IDGT    *int64  `json:"idGT,omitempty"`
	IDGTE   *int64  `json:"idGTE,omitempty"`
	IDLT    *int64  `json:"idLT,omitempty"`
	IDLTE   *int64  `json:"idLTE,omitempty"`

	// "skyfunction_name" field predicates.
	SkyfunctionName             *string  `json:"skyfunctionName,omitempty"`
	SkyfunctionNameNEQ          *string  `json:"skyfunctionNameNEQ,omitempty"`
	SkyfunctionNameIn           []string `json:"skyfunctionNameIn,omitempty"`
	SkyfunctionNameNotIn        []string `json:"skyfunctionNameNotIn,omitempty"`
	SkyfunctionNameGT           *string  `json:"skyfunctionNameGT,omitempty"`
	SkyfunctionNameGTE          *string  `json:"skyfunctionNameGTE,omitempty"`
	SkyfunctionNameLT           *string  `json:"skyfunctionNameLT,omitempty"`
	SkyfunctionNameLTE          *string  `json:"skyfunctionNameLTE,omitempty"`
	SkyfunctionNameContains     *string  `json:"skyfunctionNameContains,omitempty"`
	SkyfunctionNameHasPrefix    *string  `json:"skyfunctionNameHasPrefix,omitempty"`
	SkyfunctionNameHasSuffix    *string  `json:"skyfunctionNameHasSuffix,omitempty"`
	SkyfunctionNameIsNil        bool     `json:"skyfunctionNameIsNil,omitempty"`
	SkyfunctionNameNotNil       bool     `json:"skyfunctionNameNotNil,omitempty"`
	SkyfunctionNameEqualFold    *string  `json:"skyfunctionNameEqualFold,omitempty"`
	SkyfunctionNameContainsFold *string  `json:"skyfunctionNameContainsFold,omitempty"`

	// "count" field predicates.
	Count       *int64  `json:"count,omitempty"`
	CountNEQ    *int64  `json:"countNEQ,omitempty"`
	CountIn     []int64 `json:"countIn,omitempty"`
	CountNotIn  []int64 `json:"countNotIn,omitempty"`
	CountGT     *int64  `json:"countGT,omitempty"`
	CountGTE    *int64  `json:"countGTE,omitempty"`
	CountLT     *int64  `json:"countLT,omitempty"`
	CountLTE    *int64  `json:"countLTE,omitempty"`
	CountIsNil  bool    `json:"countIsNil,omitempty"`
	CountNotNil bool    `json:"countNotNil,omitempty"`

	// "build_graph_metrics" edge predicates.
	HasBuildGraphMetrics     *bool                          `json:"hasBuildGraphMetrics,omitempty"`
	HasBuildGraphMetricsWith []*BuildGraphMetricsWhereInput `json:"hasBuildGraphMetricsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *EvaluationStatWhereInput) AddPredicates(predicates ...predicate.EvaluationStat) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the EvaluationStatWhereInput filter on the EvaluationStatQuery builder.
func (i *EvaluationStatWhereInput) Filter(q *EvaluationStatQuery) (*EvaluationStatQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyEvaluationStatWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyEvaluationStatWhereInput is returned in case the EvaluationStatWhereInput is empty.
var ErrEmptyEvaluationStatWhereInput = errors.New("ent: empty predicate EvaluationStatWhereInput")

// P returns a predicate for filtering evaluationstats.
// An error is returned if the input is empty or invalid.
func (i *EvaluationStatWhereInput) P() (predicate.EvaluationStat, error) {
	var predicates []predicate.EvaluationStat
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, evaluationstat.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.EvaluationStat, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, evaluationstat.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.EvaluationStat, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, evaluationstat.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, evaluationstat.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, evaluationstat.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, evaluationstat.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, evaluationstat.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, evaluationstat.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, evaluationstat.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, evaluationstat.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, evaluationstat.IDLTE(*i.IDLTE))
	}
	if i.SkyfunctionName != nil {
		predicates = append(predicates, evaluationstat.SkyfunctionNameEQ(*i.SkyfunctionName))
	}
	if i.SkyfunctionNameNEQ != nil {
		predicates = append(predicates, evaluationstat.SkyfunctionNameNEQ(*i.SkyfunctionNameNEQ))
	}
	if len(i.SkyfunctionNameIn) > 0 {
		predicates = append(predicates, evaluationstat.SkyfunctionNameIn(i.SkyfunctionNameIn...))
	}
	if len(i.SkyfunctionNameNotIn) > 0 {
		predicates = append(predicates, evaluationstat.SkyfunctionNameNotIn(i.SkyfunctionNameNotIn...))
	}
	if i.SkyfunctionNameGT != nil {
		predicates = append(predicates, evaluationstat.SkyfunctionNameGT(*i.SkyfunctionNameGT))
	}
	if i.SkyfunctionNameGTE != nil {
		predicates = append(predicates, evaluationstat.SkyfunctionNameGTE(*i.SkyfunctionNameGTE))
	}
	if i.SkyfunctionNameLT != nil {
		predicates = append(predicates, evaluationstat.SkyfunctionNameLT(*i.SkyfunctionNameLT))
	}
	if i.SkyfunctionNameLTE != nil {
		predicates = append(predicates, evaluationstat.SkyfunctionNameLTE(*i.SkyfunctionNameLTE))
	}
	if i.SkyfunctionNameContains != nil {
		predicates = append(predicates, evaluationstat.SkyfunctionNameContains(*i.SkyfunctionNameContains))
	}
	if i.SkyfunctionNameHasPrefix != nil {
		predicates = append(predicates, evaluationstat.SkyfunctionNameHasPrefix(*i.SkyfunctionNameHasPrefix))
	}
	if i.SkyfunctionNameHasSuffix != nil {
		predicates = append(predicates, evaluationstat.SkyfunctionNameHasSuffix(*i.SkyfunctionNameHasSuffix))
	}
	if i.SkyfunctionNameIsNil {
		predicates = append(predicates, evaluationstat.SkyfunctionNameIsNil())
	}
	if i.SkyfunctionNameNotNil {
		predicates = append(predicates, evaluationstat.SkyfunctionNameNotNil())
	}
	if i.SkyfunctionNameEqualFold != nil {
		predicates = append(predicates, evaluationstat.SkyfunctionNameEqualFold(*i.SkyfunctionNameEqualFold))
	}
	if i.SkyfunctionNameContainsFold != nil {
		predicates = append(predicates, evaluationstat.SkyfunctionNameContainsFold(*i.SkyfunctionNameContainsFold))
	}
	if i.Count != nil {
		predicates = append(predicates, evaluationstat.CountEQ(*i.Count))
	}
	if i.CountNEQ != nil {
		predicates = append(predicates, evaluationstat.CountNEQ(*i.CountNEQ))
	}
	if len(i.CountIn) > 0 {
		predicates = append(predicates, evaluationstat.CountIn(i.CountIn...))
	}
	if len(i.CountNotIn) > 0 {
		predicates = append(predicates, evaluationstat.CountNotIn(i.CountNotIn...))
	}
	if i.CountGT != nil {
		predicates = append(predicates, evaluationstat.CountGT(*i.CountGT))
	}
	if i.CountGTE != nil {
		predicates = append(predicates, evaluationstat.CountGTE(*i.CountGTE))
	}
	if i.CountLT != nil {
		predicates = append(predicates, evaluationstat.CountLT(*i.CountLT))
	}
	if i.CountLTE != nil {
		predicates = append(predicates, evaluationstat.CountLTE(*i.CountLTE))
	}
	if i.CountIsNil {
		predicates = append(predicates, evaluationstat.CountIsNil())
	}
	if i.CountNotNil {
		predicates = append(predicates, evaluationstat.CountNotNil())
	}

	if i.HasBuildGraphMetrics != nil {
		p := evaluationstat.HasBuildGraphMetrics()
		if !*i.HasBuildGraphMetrics {
			p = evaluationstat.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBuildGraphMetricsWith) > 0 {
		with := make([]predicate.BuildGraphMetrics, 0, len(i.HasBuildGraphMetricsWith))
		for _, w := range i.HasBuildGraphMetricsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBuildGraphMetricsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, evaluationstat.HasBuildGraphMetricsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyEvaluationStatWhereInput
	case 1:
		return predicates[0], nil
	default:
		return evaluationstat.And(predicates...), nil
	}
}

// GarbageMetricsWhereInput represents a where input for filtering GarbageMetrics queries.
type GarbageMetricsWhereInput struct {
	Predicates []predicate.GarbageMetrics  `json:"-"`
	Not        *GarbageMetricsWhereInput   `json:"not,omitempty"`
	Or         []*GarbageMetricsWhereInput `json:"or,omitempty"`
	And        []*GarbageMetricsWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int64  `json:"id,omitempty"`
	IDNEQ   *int64  `json:"idNEQ,omitempty"`
	IDIn    []int64 `json:"idIn,omitempty"`
	IDNotIn []int64 `json:"idNotIn,omitempty"`
	IDGT    *int64  `json:"idGT,omitempty"`
	IDGTE   *int64  `json:"idGTE,omitempty"`
	IDLT    *int64  `json:"idLT,omitempty"`
	IDLTE   *int64  `json:"idLTE,omitempty"`

	// "type" field predicates.
	Type             *string  `json:"type,omitempty"`
	TypeNEQ          *string  `json:"typeNEQ,omitempty"`
	TypeIn           []string `json:"typeIn,omitempty"`
	TypeNotIn        []string `json:"typeNotIn,omitempty"`
	TypeGT           *string  `json:"typeGT,omitempty"`
	TypeGTE          *string  `json:"typeGTE,omitempty"`
	TypeLT           *string  `json:"typeLT,omitempty"`
	TypeLTE          *string  `json:"typeLTE,omitempty"`
	TypeContains     *string  `json:"typeContains,omitempty"`
	TypeHasPrefix    *string  `json:"typeHasPrefix,omitempty"`
	TypeHasSuffix    *string  `json:"typeHasSuffix,omitempty"`
	TypeIsNil        bool     `json:"typeIsNil,omitempty"`
	TypeNotNil       bool     `json:"typeNotNil,omitempty"`
	TypeEqualFold    *string  `json:"typeEqualFold,omitempty"`
	TypeContainsFold *string  `json:"typeContainsFold,omitempty"`

	// "garbage_collected" field predicates.
	GarbageCollected       *int64  `json:"garbageCollected,omitempty"`
	GarbageCollectedNEQ    *int64  `json:"garbageCollectedNEQ,omitempty"`
	GarbageCollectedIn     []int64 `json:"garbageCollectedIn,omitempty"`
	GarbageCollectedNotIn  []int64 `json:"garbageCollectedNotIn,omitempty"`
	GarbageCollectedGT     *int64  `json:"garbageCollectedGT,omitempty"`
	GarbageCollectedGTE    *int64  `json:"garbageCollectedGTE,omitempty"`
	GarbageCollectedLT     *int64  `json:"garbageCollectedLT,omitempty"`
	GarbageCollectedLTE    *int64  `json:"garbageCollectedLTE,omitempty"`
	GarbageCollectedIsNil  bool    `json:"garbageCollectedIsNil,omitempty"`
	GarbageCollectedNotNil bool    `json:"garbageCollectedNotNil,omitempty"`

	// "memory_metrics" edge predicates.
	HasMemoryMetrics     *bool                      `json:"hasMemoryMetrics,omitempty"`
	HasMemoryMetricsWith []*MemoryMetricsWhereInput `json:"hasMemoryMetricsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *GarbageMetricsWhereInput) AddPredicates(predicates ...predicate.GarbageMetrics) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the GarbageMetricsWhereInput filter on the GarbageMetricsQuery builder.
func (i *GarbageMetricsWhereInput) Filter(q *GarbageMetricsQuery) (*GarbageMetricsQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyGarbageMetricsWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyGarbageMetricsWhereInput is returned in case the GarbageMetricsWhereInput is empty.
var ErrEmptyGarbageMetricsWhereInput = errors.New("ent: empty predicate GarbageMetricsWhereInput")

// P returns a predicate for filtering garbagemetricsslice.
// An error is returned if the input is empty or invalid.
func (i *GarbageMetricsWhereInput) P() (predicate.GarbageMetrics, error) {
	var predicates []predicate.GarbageMetrics
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, garbagemetrics.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.GarbageMetrics, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, garbagemetrics.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.GarbageMetrics, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, garbagemetrics.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, garbagemetrics.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, garbagemetrics.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, garbagemetrics.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, garbagemetrics.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, garbagemetrics.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, garbagemetrics.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, garbagemetrics.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, garbagemetrics.IDLTE(*i.IDLTE))
	}
	if i.Type != nil {
		predicates = append(predicates, garbagemetrics.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, garbagemetrics.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, garbagemetrics.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, garbagemetrics.TypeNotIn(i.TypeNotIn...))
	}
	if i.TypeGT != nil {
		predicates = append(predicates, garbagemetrics.TypeGT(*i.TypeGT))
	}
	if i.TypeGTE != nil {
		predicates = append(predicates, garbagemetrics.TypeGTE(*i.TypeGTE))
	}
	if i.TypeLT != nil {
		predicates = append(predicates, garbagemetrics.TypeLT(*i.TypeLT))
	}
	if i.TypeLTE != nil {
		predicates = append(predicates, garbagemetrics.TypeLTE(*i.TypeLTE))
	}
	if i.TypeContains != nil {
		predicates = append(predicates, garbagemetrics.TypeContains(*i.TypeContains))
	}
	if i.TypeHasPrefix != nil {
		predicates = append(predicates, garbagemetrics.TypeHasPrefix(*i.TypeHasPrefix))
	}
	if i.TypeHasSuffix != nil {
		predicates = append(predicates, garbagemetrics.TypeHasSuffix(*i.TypeHasSuffix))
	}
	if i.TypeIsNil {
		predicates = append(predicates, garbagemetrics.TypeIsNil())
	}
	if i.TypeNotNil {
		predicates = append(predicates, garbagemetrics.TypeNotNil())
	}
	if i.TypeEqualFold != nil {
		predicates = append(predicates, garbagemetrics.TypeEqualFold(*i.TypeEqualFold))
	}
	if i.TypeContainsFold != nil {
		predicates = append(predicates, garbagemetrics.TypeContainsFold(*i.TypeContainsFold))
	}
	if i.GarbageCollected != nil {
		predicates = append(predicates, garbagemetrics.GarbageCollectedEQ(*i.GarbageCollected))
	}
	if i.GarbageCollectedNEQ != nil {
		predicates = append(predicates, garbagemetrics.GarbageCollectedNEQ(*i.GarbageCollectedNEQ))
	}
	if len(i.GarbageCollectedIn) > 0 {
		predicates = append(predicates, garbagemetrics.GarbageCollectedIn(i.GarbageCollectedIn...))
	}
	if len(i.GarbageCollectedNotIn) > 0 {
		predicates = append(predicates, garbagemetrics.GarbageCollectedNotIn(i.GarbageCollectedNotIn...))
	}
	if i.GarbageCollectedGT != nil {
		predicates = append(predicates, garbagemetrics.GarbageCollectedGT(*i.GarbageCollectedGT))
	}
	if i.GarbageCollectedGTE != nil {
		predicates = append(predicates, garbagemetrics.GarbageCollectedGTE(*i.GarbageCollectedGTE))
	}
	if i.GarbageCollectedLT != nil {
		predicates = append(predicates, garbagemetrics.GarbageCollectedLT(*i.GarbageCollectedLT))
	}
	if i.GarbageCollectedLTE != nil {
		predicates = append(predicates, garbagemetrics.GarbageCollectedLTE(*i.GarbageCollectedLTE))
	}
	if i.GarbageCollectedIsNil {
		predicates = append(predicates, garbagemetrics.GarbageCollectedIsNil())
	}
	if i.GarbageCollectedNotNil {
		predicates = append(predicates, garbagemetrics.GarbageCollectedNotNil())
	}

	if i.HasMemoryMetrics != nil {
		p := garbagemetrics.HasMemoryMetrics()
		if !*i.HasMemoryMetrics {
			p = garbagemetrics.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMemoryMetricsWith) > 0 {
		with := make([]predicate.MemoryMetrics, 0, len(i.HasMemoryMetricsWith))
		for _, w := range i.HasMemoryMetricsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMemoryMetricsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, garbagemetrics.HasMemoryMetricsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyGarbageMetricsWhereInput
	case 1:
		return predicates[0], nil
	default:
		return garbagemetrics.And(predicates...), nil
	}
}

// InstanceNameWhereInput represents a where input for filtering InstanceName queries.
type InstanceNameWhereInput struct {
	Predicates []predicate.InstanceName  `json:"-"`
	Not        *InstanceNameWhereInput   `json:"not,omitempty"`
	Or         []*InstanceNameWhereInput `json:"or,omitempty"`
	And        []*InstanceNameWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int64  `json:"id,omitempty"`
	IDNEQ   *int64  `json:"idNEQ,omitempty"`
	IDIn    []int64 `json:"idIn,omitempty"`
	IDNotIn []int64 `json:"idNotIn,omitempty"`
	IDGT    *int64  `json:"idGT,omitempty"`
	IDGTE   *int64  `json:"idGTE,omitempty"`
	IDLT    *int64  `json:"idLT,omitempty"`
	IDLTE   *int64  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "bazel_invocations" edge predicates.
	HasBazelInvocations     *bool                        `json:"hasBazelInvocations,omitempty"`
	HasBazelInvocationsWith []*BazelInvocationWhereInput `json:"hasBazelInvocationsWith,omitempty"`

	// "builds" edge predicates.
	HasBuilds     *bool              `json:"hasBuilds,omitempty"`
	HasBuildsWith []*BuildWhereInput `json:"hasBuildsWith,omitempty"`

	// "targets" edge predicates.
	HasTargets     *bool               `json:"hasTargets,omitempty"`
	HasTargetsWith []*TargetWhereInput `json:"hasTargetsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *InstanceNameWhereInput) AddPredicates(predicates ...predicate.InstanceName) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the InstanceNameWhereInput filter on the InstanceNameQuery builder.
func (i *InstanceNameWhereInput) Filter(q *InstanceNameQuery) (*InstanceNameQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyInstanceNameWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyInstanceNameWhereInput is returned in case the InstanceNameWhereInput is empty.
var ErrEmptyInstanceNameWhereInput = errors.New("ent: empty predicate InstanceNameWhereInput")

// P returns a predicate for filtering instancenames.
// An error is returned if the input is empty or invalid.
func (i *InstanceNameWhereInput) P() (predicate.InstanceName, error) {
	var predicates []predicate.InstanceName
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, instancename.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.InstanceName, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, instancename.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.InstanceName, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, instancename.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, instancename.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, instancename.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, instancename.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, instancename.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, instancename.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, instancename.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, instancename.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, instancename.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, instancename.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, instancename.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, instancename.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, instancename.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, instancename.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, instancename.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, instancename.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, instancename.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, instancename.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, instancename.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, instancename.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, instancename.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, instancename.NameContainsFold(*i.NameContainsFold))
	}

	if i.HasBazelInvocations != nil {
		p := instancename.HasBazelInvocations()
		if !*i.HasBazelInvocations {
			p = instancename.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBazelInvocationsWith) > 0 {
		with := make([]predicate.BazelInvocation, 0, len(i.HasBazelInvocationsWith))
		for _, w := range i.HasBazelInvocationsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBazelInvocationsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, instancename.HasBazelInvocationsWith(with...))
	}
	if i.HasBuilds != nil {
		p := instancename.HasBuilds()
		if !*i.HasBuilds {
			p = instancename.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBuildsWith) > 0 {
		with := make([]predicate.Build, 0, len(i.HasBuildsWith))
		for _, w := range i.HasBuildsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBuildsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, instancename.HasBuildsWith(with...))
	}
	if i.HasTargets != nil {
		p := instancename.HasTargets()
		if !*i.HasTargets {
			p = instancename.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTargetsWith) > 0 {
		with := make([]predicate.Target, 0, len(i.HasTargetsWith))
		for _, w := range i.HasTargetsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTargetsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, instancename.HasTargetsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyInstanceNameWhereInput
	case 1:
		return predicates[0], nil
	default:
		return instancename.And(predicates...), nil
	}
}

// InvocationFilesWhereInput represents a where input for filtering InvocationFiles queries.
type InvocationFilesWhereInput struct {
	Predicates []predicate.InvocationFiles  `json:"-"`
	Not        *InvocationFilesWhereInput   `json:"not,omitempty"`
	Or         []*InvocationFilesWhereInput `json:"or,omitempty"`
	And        []*InvocationFilesWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int64  `json:"id,omitempty"`
	IDNEQ   *int64  `json:"idNEQ,omitempty"`
	IDIn    []int64 `json:"idIn,omitempty"`
	IDNotIn []int64 `json:"idNotIn,omitempty"`
	IDGT    *int64  `json:"idGT,omitempty"`
	IDGTE   *int64  `json:"idGTE,omitempty"`
	IDLT    *int64  `json:"idLT,omitempty"`
	IDLTE   *int64  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "content" field predicates.
	Content             *string  `json:"content,omitempty"`
	ContentNEQ          *string  `json:"contentNEQ,omitempty"`
	ContentIn           []string `json:"contentIn,omitempty"`
	ContentNotIn        []string `json:"contentNotIn,omitempty"`
	ContentGT           *string  `json:"contentGT,omitempty"`
	ContentGTE          *string  `json:"contentGTE,omitempty"`
	ContentLT           *string  `json:"contentLT,omitempty"`
	ContentLTE          *string  `json:"contentLTE,omitempty"`
	ContentContains     *string  `json:"contentContains,omitempty"`
	ContentHasPrefix    *string  `json:"contentHasPrefix,omitempty"`
	ContentHasSuffix    *string  `json:"contentHasSuffix,omitempty"`
	ContentIsNil        bool     `json:"contentIsNil,omitempty"`
	ContentNotNil       bool     `json:"contentNotNil,omitempty"`
	ContentEqualFold    *string  `json:"contentEqualFold,omitempty"`
	ContentContainsFold *string  `json:"contentContainsFold,omitempty"`

	// "digest" field predicates.
	Digest             *string  `json:"digest,omitempty"`
	DigestNEQ          *string  `json:"digestNEQ,omitempty"`
	DigestIn           []string `json:"digestIn,omitempty"`
	DigestNotIn        []string `json:"digestNotIn,omitempty"`
	DigestGT           *string  `json:"digestGT,omitempty"`
	DigestGTE          *string  `json:"digestGTE,omitempty"`
	DigestLT           *string  `json:"digestLT,omitempty"`
	DigestLTE          *string  `json:"digestLTE,omitempty"`
	DigestContains     *string  `json:"digestContains,omitempty"`
	DigestHasPrefix    *string  `json:"digestHasPrefix,omitempty"`
	DigestHasSuffix    *string  `json:"digestHasSuffix,omitempty"`
	DigestIsNil        bool     `json:"digestIsNil,omitempty"`
	DigestNotNil       bool     `json:"digestNotNil,omitempty"`
	DigestEqualFold    *string  `json:"digestEqualFold,omitempty"`
	DigestContainsFold *string  `json:"digestContainsFold,omitempty"`

	// "size_bytes" field predicates.
	SizeBytes       *int64  `json:"sizeBytes,omitempty"`
	SizeBytesNEQ    *int64  `json:"sizeBytesNEQ,omitempty"`
	SizeBytesIn     []int64 `json:"sizeBytesIn,omitempty"`
	SizeBytesNotIn  []int64 `json:"sizeBytesNotIn,omitempty"`
	SizeBytesGT     *int64  `json:"sizeBytesGT,omitempty"`
	SizeBytesGTE    *int64  `json:"sizeBytesGTE,omitempty"`
	SizeBytesLT     *int64  `json:"sizeBytesLT,omitempty"`
	SizeBytesLTE    *int64  `json:"sizeBytesLTE,omitempty"`
	SizeBytesIsNil  bool    `json:"sizeBytesIsNil,omitempty"`
	SizeBytesNotNil bool    `json:"sizeBytesNotNil,omitempty"`

	// "digest_function" field predicates.
	DigestFunction             *string  `json:"digestFunction,omitempty"`
	DigestFunctionNEQ          *string  `json:"digestFunctionNEQ,omitempty"`
	DigestFunctionIn           []string `json:"digestFunctionIn,omitempty"`
	DigestFunctionNotIn        []string `json:"digestFunctionNotIn,omitempty"`
	DigestFunctionGT           *string  `json:"digestFunctionGT,omitempty"`
	DigestFunctionGTE          *string  `json:"digestFunctionGTE,omitempty"`
	DigestFunctionLT           *string  `json:"digestFunctionLT,omitempty"`
	DigestFunctionLTE          *string  `json:"digestFunctionLTE,omitempty"`
	DigestFunctionContains     *string  `json:"digestFunctionContains,omitempty"`
	DigestFunctionHasPrefix    *string  `json:"digestFunctionHasPrefix,omitempty"`
	DigestFunctionHasSuffix    *string  `json:"digestFunctionHasSuffix,omitempty"`
	DigestFunctionIsNil        bool     `json:"digestFunctionIsNil,omitempty"`
	DigestFunctionNotNil       bool     `json:"digestFunctionNotNil,omitempty"`
	DigestFunctionEqualFold    *string  `json:"digestFunctionEqualFold,omitempty"`
	DigestFunctionContainsFold *string  `json:"digestFunctionContainsFold,omitempty"`

	// "bazel_invocation" edge predicates.
	HasBazelInvocation     *bool                        `json:"hasBazelInvocation,omitempty"`
	HasBazelInvocationWith []*BazelInvocationWhereInput `json:"hasBazelInvocationWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *InvocationFilesWhereInput) AddPredicates(predicates ...predicate.InvocationFiles) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the InvocationFilesWhereInput filter on the InvocationFilesQuery builder.
func (i *InvocationFilesWhereInput) Filter(q *InvocationFilesQuery) (*InvocationFilesQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyInvocationFilesWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyInvocationFilesWhereInput is returned in case the InvocationFilesWhereInput is empty.
var ErrEmptyInvocationFilesWhereInput = errors.New("ent: empty predicate InvocationFilesWhereInput")

// P returns a predicate for filtering invocationfilesslice.
// An error is returned if the input is empty or invalid.
func (i *InvocationFilesWhereInput) P() (predicate.InvocationFiles, error) {
	var predicates []predicate.InvocationFiles
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, invocationfiles.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.InvocationFiles, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, invocationfiles.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.InvocationFiles, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, invocationfiles.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, invocationfiles.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, invocationfiles.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, invocationfiles.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, invocationfiles.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, invocationfiles.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, invocationfiles.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, invocationfiles.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, invocationfiles.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, invocationfiles.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, invocationfiles.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, invocationfiles.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, invocationfiles.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, invocationfiles.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, invocationfiles.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, invocationfiles.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, invocationfiles.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, invocationfiles.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, invocationfiles.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, invocationfiles.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, invocationfiles.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, invocationfiles.NameContainsFold(*i.NameContainsFold))
	}
	if i.Content != nil {
		predicates = append(predicates, invocationfiles.ContentEQ(*i.Content))
	}
	if i.ContentNEQ != nil {
		predicates = append(predicates, invocationfiles.ContentNEQ(*i.ContentNEQ))
	}
	if len(i.ContentIn) > 0 {
		predicates = append(predicates, invocationfiles.ContentIn(i.ContentIn...))
	}
	if len(i.ContentNotIn) > 0 {
		predicates = append(predicates, invocationfiles.ContentNotIn(i.ContentNotIn...))
	}
	if i.ContentGT != nil {
		predicates = append(predicates, invocationfiles.ContentGT(*i.ContentGT))
	}
	if i.ContentGTE != nil {
		predicates = append(predicates, invocationfiles.ContentGTE(*i.ContentGTE))
	}
	if i.ContentLT != nil {
		predicates = append(predicates, invocationfiles.ContentLT(*i.ContentLT))
	}
	if i.ContentLTE != nil {
		predicates = append(predicates, invocationfiles.ContentLTE(*i.ContentLTE))
	}
	if i.ContentContains != nil {
		predicates = append(predicates, invocationfiles.ContentContains(*i.ContentContains))
	}
	if i.ContentHasPrefix != nil {
		predicates = append(predicates, invocationfiles.ContentHasPrefix(*i.ContentHasPrefix))
	}
	if i.ContentHasSuffix != nil {
		predicates = append(predicates, invocationfiles.ContentHasSuffix(*i.ContentHasSuffix))
	}
	if i.ContentIsNil {
		predicates = append(predicates, invocationfiles.ContentIsNil())
	}
	if i.ContentNotNil {
		predicates = append(predicates, invocationfiles.ContentNotNil())
	}
	if i.ContentEqualFold != nil {
		predicates = append(predicates, invocationfiles.ContentEqualFold(*i.ContentEqualFold))
	}
	if i.ContentContainsFold != nil {
		predicates = append(predicates, invocationfiles.ContentContainsFold(*i.ContentContainsFold))
	}
	if i.Digest != nil {
		predicates = append(predicates, invocationfiles.DigestEQ(*i.Digest))
	}
	if i.DigestNEQ != nil {
		predicates = append(predicates, invocationfiles.DigestNEQ(*i.DigestNEQ))
	}
	if len(i.DigestIn) > 0 {
		predicates = append(predicates, invocationfiles.DigestIn(i.DigestIn...))
	}
	if len(i.DigestNotIn) > 0 {
		predicates = append(predicates, invocationfiles.DigestNotIn(i.DigestNotIn...))
	}
	if i.DigestGT != nil {
		predicates = append(predicates, invocationfiles.DigestGT(*i.DigestGT))
	}
	if i.DigestGTE != nil {
		predicates = append(predicates, invocationfiles.DigestGTE(*i.DigestGTE))
	}
	if i.DigestLT != nil {
		predicates = append(predicates, invocationfiles.DigestLT(*i.DigestLT))
	}
	if i.DigestLTE != nil {
		predicates = append(predicates, invocationfiles.DigestLTE(*i.DigestLTE))
	}
	if i.DigestContains != nil {
		predicates = append(predicates, invocationfiles.DigestContains(*i.DigestContains))
	}
	if i.DigestHasPrefix != nil {
		predicates = append(predicates, invocationfiles.DigestHasPrefix(*i.DigestHasPrefix))
	}
	if i.DigestHasSuffix != nil {
		predicates = append(predicates, invocationfiles.DigestHasSuffix(*i.DigestHasSuffix))
	}
	if i.DigestIsNil {
		predicates = append(predicates, invocationfiles.DigestIsNil())
	}
	if i.DigestNotNil {
		predicates = append(predicates, invocationfiles.DigestNotNil())
	}
	if i.DigestEqualFold != nil {
		predicates = append(predicates, invocationfiles.DigestEqualFold(*i.DigestEqualFold))
	}
	if i.DigestContainsFold != nil {
		predicates = append(predicates, invocationfiles.DigestContainsFold(*i.DigestContainsFold))
	}
	if i.SizeBytes != nil {
		predicates = append(predicates, invocationfiles.SizeBytesEQ(*i.SizeBytes))
	}
	if i.SizeBytesNEQ != nil {
		predicates = append(predicates, invocationfiles.SizeBytesNEQ(*i.SizeBytesNEQ))
	}
	if len(i.SizeBytesIn) > 0 {
		predicates = append(predicates, invocationfiles.SizeBytesIn(i.SizeBytesIn...))
	}
	if len(i.SizeBytesNotIn) > 0 {
		predicates = append(predicates, invocationfiles.SizeBytesNotIn(i.SizeBytesNotIn...))
	}
	if i.SizeBytesGT != nil {
		predicates = append(predicates, invocationfiles.SizeBytesGT(*i.SizeBytesGT))
	}
	if i.SizeBytesGTE != nil {
		predicates = append(predicates, invocationfiles.SizeBytesGTE(*i.SizeBytesGTE))
	}
	if i.SizeBytesLT != nil {
		predicates = append(predicates, invocationfiles.SizeBytesLT(*i.SizeBytesLT))
	}
	if i.SizeBytesLTE != nil {
		predicates = append(predicates, invocationfiles.SizeBytesLTE(*i.SizeBytesLTE))
	}
	if i.SizeBytesIsNil {
		predicates = append(predicates, invocationfiles.SizeBytesIsNil())
	}
	if i.SizeBytesNotNil {
		predicates = append(predicates, invocationfiles.SizeBytesNotNil())
	}
	if i.DigestFunction != nil {
		predicates = append(predicates, invocationfiles.DigestFunctionEQ(*i.DigestFunction))
	}
	if i.DigestFunctionNEQ != nil {
		predicates = append(predicates, invocationfiles.DigestFunctionNEQ(*i.DigestFunctionNEQ))
	}
	if len(i.DigestFunctionIn) > 0 {
		predicates = append(predicates, invocationfiles.DigestFunctionIn(i.DigestFunctionIn...))
	}
	if len(i.DigestFunctionNotIn) > 0 {
		predicates = append(predicates, invocationfiles.DigestFunctionNotIn(i.DigestFunctionNotIn...))
	}
	if i.DigestFunctionGT != nil {
		predicates = append(predicates, invocationfiles.DigestFunctionGT(*i.DigestFunctionGT))
	}
	if i.DigestFunctionGTE != nil {
		predicates = append(predicates, invocationfiles.DigestFunctionGTE(*i.DigestFunctionGTE))
	}
	if i.DigestFunctionLT != nil {
		predicates = append(predicates, invocationfiles.DigestFunctionLT(*i.DigestFunctionLT))
	}
	if i.DigestFunctionLTE != nil {
		predicates = append(predicates, invocationfiles.DigestFunctionLTE(*i.DigestFunctionLTE))
	}
	if i.DigestFunctionContains != nil {
		predicates = append(predicates, invocationfiles.DigestFunctionContains(*i.DigestFunctionContains))
	}
	if i.DigestFunctionHasPrefix != nil {
		predicates = append(predicates, invocationfiles.DigestFunctionHasPrefix(*i.DigestFunctionHasPrefix))
	}
	if i.DigestFunctionHasSuffix != nil {
		predicates = append(predicates, invocationfiles.DigestFunctionHasSuffix(*i.DigestFunctionHasSuffix))
	}
	if i.DigestFunctionIsNil {
		predicates = append(predicates, invocationfiles.DigestFunctionIsNil())
	}
	if i.DigestFunctionNotNil {
		predicates = append(predicates, invocationfiles.DigestFunctionNotNil())
	}
	if i.DigestFunctionEqualFold != nil {
		predicates = append(predicates, invocationfiles.DigestFunctionEqualFold(*i.DigestFunctionEqualFold))
	}
	if i.DigestFunctionContainsFold != nil {
		predicates = append(predicates, invocationfiles.DigestFunctionContainsFold(*i.DigestFunctionContainsFold))
	}

	if i.HasBazelInvocation != nil {
		p := invocationfiles.HasBazelInvocation()
		if !*i.HasBazelInvocation {
			p = invocationfiles.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBazelInvocationWith) > 0 {
		with := make([]predicate.BazelInvocation, 0, len(i.HasBazelInvocationWith))
		for _, w := range i.HasBazelInvocationWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBazelInvocationWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, invocationfiles.HasBazelInvocationWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyInvocationFilesWhereInput
	case 1:
		return predicates[0], nil
	default:
		return invocationfiles.And(predicates...), nil
	}
}

// InvocationTargetWhereInput represents a where input for filtering InvocationTarget queries.
type InvocationTargetWhereInput struct {
	Predicates []predicate.InvocationTarget  `json:"-"`
	Not        *InvocationTargetWhereInput   `json:"not,omitempty"`
	Or         []*InvocationTargetWhereInput `json:"or,omitempty"`
	And        []*InvocationTargetWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int64  `json:"id,omitempty"`
	IDNEQ   *int64  `json:"idNEQ,omitempty"`
	IDIn    []int64 `json:"idIn,omitempty"`
	IDNotIn []int64 `json:"idNotIn,omitempty"`
	IDGT    *int64  `json:"idGT,omitempty"`
	IDGTE   *int64  `json:"idGTE,omitempty"`
	IDLT    *int64  `json:"idLT,omitempty"`
	IDLTE   *int64  `json:"idLTE,omitempty"`

	// "success" field predicates.
	Success    *bool `json:"success,omitempty"`
	SuccessNEQ *bool `json:"successNEQ,omitempty"`

	// "start_time_in_ms" field predicates.
	StartTimeInMs       *int64  `json:"startTimeInMs,omitempty"`
	StartTimeInMsNEQ    *int64  `json:"startTimeInMsNEQ,omitempty"`
	StartTimeInMsIn     []int64 `json:"startTimeInMsIn,omitempty"`
	StartTimeInMsNotIn  []int64 `json:"startTimeInMsNotIn,omitempty"`
	StartTimeInMsGT     *int64  `json:"startTimeInMsGT,omitempty"`
	StartTimeInMsGTE    *int64  `json:"startTimeInMsGTE,omitempty"`
	StartTimeInMsLT     *int64  `json:"startTimeInMsLT,omitempty"`
	StartTimeInMsLTE    *int64  `json:"startTimeInMsLTE,omitempty"`
	StartTimeInMsIsNil  bool    `json:"startTimeInMsIsNil,omitempty"`
	StartTimeInMsNotNil bool    `json:"startTimeInMsNotNil,omitempty"`

	// "end_time_in_ms" field predicates.
	EndTimeInMs       *int64  `json:"endTimeInMs,omitempty"`
	EndTimeInMsNEQ    *int64  `json:"endTimeInMsNEQ,omitempty"`
	EndTimeInMsIn     []int64 `json:"endTimeInMsIn,omitempty"`
	EndTimeInMsNotIn  []int64 `json:"endTimeInMsNotIn,omitempty"`
	EndTimeInMsGT     *int64  `json:"endTimeInMsGT,omitempty"`
	EndTimeInMsGTE    *int64  `json:"endTimeInMsGTE,omitempty"`
	EndTimeInMsLT     *int64  `json:"endTimeInMsLT,omitempty"`
	EndTimeInMsLTE    *int64  `json:"endTimeInMsLTE,omitempty"`
	EndTimeInMsIsNil  bool    `json:"endTimeInMsIsNil,omitempty"`
	EndTimeInMsNotNil bool    `json:"endTimeInMsNotNil,omitempty"`

	// "duration_in_ms" field predicates.
	DurationInMs       *int64  `json:"durationInMs,omitempty"`
	DurationInMsNEQ    *int64  `json:"durationInMsNEQ,omitempty"`
	DurationInMsIn     []int64 `json:"durationInMsIn,omitempty"`
	DurationInMsNotIn  []int64 `json:"durationInMsNotIn,omitempty"`
	DurationInMsGT     *int64  `json:"durationInMsGT,omitempty"`
	DurationInMsGTE    *int64  `json:"durationInMsGTE,omitempty"`
	DurationInMsLT     *int64  `json:"durationInMsLT,omitempty"`
	DurationInMsLTE    *int64  `json:"durationInMsLTE,omitempty"`
	DurationInMsIsNil  bool    `json:"durationInMsIsNil,omitempty"`
	DurationInMsNotNil bool    `json:"durationInMsNotNil,omitempty"`

	// "failure_message" field predicates.
	FailureMessage             *string  `json:"failureMessage,omitempty"`
	FailureMessageNEQ          *string  `json:"failureMessageNEQ,omitempty"`
	FailureMessageIn           []string `json:"failureMessageIn,omitempty"`
	FailureMessageNotIn        []string `json:"failureMessageNotIn,omitempty"`
	FailureMessageGT           *string  `json:"failureMessageGT,omitempty"`
	FailureMessageGTE          *string  `json:"failureMessageGTE,omitempty"`
	FailureMessageLT           *string  `json:"failureMessageLT,omitempty"`
	FailureMessageLTE          *string  `json:"failureMessageLTE,omitempty"`
	FailureMessageContains     *string  `json:"failureMessageContains,omitempty"`
	FailureMessageHasPrefix    *string  `json:"failureMessageHasPrefix,omitempty"`
	FailureMessageHasSuffix    *string  `json:"failureMessageHasSuffix,omitempty"`
	FailureMessageIsNil        bool     `json:"failureMessageIsNil,omitempty"`
	FailureMessageNotNil       bool     `json:"failureMessageNotNil,omitempty"`
	FailureMessageEqualFold    *string  `json:"failureMessageEqualFold,omitempty"`
	FailureMessageContainsFold *string  `json:"failureMessageContainsFold,omitempty"`

	// "abort_reason" field predicates.
	AbortReason      *invocationtarget.AbortReason  `json:"abortReason,omitempty"`
	AbortReasonNEQ   *invocationtarget.AbortReason  `json:"abortReasonNEQ,omitempty"`
	AbortReasonIn    []invocationtarget.AbortReason `json:"abortReasonIn,omitempty"`
	AbortReasonNotIn []invocationtarget.AbortReason `json:"abortReasonNotIn,omitempty"`

	// "bazel_invocation" edge predicates.
	HasBazelInvocation     *bool                        `json:"hasBazelInvocation,omitempty"`
	HasBazelInvocationWith []*BazelInvocationWhereInput `json:"hasBazelInvocationWith,omitempty"`

	// "target" edge predicates.
	HasTarget     *bool               `json:"hasTarget,omitempty"`
	HasTargetWith []*TargetWhereInput `json:"hasTargetWith,omitempty"`

	// "configuration" edge predicates.
	HasConfiguration     *bool                      `json:"hasConfiguration,omitempty"`
	HasConfigurationWith []*ConfigurationWhereInput `json:"hasConfigurationWith,omitempty"`

	// "test_summary" edge predicates.
	HasTestSummary     *bool                    `json:"hasTestSummary,omitempty"`
	HasTestSummaryWith []*TestSummaryWhereInput `json:"hasTestSummaryWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *InvocationTargetWhereInput) AddPredicates(predicates ...predicate.InvocationTarget) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the InvocationTargetWhereInput filter on the InvocationTargetQuery builder.
func (i *InvocationTargetWhereInput) Filter(q *InvocationTargetQuery) (*InvocationTargetQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyInvocationTargetWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyInvocationTargetWhereInput is returned in case the InvocationTargetWhereInput is empty.
var ErrEmptyInvocationTargetWhereInput = errors.New("ent: empty predicate InvocationTargetWhereInput")

// P returns a predicate for filtering invocationtargets.
// An error is returned if the input is empty or invalid.
func (i *InvocationTargetWhereInput) P() (predicate.InvocationTarget, error) {
	var predicates []predicate.InvocationTarget
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, invocationtarget.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.InvocationTarget, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, invocationtarget.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.InvocationTarget, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, invocationtarget.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, invocationtarget.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, invocationtarget.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, invocationtarget.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, invocationtarget.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, invocationtarget.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, invocationtarget.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, invocationtarget.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, invocationtarget.IDLTE(*i.IDLTE))
	}
	if i.Success != nil {
		predicates = append(predicates, invocationtarget.SuccessEQ(*i.Success))
	}
	if i.SuccessNEQ != nil {
		predicates = append(predicates, invocationtarget.SuccessNEQ(*i.SuccessNEQ))
	}
	if i.StartTimeInMs != nil {
		predicates = append(predicates, invocationtarget.StartTimeInMsEQ(*i.StartTimeInMs))
	}
	if i.StartTimeInMsNEQ != nil {
		predicates = append(predicates, invocationtarget.StartTimeInMsNEQ(*i.StartTimeInMsNEQ))
	}
	if len(i.StartTimeInMsIn) > 0 {
		predicates = append(predicates, invocationtarget.StartTimeInMsIn(i.StartTimeInMsIn...))
	}
	if len(i.StartTimeInMsNotIn) > 0 {
		predicates = append(predicates, invocationtarget.StartTimeInMsNotIn(i.StartTimeInMsNotIn...))
	}
	if i.StartTimeInMsGT != nil {
		predicates = append(predicates, invocationtarget.StartTimeInMsGT(*i.StartTimeInMsGT))
	}
	if i.StartTimeInMsGTE != nil {
		predicates = append(predicates, invocationtarget.StartTimeInMsGTE(*i.StartTimeInMsGTE))
	}
	if i.StartTimeInMsLT != nil {
		predicates = append(predicates, invocationtarget.StartTimeInMsLT(*i.StartTimeInMsLT))
	}
	if i.StartTimeInMsLTE != nil {
		predicates = append(predicates, invocationtarget.StartTimeInMsLTE(*i.StartTimeInMsLTE))
	}
	if i.StartTimeInMsIsNil {
		predicates = append(predicates, invocationtarget.StartTimeInMsIsNil())
	}
	if i.StartTimeInMsNotNil {
		predicates = append(predicates, invocationtarget.StartTimeInMsNotNil())
	}
	if i.EndTimeInMs != nil {
		predicates = append(predicates, invocationtarget.EndTimeInMsEQ(*i.EndTimeInMs))
	}
	if i.EndTimeInMsNEQ != nil {
		predicates = append(predicates, invocationtarget.EndTimeInMsNEQ(*i.EndTimeInMsNEQ))
	}
	if len(i.EndTimeInMsIn) > 0 {
		predicates = append(predicates, invocationtarget.EndTimeInMsIn(i.EndTimeInMsIn...))
	}
	if len(i.EndTimeInMsNotIn) > 0 {
		predicates = append(predicates, invocationtarget.EndTimeInMsNotIn(i.EndTimeInMsNotIn...))
	}
	if i.EndTimeInMsGT != nil {
		predicates = append(predicates, invocationtarget.EndTimeInMsGT(*i.EndTimeInMsGT))
	}
	if i.EndTimeInMsGTE != nil {
		predicates = append(predicates, invocationtarget.EndTimeInMsGTE(*i.EndTimeInMsGTE))
	}
	if i.EndTimeInMsLT != nil {
		predicates = append(predicates, invocationtarget.EndTimeInMsLT(*i.EndTimeInMsLT))
	}
	if i.EndTimeInMsLTE != nil {
		predicates = append(predicates, invocationtarget.EndTimeInMsLTE(*i.EndTimeInMsLTE))
	}
	if i.EndTimeInMsIsNil {
		predicates = append(predicates, invocationtarget.EndTimeInMsIsNil())
	}
	if i.EndTimeInMsNotNil {
		predicates = append(predicates, invocationtarget.EndTimeInMsNotNil())
	}
	if i.DurationInMs != nil {
		predicates = append(predicates, invocationtarget.DurationInMsEQ(*i.DurationInMs))
	}
	if i.DurationInMsNEQ != nil {
		predicates = append(predicates, invocationtarget.DurationInMsNEQ(*i.DurationInMsNEQ))
	}
	if len(i.DurationInMsIn) > 0 {
		predicates = append(predicates, invocationtarget.DurationInMsIn(i.DurationInMsIn...))
	}
	if len(i.DurationInMsNotIn) > 0 {
		predicates = append(predicates, invocationtarget.DurationInMsNotIn(i.DurationInMsNotIn...))
	}
	if i.DurationInMsGT != nil {
		predicates = append(predicates, invocationtarget.DurationInMsGT(*i.DurationInMsGT))
	}
	if i.DurationInMsGTE != nil {
		predicates = append(predicates, invocationtarget.DurationInMsGTE(*i.DurationInMsGTE))
	}
	if i.DurationInMsLT != nil {
		predicates = append(predicates, invocationtarget.DurationInMsLT(*i.DurationInMsLT))
	}
	if i.DurationInMsLTE != nil {
		predicates = append(predicates, invocationtarget.DurationInMsLTE(*i.DurationInMsLTE))
	}
	if i.DurationInMsIsNil {
		predicates = append(predicates, invocationtarget.DurationInMsIsNil())
	}
	if i.DurationInMsNotNil {
		predicates = append(predicates, invocationtarget.DurationInMsNotNil())
	}
	if i.FailureMessage != nil {
		predicates = append(predicates, invocationtarget.FailureMessageEQ(*i.FailureMessage))
	}
	if i.FailureMessageNEQ != nil {
		predicates = append(predicates, invocationtarget.FailureMessageNEQ(*i.FailureMessageNEQ))
	}
	if len(i.FailureMessageIn) > 0 {
		predicates = append(predicates, invocationtarget.FailureMessageIn(i.FailureMessageIn...))
	}
	if len(i.FailureMessageNotIn) > 0 {
		predicates = append(predicates, invocationtarget.FailureMessageNotIn(i.FailureMessageNotIn...))
	}
	if i.FailureMessageGT != nil {
		predicates = append(predicates, invocationtarget.FailureMessageGT(*i.FailureMessageGT))
	}
	if i.FailureMessageGTE != nil {
		predicates = append(predicates, invocationtarget.FailureMessageGTE(*i.FailureMessageGTE))
	}
	if i.FailureMessageLT != nil {
		predicates = append(predicates, invocationtarget.FailureMessageLT(*i.FailureMessageLT))
	}
	if i.FailureMessageLTE != nil {
		predicates = append(predicates, invocationtarget.FailureMessageLTE(*i.FailureMessageLTE))
	}
	if i.FailureMessageContains != nil {
		predicates = append(predicates, invocationtarget.FailureMessageContains(*i.FailureMessageContains))
	}
	if i.FailureMessageHasPrefix != nil {
		predicates = append(predicates, invocationtarget.FailureMessageHasPrefix(*i.FailureMessageHasPrefix))
	}
	if i.FailureMessageHasSuffix != nil {
		predicates = append(predicates, invocationtarget.FailureMessageHasSuffix(*i.FailureMessageHasSuffix))
	}
	if i.FailureMessageIsNil {
		predicates = append(predicates, invocationtarget.FailureMessageIsNil())
	}
	if i.FailureMessageNotNil {
		predicates = append(predicates, invocationtarget.FailureMessageNotNil())
	}
	if i.FailureMessageEqualFold != nil {
		predicates = append(predicates, invocationtarget.FailureMessageEqualFold(*i.FailureMessageEqualFold))
	}
	if i.FailureMessageContainsFold != nil {
		predicates = append(predicates, invocationtarget.FailureMessageContainsFold(*i.FailureMessageContainsFold))
	}
	if i.AbortReason != nil {
		predicates = append(predicates, invocationtarget.AbortReasonEQ(*i.AbortReason))
	}
	if i.AbortReasonNEQ != nil {
		predicates = append(predicates, invocationtarget.AbortReasonNEQ(*i.AbortReasonNEQ))
	}
	if len(i.AbortReasonIn) > 0 {
		predicates = append(predicates, invocationtarget.AbortReasonIn(i.AbortReasonIn...))
	}
	if len(i.AbortReasonNotIn) > 0 {
		predicates = append(predicates, invocationtarget.AbortReasonNotIn(i.AbortReasonNotIn...))
	}

	if i.HasBazelInvocation != nil {
		p := invocationtarget.HasBazelInvocation()
		if !*i.HasBazelInvocation {
			p = invocationtarget.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBazelInvocationWith) > 0 {
		with := make([]predicate.BazelInvocation, 0, len(i.HasBazelInvocationWith))
		for _, w := range i.HasBazelInvocationWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBazelInvocationWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, invocationtarget.HasBazelInvocationWith(with...))
	}
	if i.HasTarget != nil {
		p := invocationtarget.HasTarget()
		if !*i.HasTarget {
			p = invocationtarget.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTargetWith) > 0 {
		with := make([]predicate.Target, 0, len(i.HasTargetWith))
		for _, w := range i.HasTargetWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTargetWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, invocationtarget.HasTargetWith(with...))
	}
	if i.HasConfiguration != nil {
		p := invocationtarget.HasConfiguration()
		if !*i.HasConfiguration {
			p = invocationtarget.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasConfigurationWith) > 0 {
		with := make([]predicate.Configuration, 0, len(i.HasConfigurationWith))
		for _, w := range i.HasConfigurationWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasConfigurationWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, invocationtarget.HasConfigurationWith(with...))
	}
	if i.HasTestSummary != nil {
		p := invocationtarget.HasTestSummary()
		if !*i.HasTestSummary {
			p = invocationtarget.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTestSummaryWith) > 0 {
		with := make([]predicate.TestSummary, 0, len(i.HasTestSummaryWith))
		for _, w := range i.HasTestSummaryWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTestSummaryWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, invocationtarget.HasTestSummaryWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyInvocationTargetWhereInput
	case 1:
		return predicates[0], nil
	default:
		return invocationtarget.And(predicates...), nil
	}
}

// MemoryMetricsWhereInput represents a where input for filtering MemoryMetrics queries.
type MemoryMetricsWhereInput struct {
	Predicates []predicate.MemoryMetrics  `json:"-"`
	Not        *MemoryMetricsWhereInput   `json:"not,omitempty"`
	Or         []*MemoryMetricsWhereInput `json:"or,omitempty"`
	And        []*MemoryMetricsWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int64  `json:"id,omitempty"`
	IDNEQ   *int64  `json:"idNEQ,omitempty"`
	IDIn    []int64 `json:"idIn,omitempty"`
	IDNotIn []int64 `json:"idNotIn,omitempty"`
	IDGT    *int64  `json:"idGT,omitempty"`
	IDGTE   *int64  `json:"idGTE,omitempty"`
	IDLT    *int64  `json:"idLT,omitempty"`
	IDLTE   *int64  `json:"idLTE,omitempty"`

	// "peak_post_gc_heap_size" field predicates.
	PeakPostGcHeapSize       *int64  `json:"peakPostGcHeapSize,omitempty"`
	PeakPostGcHeapSizeNEQ    *int64  `json:"peakPostGcHeapSizeNEQ,omitempty"`
	PeakPostGcHeapSizeIn     []int64 `json:"peakPostGcHeapSizeIn,omitempty"`
	PeakPostGcHeapSizeNotIn  []int64 `json:"peakPostGcHeapSizeNotIn,omitempty"`
	PeakPostGcHeapSizeGT     *int64  `json:"peakPostGcHeapSizeGT,omitempty"`
	PeakPostGcHeapSizeGTE    *int64  `json:"peakPostGcHeapSizeGTE,omitempty"`
	PeakPostGcHeapSizeLT     *int64  `json:"peakPostGcHeapSizeLT,omitempty"`
	PeakPostGcHeapSizeLTE    *int64  `json:"peakPostGcHeapSizeLTE,omitempty"`
	PeakPostGcHeapSizeIsNil  bool    `json:"peakPostGcHeapSizeIsNil,omitempty"`
	PeakPostGcHeapSizeNotNil bool    `json:"peakPostGcHeapSizeNotNil,omitempty"`

	// "used_heap_size_post_build" field predicates.
	UsedHeapSizePostBuild       *int64  `json:"usedHeapSizePostBuild,omitempty"`
	UsedHeapSizePostBuildNEQ    *int64  `json:"usedHeapSizePostBuildNEQ,omitempty"`
	UsedHeapSizePostBuildIn     []int64 `json:"usedHeapSizePostBuildIn,omitempty"`
	UsedHeapSizePostBuildNotIn  []int64 `json:"usedHeapSizePostBuildNotIn,omitempty"`
	UsedHeapSizePostBuildGT     *int64  `json:"usedHeapSizePostBuildGT,omitempty"`
	UsedHeapSizePostBuildGTE    *int64  `json:"usedHeapSizePostBuildGTE,omitempty"`
	UsedHeapSizePostBuildLT     *int64  `json:"usedHeapSizePostBuildLT,omitempty"`
	UsedHeapSizePostBuildLTE    *int64  `json:"usedHeapSizePostBuildLTE,omitempty"`
	UsedHeapSizePostBuildIsNil  bool    `json:"usedHeapSizePostBuildIsNil,omitempty"`
	UsedHeapSizePostBuildNotNil bool    `json:"usedHeapSizePostBuildNotNil,omitempty"`

	// "peak_post_gc_tenured_space_heap_size" field predicates.
	PeakPostGcTenuredSpaceHeapSize       *int64  `json:"peakPostGcTenuredSpaceHeapSize,omitempty"`
	PeakPostGcTenuredSpaceHeapSizeNEQ    *int64  `json:"peakPostGcTenuredSpaceHeapSizeNEQ,omitempty"`
	PeakPostGcTenuredSpaceHeapSizeIn     []int64 `json:"peakPostGcTenuredSpaceHeapSizeIn,omitempty"`
	PeakPostGcTenuredSpaceHeapSizeNotIn  []int64 `json:"peakPostGcTenuredSpaceHeapSizeNotIn,omitempty"`
	PeakPostGcTenuredSpaceHeapSizeGT     *int64  `json:"peakPostGcTenuredSpaceHeapSizeGT,omitempty"`
	PeakPostGcTenuredSpaceHeapSizeGTE    *int64  `json:"peakPostGcTenuredSpaceHeapSizeGTE,omitempty"`
	PeakPostGcTenuredSpaceHeapSizeLT     *int64  `json:"peakPostGcTenuredSpaceHeapSizeLT,omitempty"`
	PeakPostGcTenuredSpaceHeapSizeLTE    *int64  `json:"peakPostGcTenuredSpaceHeapSizeLTE,omitempty"`
	PeakPostGcTenuredSpaceHeapSizeIsNil  bool    `json:"peakPostGcTenuredSpaceHeapSizeIsNil,omitempty"`
	PeakPostGcTenuredSpaceHeapSizeNotNil bool    `json:"peakPostGcTenuredSpaceHeapSizeNotNil,omitempty"`

	// "metrics" edge predicates.
	HasMetrics     *bool                `json:"hasMetrics,omitempty"`
	HasMetricsWith []*MetricsWhereInput `json:"hasMetricsWith,omitempty"`

	// "garbage_metrics" edge predicates.
	HasGarbageMetrics     *bool                       `json:"hasGarbageMetrics,omitempty"`
	HasGarbageMetricsWith []*GarbageMetricsWhereInput `json:"hasGarbageMetricsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *MemoryMetricsWhereInput) AddPredicates(predicates ...predicate.MemoryMetrics) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the MemoryMetricsWhereInput filter on the MemoryMetricsQuery builder.
func (i *MemoryMetricsWhereInput) Filter(q *MemoryMetricsQuery) (*MemoryMetricsQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyMemoryMetricsWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyMemoryMetricsWhereInput is returned in case the MemoryMetricsWhereInput is empty.
var ErrEmptyMemoryMetricsWhereInput = errors.New("ent: empty predicate MemoryMetricsWhereInput")

// P returns a predicate for filtering memorymetricsslice.
// An error is returned if the input is empty or invalid.
func (i *MemoryMetricsWhereInput) P() (predicate.MemoryMetrics, error) {
	var predicates []predicate.MemoryMetrics
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, memorymetrics.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.MemoryMetrics, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, memorymetrics.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.MemoryMetrics, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, memorymetrics.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, memorymetrics.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, memorymetrics.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, memorymetrics.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, memorymetrics.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, memorymetrics.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, memorymetrics.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, memorymetrics.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, memorymetrics.IDLTE(*i.IDLTE))
	}
	if i.PeakPostGcHeapSize != nil {
		predicates = append(predicates, memorymetrics.PeakPostGcHeapSizeEQ(*i.PeakPostGcHeapSize))
	}
	if i.PeakPostGcHeapSizeNEQ != nil {
		predicates = append(predicates, memorymetrics.PeakPostGcHeapSizeNEQ(*i.PeakPostGcHeapSizeNEQ))
	}
	if len(i.PeakPostGcHeapSizeIn) > 0 {
		predicates = append(predicates, memorymetrics.PeakPostGcHeapSizeIn(i.PeakPostGcHeapSizeIn...))
	}
	if len(i.PeakPostGcHeapSizeNotIn) > 0 {
		predicates = append(predicates, memorymetrics.PeakPostGcHeapSizeNotIn(i.PeakPostGcHeapSizeNotIn...))
	}
	if i.PeakPostGcHeapSizeGT != nil {
		predicates = append(predicates, memorymetrics.PeakPostGcHeapSizeGT(*i.PeakPostGcHeapSizeGT))
	}
	if i.PeakPostGcHeapSizeGTE != nil {
		predicates = append(predicates, memorymetrics.PeakPostGcHeapSizeGTE(*i.PeakPostGcHeapSizeGTE))
	}
	if i.PeakPostGcHeapSizeLT != nil {
		predicates = append(predicates, memorymetrics.PeakPostGcHeapSizeLT(*i.PeakPostGcHeapSizeLT))
	}
	if i.PeakPostGcHeapSizeLTE != nil {
		predicates = append(predicates, memorymetrics.PeakPostGcHeapSizeLTE(*i.PeakPostGcHeapSizeLTE))
	}
	if i.PeakPostGcHeapSizeIsNil {
		predicates = append(predicates, memorymetrics.PeakPostGcHeapSizeIsNil())
	}
	if i.PeakPostGcHeapSizeNotNil {
		predicates = append(predicates, memorymetrics.PeakPostGcHeapSizeNotNil())
	}
	if i.UsedHeapSizePostBuild != nil {
		predicates = append(predicates, memorymetrics.UsedHeapSizePostBuildEQ(*i.UsedHeapSizePostBuild))
	}
	if i.UsedHeapSizePostBuildNEQ != nil {
		predicates = append(predicates, memorymetrics.UsedHeapSizePostBuildNEQ(*i.UsedHeapSizePostBuildNEQ))
	}
	if len(i.UsedHeapSizePostBuildIn) > 0 {
		predicates = append(predicates, memorymetrics.UsedHeapSizePostBuildIn(i.UsedHeapSizePostBuildIn...))
	}
	if len(i.UsedHeapSizePostBuildNotIn) > 0 {
		predicates = append(predicates, memorymetrics.UsedHeapSizePostBuildNotIn(i.UsedHeapSizePostBuildNotIn...))
	}
	if i.UsedHeapSizePostBuildGT != nil {
		predicates = append(predicates, memorymetrics.UsedHeapSizePostBuildGT(*i.UsedHeapSizePostBuildGT))
	}
	if i.UsedHeapSizePostBuildGTE != nil {
		predicates = append(predicates, memorymetrics.UsedHeapSizePostBuildGTE(*i.UsedHeapSizePostBuildGTE))
	}
	if i.UsedHeapSizePostBuildLT != nil {
		predicates = append(predicates, memorymetrics.UsedHeapSizePostBuildLT(*i.UsedHeapSizePostBuildLT))
	}
	if i.UsedHeapSizePostBuildLTE != nil {
		predicates = append(predicates, memorymetrics.UsedHeapSizePostBuildLTE(*i.UsedHeapSizePostBuildLTE))
	}
	if i.UsedHeapSizePostBuildIsNil {
		predicates = append(predicates, memorymetrics.UsedHeapSizePostBuildIsNil())
	}
	if i.UsedHeapSizePostBuildNotNil {
		predicates = append(predicates, memorymetrics.UsedHeapSizePostBuildNotNil())
	}
	if i.PeakPostGcTenuredSpaceHeapSize != nil {
		predicates = append(predicates, memorymetrics.PeakPostGcTenuredSpaceHeapSizeEQ(*i.PeakPostGcTenuredSpaceHeapSize))
	}
	if i.PeakPostGcTenuredSpaceHeapSizeNEQ != nil {
		predicates = append(predicates, memorymetrics.PeakPostGcTenuredSpaceHeapSizeNEQ(*i.PeakPostGcTenuredSpaceHeapSizeNEQ))
	}
	if len(i.PeakPostGcTenuredSpaceHeapSizeIn) > 0 {
		predicates = append(predicates, memorymetrics.PeakPostGcTenuredSpaceHeapSizeIn(i.PeakPostGcTenuredSpaceHeapSizeIn...))
	}
	if len(i.PeakPostGcTenuredSpaceHeapSizeNotIn) > 0 {
		predicates = append(predicates, memorymetrics.PeakPostGcTenuredSpaceHeapSizeNotIn(i.PeakPostGcTenuredSpaceHeapSizeNotIn...))
	}
	if i.PeakPostGcTenuredSpaceHeapSizeGT != nil {
		predicates = append(predicates, memorymetrics.PeakPostGcTenuredSpaceHeapSizeGT(*i.PeakPostGcTenuredSpaceHeapSizeGT))
	}
	if i.PeakPostGcTenuredSpaceHeapSizeGTE != nil {
		predicates = append(predicates, memorymetrics.PeakPostGcTenuredSpaceHeapSizeGTE(*i.PeakPostGcTenuredSpaceHeapSizeGTE))
	}
	if i.PeakPostGcTenuredSpaceHeapSizeLT != nil {
		predicates = append(predicates, memorymetrics.PeakPostGcTenuredSpaceHeapSizeLT(*i.PeakPostGcTenuredSpaceHeapSizeLT))
	}
	if i.PeakPostGcTenuredSpaceHeapSizeLTE != nil {
		predicates = append(predicates, memorymetrics.PeakPostGcTenuredSpaceHeapSizeLTE(*i.PeakPostGcTenuredSpaceHeapSizeLTE))
	}
	if i.PeakPostGcTenuredSpaceHeapSizeIsNil {
		predicates = append(predicates, memorymetrics.PeakPostGcTenuredSpaceHeapSizeIsNil())
	}
	if i.PeakPostGcTenuredSpaceHeapSizeNotNil {
		predicates = append(predicates, memorymetrics.PeakPostGcTenuredSpaceHeapSizeNotNil())
	}

	if i.HasMetrics != nil {
		p := memorymetrics.HasMetrics()
		if !*i.HasMetrics {
			p = memorymetrics.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMetricsWith) > 0 {
		with := make([]predicate.Metrics, 0, len(i.HasMetricsWith))
		for _, w := range i.HasMetricsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMetricsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, memorymetrics.HasMetricsWith(with...))
	}
	if i.HasGarbageMetrics != nil {
		p := memorymetrics.HasGarbageMetrics()
		if !*i.HasGarbageMetrics {
			p = memorymetrics.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasGarbageMetricsWith) > 0 {
		with := make([]predicate.GarbageMetrics, 0, len(i.HasGarbageMetricsWith))
		for _, w := range i.HasGarbageMetricsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasGarbageMetricsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, memorymetrics.HasGarbageMetricsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyMemoryMetricsWhereInput
	case 1:
		return predicates[0], nil
	default:
		return memorymetrics.And(predicates...), nil
	}
}

// MetricsWhereInput represents a where input for filtering Metrics queries.
type MetricsWhereInput struct {
	Predicates []predicate.Metrics  `json:"-"`
	Not        *MetricsWhereInput   `json:"not,omitempty"`
	Or         []*MetricsWhereInput `json:"or,omitempty"`
	And        []*MetricsWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int64  `json:"id,omitempty"`
	IDNEQ   *int64  `json:"idNEQ,omitempty"`
	IDIn    []int64 `json:"idIn,omitempty"`
	IDNotIn []int64 `json:"idNotIn,omitempty"`
	IDGT    *int64  `json:"idGT,omitempty"`
	IDGTE   *int64  `json:"idGTE,omitempty"`
	IDLT    *int64  `json:"idLT,omitempty"`
	IDLTE   *int64  `json:"idLTE,omitempty"`

	// "bazel_invocation" edge predicates.
	HasBazelInvocation     *bool                        `json:"hasBazelInvocation,omitempty"`
	HasBazelInvocationWith []*BazelInvocationWhereInput `json:"hasBazelInvocationWith,omitempty"`

	// "action_summary" edge predicates.
	HasActionSummary     *bool                      `json:"hasActionSummary,omitempty"`
	HasActionSummaryWith []*ActionSummaryWhereInput `json:"hasActionSummaryWith,omitempty"`

	// "memory_metrics" edge predicates.
	HasMemoryMetrics     *bool                      `json:"hasMemoryMetrics,omitempty"`
	HasMemoryMetricsWith []*MemoryMetricsWhereInput `json:"hasMemoryMetricsWith,omitempty"`

	// "target_metrics" edge predicates.
	HasTargetMetrics     *bool                      `json:"hasTargetMetrics,omitempty"`
	HasTargetMetricsWith []*TargetMetricsWhereInput `json:"hasTargetMetricsWith,omitempty"`

	// "package_metrics" edge predicates.
	HasPackageMetrics     *bool                       `json:"hasPackageMetrics,omitempty"`
	HasPackageMetricsWith []*PackageMetricsWhereInput `json:"hasPackageMetricsWith,omitempty"`

	// "timing_metrics" edge predicates.
	HasTimingMetrics     *bool                      `json:"hasTimingMetrics,omitempty"`
	HasTimingMetricsWith []*TimingMetricsWhereInput `json:"hasTimingMetricsWith,omitempty"`

	// "cumulative_metrics" edge predicates.
	HasCumulativeMetrics     *bool                          `json:"hasCumulativeMetrics,omitempty"`
	HasCumulativeMetricsWith []*CumulativeMetricsWhereInput `json:"hasCumulativeMetricsWith,omitempty"`

	// "artifact_metrics" edge predicates.
	HasArtifactMetrics     *bool                        `json:"hasArtifactMetrics,omitempty"`
	HasArtifactMetricsWith []*ArtifactMetricsWhereInput `json:"hasArtifactMetricsWith,omitempty"`

	// "network_metrics" edge predicates.
	HasNetworkMetrics     *bool                       `json:"hasNetworkMetrics,omitempty"`
	HasNetworkMetricsWith []*NetworkMetricsWhereInput `json:"hasNetworkMetricsWith,omitempty"`

	// "build_graph_metrics" edge predicates.
	HasBuildGraphMetrics     *bool                          `json:"hasBuildGraphMetrics,omitempty"`
	HasBuildGraphMetricsWith []*BuildGraphMetricsWhereInput `json:"hasBuildGraphMetricsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *MetricsWhereInput) AddPredicates(predicates ...predicate.Metrics) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the MetricsWhereInput filter on the MetricsQuery builder.
func (i *MetricsWhereInput) Filter(q *MetricsQuery) (*MetricsQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyMetricsWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyMetricsWhereInput is returned in case the MetricsWhereInput is empty.
var ErrEmptyMetricsWhereInput = errors.New("ent: empty predicate MetricsWhereInput")

// P returns a predicate for filtering metricsslice.
// An error is returned if the input is empty or invalid.
func (i *MetricsWhereInput) P() (predicate.Metrics, error) {
	var predicates []predicate.Metrics
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, metrics.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Metrics, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, metrics.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Metrics, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, metrics.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, metrics.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, metrics.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, metrics.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, metrics.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, metrics.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, metrics.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, metrics.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, metrics.IDLTE(*i.IDLTE))
	}

	if i.HasBazelInvocation != nil {
		p := metrics.HasBazelInvocation()
		if !*i.HasBazelInvocation {
			p = metrics.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBazelInvocationWith) > 0 {
		with := make([]predicate.BazelInvocation, 0, len(i.HasBazelInvocationWith))
		for _, w := range i.HasBazelInvocationWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBazelInvocationWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, metrics.HasBazelInvocationWith(with...))
	}
	if i.HasActionSummary != nil {
		p := metrics.HasActionSummary()
		if !*i.HasActionSummary {
			p = metrics.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasActionSummaryWith) > 0 {
		with := make([]predicate.ActionSummary, 0, len(i.HasActionSummaryWith))
		for _, w := range i.HasActionSummaryWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasActionSummaryWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, metrics.HasActionSummaryWith(with...))
	}
	if i.HasMemoryMetrics != nil {
		p := metrics.HasMemoryMetrics()
		if !*i.HasMemoryMetrics {
			p = metrics.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMemoryMetricsWith) > 0 {
		with := make([]predicate.MemoryMetrics, 0, len(i.HasMemoryMetricsWith))
		for _, w := range i.HasMemoryMetricsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMemoryMetricsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, metrics.HasMemoryMetricsWith(with...))
	}
	if i.HasTargetMetrics != nil {
		p := metrics.HasTargetMetrics()
		if !*i.HasTargetMetrics {
			p = metrics.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTargetMetricsWith) > 0 {
		with := make([]predicate.TargetMetrics, 0, len(i.HasTargetMetricsWith))
		for _, w := range i.HasTargetMetricsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTargetMetricsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, metrics.HasTargetMetricsWith(with...))
	}
	if i.HasPackageMetrics != nil {
		p := metrics.HasPackageMetrics()
		if !*i.HasPackageMetrics {
			p = metrics.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPackageMetricsWith) > 0 {
		with := make([]predicate.PackageMetrics, 0, len(i.HasPackageMetricsWith))
		for _, w := range i.HasPackageMetricsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPackageMetricsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, metrics.HasPackageMetricsWith(with...))
	}
	if i.HasTimingMetrics != nil {
		p := metrics.HasTimingMetrics()
		if !*i.HasTimingMetrics {
			p = metrics.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTimingMetricsWith) > 0 {
		with := make([]predicate.TimingMetrics, 0, len(i.HasTimingMetricsWith))
		for _, w := range i.HasTimingMetricsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTimingMetricsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, metrics.HasTimingMetricsWith(with...))
	}
	if i.HasCumulativeMetrics != nil {
		p := metrics.HasCumulativeMetrics()
		if !*i.HasCumulativeMetrics {
			p = metrics.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCumulativeMetricsWith) > 0 {
		with := make([]predicate.CumulativeMetrics, 0, len(i.HasCumulativeMetricsWith))
		for _, w := range i.HasCumulativeMetricsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCumulativeMetricsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, metrics.HasCumulativeMetricsWith(with...))
	}
	if i.HasArtifactMetrics != nil {
		p := metrics.HasArtifactMetrics()
		if !*i.HasArtifactMetrics {
			p = metrics.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasArtifactMetricsWith) > 0 {
		with := make([]predicate.ArtifactMetrics, 0, len(i.HasArtifactMetricsWith))
		for _, w := range i.HasArtifactMetricsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasArtifactMetricsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, metrics.HasArtifactMetricsWith(with...))
	}
	if i.HasNetworkMetrics != nil {
		p := metrics.HasNetworkMetrics()
		if !*i.HasNetworkMetrics {
			p = metrics.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasNetworkMetricsWith) > 0 {
		with := make([]predicate.NetworkMetrics, 0, len(i.HasNetworkMetricsWith))
		for _, w := range i.HasNetworkMetricsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasNetworkMetricsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, metrics.HasNetworkMetricsWith(with...))
	}
	if i.HasBuildGraphMetrics != nil {
		p := metrics.HasBuildGraphMetrics()
		if !*i.HasBuildGraphMetrics {
			p = metrics.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBuildGraphMetricsWith) > 0 {
		with := make([]predicate.BuildGraphMetrics, 0, len(i.HasBuildGraphMetricsWith))
		for _, w := range i.HasBuildGraphMetricsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBuildGraphMetricsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, metrics.HasBuildGraphMetricsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyMetricsWhereInput
	case 1:
		return predicates[0], nil
	default:
		return metrics.And(predicates...), nil
	}
}

// MissDetailWhereInput represents a where input for filtering MissDetail queries.
type MissDetailWhereInput struct {
	Predicates []predicate.MissDetail  `json:"-"`
	Not        *MissDetailWhereInput   `json:"not,omitempty"`
	Or         []*MissDetailWhereInput `json:"or,omitempty"`
	And        []*MissDetailWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int64  `json:"id,omitempty"`
	IDNEQ   *int64  `json:"idNEQ,omitempty"`
	IDIn    []int64 `json:"idIn,omitempty"`
	IDNotIn []int64 `json:"idNotIn,omitempty"`
	IDGT    *int64  `json:"idGT,omitempty"`
	IDGTE   *int64  `json:"idGTE,omitempty"`
	IDLT    *int64  `json:"idLT,omitempty"`
	IDLTE   *int64  `json:"idLTE,omitempty"`

	// "reason" field predicates.
	Reason             *string  `json:"reason,omitempty"`
	ReasonNEQ          *string  `json:"reasonNEQ,omitempty"`
	ReasonIn           []string `json:"reasonIn,omitempty"`
	ReasonNotIn        []string `json:"reasonNotIn,omitempty"`
	ReasonGT           *string  `json:"reasonGT,omitempty"`
	ReasonGTE          *string  `json:"reasonGTE,omitempty"`
	ReasonLT           *string  `json:"reasonLT,omitempty"`
	ReasonLTE          *string  `json:"reasonLTE,omitempty"`
	ReasonContains     *string  `json:"reasonContains,omitempty"`
	ReasonHasPrefix    *string  `json:"reasonHasPrefix,omitempty"`
	ReasonHasSuffix    *string  `json:"reasonHasSuffix,omitempty"`
	ReasonEqualFold    *string  `json:"reasonEqualFold,omitempty"`
	ReasonContainsFold *string  `json:"reasonContainsFold,omitempty"`

	// "count" field predicates.
	Count       *int32  `json:"count,omitempty"`
	CountNEQ    *int32  `json:"countNEQ,omitempty"`
	CountIn     []int32 `json:"countIn,omitempty"`
	CountNotIn  []int32 `json:"countNotIn,omitempty"`
	CountGT     *int32  `json:"countGT,omitempty"`
	CountGTE    *int32  `json:"countGTE,omitempty"`
	CountLT     *int32  `json:"countLT,omitempty"`
	CountLTE    *int32  `json:"countLTE,omitempty"`
	CountIsNil  bool    `json:"countIsNil,omitempty"`
	CountNotNil bool    `json:"countNotNil,omitempty"`

	// "action_cache_statistics" edge predicates.
	HasActionCacheStatistics     *bool                              `json:"hasActionCacheStatistics,omitempty"`
	HasActionCacheStatisticsWith []*ActionCacheStatisticsWhereInput `json:"hasActionCacheStatisticsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *MissDetailWhereInput) AddPredicates(predicates ...predicate.MissDetail) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the MissDetailWhereInput filter on the MissDetailQuery builder.
func (i *MissDetailWhereInput) Filter(q *MissDetailQuery) (*MissDetailQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyMissDetailWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyMissDetailWhereInput is returned in case the MissDetailWhereInput is empty.
var ErrEmptyMissDetailWhereInput = errors.New("ent: empty predicate MissDetailWhereInput")

// P returns a predicate for filtering missdetails.
// An error is returned if the input is empty or invalid.
func (i *MissDetailWhereInput) P() (predicate.MissDetail, error) {
	var predicates []predicate.MissDetail
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, missdetail.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.MissDetail, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, missdetail.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.MissDetail, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, missdetail.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, missdetail.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, missdetail.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, missdetail.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, missdetail.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, missdetail.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, missdetail.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, missdetail.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, missdetail.IDLTE(*i.IDLTE))
	}
	if i.Reason != nil {
		predicates = append(predicates, missdetail.ReasonEQ(*i.Reason))
	}
	if i.ReasonNEQ != nil {
		predicates = append(predicates, missdetail.ReasonNEQ(*i.ReasonNEQ))
	}
	if len(i.ReasonIn) > 0 {
		predicates = append(predicates, missdetail.ReasonIn(i.ReasonIn...))
	}
	if len(i.ReasonNotIn) > 0 {
		predicates = append(predicates, missdetail.ReasonNotIn(i.ReasonNotIn...))
	}
	if i.ReasonGT != nil {
		predicates = append(predicates, missdetail.ReasonGT(*i.ReasonGT))
	}
	if i.ReasonGTE != nil {
		predicates = append(predicates, missdetail.ReasonGTE(*i.ReasonGTE))
	}
	if i.ReasonLT != nil {
		predicates = append(predicates, missdetail.ReasonLT(*i.ReasonLT))
	}
	if i.ReasonLTE != nil {
		predicates = append(predicates, missdetail.ReasonLTE(*i.ReasonLTE))
	}
	if i.ReasonContains != nil {
		predicates = append(predicates, missdetail.ReasonContains(*i.ReasonContains))
	}
	if i.ReasonHasPrefix != nil {
		predicates = append(predicates, missdetail.ReasonHasPrefix(*i.ReasonHasPrefix))
	}
	if i.ReasonHasSuffix != nil {
		predicates = append(predicates, missdetail.ReasonHasSuffix(*i.ReasonHasSuffix))
	}
	if i.ReasonEqualFold != nil {
		predicates = append(predicates, missdetail.ReasonEqualFold(*i.ReasonEqualFold))
	}
	if i.ReasonContainsFold != nil {
		predicates = append(predicates, missdetail.ReasonContainsFold(*i.ReasonContainsFold))
	}
	if i.Count != nil {
		predicates = append(predicates, missdetail.CountEQ(*i.Count))
	}
	if i.CountNEQ != nil {
		predicates = append(predicates, missdetail.CountNEQ(*i.CountNEQ))
	}
	if len(i.CountIn) > 0 {
		predicates = append(predicates, missdetail.CountIn(i.CountIn...))
	}
	if len(i.CountNotIn) > 0 {
		predicates = append(predicates, missdetail.CountNotIn(i.CountNotIn...))
	}
	if i.CountGT != nil {
		predicates = append(predicates, missdetail.CountGT(*i.CountGT))
	}
	if i.CountGTE != nil {
		predicates = append(predicates, missdetail.CountGTE(*i.CountGTE))
	}
	if i.CountLT != nil {
		predicates = append(predicates, missdetail.CountLT(*i.CountLT))
	}
	if i.CountLTE != nil {
		predicates = append(predicates, missdetail.CountLTE(*i.CountLTE))
	}
	if i.CountIsNil {
		predicates = append(predicates, missdetail.CountIsNil())
	}
	if i.CountNotNil {
		predicates = append(predicates, missdetail.CountNotNil())
	}

	if i.HasActionCacheStatistics != nil {
		p := missdetail.HasActionCacheStatistics()
		if !*i.HasActionCacheStatistics {
			p = missdetail.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasActionCacheStatisticsWith) > 0 {
		with := make([]predicate.ActionCacheStatistics, 0, len(i.HasActionCacheStatisticsWith))
		for _, w := range i.HasActionCacheStatisticsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasActionCacheStatisticsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, missdetail.HasActionCacheStatisticsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyMissDetailWhereInput
	case 1:
		return predicates[0], nil
	default:
		return missdetail.And(predicates...), nil
	}
}

// NetworkMetricsWhereInput represents a where input for filtering NetworkMetrics queries.
type NetworkMetricsWhereInput struct {
	Predicates []predicate.NetworkMetrics  `json:"-"`
	Not        *NetworkMetricsWhereInput   `json:"not,omitempty"`
	Or         []*NetworkMetricsWhereInput `json:"or,omitempty"`
	And        []*NetworkMetricsWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int64  `json:"id,omitempty"`
	IDNEQ   *int64  `json:"idNEQ,omitempty"`
	IDIn    []int64 `json:"idIn,omitempty"`
	IDNotIn []int64 `json:"idNotIn,omitempty"`
	IDGT    *int64  `json:"idGT,omitempty"`
	IDGTE   *int64  `json:"idGTE,omitempty"`
	IDLT    *int64  `json:"idLT,omitempty"`
	IDLTE   *int64  `json:"idLTE,omitempty"`

	// "metrics" edge predicates.
	HasMetrics     *bool                `json:"hasMetrics,omitempty"`
	HasMetricsWith []*MetricsWhereInput `json:"hasMetricsWith,omitempty"`

	// "system_network_stats" edge predicates.
	HasSystemNetworkStats     *bool                           `json:"hasSystemNetworkStats,omitempty"`
	HasSystemNetworkStatsWith []*SystemNetworkStatsWhereInput `json:"hasSystemNetworkStatsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *NetworkMetricsWhereInput) AddPredicates(predicates ...predicate.NetworkMetrics) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the NetworkMetricsWhereInput filter on the NetworkMetricsQuery builder.
func (i *NetworkMetricsWhereInput) Filter(q *NetworkMetricsQuery) (*NetworkMetricsQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyNetworkMetricsWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyNetworkMetricsWhereInput is returned in case the NetworkMetricsWhereInput is empty.
var ErrEmptyNetworkMetricsWhereInput = errors.New("ent: empty predicate NetworkMetricsWhereInput")

// P returns a predicate for filtering networkmetricsslice.
// An error is returned if the input is empty or invalid.
func (i *NetworkMetricsWhereInput) P() (predicate.NetworkMetrics, error) {
	var predicates []predicate.NetworkMetrics
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, networkmetrics.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.NetworkMetrics, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, networkmetrics.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.NetworkMetrics, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, networkmetrics.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, networkmetrics.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, networkmetrics.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, networkmetrics.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, networkmetrics.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, networkmetrics.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, networkmetrics.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, networkmetrics.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, networkmetrics.IDLTE(*i.IDLTE))
	}

	if i.HasMetrics != nil {
		p := networkmetrics.HasMetrics()
		if !*i.HasMetrics {
			p = networkmetrics.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMetricsWith) > 0 {
		with := make([]predicate.Metrics, 0, len(i.HasMetricsWith))
		for _, w := range i.HasMetricsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMetricsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, networkmetrics.HasMetricsWith(with...))
	}
	if i.HasSystemNetworkStats != nil {
		p := networkmetrics.HasSystemNetworkStats()
		if !*i.HasSystemNetworkStats {
			p = networkmetrics.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSystemNetworkStatsWith) > 0 {
		with := make([]predicate.SystemNetworkStats, 0, len(i.HasSystemNetworkStatsWith))
		for _, w := range i.HasSystemNetworkStatsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSystemNetworkStatsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, networkmetrics.HasSystemNetworkStatsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyNetworkMetricsWhereInput
	case 1:
		return predicates[0], nil
	default:
		return networkmetrics.And(predicates...), nil
	}
}

// PackageLoadMetricsWhereInput represents a where input for filtering PackageLoadMetrics queries.
type PackageLoadMetricsWhereInput struct {
	Predicates []predicate.PackageLoadMetrics  `json:"-"`
	Not        *PackageLoadMetricsWhereInput   `json:"not,omitempty"`
	Or         []*PackageLoadMetricsWhereInput `json:"or,omitempty"`
	And        []*PackageLoadMetricsWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int64  `json:"id,omitempty"`
	IDNEQ   *int64  `json:"idNEQ,omitempty"`
	IDIn    []int64 `json:"idIn,omitempty"`
	IDNotIn []int64 `json:"idNotIn,omitempty"`
	IDGT    *int64  `json:"idGT,omitempty"`
	IDGTE   *int64  `json:"idGTE,omitempty"`
	IDLT    *int64  `json:"idLT,omitempty"`
	IDLTE   *int64  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameIsNil        bool     `json:"nameIsNil,omitempty"`
	NameNotNil       bool     `json:"nameNotNil,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "load_duration" field predicates.
	LoadDuration       *int64  `json:"loadDuration,omitempty"`
	LoadDurationNEQ    *int64  `json:"loadDurationNEQ,omitempty"`
	LoadDurationIn     []int64 `json:"loadDurationIn,omitempty"`
	LoadDurationNotIn  []int64 `json:"loadDurationNotIn,omitempty"`
	LoadDurationGT     *int64  `json:"loadDurationGT,omitempty"`
	LoadDurationGTE    *int64  `json:"loadDurationGTE,omitempty"`
	LoadDurationLT     *int64  `json:"loadDurationLT,omitempty"`
	LoadDurationLTE    *int64  `json:"loadDurationLTE,omitempty"`
	LoadDurationIsNil  bool    `json:"loadDurationIsNil,omitempty"`
	LoadDurationNotNil bool    `json:"loadDurationNotNil,omitempty"`

	// "num_targets" field predicates.
	NumTargets       *uint64  `json:"numTargets,omitempty"`
	NumTargetsNEQ    *uint64  `json:"numTargetsNEQ,omitempty"`
	NumTargetsIn     []uint64 `json:"numTargetsIn,omitempty"`
	NumTargetsNotIn  []uint64 `json:"numTargetsNotIn,omitempty"`
	NumTargetsGT     *uint64  `json:"numTargetsGT,omitempty"`
	NumTargetsGTE    *uint64  `json:"numTargetsGTE,omitempty"`
	NumTargetsLT     *uint64  `json:"numTargetsLT,omitempty"`
	NumTargetsLTE    *uint64  `json:"numTargetsLTE,omitempty"`
	NumTargetsIsNil  bool     `json:"numTargetsIsNil,omitempty"`
	NumTargetsNotNil bool     `json:"numTargetsNotNil,omitempty"`

	// "computation_steps" field predicates.
	ComputationSteps       *uint64  `json:"computationSteps,omitempty"`
	ComputationStepsNEQ    *uint64  `json:"computationStepsNEQ,omitempty"`
	ComputationStepsIn     []uint64 `json:"computationStepsIn,omitempty"`
	ComputationStepsNotIn  []uint64 `json:"computationStepsNotIn,omitempty"`
	ComputationStepsGT     *uint64  `json:"computationStepsGT,omitempty"`
	ComputationStepsGTE    *uint64  `json:"computationStepsGTE,omitempty"`
	ComputationStepsLT     *uint64  `json:"computationStepsLT,omitempty"`
	ComputationStepsLTE    *uint64  `json:"computationStepsLTE,omitempty"`
	ComputationStepsIsNil  bool     `json:"computationStepsIsNil,omitempty"`
	ComputationStepsNotNil bool     `json:"computationStepsNotNil,omitempty"`

	// "num_transitive_loads" field predicates.
	NumTransitiveLoads       *uint64  `json:"numTransitiveLoads,omitempty"`
	NumTransitiveLoadsNEQ    *uint64  `json:"numTransitiveLoadsNEQ,omitempty"`
	NumTransitiveLoadsIn     []uint64 `json:"numTransitiveLoadsIn,omitempty"`
	NumTransitiveLoadsNotIn  []uint64 `json:"numTransitiveLoadsNotIn,omitempty"`
	NumTransitiveLoadsGT     *uint64  `json:"numTransitiveLoadsGT,omitempty"`
	NumTransitiveLoadsGTE    *uint64  `json:"numTransitiveLoadsGTE,omitempty"`
	NumTransitiveLoadsLT     *uint64  `json:"numTransitiveLoadsLT,omitempty"`
	NumTransitiveLoadsLTE    *uint64  `json:"numTransitiveLoadsLTE,omitempty"`
	NumTransitiveLoadsIsNil  bool     `json:"numTransitiveLoadsIsNil,omitempty"`
	NumTransitiveLoadsNotNil bool     `json:"numTransitiveLoadsNotNil,omitempty"`

	// "package_overhead" field predicates.
	PackageOverhead       *uint64  `json:"packageOverhead,omitempty"`
	PackageOverheadNEQ    *uint64  `json:"packageOverheadNEQ,omitempty"`
	PackageOverheadIn     []uint64 `json:"packageOverheadIn,omitempty"`
	PackageOverheadNotIn  []uint64 `json:"packageOverheadNotIn,omitempty"`
	PackageOverheadGT     *uint64  `json:"packageOverheadGT,omitempty"`
	PackageOverheadGTE    *uint64  `json:"packageOverheadGTE,omitempty"`
	PackageOverheadLT     *uint64  `json:"packageOverheadLT,omitempty"`
	PackageOverheadLTE    *uint64  `json:"packageOverheadLTE,omitempty"`
	PackageOverheadIsNil  bool     `json:"packageOverheadIsNil,omitempty"`
	PackageOverheadNotNil bool     `json:"packageOverheadNotNil,omitempty"`

	// "package_metrics" edge predicates.
	HasPackageMetrics     *bool                       `json:"hasPackageMetrics,omitempty"`
	HasPackageMetricsWith []*PackageMetricsWhereInput `json:"hasPackageMetricsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PackageLoadMetricsWhereInput) AddPredicates(predicates ...predicate.PackageLoadMetrics) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PackageLoadMetricsWhereInput filter on the PackageLoadMetricsQuery builder.
func (i *PackageLoadMetricsWhereInput) Filter(q *PackageLoadMetricsQuery) (*PackageLoadMetricsQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPackageLoadMetricsWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPackageLoadMetricsWhereInput is returned in case the PackageLoadMetricsWhereInput is empty.
var ErrEmptyPackageLoadMetricsWhereInput = errors.New("ent: empty predicate PackageLoadMetricsWhereInput")

// P returns a predicate for filtering packageloadmetricsslice.
// An error is returned if the input is empty or invalid.
func (i *PackageLoadMetricsWhereInput) P() (predicate.PackageLoadMetrics, error) {
	var predicates []predicate.PackageLoadMetrics
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, packageloadmetrics.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.PackageLoadMetrics, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, packageloadmetrics.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.PackageLoadMetrics, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, packageloadmetrics.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, packageloadmetrics.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, packageloadmetrics.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, packageloadmetrics.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, packageloadmetrics.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, packageloadmetrics.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, packageloadmetrics.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, packageloadmetrics.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, packageloadmetrics.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, packageloadmetrics.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, packageloadmetrics.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, packageloadmetrics.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, packageloadmetrics.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, packageloadmetrics.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, packageloadmetrics.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, packageloadmetrics.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, packageloadmetrics.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, packageloadmetrics.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, packageloadmetrics.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, packageloadmetrics.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameIsNil {
		predicates = append(predicates, packageloadmetrics.NameIsNil())
	}
	if i.NameNotNil {
		predicates = append(predicates, packageloadmetrics.NameNotNil())
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, packageloadmetrics.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, packageloadmetrics.NameContainsFold(*i.NameContainsFold))
	}
	if i.LoadDuration != nil {
		predicates = append(predicates, packageloadmetrics.LoadDurationEQ(*i.LoadDuration))
	}
	if i.LoadDurationNEQ != nil {
		predicates = append(predicates, packageloadmetrics.LoadDurationNEQ(*i.LoadDurationNEQ))
	}
	if len(i.LoadDurationIn) > 0 {
		predicates = append(predicates, packageloadmetrics.LoadDurationIn(i.LoadDurationIn...))
	}
	if len(i.LoadDurationNotIn) > 0 {
		predicates = append(predicates, packageloadmetrics.LoadDurationNotIn(i.LoadDurationNotIn...))
	}
	if i.LoadDurationGT != nil {
		predicates = append(predicates, packageloadmetrics.LoadDurationGT(*i.LoadDurationGT))
	}
	if i.LoadDurationGTE != nil {
		predicates = append(predicates, packageloadmetrics.LoadDurationGTE(*i.LoadDurationGTE))
	}
	if i.LoadDurationLT != nil {
		predicates = append(predicates, packageloadmetrics.LoadDurationLT(*i.LoadDurationLT))
	}
	if i.LoadDurationLTE != nil {
		predicates = append(predicates, packageloadmetrics.LoadDurationLTE(*i.LoadDurationLTE))
	}
	if i.LoadDurationIsNil {
		predicates = append(predicates, packageloadmetrics.LoadDurationIsNil())
	}
	if i.LoadDurationNotNil {
		predicates = append(predicates, packageloadmetrics.LoadDurationNotNil())
	}
	if i.NumTargets != nil {
		predicates = append(predicates, packageloadmetrics.NumTargetsEQ(*i.NumTargets))
	}
	if i.NumTargetsNEQ != nil {
		predicates = append(predicates, packageloadmetrics.NumTargetsNEQ(*i.NumTargetsNEQ))
	}
	if len(i.NumTargetsIn) > 0 {
		predicates = append(predicates, packageloadmetrics.NumTargetsIn(i.NumTargetsIn...))
	}
	if len(i.NumTargetsNotIn) > 0 {
		predicates = append(predicates, packageloadmetrics.NumTargetsNotIn(i.NumTargetsNotIn...))
	}
	if i.NumTargetsGT != nil {
		predicates = append(predicates, packageloadmetrics.NumTargetsGT(*i.NumTargetsGT))
	}
	if i.NumTargetsGTE != nil {
		predicates = append(predicates, packageloadmetrics.NumTargetsGTE(*i.NumTargetsGTE))
	}
	if i.NumTargetsLT != nil {
		predicates = append(predicates, packageloadmetrics.NumTargetsLT(*i.NumTargetsLT))
	}
	if i.NumTargetsLTE != nil {
		predicates = append(predicates, packageloadmetrics.NumTargetsLTE(*i.NumTargetsLTE))
	}
	if i.NumTargetsIsNil {
		predicates = append(predicates, packageloadmetrics.NumTargetsIsNil())
	}
	if i.NumTargetsNotNil {
		predicates = append(predicates, packageloadmetrics.NumTargetsNotNil())
	}
	if i.ComputationSteps != nil {
		predicates = append(predicates, packageloadmetrics.ComputationStepsEQ(*i.ComputationSteps))
	}
	if i.ComputationStepsNEQ != nil {
		predicates = append(predicates, packageloadmetrics.ComputationStepsNEQ(*i.ComputationStepsNEQ))
	}
	if len(i.ComputationStepsIn) > 0 {
		predicates = append(predicates, packageloadmetrics.ComputationStepsIn(i.ComputationStepsIn...))
	}
	if len(i.ComputationStepsNotIn) > 0 {
		predicates = append(predicates, packageloadmetrics.ComputationStepsNotIn(i.ComputationStepsNotIn...))
	}
	if i.ComputationStepsGT != nil {
		predicates = append(predicates, packageloadmetrics.ComputationStepsGT(*i.ComputationStepsGT))
	}
	if i.ComputationStepsGTE != nil {
		predicates = append(predicates, packageloadmetrics.ComputationStepsGTE(*i.ComputationStepsGTE))
	}
	if i.ComputationStepsLT != nil {
		predicates = append(predicates, packageloadmetrics.ComputationStepsLT(*i.ComputationStepsLT))
	}
	if i.ComputationStepsLTE != nil {
		predicates = append(predicates, packageloadmetrics.ComputationStepsLTE(*i.ComputationStepsLTE))
	}
	if i.ComputationStepsIsNil {
		predicates = append(predicates, packageloadmetrics.ComputationStepsIsNil())
	}
	if i.ComputationStepsNotNil {
		predicates = append(predicates, packageloadmetrics.ComputationStepsNotNil())
	}
	if i.NumTransitiveLoads != nil {
		predicates = append(predicates, packageloadmetrics.NumTransitiveLoadsEQ(*i.NumTransitiveLoads))
	}
	if i.NumTransitiveLoadsNEQ != nil {
		predicates = append(predicates, packageloadmetrics.NumTransitiveLoadsNEQ(*i.NumTransitiveLoadsNEQ))
	}
	if len(i.NumTransitiveLoadsIn) > 0 {
		predicates = append(predicates, packageloadmetrics.NumTransitiveLoadsIn(i.NumTransitiveLoadsIn...))
	}
	if len(i.NumTransitiveLoadsNotIn) > 0 {
		predicates = append(predicates, packageloadmetrics.NumTransitiveLoadsNotIn(i.NumTransitiveLoadsNotIn...))
	}
	if i.NumTransitiveLoadsGT != nil {
		predicates = append(predicates, packageloadmetrics.NumTransitiveLoadsGT(*i.NumTransitiveLoadsGT))
	}
	if i.NumTransitiveLoadsGTE != nil {
		predicates = append(predicates, packageloadmetrics.NumTransitiveLoadsGTE(*i.NumTransitiveLoadsGTE))
	}
	if i.NumTransitiveLoadsLT != nil {
		predicates = append(predicates, packageloadmetrics.NumTransitiveLoadsLT(*i.NumTransitiveLoadsLT))
	}
	if i.NumTransitiveLoadsLTE != nil {
		predicates = append(predicates, packageloadmetrics.NumTransitiveLoadsLTE(*i.NumTransitiveLoadsLTE))
	}
	if i.NumTransitiveLoadsIsNil {
		predicates = append(predicates, packageloadmetrics.NumTransitiveLoadsIsNil())
	}
	if i.NumTransitiveLoadsNotNil {
		predicates = append(predicates, packageloadmetrics.NumTransitiveLoadsNotNil())
	}
	if i.PackageOverhead != nil {
		predicates = append(predicates, packageloadmetrics.PackageOverheadEQ(*i.PackageOverhead))
	}
	if i.PackageOverheadNEQ != nil {
		predicates = append(predicates, packageloadmetrics.PackageOverheadNEQ(*i.PackageOverheadNEQ))
	}
	if len(i.PackageOverheadIn) > 0 {
		predicates = append(predicates, packageloadmetrics.PackageOverheadIn(i.PackageOverheadIn...))
	}
	if len(i.PackageOverheadNotIn) > 0 {
		predicates = append(predicates, packageloadmetrics.PackageOverheadNotIn(i.PackageOverheadNotIn...))
	}
	if i.PackageOverheadGT != nil {
		predicates = append(predicates, packageloadmetrics.PackageOverheadGT(*i.PackageOverheadGT))
	}
	if i.PackageOverheadGTE != nil {
		predicates = append(predicates, packageloadmetrics.PackageOverheadGTE(*i.PackageOverheadGTE))
	}
	if i.PackageOverheadLT != nil {
		predicates = append(predicates, packageloadmetrics.PackageOverheadLT(*i.PackageOverheadLT))
	}
	if i.PackageOverheadLTE != nil {
		predicates = append(predicates, packageloadmetrics.PackageOverheadLTE(*i.PackageOverheadLTE))
	}
	if i.PackageOverheadIsNil {
		predicates = append(predicates, packageloadmetrics.PackageOverheadIsNil())
	}
	if i.PackageOverheadNotNil {
		predicates = append(predicates, packageloadmetrics.PackageOverheadNotNil())
	}

	if i.HasPackageMetrics != nil {
		p := packageloadmetrics.HasPackageMetrics()
		if !*i.HasPackageMetrics {
			p = packageloadmetrics.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPackageMetricsWith) > 0 {
		with := make([]predicate.PackageMetrics, 0, len(i.HasPackageMetricsWith))
		for _, w := range i.HasPackageMetricsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPackageMetricsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, packageloadmetrics.HasPackageMetricsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPackageLoadMetricsWhereInput
	case 1:
		return predicates[0], nil
	default:
		return packageloadmetrics.And(predicates...), nil
	}
}

// PackageMetricsWhereInput represents a where input for filtering PackageMetrics queries.
type PackageMetricsWhereInput struct {
	Predicates []predicate.PackageMetrics  `json:"-"`
	Not        *PackageMetricsWhereInput   `json:"not,omitempty"`
	Or         []*PackageMetricsWhereInput `json:"or,omitempty"`
	And        []*PackageMetricsWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int64  `json:"id,omitempty"`
	IDNEQ   *int64  `json:"idNEQ,omitempty"`
	IDIn    []int64 `json:"idIn,omitempty"`
	IDNotIn []int64 `json:"idNotIn,omitempty"`
	IDGT    *int64  `json:"idGT,omitempty"`
	IDGTE   *int64  `json:"idGTE,omitempty"`
	IDLT    *int64  `json:"idLT,omitempty"`
	IDLTE   *int64  `json:"idLTE,omitempty"`

	// "packages_loaded" field predicates.
	PackagesLoaded       *int64  `json:"packagesLoaded,omitempty"`
	PackagesLoadedNEQ    *int64  `json:"packagesLoadedNEQ,omitempty"`
	PackagesLoadedIn     []int64 `json:"packagesLoadedIn,omitempty"`
	PackagesLoadedNotIn  []int64 `json:"packagesLoadedNotIn,omitempty"`
	PackagesLoadedGT     *int64  `json:"packagesLoadedGT,omitempty"`
	PackagesLoadedGTE    *int64  `json:"packagesLoadedGTE,omitempty"`
	PackagesLoadedLT     *int64  `json:"packagesLoadedLT,omitempty"`
	PackagesLoadedLTE    *int64  `json:"packagesLoadedLTE,omitempty"`
	PackagesLoadedIsNil  bool    `json:"packagesLoadedIsNil,omitempty"`
	PackagesLoadedNotNil bool    `json:"packagesLoadedNotNil,omitempty"`

	// "metrics" edge predicates.
	HasMetrics     *bool                `json:"hasMetrics,omitempty"`
	HasMetricsWith []*MetricsWhereInput `json:"hasMetricsWith,omitempty"`

	// "package_load_metrics" edge predicates.
	HasPackageLoadMetrics     *bool                           `json:"hasPackageLoadMetrics,omitempty"`
	HasPackageLoadMetricsWith []*PackageLoadMetricsWhereInput `json:"hasPackageLoadMetricsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PackageMetricsWhereInput) AddPredicates(predicates ...predicate.PackageMetrics) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PackageMetricsWhereInput filter on the PackageMetricsQuery builder.
func (i *PackageMetricsWhereInput) Filter(q *PackageMetricsQuery) (*PackageMetricsQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPackageMetricsWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPackageMetricsWhereInput is returned in case the PackageMetricsWhereInput is empty.
var ErrEmptyPackageMetricsWhereInput = errors.New("ent: empty predicate PackageMetricsWhereInput")

// P returns a predicate for filtering packagemetricsslice.
// An error is returned if the input is empty or invalid.
func (i *PackageMetricsWhereInput) P() (predicate.PackageMetrics, error) {
	var predicates []predicate.PackageMetrics
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, packagemetrics.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.PackageMetrics, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, packagemetrics.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.PackageMetrics, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, packagemetrics.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, packagemetrics.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, packagemetrics.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, packagemetrics.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, packagemetrics.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, packagemetrics.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, packagemetrics.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, packagemetrics.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, packagemetrics.IDLTE(*i.IDLTE))
	}
	if i.PackagesLoaded != nil {
		predicates = append(predicates, packagemetrics.PackagesLoadedEQ(*i.PackagesLoaded))
	}
	if i.PackagesLoadedNEQ != nil {
		predicates = append(predicates, packagemetrics.PackagesLoadedNEQ(*i.PackagesLoadedNEQ))
	}
	if len(i.PackagesLoadedIn) > 0 {
		predicates = append(predicates, packagemetrics.PackagesLoadedIn(i.PackagesLoadedIn...))
	}
	if len(i.PackagesLoadedNotIn) > 0 {
		predicates = append(predicates, packagemetrics.PackagesLoadedNotIn(i.PackagesLoadedNotIn...))
	}
	if i.PackagesLoadedGT != nil {
		predicates = append(predicates, packagemetrics.PackagesLoadedGT(*i.PackagesLoadedGT))
	}
	if i.PackagesLoadedGTE != nil {
		predicates = append(predicates, packagemetrics.PackagesLoadedGTE(*i.PackagesLoadedGTE))
	}
	if i.PackagesLoadedLT != nil {
		predicates = append(predicates, packagemetrics.PackagesLoadedLT(*i.PackagesLoadedLT))
	}
	if i.PackagesLoadedLTE != nil {
		predicates = append(predicates, packagemetrics.PackagesLoadedLTE(*i.PackagesLoadedLTE))
	}
	if i.PackagesLoadedIsNil {
		predicates = append(predicates, packagemetrics.PackagesLoadedIsNil())
	}
	if i.PackagesLoadedNotNil {
		predicates = append(predicates, packagemetrics.PackagesLoadedNotNil())
	}

	if i.HasMetrics != nil {
		p := packagemetrics.HasMetrics()
		if !*i.HasMetrics {
			p = packagemetrics.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMetricsWith) > 0 {
		with := make([]predicate.Metrics, 0, len(i.HasMetricsWith))
		for _, w := range i.HasMetricsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMetricsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, packagemetrics.HasMetricsWith(with...))
	}
	if i.HasPackageLoadMetrics != nil {
		p := packagemetrics.HasPackageLoadMetrics()
		if !*i.HasPackageLoadMetrics {
			p = packagemetrics.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPackageLoadMetricsWith) > 0 {
		with := make([]predicate.PackageLoadMetrics, 0, len(i.HasPackageLoadMetricsWith))
		for _, w := range i.HasPackageLoadMetricsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPackageLoadMetricsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, packagemetrics.HasPackageLoadMetricsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPackageMetricsWhereInput
	case 1:
		return predicates[0], nil
	default:
		return packagemetrics.And(predicates...), nil
	}
}

// RunnerCountWhereInput represents a where input for filtering RunnerCount queries.
type RunnerCountWhereInput struct {
	Predicates []predicate.RunnerCount  `json:"-"`
	Not        *RunnerCountWhereInput   `json:"not,omitempty"`
	Or         []*RunnerCountWhereInput `json:"or,omitempty"`
	And        []*RunnerCountWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int64  `json:"id,omitempty"`
	IDNEQ   *int64  `json:"idNEQ,omitempty"`
	IDIn    []int64 `json:"idIn,omitempty"`
	IDNotIn []int64 `json:"idNotIn,omitempty"`
	IDGT    *int64  `json:"idGT,omitempty"`
	IDGTE   *int64  `json:"idGTE,omitempty"`
	IDLT    *int64  `json:"idLT,omitempty"`
	IDLTE   *int64  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameIsNil        bool     `json:"nameIsNil,omitempty"`
	NameNotNil       bool     `json:"nameNotNil,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "exec_kind" field predicates.
	ExecKind             *string  `json:"execKind,omitempty"`
	ExecKindNEQ          *string  `json:"execKindNEQ,omitempty"`
	ExecKindIn           []string `json:"execKindIn,omitempty"`
	ExecKindNotIn        []string `json:"execKindNotIn,omitempty"`
	ExecKindGT           *string  `json:"execKindGT,omitempty"`
	ExecKindGTE          *string  `json:"execKindGTE,omitempty"`
	ExecKindLT           *string  `json:"execKindLT,omitempty"`
	ExecKindLTE          *string  `json:"execKindLTE,omitempty"`
	ExecKindContains     *string  `json:"execKindContains,omitempty"`
	ExecKindHasPrefix    *string  `json:"execKindHasPrefix,omitempty"`
	ExecKindHasSuffix    *string  `json:"execKindHasSuffix,omitempty"`
	ExecKindIsNil        bool     `json:"execKindIsNil,omitempty"`
	ExecKindNotNil       bool     `json:"execKindNotNil,omitempty"`
	ExecKindEqualFold    *string  `json:"execKindEqualFold,omitempty"`
	ExecKindContainsFold *string  `json:"execKindContainsFold,omitempty"`

	// "actions_executed" field predicates.
	ActionsExecuted       *int64  `json:"actionsExecuted,omitempty"`
	ActionsExecutedNEQ    *int64  `json:"actionsExecutedNEQ,omitempty"`
	ActionsExecutedIn     []int64 `json:"actionsExecutedIn,omitempty"`
	ActionsExecutedNotIn  []int64 `json:"actionsExecutedNotIn,omitempty"`
	ActionsExecutedGT     *int64  `json:"actionsExecutedGT,omitempty"`
	ActionsExecutedGTE    *int64  `json:"actionsExecutedGTE,omitempty"`
	ActionsExecutedLT     *int64  `json:"actionsExecutedLT,omitempty"`
	ActionsExecutedLTE    *int64  `json:"actionsExecutedLTE,omitempty"`
	ActionsExecutedIsNil  bool    `json:"actionsExecutedIsNil,omitempty"`
	ActionsExecutedNotNil bool    `json:"actionsExecutedNotNil,omitempty"`

	// "action_summary" edge predicates.
	HasActionSummary     *bool                      `json:"hasActionSummary,omitempty"`
	HasActionSummaryWith []*ActionSummaryWhereInput `json:"hasActionSummaryWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *RunnerCountWhereInput) AddPredicates(predicates ...predicate.RunnerCount) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the RunnerCountWhereInput filter on the RunnerCountQuery builder.
func (i *RunnerCountWhereInput) Filter(q *RunnerCountQuery) (*RunnerCountQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyRunnerCountWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyRunnerCountWhereInput is returned in case the RunnerCountWhereInput is empty.
var ErrEmptyRunnerCountWhereInput = errors.New("ent: empty predicate RunnerCountWhereInput")

// P returns a predicate for filtering runnercounts.
// An error is returned if the input is empty or invalid.
func (i *RunnerCountWhereInput) P() (predicate.RunnerCount, error) {
	var predicates []predicate.RunnerCount
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, runnercount.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.RunnerCount, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, runnercount.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.RunnerCount, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, runnercount.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, runnercount.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, runnercount.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, runnercount.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, runnercount.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, runnercount.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, runnercount.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, runnercount.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, runnercount.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, runnercount.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, runnercount.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, runnercount.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, runnercount.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, runnercount.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, runnercount.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, runnercount.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, runnercount.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, runnercount.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, runnercount.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, runnercount.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameIsNil {
		predicates = append(predicates, runnercount.NameIsNil())
	}
	if i.NameNotNil {
		predicates = append(predicates, runnercount.NameNotNil())
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, runnercount.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, runnercount.NameContainsFold(*i.NameContainsFold))
	}
	if i.ExecKind != nil {
		predicates = append(predicates, runnercount.ExecKindEQ(*i.ExecKind))
	}
	if i.ExecKindNEQ != nil {
		predicates = append(predicates, runnercount.ExecKindNEQ(*i.ExecKindNEQ))
	}
	if len(i.ExecKindIn) > 0 {
		predicates = append(predicates, runnercount.ExecKindIn(i.ExecKindIn...))
	}
	if len(i.ExecKindNotIn) > 0 {
		predicates = append(predicates, runnercount.ExecKindNotIn(i.ExecKindNotIn...))
	}
	if i.ExecKindGT != nil {
		predicates = append(predicates, runnercount.ExecKindGT(*i.ExecKindGT))
	}
	if i.ExecKindGTE != nil {
		predicates = append(predicates, runnercount.ExecKindGTE(*i.ExecKindGTE))
	}
	if i.ExecKindLT != nil {
		predicates = append(predicates, runnercount.ExecKindLT(*i.ExecKindLT))
	}
	if i.ExecKindLTE != nil {
		predicates = append(predicates, runnercount.ExecKindLTE(*i.ExecKindLTE))
	}
	if i.ExecKindContains != nil {
		predicates = append(predicates, runnercount.ExecKindContains(*i.ExecKindContains))
	}
	if i.ExecKindHasPrefix != nil {
		predicates = append(predicates, runnercount.ExecKindHasPrefix(*i.ExecKindHasPrefix))
	}
	if i.ExecKindHasSuffix != nil {
		predicates = append(predicates, runnercount.ExecKindHasSuffix(*i.ExecKindHasSuffix))
	}
	if i.ExecKindIsNil {
		predicates = append(predicates, runnercount.ExecKindIsNil())
	}
	if i.ExecKindNotNil {
		predicates = append(predicates, runnercount.ExecKindNotNil())
	}
	if i.ExecKindEqualFold != nil {
		predicates = append(predicates, runnercount.ExecKindEqualFold(*i.ExecKindEqualFold))
	}
	if i.ExecKindContainsFold != nil {
		predicates = append(predicates, runnercount.ExecKindContainsFold(*i.ExecKindContainsFold))
	}
	if i.ActionsExecuted != nil {
		predicates = append(predicates, runnercount.ActionsExecutedEQ(*i.ActionsExecuted))
	}
	if i.ActionsExecutedNEQ != nil {
		predicates = append(predicates, runnercount.ActionsExecutedNEQ(*i.ActionsExecutedNEQ))
	}
	if len(i.ActionsExecutedIn) > 0 {
		predicates = append(predicates, runnercount.ActionsExecutedIn(i.ActionsExecutedIn...))
	}
	if len(i.ActionsExecutedNotIn) > 0 {
		predicates = append(predicates, runnercount.ActionsExecutedNotIn(i.ActionsExecutedNotIn...))
	}
	if i.ActionsExecutedGT != nil {
		predicates = append(predicates, runnercount.ActionsExecutedGT(*i.ActionsExecutedGT))
	}
	if i.ActionsExecutedGTE != nil {
		predicates = append(predicates, runnercount.ActionsExecutedGTE(*i.ActionsExecutedGTE))
	}
	if i.ActionsExecutedLT != nil {
		predicates = append(predicates, runnercount.ActionsExecutedLT(*i.ActionsExecutedLT))
	}
	if i.ActionsExecutedLTE != nil {
		predicates = append(predicates, runnercount.ActionsExecutedLTE(*i.ActionsExecutedLTE))
	}
	if i.ActionsExecutedIsNil {
		predicates = append(predicates, runnercount.ActionsExecutedIsNil())
	}
	if i.ActionsExecutedNotNil {
		predicates = append(predicates, runnercount.ActionsExecutedNotNil())
	}

	if i.HasActionSummary != nil {
		p := runnercount.HasActionSummary()
		if !*i.HasActionSummary {
			p = runnercount.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasActionSummaryWith) > 0 {
		with := make([]predicate.ActionSummary, 0, len(i.HasActionSummaryWith))
		for _, w := range i.HasActionSummaryWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasActionSummaryWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, runnercount.HasActionSummaryWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyRunnerCountWhereInput
	case 1:
		return predicates[0], nil
	default:
		return runnercount.And(predicates...), nil
	}
}

// SourceControlWhereInput represents a where input for filtering SourceControl queries.
type SourceControlWhereInput struct {
	Predicates []predicate.SourceControl  `json:"-"`
	Not        *SourceControlWhereInput   `json:"not,omitempty"`
	Or         []*SourceControlWhereInput `json:"or,omitempty"`
	And        []*SourceControlWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int64  `json:"id,omitempty"`
	IDNEQ   *int64  `json:"idNEQ,omitempty"`
	IDIn    []int64 `json:"idIn,omitempty"`
	IDNotIn []int64 `json:"idNotIn,omitempty"`
	IDGT    *int64  `json:"idGT,omitempty"`
	IDGTE   *int64  `json:"idGTE,omitempty"`
	IDLT    *int64  `json:"idLT,omitempty"`
	IDLTE   *int64  `json:"idLTE,omitempty"`

	// "provider" field predicates.
	Provider       *sourcecontrol.Provider  `json:"provider,omitempty"`
	ProviderNEQ    *sourcecontrol.Provider  `json:"providerNEQ,omitempty"`
	ProviderIn     []sourcecontrol.Provider `json:"providerIn,omitempty"`
	ProviderNotIn  []sourcecontrol.Provider `json:"providerNotIn,omitempty"`
	ProviderIsNil  bool                     `json:"providerIsNil,omitempty"`
	ProviderNotNil bool                     `json:"providerNotNil,omitempty"`

	// "instance_url" field predicates.
	InstanceURL             *string  `json:"instanceURL,omitempty"`
	InstanceURLNEQ          *string  `json:"instanceURLNEQ,omitempty"`
	InstanceURLIn           []string `json:"instanceURLIn,omitempty"`
	InstanceURLNotIn        []string `json:"instanceURLNotIn,omitempty"`
	InstanceURLGT           *string  `json:"instanceURLGT,omitempty"`
	InstanceURLGTE          *string  `json:"instanceURLGTE,omitempty"`
	InstanceURLLT           *string  `json:"instanceURLLT,omitempty"`
	InstanceURLLTE          *string  `json:"instanceURLLTE,omitempty"`
	InstanceURLContains     *string  `json:"instanceURLContains,omitempty"`
	InstanceURLHasPrefix    *string  `json:"instanceURLHasPrefix,omitempty"`
	InstanceURLHasSuffix    *string  `json:"instanceURLHasSuffix,omitempty"`
	InstanceURLIsNil        bool     `json:"instanceURLIsNil,omitempty"`
	InstanceURLNotNil       bool     `json:"instanceURLNotNil,omitempty"`
	InstanceURLEqualFold    *string  `json:"instanceURLEqualFold,omitempty"`
	InstanceURLContainsFold *string  `json:"instanceURLContainsFold,omitempty"`

	// "repo" field predicates.
	Repo             *string  `json:"repo,omitempty"`
	RepoNEQ          *string  `json:"repoNEQ,omitempty"`
	RepoIn           []string `json:"repoIn,omitempty"`
	RepoNotIn        []string `json:"repoNotIn,omitempty"`
	RepoGT           *string  `json:"repoGT,omitempty"`
	RepoGTE          *string  `json:"repoGTE,omitempty"`
	RepoLT           *string  `json:"repoLT,omitempty"`
	RepoLTE          *string  `json:"repoLTE,omitempty"`
	RepoContains     *string  `json:"repoContains,omitempty"`
	RepoHasPrefix    *string  `json:"repoHasPrefix,omitempty"`
	RepoHasSuffix    *string  `json:"repoHasSuffix,omitempty"`
	RepoIsNil        bool     `json:"repoIsNil,omitempty"`
	RepoNotNil       bool     `json:"repoNotNil,omitempty"`
	RepoEqualFold    *string  `json:"repoEqualFold,omitempty"`
	RepoContainsFold *string  `json:"repoContainsFold,omitempty"`

	// "refs" field predicates.
	Refs             *string  `json:"refs,omitempty"`
	RefsNEQ          *string  `json:"refsNEQ,omitempty"`
	RefsIn           []string `json:"refsIn,omitempty"`
	RefsNotIn        []string `json:"refsNotIn,omitempty"`
	RefsGT           *string  `json:"refsGT,omitempty"`
	RefsGTE          *string  `json:"refsGTE,omitempty"`
	RefsLT           *string  `json:"refsLT,omitempty"`
	RefsLTE          *string  `json:"refsLTE,omitempty"`
	RefsContains     *string  `json:"refsContains,omitempty"`
	RefsHasPrefix    *string  `json:"refsHasPrefix,omitempty"`
	RefsHasSuffix    *string  `json:"refsHasSuffix,omitempty"`
	RefsIsNil        bool     `json:"refsIsNil,omitempty"`
	RefsNotNil       bool     `json:"refsNotNil,omitempty"`
	RefsEqualFold    *string  `json:"refsEqualFold,omitempty"`
	RefsContainsFold *string  `json:"refsContainsFold,omitempty"`

	// "commit_sha" field predicates.
	CommitSha             *string  `json:"commitSha,omitempty"`
	CommitShaNEQ          *string  `json:"commitShaNEQ,omitempty"`
	CommitShaIn           []string `json:"commitShaIn,omitempty"`
	CommitShaNotIn        []string `json:"commitShaNotIn,omitempty"`
	CommitShaGT           *string  `json:"commitShaGT,omitempty"`
	CommitShaGTE          *string  `json:"commitShaGTE,omitempty"`
	CommitShaLT           *string  `json:"commitShaLT,omitempty"`
	CommitShaLTE          *string  `json:"commitShaLTE,omitempty"`
	CommitShaContains     *string  `json:"commitShaContains,omitempty"`
	CommitShaHasPrefix    *string  `json:"commitShaHasPrefix,omitempty"`
	CommitShaHasSuffix    *string  `json:"commitShaHasSuffix,omitempty"`
	CommitShaIsNil        bool     `json:"commitShaIsNil,omitempty"`
	CommitShaNotNil       bool     `json:"commitShaNotNil,omitempty"`
	CommitShaEqualFold    *string  `json:"commitShaEqualFold,omitempty"`
	CommitShaContainsFold *string  `json:"commitShaContainsFold,omitempty"`

	// "actor" field predicates.
	Actor             *string  `json:"actor,omitempty"`
	ActorNEQ          *string  `json:"actorNEQ,omitempty"`
	ActorIn           []string `json:"actorIn,omitempty"`
	ActorNotIn        []string `json:"actorNotIn,omitempty"`
	ActorGT           *string  `json:"actorGT,omitempty"`
	ActorGTE          *string  `json:"actorGTE,omitempty"`
	ActorLT           *string  `json:"actorLT,omitempty"`
	ActorLTE          *string  `json:"actorLTE,omitempty"`
	ActorContains     *string  `json:"actorContains,omitempty"`
	ActorHasPrefix    *string  `json:"actorHasPrefix,omitempty"`
	ActorHasSuffix    *string  `json:"actorHasSuffix,omitempty"`
	ActorIsNil        bool     `json:"actorIsNil,omitempty"`
	ActorNotNil       bool     `json:"actorNotNil,omitempty"`
	ActorEqualFold    *string  `json:"actorEqualFold,omitempty"`
	ActorContainsFold *string  `json:"actorContainsFold,omitempty"`

	// "event_name" field predicates.
	EventName             *string  `json:"eventName,omitempty"`
	EventNameNEQ          *string  `json:"eventNameNEQ,omitempty"`
	EventNameIn           []string `json:"eventNameIn,omitempty"`
	EventNameNotIn        []string `json:"eventNameNotIn,omitempty"`
	EventNameGT           *string  `json:"eventNameGT,omitempty"`
	EventNameGTE          *string  `json:"eventNameGTE,omitempty"`
	EventNameLT           *string  `json:"eventNameLT,omitempty"`
	EventNameLTE          *string  `json:"eventNameLTE,omitempty"`
	EventNameContains     *string  `json:"eventNameContains,omitempty"`
	EventNameHasPrefix    *string  `json:"eventNameHasPrefix,omitempty"`
	EventNameHasSuffix    *string  `json:"eventNameHasSuffix,omitempty"`
	EventNameIsNil        bool     `json:"eventNameIsNil,omitempty"`
	EventNameNotNil       bool     `json:"eventNameNotNil,omitempty"`
	EventNameEqualFold    *string  `json:"eventNameEqualFold,omitempty"`
	EventNameContainsFold *string  `json:"eventNameContainsFold,omitempty"`

	// "workflow" field predicates.
	Workflow             *string  `json:"workflow,omitempty"`
	WorkflowNEQ          *string  `json:"workflowNEQ,omitempty"`
	WorkflowIn           []string `json:"workflowIn,omitempty"`
	WorkflowNotIn        []string `json:"workflowNotIn,omitempty"`
	WorkflowGT           *string  `json:"workflowGT,omitempty"`
	WorkflowGTE          *string  `json:"workflowGTE,omitempty"`
	WorkflowLT           *string  `json:"workflowLT,omitempty"`
	WorkflowLTE          *string  `json:"workflowLTE,omitempty"`
	WorkflowContains     *string  `json:"workflowContains,omitempty"`
	WorkflowHasPrefix    *string  `json:"workflowHasPrefix,omitempty"`
	WorkflowHasSuffix    *string  `json:"workflowHasSuffix,omitempty"`
	WorkflowIsNil        bool     `json:"workflowIsNil,omitempty"`
	WorkflowNotNil       bool     `json:"workflowNotNil,omitempty"`
	WorkflowEqualFold    *string  `json:"workflowEqualFold,omitempty"`
	WorkflowContainsFold *string  `json:"workflowContainsFold,omitempty"`

	// "run_id" field predicates.
	RunID             *string  `json:"runID,omitempty"`
	RunIDNEQ          *string  `json:"runIDNEQ,omitempty"`
	RunIDIn           []string `json:"runIDIn,omitempty"`
	RunIDNotIn        []string `json:"runIDNotIn,omitempty"`
	RunIDGT           *string  `json:"runIDGT,omitempty"`
	RunIDGTE          *string  `json:"runIDGTE,omitempty"`
	RunIDLT           *string  `json:"runIDLT,omitempty"`
	RunIDLTE          *string  `json:"runIDLTE,omitempty"`
	RunIDContains     *string  `json:"runIDContains,omitempty"`
	RunIDHasPrefix    *string  `json:"runIDHasPrefix,omitempty"`
	RunIDHasSuffix    *string  `json:"runIDHasSuffix,omitempty"`
	RunIDIsNil        bool     `json:"runIDIsNil,omitempty"`
	RunIDNotNil       bool     `json:"runIDNotNil,omitempty"`
	RunIDEqualFold    *string  `json:"runIDEqualFold,omitempty"`
	RunIDContainsFold *string  `json:"runIDContainsFold,omitempty"`

	// "run_number" field predicates.
	RunNumber             *string  `json:"runNumber,omitempty"`
	RunNumberNEQ          *string  `json:"runNumberNEQ,omitempty"`
	RunNumberIn           []string `json:"runNumberIn,omitempty"`
	RunNumberNotIn        []string `json:"runNumberNotIn,omitempty"`
	RunNumberGT           *string  `json:"runNumberGT,omitempty"`
	RunNumberGTE          *string  `json:"runNumberGTE,omitempty"`
	RunNumberLT           *string  `json:"runNumberLT,omitempty"`
	RunNumberLTE          *string  `json:"runNumberLTE,omitempty"`
	RunNumberContains     *string  `json:"runNumberContains,omitempty"`
	RunNumberHasPrefix    *string  `json:"runNumberHasPrefix,omitempty"`
	RunNumberHasSuffix    *string  `json:"runNumberHasSuffix,omitempty"`
	RunNumberIsNil        bool     `json:"runNumberIsNil,omitempty"`
	RunNumberNotNil       bool     `json:"runNumberNotNil,omitempty"`
	RunNumberEqualFold    *string  `json:"runNumberEqualFold,omitempty"`
	RunNumberContainsFold *string  `json:"runNumberContainsFold,omitempty"`

	// "job" field predicates.
	Job             *string  `json:"job,omitempty"`
	JobNEQ          *string  `json:"jobNEQ,omitempty"`
	JobIn           []string `json:"jobIn,omitempty"`
	JobNotIn        []string `json:"jobNotIn,omitempty"`
	JobGT           *string  `json:"jobGT,omitempty"`
	JobGTE          *string  `json:"jobGTE,omitempty"`
	JobLT           *string  `json:"jobLT,omitempty"`
	JobLTE          *string  `json:"jobLTE,omitempty"`
	JobContains     *string  `json:"jobContains,omitempty"`
	JobHasPrefix    *string  `json:"jobHasPrefix,omitempty"`
	JobHasSuffix    *string  `json:"jobHasSuffix,omitempty"`
	JobIsNil        bool     `json:"jobIsNil,omitempty"`
	JobNotNil       bool     `json:"jobNotNil,omitempty"`
	JobEqualFold    *string  `json:"jobEqualFold,omitempty"`
	JobContainsFold *string  `json:"jobContainsFold,omitempty"`

	// "action" field predicates.
	Action             *string  `json:"action,omitempty"`
	ActionNEQ          *string  `json:"actionNEQ,omitempty"`
	ActionIn           []string `json:"actionIn,omitempty"`
	ActionNotIn        []string `json:"actionNotIn,omitempty"`
	ActionGT           *string  `json:"actionGT,omitempty"`
	ActionGTE          *string  `json:"actionGTE,omitempty"`
	ActionLT           *string  `json:"actionLT,omitempty"`
	ActionLTE          *string  `json:"actionLTE,omitempty"`
	ActionContains     *string  `json:"actionContains,omitempty"`
	ActionHasPrefix    *string  `json:"actionHasPrefix,omitempty"`
	ActionHasSuffix    *string  `json:"actionHasSuffix,omitempty"`
	ActionIsNil        bool     `json:"actionIsNil,omitempty"`
	ActionNotNil       bool     `json:"actionNotNil,omitempty"`
	ActionEqualFold    *string  `json:"actionEqualFold,omitempty"`
	ActionContainsFold *string  `json:"actionContainsFold,omitempty"`

	// "runner_name" field predicates.
	RunnerName             *string  `json:"runnerName,omitempty"`
	RunnerNameNEQ          *string  `json:"runnerNameNEQ,omitempty"`
	RunnerNameIn           []string `json:"runnerNameIn,omitempty"`
	RunnerNameNotIn        []string `json:"runnerNameNotIn,omitempty"`
	RunnerNameGT           *string  `json:"runnerNameGT,omitempty"`
	RunnerNameGTE          *string  `json:"runnerNameGTE,omitempty"`
	RunnerNameLT           *string  `json:"runnerNameLT,omitempty"`
	RunnerNameLTE          *string  `json:"runnerNameLTE,omitempty"`
	RunnerNameContains     *string  `json:"runnerNameContains,omitempty"`
	RunnerNameHasPrefix    *string  `json:"runnerNameHasPrefix,omitempty"`
	RunnerNameHasSuffix    *string  `json:"runnerNameHasSuffix,omitempty"`
	RunnerNameIsNil        bool     `json:"runnerNameIsNil,omitempty"`
	RunnerNameNotNil       bool     `json:"runnerNameNotNil,omitempty"`
	RunnerNameEqualFold    *string  `json:"runnerNameEqualFold,omitempty"`
	RunnerNameContainsFold *string  `json:"runnerNameContainsFold,omitempty"`

	// "runner_arch" field predicates.
	RunnerArch             *string  `json:"runnerArch,omitempty"`
	RunnerArchNEQ          *string  `json:"runnerArchNEQ,omitempty"`
	RunnerArchIn           []string `json:"runnerArchIn,omitempty"`
	RunnerArchNotIn        []string `json:"runnerArchNotIn,omitempty"`
	RunnerArchGT           *string  `json:"runnerArchGT,omitempty"`
	RunnerArchGTE          *string  `json:"runnerArchGTE,omitempty"`
	RunnerArchLT           *string  `json:"runnerArchLT,omitempty"`
	RunnerArchLTE          *string  `json:"runnerArchLTE,omitempty"`
	RunnerArchContains     *string  `json:"runnerArchContains,omitempty"`
	RunnerArchHasPrefix    *string  `json:"runnerArchHasPrefix,omitempty"`
	RunnerArchHasSuffix    *string  `json:"runnerArchHasSuffix,omitempty"`
	RunnerArchIsNil        bool     `json:"runnerArchIsNil,omitempty"`
	RunnerArchNotNil       bool     `json:"runnerArchNotNil,omitempty"`
	RunnerArchEqualFold    *string  `json:"runnerArchEqualFold,omitempty"`
	RunnerArchContainsFold *string  `json:"runnerArchContainsFold,omitempty"`

	// "runner_os" field predicates.
	RunnerOs             *string  `json:"runnerOs,omitempty"`
	RunnerOsNEQ          *string  `json:"runnerOsNEQ,omitempty"`
	RunnerOsIn           []string `json:"runnerOsIn,omitempty"`
	RunnerOsNotIn        []string `json:"runnerOsNotIn,omitempty"`
	RunnerOsGT           *string  `json:"runnerOsGT,omitempty"`
	RunnerOsGTE          *string  `json:"runnerOsGTE,omitempty"`
	RunnerOsLT           *string  `json:"runnerOsLT,omitempty"`
	RunnerOsLTE          *string  `json:"runnerOsLTE,omitempty"`
	RunnerOsContains     *string  `json:"runnerOsContains,omitempty"`
	RunnerOsHasPrefix    *string  `json:"runnerOsHasPrefix,omitempty"`
	RunnerOsHasSuffix    *string  `json:"runnerOsHasSuffix,omitempty"`
	RunnerOsIsNil        bool     `json:"runnerOsIsNil,omitempty"`
	RunnerOsNotNil       bool     `json:"runnerOsNotNil,omitempty"`
	RunnerOsEqualFold    *string  `json:"runnerOsEqualFold,omitempty"`
	RunnerOsContainsFold *string  `json:"runnerOsContainsFold,omitempty"`

	// "workspace" field predicates.
	Workspace             *string  `json:"workspace,omitempty"`
	WorkspaceNEQ          *string  `json:"workspaceNEQ,omitempty"`
	WorkspaceIn           []string `json:"workspaceIn,omitempty"`
	WorkspaceNotIn        []string `json:"workspaceNotIn,omitempty"`
	WorkspaceGT           *string  `json:"workspaceGT,omitempty"`
	WorkspaceGTE          *string  `json:"workspaceGTE,omitempty"`
	WorkspaceLT           *string  `json:"workspaceLT,omitempty"`
	WorkspaceLTE          *string  `json:"workspaceLTE,omitempty"`
	WorkspaceContains     *string  `json:"workspaceContains,omitempty"`
	WorkspaceHasPrefix    *string  `json:"workspaceHasPrefix,omitempty"`
	WorkspaceHasSuffix    *string  `json:"workspaceHasSuffix,omitempty"`
	WorkspaceIsNil        bool     `json:"workspaceIsNil,omitempty"`
	WorkspaceNotNil       bool     `json:"workspaceNotNil,omitempty"`
	WorkspaceEqualFold    *string  `json:"workspaceEqualFold,omitempty"`
	WorkspaceContainsFold *string  `json:"workspaceContainsFold,omitempty"`

	// "bazel_invocation" edge predicates.
	HasBazelInvocation     *bool                        `json:"hasBazelInvocation,omitempty"`
	HasBazelInvocationWith []*BazelInvocationWhereInput `json:"hasBazelInvocationWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *SourceControlWhereInput) AddPredicates(predicates ...predicate.SourceControl) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the SourceControlWhereInput filter on the SourceControlQuery builder.
func (i *SourceControlWhereInput) Filter(q *SourceControlQuery) (*SourceControlQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptySourceControlWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptySourceControlWhereInput is returned in case the SourceControlWhereInput is empty.
var ErrEmptySourceControlWhereInput = errors.New("ent: empty predicate SourceControlWhereInput")

// P returns a predicate for filtering sourcecontrols.
// An error is returned if the input is empty or invalid.
func (i *SourceControlWhereInput) P() (predicate.SourceControl, error) {
	var predicates []predicate.SourceControl
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, sourcecontrol.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.SourceControl, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, sourcecontrol.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.SourceControl, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, sourcecontrol.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, sourcecontrol.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, sourcecontrol.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, sourcecontrol.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, sourcecontrol.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, sourcecontrol.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, sourcecontrol.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, sourcecontrol.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, sourcecontrol.IDLTE(*i.IDLTE))
	}
	if i.Provider != nil {
		predicates = append(predicates, sourcecontrol.ProviderEQ(*i.Provider))
	}
	if i.ProviderNEQ != nil {
		predicates = append(predicates, sourcecontrol.ProviderNEQ(*i.ProviderNEQ))
	}
	if len(i.ProviderIn) > 0 {
		predicates = append(predicates, sourcecontrol.ProviderIn(i.ProviderIn...))
	}
	if len(i.ProviderNotIn) > 0 {
		predicates = append(predicates, sourcecontrol.ProviderNotIn(i.ProviderNotIn...))
	}
	if i.ProviderIsNil {
		predicates = append(predicates, sourcecontrol.ProviderIsNil())
	}
	if i.ProviderNotNil {
		predicates = append(predicates, sourcecontrol.ProviderNotNil())
	}
	if i.InstanceURL != nil {
		predicates = append(predicates, sourcecontrol.InstanceURLEQ(*i.InstanceURL))
	}
	if i.InstanceURLNEQ != nil {
		predicates = append(predicates, sourcecontrol.InstanceURLNEQ(*i.InstanceURLNEQ))
	}
	if len(i.InstanceURLIn) > 0 {
		predicates = append(predicates, sourcecontrol.InstanceURLIn(i.InstanceURLIn...))
	}
	if len(i.InstanceURLNotIn) > 0 {
		predicates = append(predicates, sourcecontrol.InstanceURLNotIn(i.InstanceURLNotIn...))
	}
	if i.InstanceURLGT != nil {
		predicates = append(predicates, sourcecontrol.InstanceURLGT(*i.InstanceURLGT))
	}
	if i.InstanceURLGTE != nil {
		predicates = append(predicates, sourcecontrol.InstanceURLGTE(*i.InstanceURLGTE))
	}
	if i.InstanceURLLT != nil {
		predicates = append(predicates, sourcecontrol.InstanceURLLT(*i.InstanceURLLT))
	}
	if i.InstanceURLLTE != nil {
		predicates = append(predicates, sourcecontrol.InstanceURLLTE(*i.InstanceURLLTE))
	}
	if i.InstanceURLContains != nil {
		predicates = append(predicates, sourcecontrol.InstanceURLContains(*i.InstanceURLContains))
	}
	if i.InstanceURLHasPrefix != nil {
		predicates = append(predicates, sourcecontrol.InstanceURLHasPrefix(*i.InstanceURLHasPrefix))
	}
	if i.InstanceURLHasSuffix != nil {
		predicates = append(predicates, sourcecontrol.InstanceURLHasSuffix(*i.InstanceURLHasSuffix))
	}
	if i.InstanceURLIsNil {
		predicates = append(predicates, sourcecontrol.InstanceURLIsNil())
	}
	if i.InstanceURLNotNil {
		predicates = append(predicates, sourcecontrol.InstanceURLNotNil())
	}
	if i.InstanceURLEqualFold != nil {
		predicates = append(predicates, sourcecontrol.InstanceURLEqualFold(*i.InstanceURLEqualFold))
	}
	if i.InstanceURLContainsFold != nil {
		predicates = append(predicates, sourcecontrol.InstanceURLContainsFold(*i.InstanceURLContainsFold))
	}
	if i.Repo != nil {
		predicates = append(predicates, sourcecontrol.RepoEQ(*i.Repo))
	}
	if i.RepoNEQ != nil {
		predicates = append(predicates, sourcecontrol.RepoNEQ(*i.RepoNEQ))
	}
	if len(i.RepoIn) > 0 {
		predicates = append(predicates, sourcecontrol.RepoIn(i.RepoIn...))
	}
	if len(i.RepoNotIn) > 0 {
		predicates = append(predicates, sourcecontrol.RepoNotIn(i.RepoNotIn...))
	}
	if i.RepoGT != nil {
		predicates = append(predicates, sourcecontrol.RepoGT(*i.RepoGT))
	}
	if i.RepoGTE != nil {
		predicates = append(predicates, sourcecontrol.RepoGTE(*i.RepoGTE))
	}
	if i.RepoLT != nil {
		predicates = append(predicates, sourcecontrol.RepoLT(*i.RepoLT))
	}
	if i.RepoLTE != nil {
		predicates = append(predicates, sourcecontrol.RepoLTE(*i.RepoLTE))
	}
	if i.RepoContains != nil {
		predicates = append(predicates, sourcecontrol.RepoContains(*i.RepoContains))
	}
	if i.RepoHasPrefix != nil {
		predicates = append(predicates, sourcecontrol.RepoHasPrefix(*i.RepoHasPrefix))
	}
	if i.RepoHasSuffix != nil {
		predicates = append(predicates, sourcecontrol.RepoHasSuffix(*i.RepoHasSuffix))
	}
	if i.RepoIsNil {
		predicates = append(predicates, sourcecontrol.RepoIsNil())
	}
	if i.RepoNotNil {
		predicates = append(predicates, sourcecontrol.RepoNotNil())
	}
	if i.RepoEqualFold != nil {
		predicates = append(predicates, sourcecontrol.RepoEqualFold(*i.RepoEqualFold))
	}
	if i.RepoContainsFold != nil {
		predicates = append(predicates, sourcecontrol.RepoContainsFold(*i.RepoContainsFold))
	}
	if i.Refs != nil {
		predicates = append(predicates, sourcecontrol.RefsEQ(*i.Refs))
	}
	if i.RefsNEQ != nil {
		predicates = append(predicates, sourcecontrol.RefsNEQ(*i.RefsNEQ))
	}
	if len(i.RefsIn) > 0 {
		predicates = append(predicates, sourcecontrol.RefsIn(i.RefsIn...))
	}
	if len(i.RefsNotIn) > 0 {
		predicates = append(predicates, sourcecontrol.RefsNotIn(i.RefsNotIn...))
	}
	if i.RefsGT != nil {
		predicates = append(predicates, sourcecontrol.RefsGT(*i.RefsGT))
	}
	if i.RefsGTE != nil {
		predicates = append(predicates, sourcecontrol.RefsGTE(*i.RefsGTE))
	}
	if i.RefsLT != nil {
		predicates = append(predicates, sourcecontrol.RefsLT(*i.RefsLT))
	}
	if i.RefsLTE != nil {
		predicates = append(predicates, sourcecontrol.RefsLTE(*i.RefsLTE))
	}
	if i.RefsContains != nil {
		predicates = append(predicates, sourcecontrol.RefsContains(*i.RefsContains))
	}
	if i.RefsHasPrefix != nil {
		predicates = append(predicates, sourcecontrol.RefsHasPrefix(*i.RefsHasPrefix))
	}
	if i.RefsHasSuffix != nil {
		predicates = append(predicates, sourcecontrol.RefsHasSuffix(*i.RefsHasSuffix))
	}
	if i.RefsIsNil {
		predicates = append(predicates, sourcecontrol.RefsIsNil())
	}
	if i.RefsNotNil {
		predicates = append(predicates, sourcecontrol.RefsNotNil())
	}
	if i.RefsEqualFold != nil {
		predicates = append(predicates, sourcecontrol.RefsEqualFold(*i.RefsEqualFold))
	}
	if i.RefsContainsFold != nil {
		predicates = append(predicates, sourcecontrol.RefsContainsFold(*i.RefsContainsFold))
	}
	if i.CommitSha != nil {
		predicates = append(predicates, sourcecontrol.CommitShaEQ(*i.CommitSha))
	}
	if i.CommitShaNEQ != nil {
		predicates = append(predicates, sourcecontrol.CommitShaNEQ(*i.CommitShaNEQ))
	}
	if len(i.CommitShaIn) > 0 {
		predicates = append(predicates, sourcecontrol.CommitShaIn(i.CommitShaIn...))
	}
	if len(i.CommitShaNotIn) > 0 {
		predicates = append(predicates, sourcecontrol.CommitShaNotIn(i.CommitShaNotIn...))
	}
	if i.CommitShaGT != nil {
		predicates = append(predicates, sourcecontrol.CommitShaGT(*i.CommitShaGT))
	}
	if i.CommitShaGTE != nil {
		predicates = append(predicates, sourcecontrol.CommitShaGTE(*i.CommitShaGTE))
	}
	if i.CommitShaLT != nil {
		predicates = append(predicates, sourcecontrol.CommitShaLT(*i.CommitShaLT))
	}
	if i.CommitShaLTE != nil {
		predicates = append(predicates, sourcecontrol.CommitShaLTE(*i.CommitShaLTE))
	}
	if i.CommitShaContains != nil {
		predicates = append(predicates, sourcecontrol.CommitShaContains(*i.CommitShaContains))
	}
	if i.CommitShaHasPrefix != nil {
		predicates = append(predicates, sourcecontrol.CommitShaHasPrefix(*i.CommitShaHasPrefix))
	}
	if i.CommitShaHasSuffix != nil {
		predicates = append(predicates, sourcecontrol.CommitShaHasSuffix(*i.CommitShaHasSuffix))
	}
	if i.CommitShaIsNil {
		predicates = append(predicates, sourcecontrol.CommitShaIsNil())
	}
	if i.CommitShaNotNil {
		predicates = append(predicates, sourcecontrol.CommitShaNotNil())
	}
	if i.CommitShaEqualFold != nil {
		predicates = append(predicates, sourcecontrol.CommitShaEqualFold(*i.CommitShaEqualFold))
	}
	if i.CommitShaContainsFold != nil {
		predicates = append(predicates, sourcecontrol.CommitShaContainsFold(*i.CommitShaContainsFold))
	}
	if i.Actor != nil {
		predicates = append(predicates, sourcecontrol.ActorEQ(*i.Actor))
	}
	if i.ActorNEQ != nil {
		predicates = append(predicates, sourcecontrol.ActorNEQ(*i.ActorNEQ))
	}
	if len(i.ActorIn) > 0 {
		predicates = append(predicates, sourcecontrol.ActorIn(i.ActorIn...))
	}
	if len(i.ActorNotIn) > 0 {
		predicates = append(predicates, sourcecontrol.ActorNotIn(i.ActorNotIn...))
	}
	if i.ActorGT != nil {
		predicates = append(predicates, sourcecontrol.ActorGT(*i.ActorGT))
	}
	if i.ActorGTE != nil {
		predicates = append(predicates, sourcecontrol.ActorGTE(*i.ActorGTE))
	}
	if i.ActorLT != nil {
		predicates = append(predicates, sourcecontrol.ActorLT(*i.ActorLT))
	}
	if i.ActorLTE != nil {
		predicates = append(predicates, sourcecontrol.ActorLTE(*i.ActorLTE))
	}
	if i.ActorContains != nil {
		predicates = append(predicates, sourcecontrol.ActorContains(*i.ActorContains))
	}
	if i.ActorHasPrefix != nil {
		predicates = append(predicates, sourcecontrol.ActorHasPrefix(*i.ActorHasPrefix))
	}
	if i.ActorHasSuffix != nil {
		predicates = append(predicates, sourcecontrol.ActorHasSuffix(*i.ActorHasSuffix))
	}
	if i.ActorIsNil {
		predicates = append(predicates, sourcecontrol.ActorIsNil())
	}
	if i.ActorNotNil {
		predicates = append(predicates, sourcecontrol.ActorNotNil())
	}
	if i.ActorEqualFold != nil {
		predicates = append(predicates, sourcecontrol.ActorEqualFold(*i.ActorEqualFold))
	}
	if i.ActorContainsFold != nil {
		predicates = append(predicates, sourcecontrol.ActorContainsFold(*i.ActorContainsFold))
	}
	if i.EventName != nil {
		predicates = append(predicates, sourcecontrol.EventNameEQ(*i.EventName))
	}
	if i.EventNameNEQ != nil {
		predicates = append(predicates, sourcecontrol.EventNameNEQ(*i.EventNameNEQ))
	}
	if len(i.EventNameIn) > 0 {
		predicates = append(predicates, sourcecontrol.EventNameIn(i.EventNameIn...))
	}
	if len(i.EventNameNotIn) > 0 {
		predicates = append(predicates, sourcecontrol.EventNameNotIn(i.EventNameNotIn...))
	}
	if i.EventNameGT != nil {
		predicates = append(predicates, sourcecontrol.EventNameGT(*i.EventNameGT))
	}
	if i.EventNameGTE != nil {
		predicates = append(predicates, sourcecontrol.EventNameGTE(*i.EventNameGTE))
	}
	if i.EventNameLT != nil {
		predicates = append(predicates, sourcecontrol.EventNameLT(*i.EventNameLT))
	}
	if i.EventNameLTE != nil {
		predicates = append(predicates, sourcecontrol.EventNameLTE(*i.EventNameLTE))
	}
	if i.EventNameContains != nil {
		predicates = append(predicates, sourcecontrol.EventNameContains(*i.EventNameContains))
	}
	if i.EventNameHasPrefix != nil {
		predicates = append(predicates, sourcecontrol.EventNameHasPrefix(*i.EventNameHasPrefix))
	}
	if i.EventNameHasSuffix != nil {
		predicates = append(predicates, sourcecontrol.EventNameHasSuffix(*i.EventNameHasSuffix))
	}
	if i.EventNameIsNil {
		predicates = append(predicates, sourcecontrol.EventNameIsNil())
	}
	if i.EventNameNotNil {
		predicates = append(predicates, sourcecontrol.EventNameNotNil())
	}
	if i.EventNameEqualFold != nil {
		predicates = append(predicates, sourcecontrol.EventNameEqualFold(*i.EventNameEqualFold))
	}
	if i.EventNameContainsFold != nil {
		predicates = append(predicates, sourcecontrol.EventNameContainsFold(*i.EventNameContainsFold))
	}
	if i.Workflow != nil {
		predicates = append(predicates, sourcecontrol.WorkflowEQ(*i.Workflow))
	}
	if i.WorkflowNEQ != nil {
		predicates = append(predicates, sourcecontrol.WorkflowNEQ(*i.WorkflowNEQ))
	}
	if len(i.WorkflowIn) > 0 {
		predicates = append(predicates, sourcecontrol.WorkflowIn(i.WorkflowIn...))
	}
	if len(i.WorkflowNotIn) > 0 {
		predicates = append(predicates, sourcecontrol.WorkflowNotIn(i.WorkflowNotIn...))
	}
	if i.WorkflowGT != nil {
		predicates = append(predicates, sourcecontrol.WorkflowGT(*i.WorkflowGT))
	}
	if i.WorkflowGTE != nil {
		predicates = append(predicates, sourcecontrol.WorkflowGTE(*i.WorkflowGTE))
	}
	if i.WorkflowLT != nil {
		predicates = append(predicates, sourcecontrol.WorkflowLT(*i.WorkflowLT))
	}
	if i.WorkflowLTE != nil {
		predicates = append(predicates, sourcecontrol.WorkflowLTE(*i.WorkflowLTE))
	}
	if i.WorkflowContains != nil {
		predicates = append(predicates, sourcecontrol.WorkflowContains(*i.WorkflowContains))
	}
	if i.WorkflowHasPrefix != nil {
		predicates = append(predicates, sourcecontrol.WorkflowHasPrefix(*i.WorkflowHasPrefix))
	}
	if i.WorkflowHasSuffix != nil {
		predicates = append(predicates, sourcecontrol.WorkflowHasSuffix(*i.WorkflowHasSuffix))
	}
	if i.WorkflowIsNil {
		predicates = append(predicates, sourcecontrol.WorkflowIsNil())
	}
	if i.WorkflowNotNil {
		predicates = append(predicates, sourcecontrol.WorkflowNotNil())
	}
	if i.WorkflowEqualFold != nil {
		predicates = append(predicates, sourcecontrol.WorkflowEqualFold(*i.WorkflowEqualFold))
	}
	if i.WorkflowContainsFold != nil {
		predicates = append(predicates, sourcecontrol.WorkflowContainsFold(*i.WorkflowContainsFold))
	}
	if i.RunID != nil {
		predicates = append(predicates, sourcecontrol.RunIDEQ(*i.RunID))
	}
	if i.RunIDNEQ != nil {
		predicates = append(predicates, sourcecontrol.RunIDNEQ(*i.RunIDNEQ))
	}
	if len(i.RunIDIn) > 0 {
		predicates = append(predicates, sourcecontrol.RunIDIn(i.RunIDIn...))
	}
	if len(i.RunIDNotIn) > 0 {
		predicates = append(predicates, sourcecontrol.RunIDNotIn(i.RunIDNotIn...))
	}
	if i.RunIDGT != nil {
		predicates = append(predicates, sourcecontrol.RunIDGT(*i.RunIDGT))
	}
	if i.RunIDGTE != nil {
		predicates = append(predicates, sourcecontrol.RunIDGTE(*i.RunIDGTE))
	}
	if i.RunIDLT != nil {
		predicates = append(predicates, sourcecontrol.RunIDLT(*i.RunIDLT))
	}
	if i.RunIDLTE != nil {
		predicates = append(predicates, sourcecontrol.RunIDLTE(*i.RunIDLTE))
	}
	if i.RunIDContains != nil {
		predicates = append(predicates, sourcecontrol.RunIDContains(*i.RunIDContains))
	}
	if i.RunIDHasPrefix != nil {
		predicates = append(predicates, sourcecontrol.RunIDHasPrefix(*i.RunIDHasPrefix))
	}
	if i.RunIDHasSuffix != nil {
		predicates = append(predicates, sourcecontrol.RunIDHasSuffix(*i.RunIDHasSuffix))
	}
	if i.RunIDIsNil {
		predicates = append(predicates, sourcecontrol.RunIDIsNil())
	}
	if i.RunIDNotNil {
		predicates = append(predicates, sourcecontrol.RunIDNotNil())
	}
	if i.RunIDEqualFold != nil {
		predicates = append(predicates, sourcecontrol.RunIDEqualFold(*i.RunIDEqualFold))
	}
	if i.RunIDContainsFold != nil {
		predicates = append(predicates, sourcecontrol.RunIDContainsFold(*i.RunIDContainsFold))
	}
	if i.RunNumber != nil {
		predicates = append(predicates, sourcecontrol.RunNumberEQ(*i.RunNumber))
	}
	if i.RunNumberNEQ != nil {
		predicates = append(predicates, sourcecontrol.RunNumberNEQ(*i.RunNumberNEQ))
	}
	if len(i.RunNumberIn) > 0 {
		predicates = append(predicates, sourcecontrol.RunNumberIn(i.RunNumberIn...))
	}
	if len(i.RunNumberNotIn) > 0 {
		predicates = append(predicates, sourcecontrol.RunNumberNotIn(i.RunNumberNotIn...))
	}
	if i.RunNumberGT != nil {
		predicates = append(predicates, sourcecontrol.RunNumberGT(*i.RunNumberGT))
	}
	if i.RunNumberGTE != nil {
		predicates = append(predicates, sourcecontrol.RunNumberGTE(*i.RunNumberGTE))
	}
	if i.RunNumberLT != nil {
		predicates = append(predicates, sourcecontrol.RunNumberLT(*i.RunNumberLT))
	}
	if i.RunNumberLTE != nil {
		predicates = append(predicates, sourcecontrol.RunNumberLTE(*i.RunNumberLTE))
	}
	if i.RunNumberContains != nil {
		predicates = append(predicates, sourcecontrol.RunNumberContains(*i.RunNumberContains))
	}
	if i.RunNumberHasPrefix != nil {
		predicates = append(predicates, sourcecontrol.RunNumberHasPrefix(*i.RunNumberHasPrefix))
	}
	if i.RunNumberHasSuffix != nil {
		predicates = append(predicates, sourcecontrol.RunNumberHasSuffix(*i.RunNumberHasSuffix))
	}
	if i.RunNumberIsNil {
		predicates = append(predicates, sourcecontrol.RunNumberIsNil())
	}
	if i.RunNumberNotNil {
		predicates = append(predicates, sourcecontrol.RunNumberNotNil())
	}
	if i.RunNumberEqualFold != nil {
		predicates = append(predicates, sourcecontrol.RunNumberEqualFold(*i.RunNumberEqualFold))
	}
	if i.RunNumberContainsFold != nil {
		predicates = append(predicates, sourcecontrol.RunNumberContainsFold(*i.RunNumberContainsFold))
	}
	if i.Job != nil {
		predicates = append(predicates, sourcecontrol.JobEQ(*i.Job))
	}
	if i.JobNEQ != nil {
		predicates = append(predicates, sourcecontrol.JobNEQ(*i.JobNEQ))
	}
	if len(i.JobIn) > 0 {
		predicates = append(predicates, sourcecontrol.JobIn(i.JobIn...))
	}
	if len(i.JobNotIn) > 0 {
		predicates = append(predicates, sourcecontrol.JobNotIn(i.JobNotIn...))
	}
	if i.JobGT != nil {
		predicates = append(predicates, sourcecontrol.JobGT(*i.JobGT))
	}
	if i.JobGTE != nil {
		predicates = append(predicates, sourcecontrol.JobGTE(*i.JobGTE))
	}
	if i.JobLT != nil {
		predicates = append(predicates, sourcecontrol.JobLT(*i.JobLT))
	}
	if i.JobLTE != nil {
		predicates = append(predicates, sourcecontrol.JobLTE(*i.JobLTE))
	}
	if i.JobContains != nil {
		predicates = append(predicates, sourcecontrol.JobContains(*i.JobContains))
	}
	if i.JobHasPrefix != nil {
		predicates = append(predicates, sourcecontrol.JobHasPrefix(*i.JobHasPrefix))
	}
	if i.JobHasSuffix != nil {
		predicates = append(predicates, sourcecontrol.JobHasSuffix(*i.JobHasSuffix))
	}
	if i.JobIsNil {
		predicates = append(predicates, sourcecontrol.JobIsNil())
	}
	if i.JobNotNil {
		predicates = append(predicates, sourcecontrol.JobNotNil())
	}
	if i.JobEqualFold != nil {
		predicates = append(predicates, sourcecontrol.JobEqualFold(*i.JobEqualFold))
	}
	if i.JobContainsFold != nil {
		predicates = append(predicates, sourcecontrol.JobContainsFold(*i.JobContainsFold))
	}
	if i.Action != nil {
		predicates = append(predicates, sourcecontrol.ActionEQ(*i.Action))
	}
	if i.ActionNEQ != nil {
		predicates = append(predicates, sourcecontrol.ActionNEQ(*i.ActionNEQ))
	}
	if len(i.ActionIn) > 0 {
		predicates = append(predicates, sourcecontrol.ActionIn(i.ActionIn...))
	}
	if len(i.ActionNotIn) > 0 {
		predicates = append(predicates, sourcecontrol.ActionNotIn(i.ActionNotIn...))
	}
	if i.ActionGT != nil {
		predicates = append(predicates, sourcecontrol.ActionGT(*i.ActionGT))
	}
	if i.ActionGTE != nil {
		predicates = append(predicates, sourcecontrol.ActionGTE(*i.ActionGTE))
	}
	if i.ActionLT != nil {
		predicates = append(predicates, sourcecontrol.ActionLT(*i.ActionLT))
	}
	if i.ActionLTE != nil {
		predicates = append(predicates, sourcecontrol.ActionLTE(*i.ActionLTE))
	}
	if i.ActionContains != nil {
		predicates = append(predicates, sourcecontrol.ActionContains(*i.ActionContains))
	}
	if i.ActionHasPrefix != nil {
		predicates = append(predicates, sourcecontrol.ActionHasPrefix(*i.ActionHasPrefix))
	}
	if i.ActionHasSuffix != nil {
		predicates = append(predicates, sourcecontrol.ActionHasSuffix(*i.ActionHasSuffix))
	}
	if i.ActionIsNil {
		predicates = append(predicates, sourcecontrol.ActionIsNil())
	}
	if i.ActionNotNil {
		predicates = append(predicates, sourcecontrol.ActionNotNil())
	}
	if i.ActionEqualFold != nil {
		predicates = append(predicates, sourcecontrol.ActionEqualFold(*i.ActionEqualFold))
	}
	if i.ActionContainsFold != nil {
		predicates = append(predicates, sourcecontrol.ActionContainsFold(*i.ActionContainsFold))
	}
	if i.RunnerName != nil {
		predicates = append(predicates, sourcecontrol.RunnerNameEQ(*i.RunnerName))
	}
	if i.RunnerNameNEQ != nil {
		predicates = append(predicates, sourcecontrol.RunnerNameNEQ(*i.RunnerNameNEQ))
	}
	if len(i.RunnerNameIn) > 0 {
		predicates = append(predicates, sourcecontrol.RunnerNameIn(i.RunnerNameIn...))
	}
	if len(i.RunnerNameNotIn) > 0 {
		predicates = append(predicates, sourcecontrol.RunnerNameNotIn(i.RunnerNameNotIn...))
	}
	if i.RunnerNameGT != nil {
		predicates = append(predicates, sourcecontrol.RunnerNameGT(*i.RunnerNameGT))
	}
	if i.RunnerNameGTE != nil {
		predicates = append(predicates, sourcecontrol.RunnerNameGTE(*i.RunnerNameGTE))
	}
	if i.RunnerNameLT != nil {
		predicates = append(predicates, sourcecontrol.RunnerNameLT(*i.RunnerNameLT))
	}
	if i.RunnerNameLTE != nil {
		predicates = append(predicates, sourcecontrol.RunnerNameLTE(*i.RunnerNameLTE))
	}
	if i.RunnerNameContains != nil {
		predicates = append(predicates, sourcecontrol.RunnerNameContains(*i.RunnerNameContains))
	}
	if i.RunnerNameHasPrefix != nil {
		predicates = append(predicates, sourcecontrol.RunnerNameHasPrefix(*i.RunnerNameHasPrefix))
	}
	if i.RunnerNameHasSuffix != nil {
		predicates = append(predicates, sourcecontrol.RunnerNameHasSuffix(*i.RunnerNameHasSuffix))
	}
	if i.RunnerNameIsNil {
		predicates = append(predicates, sourcecontrol.RunnerNameIsNil())
	}
	if i.RunnerNameNotNil {
		predicates = append(predicates, sourcecontrol.RunnerNameNotNil())
	}
	if i.RunnerNameEqualFold != nil {
		predicates = append(predicates, sourcecontrol.RunnerNameEqualFold(*i.RunnerNameEqualFold))
	}
	if i.RunnerNameContainsFold != nil {
		predicates = append(predicates, sourcecontrol.RunnerNameContainsFold(*i.RunnerNameContainsFold))
	}
	if i.RunnerArch != nil {
		predicates = append(predicates, sourcecontrol.RunnerArchEQ(*i.RunnerArch))
	}
	if i.RunnerArchNEQ != nil {
		predicates = append(predicates, sourcecontrol.RunnerArchNEQ(*i.RunnerArchNEQ))
	}
	if len(i.RunnerArchIn) > 0 {
		predicates = append(predicates, sourcecontrol.RunnerArchIn(i.RunnerArchIn...))
	}
	if len(i.RunnerArchNotIn) > 0 {
		predicates = append(predicates, sourcecontrol.RunnerArchNotIn(i.RunnerArchNotIn...))
	}
	if i.RunnerArchGT != nil {
		predicates = append(predicates, sourcecontrol.RunnerArchGT(*i.RunnerArchGT))
	}
	if i.RunnerArchGTE != nil {
		predicates = append(predicates, sourcecontrol.RunnerArchGTE(*i.RunnerArchGTE))
	}
	if i.RunnerArchLT != nil {
		predicates = append(predicates, sourcecontrol.RunnerArchLT(*i.RunnerArchLT))
	}
	if i.RunnerArchLTE != nil {
		predicates = append(predicates, sourcecontrol.RunnerArchLTE(*i.RunnerArchLTE))
	}
	if i.RunnerArchContains != nil {
		predicates = append(predicates, sourcecontrol.RunnerArchContains(*i.RunnerArchContains))
	}
	if i.RunnerArchHasPrefix != nil {
		predicates = append(predicates, sourcecontrol.RunnerArchHasPrefix(*i.RunnerArchHasPrefix))
	}
	if i.RunnerArchHasSuffix != nil {
		predicates = append(predicates, sourcecontrol.RunnerArchHasSuffix(*i.RunnerArchHasSuffix))
	}
	if i.RunnerArchIsNil {
		predicates = append(predicates, sourcecontrol.RunnerArchIsNil())
	}
	if i.RunnerArchNotNil {
		predicates = append(predicates, sourcecontrol.RunnerArchNotNil())
	}
	if i.RunnerArchEqualFold != nil {
		predicates = append(predicates, sourcecontrol.RunnerArchEqualFold(*i.RunnerArchEqualFold))
	}
	if i.RunnerArchContainsFold != nil {
		predicates = append(predicates, sourcecontrol.RunnerArchContainsFold(*i.RunnerArchContainsFold))
	}
	if i.RunnerOs != nil {
		predicates = append(predicates, sourcecontrol.RunnerOsEQ(*i.RunnerOs))
	}
	if i.RunnerOsNEQ != nil {
		predicates = append(predicates, sourcecontrol.RunnerOsNEQ(*i.RunnerOsNEQ))
	}
	if len(i.RunnerOsIn) > 0 {
		predicates = append(predicates, sourcecontrol.RunnerOsIn(i.RunnerOsIn...))
	}
	if len(i.RunnerOsNotIn) > 0 {
		predicates = append(predicates, sourcecontrol.RunnerOsNotIn(i.RunnerOsNotIn...))
	}
	if i.RunnerOsGT != nil {
		predicates = append(predicates, sourcecontrol.RunnerOsGT(*i.RunnerOsGT))
	}
	if i.RunnerOsGTE != nil {
		predicates = append(predicates, sourcecontrol.RunnerOsGTE(*i.RunnerOsGTE))
	}
	if i.RunnerOsLT != nil {
		predicates = append(predicates, sourcecontrol.RunnerOsLT(*i.RunnerOsLT))
	}
	if i.RunnerOsLTE != nil {
		predicates = append(predicates, sourcecontrol.RunnerOsLTE(*i.RunnerOsLTE))
	}
	if i.RunnerOsContains != nil {
		predicates = append(predicates, sourcecontrol.RunnerOsContains(*i.RunnerOsContains))
	}
	if i.RunnerOsHasPrefix != nil {
		predicates = append(predicates, sourcecontrol.RunnerOsHasPrefix(*i.RunnerOsHasPrefix))
	}
	if i.RunnerOsHasSuffix != nil {
		predicates = append(predicates, sourcecontrol.RunnerOsHasSuffix(*i.RunnerOsHasSuffix))
	}
	if i.RunnerOsIsNil {
		predicates = append(predicates, sourcecontrol.RunnerOsIsNil())
	}
	if i.RunnerOsNotNil {
		predicates = append(predicates, sourcecontrol.RunnerOsNotNil())
	}
	if i.RunnerOsEqualFold != nil {
		predicates = append(predicates, sourcecontrol.RunnerOsEqualFold(*i.RunnerOsEqualFold))
	}
	if i.RunnerOsContainsFold != nil {
		predicates = append(predicates, sourcecontrol.RunnerOsContainsFold(*i.RunnerOsContainsFold))
	}
	if i.Workspace != nil {
		predicates = append(predicates, sourcecontrol.WorkspaceEQ(*i.Workspace))
	}
	if i.WorkspaceNEQ != nil {
		predicates = append(predicates, sourcecontrol.WorkspaceNEQ(*i.WorkspaceNEQ))
	}
	if len(i.WorkspaceIn) > 0 {
		predicates = append(predicates, sourcecontrol.WorkspaceIn(i.WorkspaceIn...))
	}
	if len(i.WorkspaceNotIn) > 0 {
		predicates = append(predicates, sourcecontrol.WorkspaceNotIn(i.WorkspaceNotIn...))
	}
	if i.WorkspaceGT != nil {
		predicates = append(predicates, sourcecontrol.WorkspaceGT(*i.WorkspaceGT))
	}
	if i.WorkspaceGTE != nil {
		predicates = append(predicates, sourcecontrol.WorkspaceGTE(*i.WorkspaceGTE))
	}
	if i.WorkspaceLT != nil {
		predicates = append(predicates, sourcecontrol.WorkspaceLT(*i.WorkspaceLT))
	}
	if i.WorkspaceLTE != nil {
		predicates = append(predicates, sourcecontrol.WorkspaceLTE(*i.WorkspaceLTE))
	}
	if i.WorkspaceContains != nil {
		predicates = append(predicates, sourcecontrol.WorkspaceContains(*i.WorkspaceContains))
	}
	if i.WorkspaceHasPrefix != nil {
		predicates = append(predicates, sourcecontrol.WorkspaceHasPrefix(*i.WorkspaceHasPrefix))
	}
	if i.WorkspaceHasSuffix != nil {
		predicates = append(predicates, sourcecontrol.WorkspaceHasSuffix(*i.WorkspaceHasSuffix))
	}
	if i.WorkspaceIsNil {
		predicates = append(predicates, sourcecontrol.WorkspaceIsNil())
	}
	if i.WorkspaceNotNil {
		predicates = append(predicates, sourcecontrol.WorkspaceNotNil())
	}
	if i.WorkspaceEqualFold != nil {
		predicates = append(predicates, sourcecontrol.WorkspaceEqualFold(*i.WorkspaceEqualFold))
	}
	if i.WorkspaceContainsFold != nil {
		predicates = append(predicates, sourcecontrol.WorkspaceContainsFold(*i.WorkspaceContainsFold))
	}

	if i.HasBazelInvocation != nil {
		p := sourcecontrol.HasBazelInvocation()
		if !*i.HasBazelInvocation {
			p = sourcecontrol.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBazelInvocationWith) > 0 {
		with := make([]predicate.BazelInvocation, 0, len(i.HasBazelInvocationWith))
		for _, w := range i.HasBazelInvocationWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBazelInvocationWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, sourcecontrol.HasBazelInvocationWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptySourceControlWhereInput
	case 1:
		return predicates[0], nil
	default:
		return sourcecontrol.And(predicates...), nil
	}
}

// SystemNetworkStatsWhereInput represents a where input for filtering SystemNetworkStats queries.
type SystemNetworkStatsWhereInput struct {
	Predicates []predicate.SystemNetworkStats  `json:"-"`
	Not        *SystemNetworkStatsWhereInput   `json:"not,omitempty"`
	Or         []*SystemNetworkStatsWhereInput `json:"or,omitempty"`
	And        []*SystemNetworkStatsWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int64  `json:"id,omitempty"`
	IDNEQ   *int64  `json:"idNEQ,omitempty"`
	IDIn    []int64 `json:"idIn,omitempty"`
	IDNotIn []int64 `json:"idNotIn,omitempty"`
	IDGT    *int64  `json:"idGT,omitempty"`
	IDGTE   *int64  `json:"idGTE,omitempty"`
	IDLT    *int64  `json:"idLT,omitempty"`
	IDLTE   *int64  `json:"idLTE,omitempty"`

	// "bytes_sent" field predicates.
	BytesSent       *uint64  `json:"bytesSent,omitempty"`
	BytesSentNEQ    *uint64  `json:"bytesSentNEQ,omitempty"`
	BytesSentIn     []uint64 `json:"bytesSentIn,omitempty"`
	BytesSentNotIn  []uint64 `json:"bytesSentNotIn,omitempty"`
	BytesSentGT     *uint64  `json:"bytesSentGT,omitempty"`
	BytesSentGTE    *uint64  `json:"bytesSentGTE,omitempty"`
	BytesSentLT     *uint64  `json:"bytesSentLT,omitempty"`
	BytesSentLTE    *uint64  `json:"bytesSentLTE,omitempty"`
	BytesSentIsNil  bool     `json:"bytesSentIsNil,omitempty"`
	BytesSentNotNil bool     `json:"bytesSentNotNil,omitempty"`

	// "bytes_recv" field predicates.
	BytesRecv       *uint64  `json:"bytesRecv,omitempty"`
	BytesRecvNEQ    *uint64  `json:"bytesRecvNEQ,omitempty"`
	BytesRecvIn     []uint64 `json:"bytesRecvIn,omitempty"`
	BytesRecvNotIn  []uint64 `json:"bytesRecvNotIn,omitempty"`
	BytesRecvGT     *uint64  `json:"bytesRecvGT,omitempty"`
	BytesRecvGTE    *uint64  `json:"bytesRecvGTE,omitempty"`
	BytesRecvLT     *uint64  `json:"bytesRecvLT,omitempty"`
	BytesRecvLTE    *uint64  `json:"bytesRecvLTE,omitempty"`
	BytesRecvIsNil  bool     `json:"bytesRecvIsNil,omitempty"`
	BytesRecvNotNil bool     `json:"bytesRecvNotNil,omitempty"`

	// "packets_sent" field predicates.
	PacketsSent       *uint64  `json:"packetsSent,omitempty"`
	PacketsSentNEQ    *uint64  `json:"packetsSentNEQ,omitempty"`
	PacketsSentIn     []uint64 `json:"packetsSentIn,omitempty"`
	PacketsSentNotIn  []uint64 `json:"packetsSentNotIn,omitempty"`
	PacketsSentGT     *uint64  `json:"packetsSentGT,omitempty"`
	PacketsSentGTE    *uint64  `json:"packetsSentGTE,omitempty"`
	PacketsSentLT     *uint64  `json:"packetsSentLT,omitempty"`
	PacketsSentLTE    *uint64  `json:"packetsSentLTE,omitempty"`
	PacketsSentIsNil  bool     `json:"packetsSentIsNil,omitempty"`
	PacketsSentNotNil bool     `json:"packetsSentNotNil,omitempty"`

	// "packets_recv" field predicates.
	PacketsRecv       *uint64  `json:"packetsRecv,omitempty"`
	PacketsRecvNEQ    *uint64  `json:"packetsRecvNEQ,omitempty"`
	PacketsRecvIn     []uint64 `json:"packetsRecvIn,omitempty"`
	PacketsRecvNotIn  []uint64 `json:"packetsRecvNotIn,omitempty"`
	PacketsRecvGT     *uint64  `json:"packetsRecvGT,omitempty"`
	PacketsRecvGTE    *uint64  `json:"packetsRecvGTE,omitempty"`
	PacketsRecvLT     *uint64  `json:"packetsRecvLT,omitempty"`
	PacketsRecvLTE    *uint64  `json:"packetsRecvLTE,omitempty"`
	PacketsRecvIsNil  bool     `json:"packetsRecvIsNil,omitempty"`
	PacketsRecvNotNil bool     `json:"packetsRecvNotNil,omitempty"`

	// "peak_bytes_sent_per_sec" field predicates.
	PeakBytesSentPerSec       *uint64  `json:"peakBytesSentPerSec,omitempty"`
	PeakBytesSentPerSecNEQ    *uint64  `json:"peakBytesSentPerSecNEQ,omitempty"`
	PeakBytesSentPerSecIn     []uint64 `json:"peakBytesSentPerSecIn,omitempty"`
	PeakBytesSentPerSecNotIn  []uint64 `json:"peakBytesSentPerSecNotIn,omitempty"`
	PeakBytesSentPerSecGT     *uint64  `json:"peakBytesSentPerSecGT,omitempty"`
	PeakBytesSentPerSecGTE    *uint64  `json:"peakBytesSentPerSecGTE,omitempty"`
	PeakBytesSentPerSecLT     *uint64  `json:"peakBytesSentPerSecLT,omitempty"`
	PeakBytesSentPerSecLTE    *uint64  `json:"peakBytesSentPerSecLTE,omitempty"`
	PeakBytesSentPerSecIsNil  bool     `json:"peakBytesSentPerSecIsNil,omitempty"`
	PeakBytesSentPerSecNotNil bool     `json:"peakBytesSentPerSecNotNil,omitempty"`

	// "peak_bytes_recv_per_sec" field predicates.
	PeakBytesRecvPerSec       *uint64  `json:"peakBytesRecvPerSec,omitempty"`
	PeakBytesRecvPerSecNEQ    *uint64  `json:"peakBytesRecvPerSecNEQ,omitempty"`
	PeakBytesRecvPerSecIn     []uint64 `json:"peakBytesRecvPerSecIn,omitempty"`
	PeakBytesRecvPerSecNotIn  []uint64 `json:"peakBytesRecvPerSecNotIn,omitempty"`
	PeakBytesRecvPerSecGT     *uint64  `json:"peakBytesRecvPerSecGT,omitempty"`
	PeakBytesRecvPerSecGTE    *uint64  `json:"peakBytesRecvPerSecGTE,omitempty"`
	PeakBytesRecvPerSecLT     *uint64  `json:"peakBytesRecvPerSecLT,omitempty"`
	PeakBytesRecvPerSecLTE    *uint64  `json:"peakBytesRecvPerSecLTE,omitempty"`
	PeakBytesRecvPerSecIsNil  bool     `json:"peakBytesRecvPerSecIsNil,omitempty"`
	PeakBytesRecvPerSecNotNil bool     `json:"peakBytesRecvPerSecNotNil,omitempty"`

	// "peak_packets_sent_per_sec" field predicates.
	PeakPacketsSentPerSec       *uint64  `json:"peakPacketsSentPerSec,omitempty"`
	PeakPacketsSentPerSecNEQ    *uint64  `json:"peakPacketsSentPerSecNEQ,omitempty"`
	PeakPacketsSentPerSecIn     []uint64 `json:"peakPacketsSentPerSecIn,omitempty"`
	PeakPacketsSentPerSecNotIn  []uint64 `json:"peakPacketsSentPerSecNotIn,omitempty"`
	PeakPacketsSentPerSecGT     *uint64  `json:"peakPacketsSentPerSecGT,omitempty"`
	PeakPacketsSentPerSecGTE    *uint64  `json:"peakPacketsSentPerSecGTE,omitempty"`
	PeakPacketsSentPerSecLT     *uint64  `json:"peakPacketsSentPerSecLT,omitempty"`
	PeakPacketsSentPerSecLTE    *uint64  `json:"peakPacketsSentPerSecLTE,omitempty"`
	PeakPacketsSentPerSecIsNil  bool     `json:"peakPacketsSentPerSecIsNil,omitempty"`
	PeakPacketsSentPerSecNotNil bool     `json:"peakPacketsSentPerSecNotNil,omitempty"`

	// "peak_packets_recv_per_sec" field predicates.
	PeakPacketsRecvPerSec       *uint64  `json:"peakPacketsRecvPerSec,omitempty"`
	PeakPacketsRecvPerSecNEQ    *uint64  `json:"peakPacketsRecvPerSecNEQ,omitempty"`
	PeakPacketsRecvPerSecIn     []uint64 `json:"peakPacketsRecvPerSecIn,omitempty"`
	PeakPacketsRecvPerSecNotIn  []uint64 `json:"peakPacketsRecvPerSecNotIn,omitempty"`
	PeakPacketsRecvPerSecGT     *uint64  `json:"peakPacketsRecvPerSecGT,omitempty"`
	PeakPacketsRecvPerSecGTE    *uint64  `json:"peakPacketsRecvPerSecGTE,omitempty"`
	PeakPacketsRecvPerSecLT     *uint64  `json:"peakPacketsRecvPerSecLT,omitempty"`
	PeakPacketsRecvPerSecLTE    *uint64  `json:"peakPacketsRecvPerSecLTE,omitempty"`
	PeakPacketsRecvPerSecIsNil  bool     `json:"peakPacketsRecvPerSecIsNil,omitempty"`
	PeakPacketsRecvPerSecNotNil bool     `json:"peakPacketsRecvPerSecNotNil,omitempty"`

	// "network_metrics" edge predicates.
	HasNetworkMetrics     *bool                       `json:"hasNetworkMetrics,omitempty"`
	HasNetworkMetricsWith []*NetworkMetricsWhereInput `json:"hasNetworkMetricsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *SystemNetworkStatsWhereInput) AddPredicates(predicates ...predicate.SystemNetworkStats) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the SystemNetworkStatsWhereInput filter on the SystemNetworkStatsQuery builder.
func (i *SystemNetworkStatsWhereInput) Filter(q *SystemNetworkStatsQuery) (*SystemNetworkStatsQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptySystemNetworkStatsWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptySystemNetworkStatsWhereInput is returned in case the SystemNetworkStatsWhereInput is empty.
var ErrEmptySystemNetworkStatsWhereInput = errors.New("ent: empty predicate SystemNetworkStatsWhereInput")

// P returns a predicate for filtering systemnetworkstatsslice.
// An error is returned if the input is empty or invalid.
func (i *SystemNetworkStatsWhereInput) P() (predicate.SystemNetworkStats, error) {
	var predicates []predicate.SystemNetworkStats
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, systemnetworkstats.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.SystemNetworkStats, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, systemnetworkstats.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.SystemNetworkStats, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, systemnetworkstats.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, systemnetworkstats.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, systemnetworkstats.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, systemnetworkstats.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, systemnetworkstats.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, systemnetworkstats.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, systemnetworkstats.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, systemnetworkstats.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, systemnetworkstats.IDLTE(*i.IDLTE))
	}
	if i.BytesSent != nil {
		predicates = append(predicates, systemnetworkstats.BytesSentEQ(*i.BytesSent))
	}
	if i.BytesSentNEQ != nil {
		predicates = append(predicates, systemnetworkstats.BytesSentNEQ(*i.BytesSentNEQ))
	}
	if len(i.BytesSentIn) > 0 {
		predicates = append(predicates, systemnetworkstats.BytesSentIn(i.BytesSentIn...))
	}
	if len(i.BytesSentNotIn) > 0 {
		predicates = append(predicates, systemnetworkstats.BytesSentNotIn(i.BytesSentNotIn...))
	}
	if i.BytesSentGT != nil {
		predicates = append(predicates, systemnetworkstats.BytesSentGT(*i.BytesSentGT))
	}
	if i.BytesSentGTE != nil {
		predicates = append(predicates, systemnetworkstats.BytesSentGTE(*i.BytesSentGTE))
	}
	if i.BytesSentLT != nil {
		predicates = append(predicates, systemnetworkstats.BytesSentLT(*i.BytesSentLT))
	}
	if i.BytesSentLTE != nil {
		predicates = append(predicates, systemnetworkstats.BytesSentLTE(*i.BytesSentLTE))
	}
	if i.BytesSentIsNil {
		predicates = append(predicates, systemnetworkstats.BytesSentIsNil())
	}
	if i.BytesSentNotNil {
		predicates = append(predicates, systemnetworkstats.BytesSentNotNil())
	}
	if i.BytesRecv != nil {
		predicates = append(predicates, systemnetworkstats.BytesRecvEQ(*i.BytesRecv))
	}
	if i.BytesRecvNEQ != nil {
		predicates = append(predicates, systemnetworkstats.BytesRecvNEQ(*i.BytesRecvNEQ))
	}
	if len(i.BytesRecvIn) > 0 {
		predicates = append(predicates, systemnetworkstats.BytesRecvIn(i.BytesRecvIn...))
	}
	if len(i.BytesRecvNotIn) > 0 {
		predicates = append(predicates, systemnetworkstats.BytesRecvNotIn(i.BytesRecvNotIn...))
	}
	if i.BytesRecvGT != nil {
		predicates = append(predicates, systemnetworkstats.BytesRecvGT(*i.BytesRecvGT))
	}
	if i.BytesRecvGTE != nil {
		predicates = append(predicates, systemnetworkstats.BytesRecvGTE(*i.BytesRecvGTE))
	}
	if i.BytesRecvLT != nil {
		predicates = append(predicates, systemnetworkstats.BytesRecvLT(*i.BytesRecvLT))
	}
	if i.BytesRecvLTE != nil {
		predicates = append(predicates, systemnetworkstats.BytesRecvLTE(*i.BytesRecvLTE))
	}
	if i.BytesRecvIsNil {
		predicates = append(predicates, systemnetworkstats.BytesRecvIsNil())
	}
	if i.BytesRecvNotNil {
		predicates = append(predicates, systemnetworkstats.BytesRecvNotNil())
	}
	if i.PacketsSent != nil {
		predicates = append(predicates, systemnetworkstats.PacketsSentEQ(*i.PacketsSent))
	}
	if i.PacketsSentNEQ != nil {
		predicates = append(predicates, systemnetworkstats.PacketsSentNEQ(*i.PacketsSentNEQ))
	}
	if len(i.PacketsSentIn) > 0 {
		predicates = append(predicates, systemnetworkstats.PacketsSentIn(i.PacketsSentIn...))
	}
	if len(i.PacketsSentNotIn) > 0 {
		predicates = append(predicates, systemnetworkstats.PacketsSentNotIn(i.PacketsSentNotIn...))
	}
	if i.PacketsSentGT != nil {
		predicates = append(predicates, systemnetworkstats.PacketsSentGT(*i.PacketsSentGT))
	}
	if i.PacketsSentGTE != nil {
		predicates = append(predicates, systemnetworkstats.PacketsSentGTE(*i.PacketsSentGTE))
	}
	if i.PacketsSentLT != nil {
		predicates = append(predicates, systemnetworkstats.PacketsSentLT(*i.PacketsSentLT))
	}
	if i.PacketsSentLTE != nil {
		predicates = append(predicates, systemnetworkstats.PacketsSentLTE(*i.PacketsSentLTE))
	}
	if i.PacketsSentIsNil {
		predicates = append(predicates, systemnetworkstats.PacketsSentIsNil())
	}
	if i.PacketsSentNotNil {
		predicates = append(predicates, systemnetworkstats.PacketsSentNotNil())
	}
	if i.PacketsRecv != nil {
		predicates = append(predicates, systemnetworkstats.PacketsRecvEQ(*i.PacketsRecv))
	}
	if i.PacketsRecvNEQ != nil {
		predicates = append(predicates, systemnetworkstats.PacketsRecvNEQ(*i.PacketsRecvNEQ))
	}
	if len(i.PacketsRecvIn) > 0 {
		predicates = append(predicates, systemnetworkstats.PacketsRecvIn(i.PacketsRecvIn...))
	}
	if len(i.PacketsRecvNotIn) > 0 {
		predicates = append(predicates, systemnetworkstats.PacketsRecvNotIn(i.PacketsRecvNotIn...))
	}
	if i.PacketsRecvGT != nil {
		predicates = append(predicates, systemnetworkstats.PacketsRecvGT(*i.PacketsRecvGT))
	}
	if i.PacketsRecvGTE != nil {
		predicates = append(predicates, systemnetworkstats.PacketsRecvGTE(*i.PacketsRecvGTE))
	}
	if i.PacketsRecvLT != nil {
		predicates = append(predicates, systemnetworkstats.PacketsRecvLT(*i.PacketsRecvLT))
	}
	if i.PacketsRecvLTE != nil {
		predicates = append(predicates, systemnetworkstats.PacketsRecvLTE(*i.PacketsRecvLTE))
	}
	if i.PacketsRecvIsNil {
		predicates = append(predicates, systemnetworkstats.PacketsRecvIsNil())
	}
	if i.PacketsRecvNotNil {
		predicates = append(predicates, systemnetworkstats.PacketsRecvNotNil())
	}
	if i.PeakBytesSentPerSec != nil {
		predicates = append(predicates, systemnetworkstats.PeakBytesSentPerSecEQ(*i.PeakBytesSentPerSec))
	}
	if i.PeakBytesSentPerSecNEQ != nil {
		predicates = append(predicates, systemnetworkstats.PeakBytesSentPerSecNEQ(*i.PeakBytesSentPerSecNEQ))
	}
	if len(i.PeakBytesSentPerSecIn) > 0 {
		predicates = append(predicates, systemnetworkstats.PeakBytesSentPerSecIn(i.PeakBytesSentPerSecIn...))
	}
	if len(i.PeakBytesSentPerSecNotIn) > 0 {
		predicates = append(predicates, systemnetworkstats.PeakBytesSentPerSecNotIn(i.PeakBytesSentPerSecNotIn...))
	}
	if i.PeakBytesSentPerSecGT != nil {
		predicates = append(predicates, systemnetworkstats.PeakBytesSentPerSecGT(*i.PeakBytesSentPerSecGT))
	}
	if i.PeakBytesSentPerSecGTE != nil {
		predicates = append(predicates, systemnetworkstats.PeakBytesSentPerSecGTE(*i.PeakBytesSentPerSecGTE))
	}
	if i.PeakBytesSentPerSecLT != nil {
		predicates = append(predicates, systemnetworkstats.PeakBytesSentPerSecLT(*i.PeakBytesSentPerSecLT))
	}
	if i.PeakBytesSentPerSecLTE != nil {
		predicates = append(predicates, systemnetworkstats.PeakBytesSentPerSecLTE(*i.PeakBytesSentPerSecLTE))
	}
	if i.PeakBytesSentPerSecIsNil {
		predicates = append(predicates, systemnetworkstats.PeakBytesSentPerSecIsNil())
	}
	if i.PeakBytesSentPerSecNotNil {
		predicates = append(predicates, systemnetworkstats.PeakBytesSentPerSecNotNil())
	}
	if i.PeakBytesRecvPerSec != nil {
		predicates = append(predicates, systemnetworkstats.PeakBytesRecvPerSecEQ(*i.PeakBytesRecvPerSec))
	}
	if i.PeakBytesRecvPerSecNEQ != nil {
		predicates = append(predicates, systemnetworkstats.PeakBytesRecvPerSecNEQ(*i.PeakBytesRecvPerSecNEQ))
	}
	if len(i.PeakBytesRecvPerSecIn) > 0 {
		predicates = append(predicates, systemnetworkstats.PeakBytesRecvPerSecIn(i.PeakBytesRecvPerSecIn...))
	}
	if len(i.PeakBytesRecvPerSecNotIn) > 0 {
		predicates = append(predicates, systemnetworkstats.PeakBytesRecvPerSecNotIn(i.PeakBytesRecvPerSecNotIn...))
	}
	if i.PeakBytesRecvPerSecGT != nil {
		predicates = append(predicates, systemnetworkstats.PeakBytesRecvPerSecGT(*i.PeakBytesRecvPerSecGT))
	}
	if i.PeakBytesRecvPerSecGTE != nil {
		predicates = append(predicates, systemnetworkstats.PeakBytesRecvPerSecGTE(*i.PeakBytesRecvPerSecGTE))
	}
	if i.PeakBytesRecvPerSecLT != nil {
		predicates = append(predicates, systemnetworkstats.PeakBytesRecvPerSecLT(*i.PeakBytesRecvPerSecLT))
	}
	if i.PeakBytesRecvPerSecLTE != nil {
		predicates = append(predicates, systemnetworkstats.PeakBytesRecvPerSecLTE(*i.PeakBytesRecvPerSecLTE))
	}
	if i.PeakBytesRecvPerSecIsNil {
		predicates = append(predicates, systemnetworkstats.PeakBytesRecvPerSecIsNil())
	}
	if i.PeakBytesRecvPerSecNotNil {
		predicates = append(predicates, systemnetworkstats.PeakBytesRecvPerSecNotNil())
	}
	if i.PeakPacketsSentPerSec != nil {
		predicates = append(predicates, systemnetworkstats.PeakPacketsSentPerSecEQ(*i.PeakPacketsSentPerSec))
	}
	if i.PeakPacketsSentPerSecNEQ != nil {
		predicates = append(predicates, systemnetworkstats.PeakPacketsSentPerSecNEQ(*i.PeakPacketsSentPerSecNEQ))
	}
	if len(i.PeakPacketsSentPerSecIn) > 0 {
		predicates = append(predicates, systemnetworkstats.PeakPacketsSentPerSecIn(i.PeakPacketsSentPerSecIn...))
	}
	if len(i.PeakPacketsSentPerSecNotIn) > 0 {
		predicates = append(predicates, systemnetworkstats.PeakPacketsSentPerSecNotIn(i.PeakPacketsSentPerSecNotIn...))
	}
	if i.PeakPacketsSentPerSecGT != nil {
		predicates = append(predicates, systemnetworkstats.PeakPacketsSentPerSecGT(*i.PeakPacketsSentPerSecGT))
	}
	if i.PeakPacketsSentPerSecGTE != nil {
		predicates = append(predicates, systemnetworkstats.PeakPacketsSentPerSecGTE(*i.PeakPacketsSentPerSecGTE))
	}
	if i.PeakPacketsSentPerSecLT != nil {
		predicates = append(predicates, systemnetworkstats.PeakPacketsSentPerSecLT(*i.PeakPacketsSentPerSecLT))
	}
	if i.PeakPacketsSentPerSecLTE != nil {
		predicates = append(predicates, systemnetworkstats.PeakPacketsSentPerSecLTE(*i.PeakPacketsSentPerSecLTE))
	}
	if i.PeakPacketsSentPerSecIsNil {
		predicates = append(predicates, systemnetworkstats.PeakPacketsSentPerSecIsNil())
	}
	if i.PeakPacketsSentPerSecNotNil {
		predicates = append(predicates, systemnetworkstats.PeakPacketsSentPerSecNotNil())
	}
	if i.PeakPacketsRecvPerSec != nil {
		predicates = append(predicates, systemnetworkstats.PeakPacketsRecvPerSecEQ(*i.PeakPacketsRecvPerSec))
	}
	if i.PeakPacketsRecvPerSecNEQ != nil {
		predicates = append(predicates, systemnetworkstats.PeakPacketsRecvPerSecNEQ(*i.PeakPacketsRecvPerSecNEQ))
	}
	if len(i.PeakPacketsRecvPerSecIn) > 0 {
		predicates = append(predicates, systemnetworkstats.PeakPacketsRecvPerSecIn(i.PeakPacketsRecvPerSecIn...))
	}
	if len(i.PeakPacketsRecvPerSecNotIn) > 0 {
		predicates = append(predicates, systemnetworkstats.PeakPacketsRecvPerSecNotIn(i.PeakPacketsRecvPerSecNotIn...))
	}
	if i.PeakPacketsRecvPerSecGT != nil {
		predicates = append(predicates, systemnetworkstats.PeakPacketsRecvPerSecGT(*i.PeakPacketsRecvPerSecGT))
	}
	if i.PeakPacketsRecvPerSecGTE != nil {
		predicates = append(predicates, systemnetworkstats.PeakPacketsRecvPerSecGTE(*i.PeakPacketsRecvPerSecGTE))
	}
	if i.PeakPacketsRecvPerSecLT != nil {
		predicates = append(predicates, systemnetworkstats.PeakPacketsRecvPerSecLT(*i.PeakPacketsRecvPerSecLT))
	}
	if i.PeakPacketsRecvPerSecLTE != nil {
		predicates = append(predicates, systemnetworkstats.PeakPacketsRecvPerSecLTE(*i.PeakPacketsRecvPerSecLTE))
	}
	if i.PeakPacketsRecvPerSecIsNil {
		predicates = append(predicates, systemnetworkstats.PeakPacketsRecvPerSecIsNil())
	}
	if i.PeakPacketsRecvPerSecNotNil {
		predicates = append(predicates, systemnetworkstats.PeakPacketsRecvPerSecNotNil())
	}

	if i.HasNetworkMetrics != nil {
		p := systemnetworkstats.HasNetworkMetrics()
		if !*i.HasNetworkMetrics {
			p = systemnetworkstats.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasNetworkMetricsWith) > 0 {
		with := make([]predicate.NetworkMetrics, 0, len(i.HasNetworkMetricsWith))
		for _, w := range i.HasNetworkMetricsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasNetworkMetricsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, systemnetworkstats.HasNetworkMetricsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptySystemNetworkStatsWhereInput
	case 1:
		return predicates[0], nil
	default:
		return systemnetworkstats.And(predicates...), nil
	}
}

// TargetWhereInput represents a where input for filtering Target queries.
type TargetWhereInput struct {
	Predicates []predicate.Target  `json:"-"`
	Not        *TargetWhereInput   `json:"not,omitempty"`
	Or         []*TargetWhereInput `json:"or,omitempty"`
	And        []*TargetWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int64  `json:"id,omitempty"`
	IDNEQ   *int64  `json:"idNEQ,omitempty"`
	IDIn    []int64 `json:"idIn,omitempty"`
	IDNotIn []int64 `json:"idNotIn,omitempty"`
	IDGT    *int64  `json:"idGT,omitempty"`
	IDGTE   *int64  `json:"idGTE,omitempty"`
	IDLT    *int64  `json:"idLT,omitempty"`
	IDLTE   *int64  `json:"idLTE,omitempty"`

	// "label" field predicates.
	Label             *string  `json:"label,omitempty"`
	LabelNEQ          *string  `json:"labelNEQ,omitempty"`
	LabelIn           []string `json:"labelIn,omitempty"`
	LabelNotIn        []string `json:"labelNotIn,omitempty"`
	LabelGT           *string  `json:"labelGT,omitempty"`
	LabelGTE          *string  `json:"labelGTE,omitempty"`
	LabelLT           *string  `json:"labelLT,omitempty"`
	LabelLTE          *string  `json:"labelLTE,omitempty"`
	LabelContains     *string  `json:"labelContains,omitempty"`
	LabelHasPrefix    *string  `json:"labelHasPrefix,omitempty"`
	LabelHasSuffix    *string  `json:"labelHasSuffix,omitempty"`
	LabelEqualFold    *string  `json:"labelEqualFold,omitempty"`
	LabelContainsFold *string  `json:"labelContainsFold,omitempty"`

	// "aspect" field predicates.
	Aspect             *string  `json:"aspect,omitempty"`
	AspectNEQ          *string  `json:"aspectNEQ,omitempty"`
	AspectIn           []string `json:"aspectIn,omitempty"`
	AspectNotIn        []string `json:"aspectNotIn,omitempty"`
	AspectGT           *string  `json:"aspectGT,omitempty"`
	AspectGTE          *string  `json:"aspectGTE,omitempty"`
	AspectLT           *string  `json:"aspectLT,omitempty"`
	AspectLTE          *string  `json:"aspectLTE,omitempty"`
	AspectContains     *string  `json:"aspectContains,omitempty"`
	AspectHasPrefix    *string  `json:"aspectHasPrefix,omitempty"`
	AspectHasSuffix    *string  `json:"aspectHasSuffix,omitempty"`
	AspectEqualFold    *string  `json:"aspectEqualFold,omitempty"`
	AspectContainsFold *string  `json:"aspectContainsFold,omitempty"`

	// "target_kind" field predicates.
	TargetKind             *string  `json:"targetKind,omitempty"`
	TargetKindNEQ          *string  `json:"targetKindNEQ,omitempty"`
	TargetKindIn           []string `json:"targetKindIn,omitempty"`
	TargetKindNotIn        []string `json:"targetKindNotIn,omitempty"`
	TargetKindGT           *string  `json:"targetKindGT,omitempty"`
	TargetKindGTE          *string  `json:"targetKindGTE,omitempty"`
	TargetKindLT           *string  `json:"targetKindLT,omitempty"`
	TargetKindLTE          *string  `json:"targetKindLTE,omitempty"`
	TargetKindContains     *string  `json:"targetKindContains,omitempty"`
	TargetKindHasPrefix    *string  `json:"targetKindHasPrefix,omitempty"`
	TargetKindHasSuffix    *string  `json:"targetKindHasSuffix,omitempty"`
	TargetKindEqualFold    *string  `json:"targetKindEqualFold,omitempty"`
	TargetKindContainsFold *string  `json:"targetKindContainsFold,omitempty"`

	// "instance_name" edge predicates.
	HasInstanceName     *bool                     `json:"hasInstanceName,omitempty"`
	HasInstanceNameWith []*InstanceNameWhereInput `json:"hasInstanceNameWith,omitempty"`

	// "invocation_targets" edge predicates.
	HasInvocationTargets     *bool                         `json:"hasInvocationTargets,omitempty"`
	HasInvocationTargetsWith []*InvocationTargetWhereInput `json:"hasInvocationTargetsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *TargetWhereInput) AddPredicates(predicates ...predicate.Target) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the TargetWhereInput filter on the TargetQuery builder.
func (i *TargetWhereInput) Filter(q *TargetQuery) (*TargetQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyTargetWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyTargetWhereInput is returned in case the TargetWhereInput is empty.
var ErrEmptyTargetWhereInput = errors.New("ent: empty predicate TargetWhereInput")

// P returns a predicate for filtering targets.
// An error is returned if the input is empty or invalid.
func (i *TargetWhereInput) P() (predicate.Target, error) {
	var predicates []predicate.Target
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, target.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Target, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, target.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Target, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, target.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, target.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, target.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, target.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, target.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, target.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, target.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, target.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, target.IDLTE(*i.IDLTE))
	}
	if i.Label != nil {
		predicates = append(predicates, target.LabelEQ(*i.Label))
	}
	if i.LabelNEQ != nil {
		predicates = append(predicates, target.LabelNEQ(*i.LabelNEQ))
	}
	if len(i.LabelIn) > 0 {
		predicates = append(predicates, target.LabelIn(i.LabelIn...))
	}
	if len(i.LabelNotIn) > 0 {
		predicates = append(predicates, target.LabelNotIn(i.LabelNotIn...))
	}
	if i.LabelGT != nil {
		predicates = append(predicates, target.LabelGT(*i.LabelGT))
	}
	if i.LabelGTE != nil {
		predicates = append(predicates, target.LabelGTE(*i.LabelGTE))
	}
	if i.LabelLT != nil {
		predicates = append(predicates, target.LabelLT(*i.LabelLT))
	}
	if i.LabelLTE != nil {
		predicates = append(predicates, target.LabelLTE(*i.LabelLTE))
	}
	if i.LabelContains != nil {
		predicates = append(predicates, target.LabelContains(*i.LabelContains))
	}
	if i.LabelHasPrefix != nil {
		predicates = append(predicates, target.LabelHasPrefix(*i.LabelHasPrefix))
	}
	if i.LabelHasSuffix != nil {
		predicates = append(predicates, target.LabelHasSuffix(*i.LabelHasSuffix))
	}
	if i.LabelEqualFold != nil {
		predicates = append(predicates, target.LabelEqualFold(*i.LabelEqualFold))
	}
	if i.LabelContainsFold != nil {
		predicates = append(predicates, target.LabelContainsFold(*i.LabelContainsFold))
	}
	if i.Aspect != nil {
		predicates = append(predicates, target.AspectEQ(*i.Aspect))
	}
	if i.AspectNEQ != nil {
		predicates = append(predicates, target.AspectNEQ(*i.AspectNEQ))
	}
	if len(i.AspectIn) > 0 {
		predicates = append(predicates, target.AspectIn(i.AspectIn...))
	}
	if len(i.AspectNotIn) > 0 {
		predicates = append(predicates, target.AspectNotIn(i.AspectNotIn...))
	}
	if i.AspectGT != nil {
		predicates = append(predicates, target.AspectGT(*i.AspectGT))
	}
	if i.AspectGTE != nil {
		predicates = append(predicates, target.AspectGTE(*i.AspectGTE))
	}
	if i.AspectLT != nil {
		predicates = append(predicates, target.AspectLT(*i.AspectLT))
	}
	if i.AspectLTE != nil {
		predicates = append(predicates, target.AspectLTE(*i.AspectLTE))
	}
	if i.AspectContains != nil {
		predicates = append(predicates, target.AspectContains(*i.AspectContains))
	}
	if i.AspectHasPrefix != nil {
		predicates = append(predicates, target.AspectHasPrefix(*i.AspectHasPrefix))
	}
	if i.AspectHasSuffix != nil {
		predicates = append(predicates, target.AspectHasSuffix(*i.AspectHasSuffix))
	}
	if i.AspectEqualFold != nil {
		predicates = append(predicates, target.AspectEqualFold(*i.AspectEqualFold))
	}
	if i.AspectContainsFold != nil {
		predicates = append(predicates, target.AspectContainsFold(*i.AspectContainsFold))
	}
	if i.TargetKind != nil {
		predicates = append(predicates, target.TargetKindEQ(*i.TargetKind))
	}
	if i.TargetKindNEQ != nil {
		predicates = append(predicates, target.TargetKindNEQ(*i.TargetKindNEQ))
	}
	if len(i.TargetKindIn) > 0 {
		predicates = append(predicates, target.TargetKindIn(i.TargetKindIn...))
	}
	if len(i.TargetKindNotIn) > 0 {
		predicates = append(predicates, target.TargetKindNotIn(i.TargetKindNotIn...))
	}
	if i.TargetKindGT != nil {
		predicates = append(predicates, target.TargetKindGT(*i.TargetKindGT))
	}
	if i.TargetKindGTE != nil {
		predicates = append(predicates, target.TargetKindGTE(*i.TargetKindGTE))
	}
	if i.TargetKindLT != nil {
		predicates = append(predicates, target.TargetKindLT(*i.TargetKindLT))
	}
	if i.TargetKindLTE != nil {
		predicates = append(predicates, target.TargetKindLTE(*i.TargetKindLTE))
	}
	if i.TargetKindContains != nil {
		predicates = append(predicates, target.TargetKindContains(*i.TargetKindContains))
	}
	if i.TargetKindHasPrefix != nil {
		predicates = append(predicates, target.TargetKindHasPrefix(*i.TargetKindHasPrefix))
	}
	if i.TargetKindHasSuffix != nil {
		predicates = append(predicates, target.TargetKindHasSuffix(*i.TargetKindHasSuffix))
	}
	if i.TargetKindEqualFold != nil {
		predicates = append(predicates, target.TargetKindEqualFold(*i.TargetKindEqualFold))
	}
	if i.TargetKindContainsFold != nil {
		predicates = append(predicates, target.TargetKindContainsFold(*i.TargetKindContainsFold))
	}

	if i.HasInstanceName != nil {
		p := target.HasInstanceName()
		if !*i.HasInstanceName {
			p = target.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasInstanceNameWith) > 0 {
		with := make([]predicate.InstanceName, 0, len(i.HasInstanceNameWith))
		for _, w := range i.HasInstanceNameWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasInstanceNameWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, target.HasInstanceNameWith(with...))
	}
	if i.HasInvocationTargets != nil {
		p := target.HasInvocationTargets()
		if !*i.HasInvocationTargets {
			p = target.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasInvocationTargetsWith) > 0 {
		with := make([]predicate.InvocationTarget, 0, len(i.HasInvocationTargetsWith))
		for _, w := range i.HasInvocationTargetsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasInvocationTargetsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, target.HasInvocationTargetsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyTargetWhereInput
	case 1:
		return predicates[0], nil
	default:
		return target.And(predicates...), nil
	}
}

// TargetMetricsWhereInput represents a where input for filtering TargetMetrics queries.
type TargetMetricsWhereInput struct {
	Predicates []predicate.TargetMetrics  `json:"-"`
	Not        *TargetMetricsWhereInput   `json:"not,omitempty"`
	Or         []*TargetMetricsWhereInput `json:"or,omitempty"`
	And        []*TargetMetricsWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int64  `json:"id,omitempty"`
	IDNEQ   *int64  `json:"idNEQ,omitempty"`
	IDIn    []int64 `json:"idIn,omitempty"`
	IDNotIn []int64 `json:"idNotIn,omitempty"`
	IDGT    *int64  `json:"idGT,omitempty"`
	IDGTE   *int64  `json:"idGTE,omitempty"`
	IDLT    *int64  `json:"idLT,omitempty"`
	IDLTE   *int64  `json:"idLTE,omitempty"`

	// "targets_loaded" field predicates.
	TargetsLoaded       *int64  `json:"targetsLoaded,omitempty"`
	TargetsLoadedNEQ    *int64  `json:"targetsLoadedNEQ,omitempty"`
	TargetsLoadedIn     []int64 `json:"targetsLoadedIn,omitempty"`
	TargetsLoadedNotIn  []int64 `json:"targetsLoadedNotIn,omitempty"`
	TargetsLoadedGT     *int64  `json:"targetsLoadedGT,omitempty"`
	TargetsLoadedGTE    *int64  `json:"targetsLoadedGTE,omitempty"`
	TargetsLoadedLT     *int64  `json:"targetsLoadedLT,omitempty"`
	TargetsLoadedLTE    *int64  `json:"targetsLoadedLTE,omitempty"`
	TargetsLoadedIsNil  bool    `json:"targetsLoadedIsNil,omitempty"`
	TargetsLoadedNotNil bool    `json:"targetsLoadedNotNil,omitempty"`

	// "targets_configured" field predicates.
	TargetsConfigured       *int64  `json:"targetsConfigured,omitempty"`
	TargetsConfiguredNEQ    *int64  `json:"targetsConfiguredNEQ,omitempty"`
	TargetsConfiguredIn     []int64 `json:"targetsConfiguredIn,omitempty"`
	TargetsConfiguredNotIn  []int64 `json:"targetsConfiguredNotIn,omitempty"`
	TargetsConfiguredGT     *int64  `json:"targetsConfiguredGT,omitempty"`
	TargetsConfiguredGTE    *int64  `json:"targetsConfiguredGTE,omitempty"`
	TargetsConfiguredLT     *int64  `json:"targetsConfiguredLT,omitempty"`
	TargetsConfiguredLTE    *int64  `json:"targetsConfiguredLTE,omitempty"`
	TargetsConfiguredIsNil  bool    `json:"targetsConfiguredIsNil,omitempty"`
	TargetsConfiguredNotNil bool    `json:"targetsConfiguredNotNil,omitempty"`

	// "targets_configured_not_including_aspects" field predicates.
	TargetsConfiguredNotIncludingAspects       *int64  `json:"targetsConfiguredNotIncludingAspects,omitempty"`
	TargetsConfiguredNotIncludingAspectsNEQ    *int64  `json:"targetsConfiguredNotIncludingAspectsNEQ,omitempty"`
	TargetsConfiguredNotIncludingAspectsIn     []int64 `json:"targetsConfiguredNotIncludingAspectsIn,omitempty"`
	TargetsConfiguredNotIncludingAspectsNotIn  []int64 `json:"targetsConfiguredNotIncludingAspectsNotIn,omitempty"`
	TargetsConfiguredNotIncludingAspectsGT     *int64  `json:"targetsConfiguredNotIncludingAspectsGT,omitempty"`
	TargetsConfiguredNotIncludingAspectsGTE    *int64  `json:"targetsConfiguredNotIncludingAspectsGTE,omitempty"`
	TargetsConfiguredNotIncludingAspectsLT     *int64  `json:"targetsConfiguredNotIncludingAspectsLT,omitempty"`
	TargetsConfiguredNotIncludingAspectsLTE    *int64  `json:"targetsConfiguredNotIncludingAspectsLTE,omitempty"`
	TargetsConfiguredNotIncludingAspectsIsNil  bool    `json:"targetsConfiguredNotIncludingAspectsIsNil,omitempty"`
	TargetsConfiguredNotIncludingAspectsNotNil bool    `json:"targetsConfiguredNotIncludingAspectsNotNil,omitempty"`

	// "metrics" edge predicates.
	HasMetrics     *bool                `json:"hasMetrics,omitempty"`
	HasMetricsWith []*MetricsWhereInput `json:"hasMetricsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *TargetMetricsWhereInput) AddPredicates(predicates ...predicate.TargetMetrics) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the TargetMetricsWhereInput filter on the TargetMetricsQuery builder.
func (i *TargetMetricsWhereInput) Filter(q *TargetMetricsQuery) (*TargetMetricsQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyTargetMetricsWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyTargetMetricsWhereInput is returned in case the TargetMetricsWhereInput is empty.
var ErrEmptyTargetMetricsWhereInput = errors.New("ent: empty predicate TargetMetricsWhereInput")

// P returns a predicate for filtering targetmetricsslice.
// An error is returned if the input is empty or invalid.
func (i *TargetMetricsWhereInput) P() (predicate.TargetMetrics, error) {
	var predicates []predicate.TargetMetrics
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, targetmetrics.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.TargetMetrics, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, targetmetrics.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.TargetMetrics, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, targetmetrics.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, targetmetrics.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, targetmetrics.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, targetmetrics.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, targetmetrics.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, targetmetrics.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, targetmetrics.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, targetmetrics.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, targetmetrics.IDLTE(*i.IDLTE))
	}
	if i.TargetsLoaded != nil {
		predicates = append(predicates, targetmetrics.TargetsLoadedEQ(*i.TargetsLoaded))
	}
	if i.TargetsLoadedNEQ != nil {
		predicates = append(predicates, targetmetrics.TargetsLoadedNEQ(*i.TargetsLoadedNEQ))
	}
	if len(i.TargetsLoadedIn) > 0 {
		predicates = append(predicates, targetmetrics.TargetsLoadedIn(i.TargetsLoadedIn...))
	}
	if len(i.TargetsLoadedNotIn) > 0 {
		predicates = append(predicates, targetmetrics.TargetsLoadedNotIn(i.TargetsLoadedNotIn...))
	}
	if i.TargetsLoadedGT != nil {
		predicates = append(predicates, targetmetrics.TargetsLoadedGT(*i.TargetsLoadedGT))
	}
	if i.TargetsLoadedGTE != nil {
		predicates = append(predicates, targetmetrics.TargetsLoadedGTE(*i.TargetsLoadedGTE))
	}
	if i.TargetsLoadedLT != nil {
		predicates = append(predicates, targetmetrics.TargetsLoadedLT(*i.TargetsLoadedLT))
	}
	if i.TargetsLoadedLTE != nil {
		predicates = append(predicates, targetmetrics.TargetsLoadedLTE(*i.TargetsLoadedLTE))
	}
	if i.TargetsLoadedIsNil {
		predicates = append(predicates, targetmetrics.TargetsLoadedIsNil())
	}
	if i.TargetsLoadedNotNil {
		predicates = append(predicates, targetmetrics.TargetsLoadedNotNil())
	}
	if i.TargetsConfigured != nil {
		predicates = append(predicates, targetmetrics.TargetsConfiguredEQ(*i.TargetsConfigured))
	}
	if i.TargetsConfiguredNEQ != nil {
		predicates = append(predicates, targetmetrics.TargetsConfiguredNEQ(*i.TargetsConfiguredNEQ))
	}
	if len(i.TargetsConfiguredIn) > 0 {
		predicates = append(predicates, targetmetrics.TargetsConfiguredIn(i.TargetsConfiguredIn...))
	}
	if len(i.TargetsConfiguredNotIn) > 0 {
		predicates = append(predicates, targetmetrics.TargetsConfiguredNotIn(i.TargetsConfiguredNotIn...))
	}
	if i.TargetsConfiguredGT != nil {
		predicates = append(predicates, targetmetrics.TargetsConfiguredGT(*i.TargetsConfiguredGT))
	}
	if i.TargetsConfiguredGTE != nil {
		predicates = append(predicates, targetmetrics.TargetsConfiguredGTE(*i.TargetsConfiguredGTE))
	}
	if i.TargetsConfiguredLT != nil {
		predicates = append(predicates, targetmetrics.TargetsConfiguredLT(*i.TargetsConfiguredLT))
	}
	if i.TargetsConfiguredLTE != nil {
		predicates = append(predicates, targetmetrics.TargetsConfiguredLTE(*i.TargetsConfiguredLTE))
	}
	if i.TargetsConfiguredIsNil {
		predicates = append(predicates, targetmetrics.TargetsConfiguredIsNil())
	}
	if i.TargetsConfiguredNotNil {
		predicates = append(predicates, targetmetrics.TargetsConfiguredNotNil())
	}
	if i.TargetsConfiguredNotIncludingAspects != nil {
		predicates = append(predicates, targetmetrics.TargetsConfiguredNotIncludingAspectsEQ(*i.TargetsConfiguredNotIncludingAspects))
	}
	if i.TargetsConfiguredNotIncludingAspectsNEQ != nil {
		predicates = append(predicates, targetmetrics.TargetsConfiguredNotIncludingAspectsNEQ(*i.TargetsConfiguredNotIncludingAspectsNEQ))
	}
	if len(i.TargetsConfiguredNotIncludingAspectsIn) > 0 {
		predicates = append(predicates, targetmetrics.TargetsConfiguredNotIncludingAspectsIn(i.TargetsConfiguredNotIncludingAspectsIn...))
	}
	if len(i.TargetsConfiguredNotIncludingAspectsNotIn) > 0 {
		predicates = append(predicates, targetmetrics.TargetsConfiguredNotIncludingAspectsNotIn(i.TargetsConfiguredNotIncludingAspectsNotIn...))
	}
	if i.TargetsConfiguredNotIncludingAspectsGT != nil {
		predicates = append(predicates, targetmetrics.TargetsConfiguredNotIncludingAspectsGT(*i.TargetsConfiguredNotIncludingAspectsGT))
	}
	if i.TargetsConfiguredNotIncludingAspectsGTE != nil {
		predicates = append(predicates, targetmetrics.TargetsConfiguredNotIncludingAspectsGTE(*i.TargetsConfiguredNotIncludingAspectsGTE))
	}
	if i.TargetsConfiguredNotIncludingAspectsLT != nil {
		predicates = append(predicates, targetmetrics.TargetsConfiguredNotIncludingAspectsLT(*i.TargetsConfiguredNotIncludingAspectsLT))
	}
	if i.TargetsConfiguredNotIncludingAspectsLTE != nil {
		predicates = append(predicates, targetmetrics.TargetsConfiguredNotIncludingAspectsLTE(*i.TargetsConfiguredNotIncludingAspectsLTE))
	}
	if i.TargetsConfiguredNotIncludingAspectsIsNil {
		predicates = append(predicates, targetmetrics.TargetsConfiguredNotIncludingAspectsIsNil())
	}
	if i.TargetsConfiguredNotIncludingAspectsNotNil {
		predicates = append(predicates, targetmetrics.TargetsConfiguredNotIncludingAspectsNotNil())
	}

	if i.HasMetrics != nil {
		p := targetmetrics.HasMetrics()
		if !*i.HasMetrics {
			p = targetmetrics.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMetricsWith) > 0 {
		with := make([]predicate.Metrics, 0, len(i.HasMetricsWith))
		for _, w := range i.HasMetricsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMetricsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, targetmetrics.HasMetricsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyTargetMetricsWhereInput
	case 1:
		return predicates[0], nil
	default:
		return targetmetrics.And(predicates...), nil
	}
}

// TestResultWhereInput represents a where input for filtering TestResult queries.
type TestResultWhereInput struct {
	Predicates []predicate.TestResult  `json:"-"`
	Not        *TestResultWhereInput   `json:"not,omitempty"`
	Or         []*TestResultWhereInput `json:"or,omitempty"`
	And        []*TestResultWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int64  `json:"id,omitempty"`
	IDNEQ   *int64  `json:"idNEQ,omitempty"`
	IDIn    []int64 `json:"idIn,omitempty"`
	IDNotIn []int64 `json:"idNotIn,omitempty"`
	IDGT    *int64  `json:"idGT,omitempty"`
	IDGTE   *int64  `json:"idGTE,omitempty"`
	IDLT    *int64  `json:"idLT,omitempty"`
	IDLTE   *int64  `json:"idLTE,omitempty"`

	// "run" field predicates.
	Run      *int32  `json:"run,omitempty"`
	RunNEQ   *int32  `json:"runNEQ,omitempty"`
	RunIn    []int32 `json:"runIn,omitempty"`
	RunNotIn []int32 `json:"runNotIn,omitempty"`
	RunGT    *int32  `json:"runGT,omitempty"`
	RunGTE   *int32  `json:"runGTE,omitempty"`
	RunLT    *int32  `json:"runLT,omitempty"`
	RunLTE   *int32  `json:"runLTE,omitempty"`

	// "shard" field predicates.
	Shard      *int32  `json:"shard,omitempty"`
	ShardNEQ   *int32  `json:"shardNEQ,omitempty"`
	ShardIn    []int32 `json:"shardIn,omitempty"`
	ShardNotIn []int32 `json:"shardNotIn,omitempty"`
	ShardGT    *int32  `json:"shardGT,omitempty"`
	ShardGTE   *int32  `json:"shardGTE,omitempty"`
	ShardLT    *int32  `json:"shardLT,omitempty"`
	ShardLTE   *int32  `json:"shardLTE,omitempty"`

	// "attempt" field predicates.
	Attempt      *int32  `json:"attempt,omitempty"`
	AttemptNEQ   *int32  `json:"attemptNEQ,omitempty"`
	AttemptIn    []int32 `json:"attemptIn,omitempty"`
	AttemptNotIn []int32 `json:"attemptNotIn,omitempty"`
	AttemptGT    *int32  `json:"attemptGT,omitempty"`
	AttemptGTE   *int32  `json:"attemptGTE,omitempty"`
	AttemptLT    *int32  `json:"attemptLT,omitempty"`
	AttemptLTE   *int32  `json:"attemptLTE,omitempty"`

	// "status" field predicates.
	Status             *string  `json:"status,omitempty"`
	StatusNEQ          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGT           *string  `json:"statusGT,omitempty"`
	StatusGTE          *string  `json:"statusGTE,omitempty"`
	StatusLT           *string  `json:"statusLT,omitempty"`
	StatusLTE          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        bool     `json:"statusIsNil,omitempty"`
	StatusNotNil       bool     `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`

	// "status_details" field predicates.
	StatusDetails             *string  `json:"statusDetails,omitempty"`
	StatusDetailsNEQ          *string  `json:"statusDetailsNEQ,omitempty"`
	StatusDetailsIn           []string `json:"statusDetailsIn,omitempty"`
	StatusDetailsNotIn        []string `json:"statusDetailsNotIn,omitempty"`
	StatusDetailsGT           *string  `json:"statusDetailsGT,omitempty"`
	StatusDetailsGTE          *string  `json:"statusDetailsGTE,omitempty"`
	StatusDetailsLT           *string  `json:"statusDetailsLT,omitempty"`
	StatusDetailsLTE          *string  `json:"statusDetailsLTE,omitempty"`
	StatusDetailsContains     *string  `json:"statusDetailsContains,omitempty"`
	StatusDetailsHasPrefix    *string  `json:"statusDetailsHasPrefix,omitempty"`
	StatusDetailsHasSuffix    *string  `json:"statusDetailsHasSuffix,omitempty"`
	StatusDetailsIsNil        bool     `json:"statusDetailsIsNil,omitempty"`
	StatusDetailsNotNil       bool     `json:"statusDetailsNotNil,omitempty"`
	StatusDetailsEqualFold    *string  `json:"statusDetailsEqualFold,omitempty"`
	StatusDetailsContainsFold *string  `json:"statusDetailsContainsFold,omitempty"`

	// "cached_locally" field predicates.
	CachedLocally       *bool `json:"cachedLocally,omitempty"`
	CachedLocallyNEQ    *bool `json:"cachedLocallyNEQ,omitempty"`
	CachedLocallyIsNil  bool  `json:"cachedLocallyIsNil,omitempty"`
	CachedLocallyNotNil bool  `json:"cachedLocallyNotNil,omitempty"`

	// "test_attempt_start" field predicates.
	TestAttemptStart       *time.Time  `json:"testAttemptStart,omitempty"`
	TestAttemptStartNEQ    *time.Time  `json:"testAttemptStartNEQ,omitempty"`
	TestAttemptStartIn     []time.Time `json:"testAttemptStartIn,omitempty"`
	TestAttemptStartNotIn  []time.Time `json:"testAttemptStartNotIn,omitempty"`
	TestAttemptStartGT     *time.Time  `json:"testAttemptStartGT,omitempty"`
	TestAttemptStartGTE    *time.Time  `json:"testAttemptStartGTE,omitempty"`
	TestAttemptStartLT     *time.Time  `json:"testAttemptStartLT,omitempty"`
	TestAttemptStartLTE    *time.Time  `json:"testAttemptStartLTE,omitempty"`
	TestAttemptStartIsNil  bool        `json:"testAttemptStartIsNil,omitempty"`
	TestAttemptStartNotNil bool        `json:"testAttemptStartNotNil,omitempty"`

	// "test_attempt_duration_in_ms" field predicates.
	TestAttemptDurationInMs       *int64  `json:"testAttemptDurationInMs,omitempty"`
	TestAttemptDurationInMsNEQ    *int64  `json:"testAttemptDurationInMsNEQ,omitempty"`
	TestAttemptDurationInMsIn     []int64 `json:"testAttemptDurationInMsIn,omitempty"`
	TestAttemptDurationInMsNotIn  []int64 `json:"testAttemptDurationInMsNotIn,omitempty"`
	TestAttemptDurationInMsGT     *int64  `json:"testAttemptDurationInMsGT,omitempty"`
	TestAttemptDurationInMsGTE    *int64  `json:"testAttemptDurationInMsGTE,omitempty"`
	TestAttemptDurationInMsLT     *int64  `json:"testAttemptDurationInMsLT,omitempty"`
	TestAttemptDurationInMsLTE    *int64  `json:"testAttemptDurationInMsLTE,omitempty"`
	TestAttemptDurationInMsIsNil  bool    `json:"testAttemptDurationInMsIsNil,omitempty"`
	TestAttemptDurationInMsNotNil bool    `json:"testAttemptDurationInMsNotNil,omitempty"`

	// "strategy" field predicates.
	Strategy             *string  `json:"strategy,omitempty"`
	StrategyNEQ          *string  `json:"strategyNEQ,omitempty"`
	StrategyIn           []string `json:"strategyIn,omitempty"`
	StrategyNotIn        []string `json:"strategyNotIn,omitempty"`
	StrategyGT           *string  `json:"strategyGT,omitempty"`
	StrategyGTE          *string  `json:"strategyGTE,omitempty"`
	StrategyLT           *string  `json:"strategyLT,omitempty"`
	StrategyLTE          *string  `json:"strategyLTE,omitempty"`
	StrategyContains     *string  `json:"strategyContains,omitempty"`
	StrategyHasPrefix    *string  `json:"strategyHasPrefix,omitempty"`
	StrategyHasSuffix    *string  `json:"strategyHasSuffix,omitempty"`
	StrategyIsNil        bool     `json:"strategyIsNil,omitempty"`
	StrategyNotNil       bool     `json:"strategyNotNil,omitempty"`
	StrategyEqualFold    *string  `json:"strategyEqualFold,omitempty"`
	StrategyContainsFold *string  `json:"strategyContainsFold,omitempty"`

	// "cached_remotely" field predicates.
	CachedRemotely       *bool `json:"cachedRemotely,omitempty"`
	CachedRemotelyNEQ    *bool `json:"cachedRemotelyNEQ,omitempty"`
	CachedRemotelyIsNil  bool  `json:"cachedRemotelyIsNil,omitempty"`
	CachedRemotelyNotNil bool  `json:"cachedRemotelyNotNil,omitempty"`

	// "exit_code" field predicates.
	ExitCode       *int32  `json:"exitCode,omitempty"`
	ExitCodeNEQ    *int32  `json:"exitCodeNEQ,omitempty"`
	ExitCodeIn     []int32 `json:"exitCodeIn,omitempty"`
	ExitCodeNotIn  []int32 `json:"exitCodeNotIn,omitempty"`
	ExitCodeGT     *int32  `json:"exitCodeGT,omitempty"`
	ExitCodeGTE    *int32  `json:"exitCodeGTE,omitempty"`
	ExitCodeLT     *int32  `json:"exitCodeLT,omitempty"`
	ExitCodeLTE    *int32  `json:"exitCodeLTE,omitempty"`
	ExitCodeIsNil  bool    `json:"exitCodeIsNil,omitempty"`
	ExitCodeNotNil bool    `json:"exitCodeNotNil,omitempty"`

	// "hostname" field predicates.
	Hostname             *string  `json:"hostname,omitempty"`
	HostnameNEQ          *string  `json:"hostnameNEQ,omitempty"`
	HostnameIn           []string `json:"hostnameIn,omitempty"`
	HostnameNotIn        []string `json:"hostnameNotIn,omitempty"`
	HostnameGT           *string  `json:"hostnameGT,omitempty"`
	HostnameGTE          *string  `json:"hostnameGTE,omitempty"`
	HostnameLT           *string  `json:"hostnameLT,omitempty"`
	HostnameLTE          *string  `json:"hostnameLTE,omitempty"`
	HostnameContains     *string  `json:"hostnameContains,omitempty"`
	HostnameHasPrefix    *string  `json:"hostnameHasPrefix,omitempty"`
	HostnameHasSuffix    *string  `json:"hostnameHasSuffix,omitempty"`
	HostnameIsNil        bool     `json:"hostnameIsNil,omitempty"`
	HostnameNotNil       bool     `json:"hostnameNotNil,omitempty"`
	HostnameEqualFold    *string  `json:"hostnameEqualFold,omitempty"`
	HostnameContainsFold *string  `json:"hostnameContainsFold,omitempty"`

	// "test_summary" edge predicates.
	HasTestSummary     *bool                    `json:"hasTestSummary,omitempty"`
	HasTestSummaryWith []*TestSummaryWhereInput `json:"hasTestSummaryWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *TestResultWhereInput) AddPredicates(predicates ...predicate.TestResult) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the TestResultWhereInput filter on the TestResultQuery builder.
func (i *TestResultWhereInput) Filter(q *TestResultQuery) (*TestResultQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyTestResultWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyTestResultWhereInput is returned in case the TestResultWhereInput is empty.
var ErrEmptyTestResultWhereInput = errors.New("ent: empty predicate TestResultWhereInput")

// P returns a predicate for filtering testresults.
// An error is returned if the input is empty or invalid.
func (i *TestResultWhereInput) P() (predicate.TestResult, error) {
	var predicates []predicate.TestResult
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, testresult.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.TestResult, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, testresult.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.TestResult, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, testresult.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, testresult.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, testresult.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, testresult.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, testresult.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, testresult.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, testresult.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, testresult.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, testresult.IDLTE(*i.IDLTE))
	}
	if i.Run != nil {
		predicates = append(predicates, testresult.RunEQ(*i.Run))
	}
	if i.RunNEQ != nil {
		predicates = append(predicates, testresult.RunNEQ(*i.RunNEQ))
	}
	if len(i.RunIn) > 0 {
		predicates = append(predicates, testresult.RunIn(i.RunIn...))
	}
	if len(i.RunNotIn) > 0 {
		predicates = append(predicates, testresult.RunNotIn(i.RunNotIn...))
	}
	if i.RunGT != nil {
		predicates = append(predicates, testresult.RunGT(*i.RunGT))
	}
	if i.RunGTE != nil {
		predicates = append(predicates, testresult.RunGTE(*i.RunGTE))
	}
	if i.RunLT != nil {
		predicates = append(predicates, testresult.RunLT(*i.RunLT))
	}
	if i.RunLTE != nil {
		predicates = append(predicates, testresult.RunLTE(*i.RunLTE))
	}
	if i.Shard != nil {
		predicates = append(predicates, testresult.ShardEQ(*i.Shard))
	}
	if i.ShardNEQ != nil {
		predicates = append(predicates, testresult.ShardNEQ(*i.ShardNEQ))
	}
	if len(i.ShardIn) > 0 {
		predicates = append(predicates, testresult.ShardIn(i.ShardIn...))
	}
	if len(i.ShardNotIn) > 0 {
		predicates = append(predicates, testresult.ShardNotIn(i.ShardNotIn...))
	}
	if i.ShardGT != nil {
		predicates = append(predicates, testresult.ShardGT(*i.ShardGT))
	}
	if i.ShardGTE != nil {
		predicates = append(predicates, testresult.ShardGTE(*i.ShardGTE))
	}
	if i.ShardLT != nil {
		predicates = append(predicates, testresult.ShardLT(*i.ShardLT))
	}
	if i.ShardLTE != nil {
		predicates = append(predicates, testresult.ShardLTE(*i.ShardLTE))
	}
	if i.Attempt != nil {
		predicates = append(predicates, testresult.AttemptEQ(*i.Attempt))
	}
	if i.AttemptNEQ != nil {
		predicates = append(predicates, testresult.AttemptNEQ(*i.AttemptNEQ))
	}
	if len(i.AttemptIn) > 0 {
		predicates = append(predicates, testresult.AttemptIn(i.AttemptIn...))
	}
	if len(i.AttemptNotIn) > 0 {
		predicates = append(predicates, testresult.AttemptNotIn(i.AttemptNotIn...))
	}
	if i.AttemptGT != nil {
		predicates = append(predicates, testresult.AttemptGT(*i.AttemptGT))
	}
	if i.AttemptGTE != nil {
		predicates = append(predicates, testresult.AttemptGTE(*i.AttemptGTE))
	}
	if i.AttemptLT != nil {
		predicates = append(predicates, testresult.AttemptLT(*i.AttemptLT))
	}
	if i.AttemptLTE != nil {
		predicates = append(predicates, testresult.AttemptLTE(*i.AttemptLTE))
	}
	if i.Status != nil {
		predicates = append(predicates, testresult.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, testresult.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, testresult.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, testresult.StatusNotIn(i.StatusNotIn...))
	}
	if i.StatusGT != nil {
		predicates = append(predicates, testresult.StatusGT(*i.StatusGT))
	}
	if i.StatusGTE != nil {
		predicates = append(predicates, testresult.StatusGTE(*i.StatusGTE))
	}
	if i.StatusLT != nil {
		predicates = append(predicates, testresult.StatusLT(*i.StatusLT))
	}
	if i.StatusLTE != nil {
		predicates = append(predicates, testresult.StatusLTE(*i.StatusLTE))
	}
	if i.StatusContains != nil {
		predicates = append(predicates, testresult.StatusContains(*i.StatusContains))
	}
	if i.StatusHasPrefix != nil {
		predicates = append(predicates, testresult.StatusHasPrefix(*i.StatusHasPrefix))
	}
	if i.StatusHasSuffix != nil {
		predicates = append(predicates, testresult.StatusHasSuffix(*i.StatusHasSuffix))
	}
	if i.StatusIsNil {
		predicates = append(predicates, testresult.StatusIsNil())
	}
	if i.StatusNotNil {
		predicates = append(predicates, testresult.StatusNotNil())
	}
	if i.StatusEqualFold != nil {
		predicates = append(predicates, testresult.StatusEqualFold(*i.StatusEqualFold))
	}
	if i.StatusContainsFold != nil {
		predicates = append(predicates, testresult.StatusContainsFold(*i.StatusContainsFold))
	}
	if i.StatusDetails != nil {
		predicates = append(predicates, testresult.StatusDetailsEQ(*i.StatusDetails))
	}
	if i.StatusDetailsNEQ != nil {
		predicates = append(predicates, testresult.StatusDetailsNEQ(*i.StatusDetailsNEQ))
	}
	if len(i.StatusDetailsIn) > 0 {
		predicates = append(predicates, testresult.StatusDetailsIn(i.StatusDetailsIn...))
	}
	if len(i.StatusDetailsNotIn) > 0 {
		predicates = append(predicates, testresult.StatusDetailsNotIn(i.StatusDetailsNotIn...))
	}
	if i.StatusDetailsGT != nil {
		predicates = append(predicates, testresult.StatusDetailsGT(*i.StatusDetailsGT))
	}
	if i.StatusDetailsGTE != nil {
		predicates = append(predicates, testresult.StatusDetailsGTE(*i.StatusDetailsGTE))
	}
	if i.StatusDetailsLT != nil {
		predicates = append(predicates, testresult.StatusDetailsLT(*i.StatusDetailsLT))
	}
	if i.StatusDetailsLTE != nil {
		predicates = append(predicates, testresult.StatusDetailsLTE(*i.StatusDetailsLTE))
	}
	if i.StatusDetailsContains != nil {
		predicates = append(predicates, testresult.StatusDetailsContains(*i.StatusDetailsContains))
	}
	if i.StatusDetailsHasPrefix != nil {
		predicates = append(predicates, testresult.StatusDetailsHasPrefix(*i.StatusDetailsHasPrefix))
	}
	if i.StatusDetailsHasSuffix != nil {
		predicates = append(predicates, testresult.StatusDetailsHasSuffix(*i.StatusDetailsHasSuffix))
	}
	if i.StatusDetailsIsNil {
		predicates = append(predicates, testresult.StatusDetailsIsNil())
	}
	if i.StatusDetailsNotNil {
		predicates = append(predicates, testresult.StatusDetailsNotNil())
	}
	if i.StatusDetailsEqualFold != nil {
		predicates = append(predicates, testresult.StatusDetailsEqualFold(*i.StatusDetailsEqualFold))
	}
	if i.StatusDetailsContainsFold != nil {
		predicates = append(predicates, testresult.StatusDetailsContainsFold(*i.StatusDetailsContainsFold))
	}
	if i.CachedLocally != nil {
		predicates = append(predicates, testresult.CachedLocallyEQ(*i.CachedLocally))
	}
	if i.CachedLocallyNEQ != nil {
		predicates = append(predicates, testresult.CachedLocallyNEQ(*i.CachedLocallyNEQ))
	}
	if i.CachedLocallyIsNil {
		predicates = append(predicates, testresult.CachedLocallyIsNil())
	}
	if i.CachedLocallyNotNil {
		predicates = append(predicates, testresult.CachedLocallyNotNil())
	}
	if i.TestAttemptStart != nil {
		predicates = append(predicates, testresult.TestAttemptStartEQ(*i.TestAttemptStart))
	}
	if i.TestAttemptStartNEQ != nil {
		predicates = append(predicates, testresult.TestAttemptStartNEQ(*i.TestAttemptStartNEQ))
	}
	if len(i.TestAttemptStartIn) > 0 {
		predicates = append(predicates, testresult.TestAttemptStartIn(i.TestAttemptStartIn...))
	}
	if len(i.TestAttemptStartNotIn) > 0 {
		predicates = append(predicates, testresult.TestAttemptStartNotIn(i.TestAttemptStartNotIn...))
	}
	if i.TestAttemptStartGT != nil {
		predicates = append(predicates, testresult.TestAttemptStartGT(*i.TestAttemptStartGT))
	}
	if i.TestAttemptStartGTE != nil {
		predicates = append(predicates, testresult.TestAttemptStartGTE(*i.TestAttemptStartGTE))
	}
	if i.TestAttemptStartLT != nil {
		predicates = append(predicates, testresult.TestAttemptStartLT(*i.TestAttemptStartLT))
	}
	if i.TestAttemptStartLTE != nil {
		predicates = append(predicates, testresult.TestAttemptStartLTE(*i.TestAttemptStartLTE))
	}
	if i.TestAttemptStartIsNil {
		predicates = append(predicates, testresult.TestAttemptStartIsNil())
	}
	if i.TestAttemptStartNotNil {
		predicates = append(predicates, testresult.TestAttemptStartNotNil())
	}
	if i.TestAttemptDurationInMs != nil {
		predicates = append(predicates, testresult.TestAttemptDurationInMsEQ(*i.TestAttemptDurationInMs))
	}
	if i.TestAttemptDurationInMsNEQ != nil {
		predicates = append(predicates, testresult.TestAttemptDurationInMsNEQ(*i.TestAttemptDurationInMsNEQ))
	}
	if len(i.TestAttemptDurationInMsIn) > 0 {
		predicates = append(predicates, testresult.TestAttemptDurationInMsIn(i.TestAttemptDurationInMsIn...))
	}
	if len(i.TestAttemptDurationInMsNotIn) > 0 {
		predicates = append(predicates, testresult.TestAttemptDurationInMsNotIn(i.TestAttemptDurationInMsNotIn...))
	}
	if i.TestAttemptDurationInMsGT != nil {
		predicates = append(predicates, testresult.TestAttemptDurationInMsGT(*i.TestAttemptDurationInMsGT))
	}
	if i.TestAttemptDurationInMsGTE != nil {
		predicates = append(predicates, testresult.TestAttemptDurationInMsGTE(*i.TestAttemptDurationInMsGTE))
	}
	if i.TestAttemptDurationInMsLT != nil {
		predicates = append(predicates, testresult.TestAttemptDurationInMsLT(*i.TestAttemptDurationInMsLT))
	}
	if i.TestAttemptDurationInMsLTE != nil {
		predicates = append(predicates, testresult.TestAttemptDurationInMsLTE(*i.TestAttemptDurationInMsLTE))
	}
	if i.TestAttemptDurationInMsIsNil {
		predicates = append(predicates, testresult.TestAttemptDurationInMsIsNil())
	}
	if i.TestAttemptDurationInMsNotNil {
		predicates = append(predicates, testresult.TestAttemptDurationInMsNotNil())
	}
	if i.Strategy != nil {
		predicates = append(predicates, testresult.StrategyEQ(*i.Strategy))
	}
	if i.StrategyNEQ != nil {
		predicates = append(predicates, testresult.StrategyNEQ(*i.StrategyNEQ))
	}
	if len(i.StrategyIn) > 0 {
		predicates = append(predicates, testresult.StrategyIn(i.StrategyIn...))
	}
	if len(i.StrategyNotIn) > 0 {
		predicates = append(predicates, testresult.StrategyNotIn(i.StrategyNotIn...))
	}
	if i.StrategyGT != nil {
		predicates = append(predicates, testresult.StrategyGT(*i.StrategyGT))
	}
	if i.StrategyGTE != nil {
		predicates = append(predicates, testresult.StrategyGTE(*i.StrategyGTE))
	}
	if i.StrategyLT != nil {
		predicates = append(predicates, testresult.StrategyLT(*i.StrategyLT))
	}
	if i.StrategyLTE != nil {
		predicates = append(predicates, testresult.StrategyLTE(*i.StrategyLTE))
	}
	if i.StrategyContains != nil {
		predicates = append(predicates, testresult.StrategyContains(*i.StrategyContains))
	}
	if i.StrategyHasPrefix != nil {
		predicates = append(predicates, testresult.StrategyHasPrefix(*i.StrategyHasPrefix))
	}
	if i.StrategyHasSuffix != nil {
		predicates = append(predicates, testresult.StrategyHasSuffix(*i.StrategyHasSuffix))
	}
	if i.StrategyIsNil {
		predicates = append(predicates, testresult.StrategyIsNil())
	}
	if i.StrategyNotNil {
		predicates = append(predicates, testresult.StrategyNotNil())
	}
	if i.StrategyEqualFold != nil {
		predicates = append(predicates, testresult.StrategyEqualFold(*i.StrategyEqualFold))
	}
	if i.StrategyContainsFold != nil {
		predicates = append(predicates, testresult.StrategyContainsFold(*i.StrategyContainsFold))
	}
	if i.CachedRemotely != nil {
		predicates = append(predicates, testresult.CachedRemotelyEQ(*i.CachedRemotely))
	}
	if i.CachedRemotelyNEQ != nil {
		predicates = append(predicates, testresult.CachedRemotelyNEQ(*i.CachedRemotelyNEQ))
	}
	if i.CachedRemotelyIsNil {
		predicates = append(predicates, testresult.CachedRemotelyIsNil())
	}
	if i.CachedRemotelyNotNil {
		predicates = append(predicates, testresult.CachedRemotelyNotNil())
	}
	if i.ExitCode != nil {
		predicates = append(predicates, testresult.ExitCodeEQ(*i.ExitCode))
	}
	if i.ExitCodeNEQ != nil {
		predicates = append(predicates, testresult.ExitCodeNEQ(*i.ExitCodeNEQ))
	}
	if len(i.ExitCodeIn) > 0 {
		predicates = append(predicates, testresult.ExitCodeIn(i.ExitCodeIn...))
	}
	if len(i.ExitCodeNotIn) > 0 {
		predicates = append(predicates, testresult.ExitCodeNotIn(i.ExitCodeNotIn...))
	}
	if i.ExitCodeGT != nil {
		predicates = append(predicates, testresult.ExitCodeGT(*i.ExitCodeGT))
	}
	if i.ExitCodeGTE != nil {
		predicates = append(predicates, testresult.ExitCodeGTE(*i.ExitCodeGTE))
	}
	if i.ExitCodeLT != nil {
		predicates = append(predicates, testresult.ExitCodeLT(*i.ExitCodeLT))
	}
	if i.ExitCodeLTE != nil {
		predicates = append(predicates, testresult.ExitCodeLTE(*i.ExitCodeLTE))
	}
	if i.ExitCodeIsNil {
		predicates = append(predicates, testresult.ExitCodeIsNil())
	}
	if i.ExitCodeNotNil {
		predicates = append(predicates, testresult.ExitCodeNotNil())
	}
	if i.Hostname != nil {
		predicates = append(predicates, testresult.HostnameEQ(*i.Hostname))
	}
	if i.HostnameNEQ != nil {
		predicates = append(predicates, testresult.HostnameNEQ(*i.HostnameNEQ))
	}
	if len(i.HostnameIn) > 0 {
		predicates = append(predicates, testresult.HostnameIn(i.HostnameIn...))
	}
	if len(i.HostnameNotIn) > 0 {
		predicates = append(predicates, testresult.HostnameNotIn(i.HostnameNotIn...))
	}
	if i.HostnameGT != nil {
		predicates = append(predicates, testresult.HostnameGT(*i.HostnameGT))
	}
	if i.HostnameGTE != nil {
		predicates = append(predicates, testresult.HostnameGTE(*i.HostnameGTE))
	}
	if i.HostnameLT != nil {
		predicates = append(predicates, testresult.HostnameLT(*i.HostnameLT))
	}
	if i.HostnameLTE != nil {
		predicates = append(predicates, testresult.HostnameLTE(*i.HostnameLTE))
	}
	if i.HostnameContains != nil {
		predicates = append(predicates, testresult.HostnameContains(*i.HostnameContains))
	}
	if i.HostnameHasPrefix != nil {
		predicates = append(predicates, testresult.HostnameHasPrefix(*i.HostnameHasPrefix))
	}
	if i.HostnameHasSuffix != nil {
		predicates = append(predicates, testresult.HostnameHasSuffix(*i.HostnameHasSuffix))
	}
	if i.HostnameIsNil {
		predicates = append(predicates, testresult.HostnameIsNil())
	}
	if i.HostnameNotNil {
		predicates = append(predicates, testresult.HostnameNotNil())
	}
	if i.HostnameEqualFold != nil {
		predicates = append(predicates, testresult.HostnameEqualFold(*i.HostnameEqualFold))
	}
	if i.HostnameContainsFold != nil {
		predicates = append(predicates, testresult.HostnameContainsFold(*i.HostnameContainsFold))
	}

	if i.HasTestSummary != nil {
		p := testresult.HasTestSummary()
		if !*i.HasTestSummary {
			p = testresult.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTestSummaryWith) > 0 {
		with := make([]predicate.TestSummary, 0, len(i.HasTestSummaryWith))
		for _, w := range i.HasTestSummaryWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTestSummaryWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, testresult.HasTestSummaryWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyTestResultWhereInput
	case 1:
		return predicates[0], nil
	default:
		return testresult.And(predicates...), nil
	}
}

// TestSummaryWhereInput represents a where input for filtering TestSummary queries.
type TestSummaryWhereInput struct {
	Predicates []predicate.TestSummary  `json:"-"`
	Not        *TestSummaryWhereInput   `json:"not,omitempty"`
	Or         []*TestSummaryWhereInput `json:"or,omitempty"`
	And        []*TestSummaryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int64  `json:"id,omitempty"`
	IDNEQ   *int64  `json:"idNEQ,omitempty"`
	IDIn    []int64 `json:"idIn,omitempty"`
	IDNotIn []int64 `json:"idNotIn,omitempty"`
	IDGT    *int64  `json:"idGT,omitempty"`
	IDGTE   *int64  `json:"idGTE,omitempty"`
	IDLT    *int64  `json:"idLT,omitempty"`
	IDLTE   *int64  `json:"idLTE,omitempty"`

	// "overall_status" field predicates.
	OverallStatus             *string  `json:"overallStatus,omitempty"`
	OverallStatusNEQ          *string  `json:"overallStatusNEQ,omitempty"`
	OverallStatusIn           []string `json:"overallStatusIn,omitempty"`
	OverallStatusNotIn        []string `json:"overallStatusNotIn,omitempty"`
	OverallStatusGT           *string  `json:"overallStatusGT,omitempty"`
	OverallStatusGTE          *string  `json:"overallStatusGTE,omitempty"`
	OverallStatusLT           *string  `json:"overallStatusLT,omitempty"`
	OverallStatusLTE          *string  `json:"overallStatusLTE,omitempty"`
	OverallStatusContains     *string  `json:"overallStatusContains,omitempty"`
	OverallStatusHasPrefix    *string  `json:"overallStatusHasPrefix,omitempty"`
	OverallStatusHasSuffix    *string  `json:"overallStatusHasSuffix,omitempty"`
	OverallStatusIsNil        bool     `json:"overallStatusIsNil,omitempty"`
	OverallStatusNotNil       bool     `json:"overallStatusNotNil,omitempty"`
	OverallStatusEqualFold    *string  `json:"overallStatusEqualFold,omitempty"`
	OverallStatusContainsFold *string  `json:"overallStatusContainsFold,omitempty"`

	// "total_run_count" field predicates.
	TotalRunCount       *int32  `json:"totalRunCount,omitempty"`
	TotalRunCountNEQ    *int32  `json:"totalRunCountNEQ,omitempty"`
	TotalRunCountIn     []int32 `json:"totalRunCountIn,omitempty"`
	TotalRunCountNotIn  []int32 `json:"totalRunCountNotIn,omitempty"`
	TotalRunCountGT     *int32  `json:"totalRunCountGT,omitempty"`
	TotalRunCountGTE    *int32  `json:"totalRunCountGTE,omitempty"`
	TotalRunCountLT     *int32  `json:"totalRunCountLT,omitempty"`
	TotalRunCountLTE    *int32  `json:"totalRunCountLTE,omitempty"`
	TotalRunCountIsNil  bool    `json:"totalRunCountIsNil,omitempty"`
	TotalRunCountNotNil bool    `json:"totalRunCountNotNil,omitempty"`

	// "run_count" field predicates.
	RunCount       *int32  `json:"runCount,omitempty"`
	RunCountNEQ    *int32  `json:"runCountNEQ,omitempty"`
	RunCountIn     []int32 `json:"runCountIn,omitempty"`
	RunCountNotIn  []int32 `json:"runCountNotIn,omitempty"`
	RunCountGT     *int32  `json:"runCountGT,omitempty"`
	RunCountGTE    *int32  `json:"runCountGTE,omitempty"`
	RunCountLT     *int32  `json:"runCountLT,omitempty"`
	RunCountLTE    *int32  `json:"runCountLTE,omitempty"`
	RunCountIsNil  bool    `json:"runCountIsNil,omitempty"`
	RunCountNotNil bool    `json:"runCountNotNil,omitempty"`

	// "attempt_count" field predicates.
	AttemptCount       *int32  `json:"attemptCount,omitempty"`
	AttemptCountNEQ    *int32  `json:"attemptCountNEQ,omitempty"`
	AttemptCountIn     []int32 `json:"attemptCountIn,omitempty"`
	AttemptCountNotIn  []int32 `json:"attemptCountNotIn,omitempty"`
	AttemptCountGT     *int32  `json:"attemptCountGT,omitempty"`
	AttemptCountGTE    *int32  `json:"attemptCountGTE,omitempty"`
	AttemptCountLT     *int32  `json:"attemptCountLT,omitempty"`
	AttemptCountLTE    *int32  `json:"attemptCountLTE,omitempty"`
	AttemptCountIsNil  bool    `json:"attemptCountIsNil,omitempty"`
	AttemptCountNotNil bool    `json:"attemptCountNotNil,omitempty"`

	// "shard_count" field predicates.
	ShardCount       *int32  `json:"shardCount,omitempty"`
	ShardCountNEQ    *int32  `json:"shardCountNEQ,omitempty"`
	ShardCountIn     []int32 `json:"shardCountIn,omitempty"`
	ShardCountNotIn  []int32 `json:"shardCountNotIn,omitempty"`
	ShardCountGT     *int32  `json:"shardCountGT,omitempty"`
	ShardCountGTE    *int32  `json:"shardCountGTE,omitempty"`
	ShardCountLT     *int32  `json:"shardCountLT,omitempty"`
	ShardCountLTE    *int32  `json:"shardCountLTE,omitempty"`
	ShardCountIsNil  bool    `json:"shardCountIsNil,omitempty"`
	ShardCountNotNil bool    `json:"shardCountNotNil,omitempty"`

	// "total_num_cached" field predicates.
	TotalNumCached       *int32  `json:"totalNumCached,omitempty"`
	TotalNumCachedNEQ    *int32  `json:"totalNumCachedNEQ,omitempty"`
	TotalNumCachedIn     []int32 `json:"totalNumCachedIn,omitempty"`
	TotalNumCachedNotIn  []int32 `json:"totalNumCachedNotIn,omitempty"`
	TotalNumCachedGT     *int32  `json:"totalNumCachedGT,omitempty"`
	TotalNumCachedGTE    *int32  `json:"totalNumCachedGTE,omitempty"`
	TotalNumCachedLT     *int32  `json:"totalNumCachedLT,omitempty"`
	TotalNumCachedLTE    *int32  `json:"totalNumCachedLTE,omitempty"`
	TotalNumCachedIsNil  bool    `json:"totalNumCachedIsNil,omitempty"`
	TotalNumCachedNotNil bool    `json:"totalNumCachedNotNil,omitempty"`

	// "first_start_time" field predicates.
	FirstStartTime       *time.Time  `json:"firstStartTime,omitempty"`
	FirstStartTimeNEQ    *time.Time  `json:"firstStartTimeNEQ,omitempty"`
	FirstStartTimeIn     []time.Time `json:"firstStartTimeIn,omitempty"`
	FirstStartTimeNotIn  []time.Time `json:"firstStartTimeNotIn,omitempty"`
	FirstStartTimeGT     *time.Time  `json:"firstStartTimeGT,omitempty"`
	FirstStartTimeGTE    *time.Time  `json:"firstStartTimeGTE,omitempty"`
	FirstStartTimeLT     *time.Time  `json:"firstStartTimeLT,omitempty"`
	FirstStartTimeLTE    *time.Time  `json:"firstStartTimeLTE,omitempty"`
	FirstStartTimeIsNil  bool        `json:"firstStartTimeIsNil,omitempty"`
	FirstStartTimeNotNil bool        `json:"firstStartTimeNotNil,omitempty"`

	// "last_stop_time" field predicates.
	LastStopTime       *time.Time  `json:"lastStopTime,omitempty"`
	LastStopTimeNEQ    *time.Time  `json:"lastStopTimeNEQ,omitempty"`
	LastStopTimeIn     []time.Time `json:"lastStopTimeIn,omitempty"`
	LastStopTimeNotIn  []time.Time `json:"lastStopTimeNotIn,omitempty"`
	LastStopTimeGT     *time.Time  `json:"lastStopTimeGT,omitempty"`
	LastStopTimeGTE    *time.Time  `json:"lastStopTimeGTE,omitempty"`
	LastStopTimeLT     *time.Time  `json:"lastStopTimeLT,omitempty"`
	LastStopTimeLTE    *time.Time  `json:"lastStopTimeLTE,omitempty"`
	LastStopTimeIsNil  bool        `json:"lastStopTimeIsNil,omitempty"`
	LastStopTimeNotNil bool        `json:"lastStopTimeNotNil,omitempty"`

	// "total_run_duration_in_ms" field predicates.
	TotalRunDurationInMs       *int64  `json:"totalRunDurationInMs,omitempty"`
	TotalRunDurationInMsNEQ    *int64  `json:"totalRunDurationInMsNEQ,omitempty"`
	TotalRunDurationInMsIn     []int64 `json:"totalRunDurationInMsIn,omitempty"`
	TotalRunDurationInMsNotIn  []int64 `json:"totalRunDurationInMsNotIn,omitempty"`
	TotalRunDurationInMsGT     *int64  `json:"totalRunDurationInMsGT,omitempty"`
	TotalRunDurationInMsGTE    *int64  `json:"totalRunDurationInMsGTE,omitempty"`
	TotalRunDurationInMsLT     *int64  `json:"totalRunDurationInMsLT,omitempty"`
	TotalRunDurationInMsLTE    *int64  `json:"totalRunDurationInMsLTE,omitempty"`
	TotalRunDurationInMsIsNil  bool    `json:"totalRunDurationInMsIsNil,omitempty"`
	TotalRunDurationInMsNotNil bool    `json:"totalRunDurationInMsNotNil,omitempty"`

	// "invocation_target" edge predicates.
	HasInvocationTarget     *bool                         `json:"hasInvocationTarget,omitempty"`
	HasInvocationTargetWith []*InvocationTargetWhereInput `json:"hasInvocationTargetWith,omitempty"`

	// "test_results" edge predicates.
	HasTestResults     *bool                   `json:"hasTestResults,omitempty"`
	HasTestResultsWith []*TestResultWhereInput `json:"hasTestResultsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *TestSummaryWhereInput) AddPredicates(predicates ...predicate.TestSummary) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the TestSummaryWhereInput filter on the TestSummaryQuery builder.
func (i *TestSummaryWhereInput) Filter(q *TestSummaryQuery) (*TestSummaryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyTestSummaryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyTestSummaryWhereInput is returned in case the TestSummaryWhereInput is empty.
var ErrEmptyTestSummaryWhereInput = errors.New("ent: empty predicate TestSummaryWhereInput")

// P returns a predicate for filtering testsummaries.
// An error is returned if the input is empty or invalid.
func (i *TestSummaryWhereInput) P() (predicate.TestSummary, error) {
	var predicates []predicate.TestSummary
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, testsummary.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.TestSummary, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, testsummary.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.TestSummary, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, testsummary.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, testsummary.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, testsummary.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, testsummary.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, testsummary.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, testsummary.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, testsummary.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, testsummary.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, testsummary.IDLTE(*i.IDLTE))
	}
	if i.OverallStatus != nil {
		predicates = append(predicates, testsummary.OverallStatusEQ(*i.OverallStatus))
	}
	if i.OverallStatusNEQ != nil {
		predicates = append(predicates, testsummary.OverallStatusNEQ(*i.OverallStatusNEQ))
	}
	if len(i.OverallStatusIn) > 0 {
		predicates = append(predicates, testsummary.OverallStatusIn(i.OverallStatusIn...))
	}
	if len(i.OverallStatusNotIn) > 0 {
		predicates = append(predicates, testsummary.OverallStatusNotIn(i.OverallStatusNotIn...))
	}
	if i.OverallStatusGT != nil {
		predicates = append(predicates, testsummary.OverallStatusGT(*i.OverallStatusGT))
	}
	if i.OverallStatusGTE != nil {
		predicates = append(predicates, testsummary.OverallStatusGTE(*i.OverallStatusGTE))
	}
	if i.OverallStatusLT != nil {
		predicates = append(predicates, testsummary.OverallStatusLT(*i.OverallStatusLT))
	}
	if i.OverallStatusLTE != nil {
		predicates = append(predicates, testsummary.OverallStatusLTE(*i.OverallStatusLTE))
	}
	if i.OverallStatusContains != nil {
		predicates = append(predicates, testsummary.OverallStatusContains(*i.OverallStatusContains))
	}
	if i.OverallStatusHasPrefix != nil {
		predicates = append(predicates, testsummary.OverallStatusHasPrefix(*i.OverallStatusHasPrefix))
	}
	if i.OverallStatusHasSuffix != nil {
		predicates = append(predicates, testsummary.OverallStatusHasSuffix(*i.OverallStatusHasSuffix))
	}
	if i.OverallStatusIsNil {
		predicates = append(predicates, testsummary.OverallStatusIsNil())
	}
	if i.OverallStatusNotNil {
		predicates = append(predicates, testsummary.OverallStatusNotNil())
	}
	if i.OverallStatusEqualFold != nil {
		predicates = append(predicates, testsummary.OverallStatusEqualFold(*i.OverallStatusEqualFold))
	}
	if i.OverallStatusContainsFold != nil {
		predicates = append(predicates, testsummary.OverallStatusContainsFold(*i.OverallStatusContainsFold))
	}
	if i.TotalRunCount != nil {
		predicates = append(predicates, testsummary.TotalRunCountEQ(*i.TotalRunCount))
	}
	if i.TotalRunCountNEQ != nil {
		predicates = append(predicates, testsummary.TotalRunCountNEQ(*i.TotalRunCountNEQ))
	}
	if len(i.TotalRunCountIn) > 0 {
		predicates = append(predicates, testsummary.TotalRunCountIn(i.TotalRunCountIn...))
	}
	if len(i.TotalRunCountNotIn) > 0 {
		predicates = append(predicates, testsummary.TotalRunCountNotIn(i.TotalRunCountNotIn...))
	}
	if i.TotalRunCountGT != nil {
		predicates = append(predicates, testsummary.TotalRunCountGT(*i.TotalRunCountGT))
	}
	if i.TotalRunCountGTE != nil {
		predicates = append(predicates, testsummary.TotalRunCountGTE(*i.TotalRunCountGTE))
	}
	if i.TotalRunCountLT != nil {
		predicates = append(predicates, testsummary.TotalRunCountLT(*i.TotalRunCountLT))
	}
	if i.TotalRunCountLTE != nil {
		predicates = append(predicates, testsummary.TotalRunCountLTE(*i.TotalRunCountLTE))
	}
	if i.TotalRunCountIsNil {
		predicates = append(predicates, testsummary.TotalRunCountIsNil())
	}
	if i.TotalRunCountNotNil {
		predicates = append(predicates, testsummary.TotalRunCountNotNil())
	}
	if i.RunCount != nil {
		predicates = append(predicates, testsummary.RunCountEQ(*i.RunCount))
	}
	if i.RunCountNEQ != nil {
		predicates = append(predicates, testsummary.RunCountNEQ(*i.RunCountNEQ))
	}
	if len(i.RunCountIn) > 0 {
		predicates = append(predicates, testsummary.RunCountIn(i.RunCountIn...))
	}
	if len(i.RunCountNotIn) > 0 {
		predicates = append(predicates, testsummary.RunCountNotIn(i.RunCountNotIn...))
	}
	if i.RunCountGT != nil {
		predicates = append(predicates, testsummary.RunCountGT(*i.RunCountGT))
	}
	if i.RunCountGTE != nil {
		predicates = append(predicates, testsummary.RunCountGTE(*i.RunCountGTE))
	}
	if i.RunCountLT != nil {
		predicates = append(predicates, testsummary.RunCountLT(*i.RunCountLT))
	}
	if i.RunCountLTE != nil {
		predicates = append(predicates, testsummary.RunCountLTE(*i.RunCountLTE))
	}
	if i.RunCountIsNil {
		predicates = append(predicates, testsummary.RunCountIsNil())
	}
	if i.RunCountNotNil {
		predicates = append(predicates, testsummary.RunCountNotNil())
	}
	if i.AttemptCount != nil {
		predicates = append(predicates, testsummary.AttemptCountEQ(*i.AttemptCount))
	}
	if i.AttemptCountNEQ != nil {
		predicates = append(predicates, testsummary.AttemptCountNEQ(*i.AttemptCountNEQ))
	}
	if len(i.AttemptCountIn) > 0 {
		predicates = append(predicates, testsummary.AttemptCountIn(i.AttemptCountIn...))
	}
	if len(i.AttemptCountNotIn) > 0 {
		predicates = append(predicates, testsummary.AttemptCountNotIn(i.AttemptCountNotIn...))
	}
	if i.AttemptCountGT != nil {
		predicates = append(predicates, testsummary.AttemptCountGT(*i.AttemptCountGT))
	}
	if i.AttemptCountGTE != nil {
		predicates = append(predicates, testsummary.AttemptCountGTE(*i.AttemptCountGTE))
	}
	if i.AttemptCountLT != nil {
		predicates = append(predicates, testsummary.AttemptCountLT(*i.AttemptCountLT))
	}
	if i.AttemptCountLTE != nil {
		predicates = append(predicates, testsummary.AttemptCountLTE(*i.AttemptCountLTE))
	}
	if i.AttemptCountIsNil {
		predicates = append(predicates, testsummary.AttemptCountIsNil())
	}
	if i.AttemptCountNotNil {
		predicates = append(predicates, testsummary.AttemptCountNotNil())
	}
	if i.ShardCount != nil {
		predicates = append(predicates, testsummary.ShardCountEQ(*i.ShardCount))
	}
	if i.ShardCountNEQ != nil {
		predicates = append(predicates, testsummary.ShardCountNEQ(*i.ShardCountNEQ))
	}
	if len(i.ShardCountIn) > 0 {
		predicates = append(predicates, testsummary.ShardCountIn(i.ShardCountIn...))
	}
	if len(i.ShardCountNotIn) > 0 {
		predicates = append(predicates, testsummary.ShardCountNotIn(i.ShardCountNotIn...))
	}
	if i.ShardCountGT != nil {
		predicates = append(predicates, testsummary.ShardCountGT(*i.ShardCountGT))
	}
	if i.ShardCountGTE != nil {
		predicates = append(predicates, testsummary.ShardCountGTE(*i.ShardCountGTE))
	}
	if i.ShardCountLT != nil {
		predicates = append(predicates, testsummary.ShardCountLT(*i.ShardCountLT))
	}
	if i.ShardCountLTE != nil {
		predicates = append(predicates, testsummary.ShardCountLTE(*i.ShardCountLTE))
	}
	if i.ShardCountIsNil {
		predicates = append(predicates, testsummary.ShardCountIsNil())
	}
	if i.ShardCountNotNil {
		predicates = append(predicates, testsummary.ShardCountNotNil())
	}
	if i.TotalNumCached != nil {
		predicates = append(predicates, testsummary.TotalNumCachedEQ(*i.TotalNumCached))
	}
	if i.TotalNumCachedNEQ != nil {
		predicates = append(predicates, testsummary.TotalNumCachedNEQ(*i.TotalNumCachedNEQ))
	}
	if len(i.TotalNumCachedIn) > 0 {
		predicates = append(predicates, testsummary.TotalNumCachedIn(i.TotalNumCachedIn...))
	}
	if len(i.TotalNumCachedNotIn) > 0 {
		predicates = append(predicates, testsummary.TotalNumCachedNotIn(i.TotalNumCachedNotIn...))
	}
	if i.TotalNumCachedGT != nil {
		predicates = append(predicates, testsummary.TotalNumCachedGT(*i.TotalNumCachedGT))
	}
	if i.TotalNumCachedGTE != nil {
		predicates = append(predicates, testsummary.TotalNumCachedGTE(*i.TotalNumCachedGTE))
	}
	if i.TotalNumCachedLT != nil {
		predicates = append(predicates, testsummary.TotalNumCachedLT(*i.TotalNumCachedLT))
	}
	if i.TotalNumCachedLTE != nil {
		predicates = append(predicates, testsummary.TotalNumCachedLTE(*i.TotalNumCachedLTE))
	}
	if i.TotalNumCachedIsNil {
		predicates = append(predicates, testsummary.TotalNumCachedIsNil())
	}
	if i.TotalNumCachedNotNil {
		predicates = append(predicates, testsummary.TotalNumCachedNotNil())
	}
	if i.FirstStartTime != nil {
		predicates = append(predicates, testsummary.FirstStartTimeEQ(*i.FirstStartTime))
	}
	if i.FirstStartTimeNEQ != nil {
		predicates = append(predicates, testsummary.FirstStartTimeNEQ(*i.FirstStartTimeNEQ))
	}
	if len(i.FirstStartTimeIn) > 0 {
		predicates = append(predicates, testsummary.FirstStartTimeIn(i.FirstStartTimeIn...))
	}
	if len(i.FirstStartTimeNotIn) > 0 {
		predicates = append(predicates, testsummary.FirstStartTimeNotIn(i.FirstStartTimeNotIn...))
	}
	if i.FirstStartTimeGT != nil {
		predicates = append(predicates, testsummary.FirstStartTimeGT(*i.FirstStartTimeGT))
	}
	if i.FirstStartTimeGTE != nil {
		predicates = append(predicates, testsummary.FirstStartTimeGTE(*i.FirstStartTimeGTE))
	}
	if i.FirstStartTimeLT != nil {
		predicates = append(predicates, testsummary.FirstStartTimeLT(*i.FirstStartTimeLT))
	}
	if i.FirstStartTimeLTE != nil {
		predicates = append(predicates, testsummary.FirstStartTimeLTE(*i.FirstStartTimeLTE))
	}
	if i.FirstStartTimeIsNil {
		predicates = append(predicates, testsummary.FirstStartTimeIsNil())
	}
	if i.FirstStartTimeNotNil {
		predicates = append(predicates, testsummary.FirstStartTimeNotNil())
	}
	if i.LastStopTime != nil {
		predicates = append(predicates, testsummary.LastStopTimeEQ(*i.LastStopTime))
	}
	if i.LastStopTimeNEQ != nil {
		predicates = append(predicates, testsummary.LastStopTimeNEQ(*i.LastStopTimeNEQ))
	}
	if len(i.LastStopTimeIn) > 0 {
		predicates = append(predicates, testsummary.LastStopTimeIn(i.LastStopTimeIn...))
	}
	if len(i.LastStopTimeNotIn) > 0 {
		predicates = append(predicates, testsummary.LastStopTimeNotIn(i.LastStopTimeNotIn...))
	}
	if i.LastStopTimeGT != nil {
		predicates = append(predicates, testsummary.LastStopTimeGT(*i.LastStopTimeGT))
	}
	if i.LastStopTimeGTE != nil {
		predicates = append(predicates, testsummary.LastStopTimeGTE(*i.LastStopTimeGTE))
	}
	if i.LastStopTimeLT != nil {
		predicates = append(predicates, testsummary.LastStopTimeLT(*i.LastStopTimeLT))
	}
	if i.LastStopTimeLTE != nil {
		predicates = append(predicates, testsummary.LastStopTimeLTE(*i.LastStopTimeLTE))
	}
	if i.LastStopTimeIsNil {
		predicates = append(predicates, testsummary.LastStopTimeIsNil())
	}
	if i.LastStopTimeNotNil {
		predicates = append(predicates, testsummary.LastStopTimeNotNil())
	}
	if i.TotalRunDurationInMs != nil {
		predicates = append(predicates, testsummary.TotalRunDurationInMsEQ(*i.TotalRunDurationInMs))
	}
	if i.TotalRunDurationInMsNEQ != nil {
		predicates = append(predicates, testsummary.TotalRunDurationInMsNEQ(*i.TotalRunDurationInMsNEQ))
	}
	if len(i.TotalRunDurationInMsIn) > 0 {
		predicates = append(predicates, testsummary.TotalRunDurationInMsIn(i.TotalRunDurationInMsIn...))
	}
	if len(i.TotalRunDurationInMsNotIn) > 0 {
		predicates = append(predicates, testsummary.TotalRunDurationInMsNotIn(i.TotalRunDurationInMsNotIn...))
	}
	if i.TotalRunDurationInMsGT != nil {
		predicates = append(predicates, testsummary.TotalRunDurationInMsGT(*i.TotalRunDurationInMsGT))
	}
	if i.TotalRunDurationInMsGTE != nil {
		predicates = append(predicates, testsummary.TotalRunDurationInMsGTE(*i.TotalRunDurationInMsGTE))
	}
	if i.TotalRunDurationInMsLT != nil {
		predicates = append(predicates, testsummary.TotalRunDurationInMsLT(*i.TotalRunDurationInMsLT))
	}
	if i.TotalRunDurationInMsLTE != nil {
		predicates = append(predicates, testsummary.TotalRunDurationInMsLTE(*i.TotalRunDurationInMsLTE))
	}
	if i.TotalRunDurationInMsIsNil {
		predicates = append(predicates, testsummary.TotalRunDurationInMsIsNil())
	}
	if i.TotalRunDurationInMsNotNil {
		predicates = append(predicates, testsummary.TotalRunDurationInMsNotNil())
	}

	if i.HasInvocationTarget != nil {
		p := testsummary.HasInvocationTarget()
		if !*i.HasInvocationTarget {
			p = testsummary.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasInvocationTargetWith) > 0 {
		with := make([]predicate.InvocationTarget, 0, len(i.HasInvocationTargetWith))
		for _, w := range i.HasInvocationTargetWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasInvocationTargetWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, testsummary.HasInvocationTargetWith(with...))
	}
	if i.HasTestResults != nil {
		p := testsummary.HasTestResults()
		if !*i.HasTestResults {
			p = testsummary.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTestResultsWith) > 0 {
		with := make([]predicate.TestResult, 0, len(i.HasTestResultsWith))
		for _, w := range i.HasTestResultsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTestResultsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, testsummary.HasTestResultsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyTestSummaryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return testsummary.And(predicates...), nil
	}
}

// TimingMetricsWhereInput represents a where input for filtering TimingMetrics queries.
type TimingMetricsWhereInput struct {
	Predicates []predicate.TimingMetrics  `json:"-"`
	Not        *TimingMetricsWhereInput   `json:"not,omitempty"`
	Or         []*TimingMetricsWhereInput `json:"or,omitempty"`
	And        []*TimingMetricsWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int64  `json:"id,omitempty"`
	IDNEQ   *int64  `json:"idNEQ,omitempty"`
	IDIn    []int64 `json:"idIn,omitempty"`
	IDNotIn []int64 `json:"idNotIn,omitempty"`
	IDGT    *int64  `json:"idGT,omitempty"`
	IDGTE   *int64  `json:"idGTE,omitempty"`
	IDLT    *int64  `json:"idLT,omitempty"`
	IDLTE   *int64  `json:"idLTE,omitempty"`

	// "cpu_time_in_ms" field predicates.
	CPUTimeInMs       *int64  `json:"cpuTimeInMs,omitempty"`
	CPUTimeInMsNEQ    *int64  `json:"cpuTimeInMsNEQ,omitempty"`
	CPUTimeInMsIn     []int64 `json:"cpuTimeInMsIn,omitempty"`
	CPUTimeInMsNotIn  []int64 `json:"cpuTimeInMsNotIn,omitempty"`
	CPUTimeInMsGT     *int64  `json:"cpuTimeInMsGT,omitempty"`
	CPUTimeInMsGTE    *int64  `json:"cpuTimeInMsGTE,omitempty"`
	CPUTimeInMsLT     *int64  `json:"cpuTimeInMsLT,omitempty"`
	CPUTimeInMsLTE    *int64  `json:"cpuTimeInMsLTE,omitempty"`
	CPUTimeInMsIsNil  bool    `json:"cpuTimeInMsIsNil,omitempty"`
	CPUTimeInMsNotNil bool    `json:"cpuTimeInMsNotNil,omitempty"`

	// "wall_time_in_ms" field predicates.
	WallTimeInMs       *int64  `json:"wallTimeInMs,omitempty"`
	WallTimeInMsNEQ    *int64  `json:"wallTimeInMsNEQ,omitempty"`
	WallTimeInMsIn     []int64 `json:"wallTimeInMsIn,omitempty"`
	WallTimeInMsNotIn  []int64 `json:"wallTimeInMsNotIn,omitempty"`
	WallTimeInMsGT     *int64  `json:"wallTimeInMsGT,omitempty"`
	WallTimeInMsGTE    *int64  `json:"wallTimeInMsGTE,omitempty"`
	WallTimeInMsLT     *int64  `json:"wallTimeInMsLT,omitempty"`
	WallTimeInMsLTE    *int64  `json:"wallTimeInMsLTE,omitempty"`
	WallTimeInMsIsNil  bool    `json:"wallTimeInMsIsNil,omitempty"`
	WallTimeInMsNotNil bool    `json:"wallTimeInMsNotNil,omitempty"`

	// "analysis_phase_time_in_ms" field predicates.
	AnalysisPhaseTimeInMs       *int64  `json:"analysisPhaseTimeInMs,omitempty"`
	AnalysisPhaseTimeInMsNEQ    *int64  `json:"analysisPhaseTimeInMsNEQ,omitempty"`
	AnalysisPhaseTimeInMsIn     []int64 `json:"analysisPhaseTimeInMsIn,omitempty"`
	AnalysisPhaseTimeInMsNotIn  []int64 `json:"analysisPhaseTimeInMsNotIn,omitempty"`
	AnalysisPhaseTimeInMsGT     *int64  `json:"analysisPhaseTimeInMsGT,omitempty"`
	AnalysisPhaseTimeInMsGTE    *int64  `json:"analysisPhaseTimeInMsGTE,omitempty"`
	AnalysisPhaseTimeInMsLT     *int64  `json:"analysisPhaseTimeInMsLT,omitempty"`
	AnalysisPhaseTimeInMsLTE    *int64  `json:"analysisPhaseTimeInMsLTE,omitempty"`
	AnalysisPhaseTimeInMsIsNil  bool    `json:"analysisPhaseTimeInMsIsNil,omitempty"`
	AnalysisPhaseTimeInMsNotNil bool    `json:"analysisPhaseTimeInMsNotNil,omitempty"`

	// "execution_phase_time_in_ms" field predicates.
	ExecutionPhaseTimeInMs       *int64  `json:"executionPhaseTimeInMs,omitempty"`
	ExecutionPhaseTimeInMsNEQ    *int64  `json:"executionPhaseTimeInMsNEQ,omitempty"`
	ExecutionPhaseTimeInMsIn     []int64 `json:"executionPhaseTimeInMsIn,omitempty"`
	ExecutionPhaseTimeInMsNotIn  []int64 `json:"executionPhaseTimeInMsNotIn,omitempty"`
	ExecutionPhaseTimeInMsGT     *int64  `json:"executionPhaseTimeInMsGT,omitempty"`
	ExecutionPhaseTimeInMsGTE    *int64  `json:"executionPhaseTimeInMsGTE,omitempty"`
	ExecutionPhaseTimeInMsLT     *int64  `json:"executionPhaseTimeInMsLT,omitempty"`
	ExecutionPhaseTimeInMsLTE    *int64  `json:"executionPhaseTimeInMsLTE,omitempty"`
	ExecutionPhaseTimeInMsIsNil  bool    `json:"executionPhaseTimeInMsIsNil,omitempty"`
	ExecutionPhaseTimeInMsNotNil bool    `json:"executionPhaseTimeInMsNotNil,omitempty"`

	// "actions_execution_start_in_ms" field predicates.
	ActionsExecutionStartInMs       *int64  `json:"actionsExecutionStartInMs,omitempty"`
	ActionsExecutionStartInMsNEQ    *int64  `json:"actionsExecutionStartInMsNEQ,omitempty"`
	ActionsExecutionStartInMsIn     []int64 `json:"actionsExecutionStartInMsIn,omitempty"`
	ActionsExecutionStartInMsNotIn  []int64 `json:"actionsExecutionStartInMsNotIn,omitempty"`
	ActionsExecutionStartInMsGT     *int64  `json:"actionsExecutionStartInMsGT,omitempty"`
	ActionsExecutionStartInMsGTE    *int64  `json:"actionsExecutionStartInMsGTE,omitempty"`
	ActionsExecutionStartInMsLT     *int64  `json:"actionsExecutionStartInMsLT,omitempty"`
	ActionsExecutionStartInMsLTE    *int64  `json:"actionsExecutionStartInMsLTE,omitempty"`
	ActionsExecutionStartInMsIsNil  bool    `json:"actionsExecutionStartInMsIsNil,omitempty"`
	ActionsExecutionStartInMsNotNil bool    `json:"actionsExecutionStartInMsNotNil,omitempty"`

	// "metrics" edge predicates.
	HasMetrics     *bool                `json:"hasMetrics,omitempty"`
	HasMetricsWith []*MetricsWhereInput `json:"hasMetricsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *TimingMetricsWhereInput) AddPredicates(predicates ...predicate.TimingMetrics) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the TimingMetricsWhereInput filter on the TimingMetricsQuery builder.
func (i *TimingMetricsWhereInput) Filter(q *TimingMetricsQuery) (*TimingMetricsQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyTimingMetricsWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyTimingMetricsWhereInput is returned in case the TimingMetricsWhereInput is empty.
var ErrEmptyTimingMetricsWhereInput = errors.New("ent: empty predicate TimingMetricsWhereInput")

// P returns a predicate for filtering timingmetricsslice.
// An error is returned if the input is empty or invalid.
func (i *TimingMetricsWhereInput) P() (predicate.TimingMetrics, error) {
	var predicates []predicate.TimingMetrics
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, timingmetrics.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.TimingMetrics, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, timingmetrics.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.TimingMetrics, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, timingmetrics.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, timingmetrics.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, timingmetrics.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, timingmetrics.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, timingmetrics.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, timingmetrics.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, timingmetrics.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, timingmetrics.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, timingmetrics.IDLTE(*i.IDLTE))
	}
	if i.CPUTimeInMs != nil {
		predicates = append(predicates, timingmetrics.CPUTimeInMsEQ(*i.CPUTimeInMs))
	}
	if i.CPUTimeInMsNEQ != nil {
		predicates = append(predicates, timingmetrics.CPUTimeInMsNEQ(*i.CPUTimeInMsNEQ))
	}
	if len(i.CPUTimeInMsIn) > 0 {
		predicates = append(predicates, timingmetrics.CPUTimeInMsIn(i.CPUTimeInMsIn...))
	}
	if len(i.CPUTimeInMsNotIn) > 0 {
		predicates = append(predicates, timingmetrics.CPUTimeInMsNotIn(i.CPUTimeInMsNotIn...))
	}
	if i.CPUTimeInMsGT != nil {
		predicates = append(predicates, timingmetrics.CPUTimeInMsGT(*i.CPUTimeInMsGT))
	}
	if i.CPUTimeInMsGTE != nil {
		predicates = append(predicates, timingmetrics.CPUTimeInMsGTE(*i.CPUTimeInMsGTE))
	}
	if i.CPUTimeInMsLT != nil {
		predicates = append(predicates, timingmetrics.CPUTimeInMsLT(*i.CPUTimeInMsLT))
	}
	if i.CPUTimeInMsLTE != nil {
		predicates = append(predicates, timingmetrics.CPUTimeInMsLTE(*i.CPUTimeInMsLTE))
	}
	if i.CPUTimeInMsIsNil {
		predicates = append(predicates, timingmetrics.CPUTimeInMsIsNil())
	}
	if i.CPUTimeInMsNotNil {
		predicates = append(predicates, timingmetrics.CPUTimeInMsNotNil())
	}
	if i.WallTimeInMs != nil {
		predicates = append(predicates, timingmetrics.WallTimeInMsEQ(*i.WallTimeInMs))
	}
	if i.WallTimeInMsNEQ != nil {
		predicates = append(predicates, timingmetrics.WallTimeInMsNEQ(*i.WallTimeInMsNEQ))
	}
	if len(i.WallTimeInMsIn) > 0 {
		predicates = append(predicates, timingmetrics.WallTimeInMsIn(i.WallTimeInMsIn...))
	}
	if len(i.WallTimeInMsNotIn) > 0 {
		predicates = append(predicates, timingmetrics.WallTimeInMsNotIn(i.WallTimeInMsNotIn...))
	}
	if i.WallTimeInMsGT != nil {
		predicates = append(predicates, timingmetrics.WallTimeInMsGT(*i.WallTimeInMsGT))
	}
	if i.WallTimeInMsGTE != nil {
		predicates = append(predicates, timingmetrics.WallTimeInMsGTE(*i.WallTimeInMsGTE))
	}
	if i.WallTimeInMsLT != nil {
		predicates = append(predicates, timingmetrics.WallTimeInMsLT(*i.WallTimeInMsLT))
	}
	if i.WallTimeInMsLTE != nil {
		predicates = append(predicates, timingmetrics.WallTimeInMsLTE(*i.WallTimeInMsLTE))
	}
	if i.WallTimeInMsIsNil {
		predicates = append(predicates, timingmetrics.WallTimeInMsIsNil())
	}
	if i.WallTimeInMsNotNil {
		predicates = append(predicates, timingmetrics.WallTimeInMsNotNil())
	}
	if i.AnalysisPhaseTimeInMs != nil {
		predicates = append(predicates, timingmetrics.AnalysisPhaseTimeInMsEQ(*i.AnalysisPhaseTimeInMs))
	}
	if i.AnalysisPhaseTimeInMsNEQ != nil {
		predicates = append(predicates, timingmetrics.AnalysisPhaseTimeInMsNEQ(*i.AnalysisPhaseTimeInMsNEQ))
	}
	if len(i.AnalysisPhaseTimeInMsIn) > 0 {
		predicates = append(predicates, timingmetrics.AnalysisPhaseTimeInMsIn(i.AnalysisPhaseTimeInMsIn...))
	}
	if len(i.AnalysisPhaseTimeInMsNotIn) > 0 {
		predicates = append(predicates, timingmetrics.AnalysisPhaseTimeInMsNotIn(i.AnalysisPhaseTimeInMsNotIn...))
	}
	if i.AnalysisPhaseTimeInMsGT != nil {
		predicates = append(predicates, timingmetrics.AnalysisPhaseTimeInMsGT(*i.AnalysisPhaseTimeInMsGT))
	}
	if i.AnalysisPhaseTimeInMsGTE != nil {
		predicates = append(predicates, timingmetrics.AnalysisPhaseTimeInMsGTE(*i.AnalysisPhaseTimeInMsGTE))
	}
	if i.AnalysisPhaseTimeInMsLT != nil {
		predicates = append(predicates, timingmetrics.AnalysisPhaseTimeInMsLT(*i.AnalysisPhaseTimeInMsLT))
	}
	if i.AnalysisPhaseTimeInMsLTE != nil {
		predicates = append(predicates, timingmetrics.AnalysisPhaseTimeInMsLTE(*i.AnalysisPhaseTimeInMsLTE))
	}
	if i.AnalysisPhaseTimeInMsIsNil {
		predicates = append(predicates, timingmetrics.AnalysisPhaseTimeInMsIsNil())
	}
	if i.AnalysisPhaseTimeInMsNotNil {
		predicates = append(predicates, timingmetrics.AnalysisPhaseTimeInMsNotNil())
	}
	if i.ExecutionPhaseTimeInMs != nil {
		predicates = append(predicates, timingmetrics.ExecutionPhaseTimeInMsEQ(*i.ExecutionPhaseTimeInMs))
	}
	if i.ExecutionPhaseTimeInMsNEQ != nil {
		predicates = append(predicates, timingmetrics.ExecutionPhaseTimeInMsNEQ(*i.ExecutionPhaseTimeInMsNEQ))
	}
	if len(i.ExecutionPhaseTimeInMsIn) > 0 {
		predicates = append(predicates, timingmetrics.ExecutionPhaseTimeInMsIn(i.ExecutionPhaseTimeInMsIn...))
	}
	if len(i.ExecutionPhaseTimeInMsNotIn) > 0 {
		predicates = append(predicates, timingmetrics.ExecutionPhaseTimeInMsNotIn(i.ExecutionPhaseTimeInMsNotIn...))
	}
	if i.ExecutionPhaseTimeInMsGT != nil {
		predicates = append(predicates, timingmetrics.ExecutionPhaseTimeInMsGT(*i.ExecutionPhaseTimeInMsGT))
	}
	if i.ExecutionPhaseTimeInMsGTE != nil {
		predicates = append(predicates, timingmetrics.ExecutionPhaseTimeInMsGTE(*i.ExecutionPhaseTimeInMsGTE))
	}
	if i.ExecutionPhaseTimeInMsLT != nil {
		predicates = append(predicates, timingmetrics.ExecutionPhaseTimeInMsLT(*i.ExecutionPhaseTimeInMsLT))
	}
	if i.ExecutionPhaseTimeInMsLTE != nil {
		predicates = append(predicates, timingmetrics.ExecutionPhaseTimeInMsLTE(*i.ExecutionPhaseTimeInMsLTE))
	}
	if i.ExecutionPhaseTimeInMsIsNil {
		predicates = append(predicates, timingmetrics.ExecutionPhaseTimeInMsIsNil())
	}
	if i.ExecutionPhaseTimeInMsNotNil {
		predicates = append(predicates, timingmetrics.ExecutionPhaseTimeInMsNotNil())
	}
	if i.ActionsExecutionStartInMs != nil {
		predicates = append(predicates, timingmetrics.ActionsExecutionStartInMsEQ(*i.ActionsExecutionStartInMs))
	}
	if i.ActionsExecutionStartInMsNEQ != nil {
		predicates = append(predicates, timingmetrics.ActionsExecutionStartInMsNEQ(*i.ActionsExecutionStartInMsNEQ))
	}
	if len(i.ActionsExecutionStartInMsIn) > 0 {
		predicates = append(predicates, timingmetrics.ActionsExecutionStartInMsIn(i.ActionsExecutionStartInMsIn...))
	}
	if len(i.ActionsExecutionStartInMsNotIn) > 0 {
		predicates = append(predicates, timingmetrics.ActionsExecutionStartInMsNotIn(i.ActionsExecutionStartInMsNotIn...))
	}
	if i.ActionsExecutionStartInMsGT != nil {
		predicates = append(predicates, timingmetrics.ActionsExecutionStartInMsGT(*i.ActionsExecutionStartInMsGT))
	}
	if i.ActionsExecutionStartInMsGTE != nil {
		predicates = append(predicates, timingmetrics.ActionsExecutionStartInMsGTE(*i.ActionsExecutionStartInMsGTE))
	}
	if i.ActionsExecutionStartInMsLT != nil {
		predicates = append(predicates, timingmetrics.ActionsExecutionStartInMsLT(*i.ActionsExecutionStartInMsLT))
	}
	if i.ActionsExecutionStartInMsLTE != nil {
		predicates = append(predicates, timingmetrics.ActionsExecutionStartInMsLTE(*i.ActionsExecutionStartInMsLTE))
	}
	if i.ActionsExecutionStartInMsIsNil {
		predicates = append(predicates, timingmetrics.ActionsExecutionStartInMsIsNil())
	}
	if i.ActionsExecutionStartInMsNotNil {
		predicates = append(predicates, timingmetrics.ActionsExecutionStartInMsNotNil())
	}

	if i.HasMetrics != nil {
		p := timingmetrics.HasMetrics()
		if !*i.HasMetrics {
			p = timingmetrics.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMetricsWith) > 0 {
		with := make([]predicate.Metrics, 0, len(i.HasMetricsWith))
		for _, w := range i.HasMetricsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMetricsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, timingmetrics.HasMetricsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyTimingMetricsWhereInput
	case 1:
		return predicates[0], nil
	default:
		return timingmetrics.And(predicates...), nil
	}
}
