// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/buildbarn/bb-portal/ent/gen/ent/action"
	"github.com/buildbarn/bb-portal/ent/gen/ent/actioncachestatistics"
	"github.com/buildbarn/bb-portal/ent/gen/ent/actiondata"
	"github.com/buildbarn/bb-portal/ent/gen/ent/actionsummary"
	"github.com/buildbarn/bb-portal/ent/gen/ent/artifactmetrics"
	"github.com/buildbarn/bb-portal/ent/gen/ent/authenticateduser"
	"github.com/buildbarn/bb-portal/ent/gen/ent/bazelinvocation"
	"github.com/buildbarn/bb-portal/ent/gen/ent/build"
	"github.com/buildbarn/bb-portal/ent/gen/ent/buildgraphmetrics"
	"github.com/buildbarn/bb-portal/ent/gen/ent/buildlogchunk"
	"github.com/buildbarn/bb-portal/ent/gen/ent/configuration"
	"github.com/buildbarn/bb-portal/ent/gen/ent/connectionmetadata"
	"github.com/buildbarn/bb-portal/ent/gen/ent/cumulativemetrics"
	"github.com/buildbarn/bb-portal/ent/gen/ent/evaluationstat"
	"github.com/buildbarn/bb-portal/ent/gen/ent/eventmetadata"
	"github.com/buildbarn/bb-portal/ent/gen/ent/garbagemetrics"
	"github.com/buildbarn/bb-portal/ent/gen/ent/incompletebuildlog"
	"github.com/buildbarn/bb-portal/ent/gen/ent/instancename"
	"github.com/buildbarn/bb-portal/ent/gen/ent/invocationfiles"
	"github.com/buildbarn/bb-portal/ent/gen/ent/invocationtarget"
	"github.com/buildbarn/bb-portal/ent/gen/ent/memorymetrics"
	"github.com/buildbarn/bb-portal/ent/gen/ent/metrics"
	"github.com/buildbarn/bb-portal/ent/gen/ent/missdetail"
	"github.com/buildbarn/bb-portal/ent/gen/ent/networkmetrics"
	"github.com/buildbarn/bb-portal/ent/gen/ent/packageloadmetrics"
	"github.com/buildbarn/bb-portal/ent/gen/ent/packagemetrics"
	"github.com/buildbarn/bb-portal/ent/gen/ent/predicate"
	"github.com/buildbarn/bb-portal/ent/gen/ent/runnercount"
	"github.com/buildbarn/bb-portal/ent/gen/ent/sourcecontrol"
	"github.com/buildbarn/bb-portal/ent/gen/ent/systemnetworkstats"
	"github.com/buildbarn/bb-portal/ent/gen/ent/target"
	"github.com/buildbarn/bb-portal/ent/gen/ent/targetkindmapping"
	"github.com/buildbarn/bb-portal/ent/gen/ent/targetmetrics"
	"github.com/buildbarn/bb-portal/ent/gen/ent/testresult"
	"github.com/buildbarn/bb-portal/ent/gen/ent/testsummary"
	"github.com/buildbarn/bb-portal/ent/gen/ent/timingmetrics"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAction                = "Action"
	TypeActionCacheStatistics = "ActionCacheStatistics"
	TypeActionData            = "ActionData"
	TypeActionSummary         = "ActionSummary"
	TypeArtifactMetrics       = "ArtifactMetrics"
	TypeAuthenticatedUser     = "AuthenticatedUser"
	TypeBazelInvocation       = "BazelInvocation"
	TypeBuild                 = "Build"
	TypeBuildGraphMetrics     = "BuildGraphMetrics"
	TypeBuildLogChunk         = "BuildLogChunk"
	TypeConfiguration         = "Configuration"
	TypeConnectionMetadata    = "ConnectionMetadata"
	TypeCumulativeMetrics     = "CumulativeMetrics"
	TypeEvaluationStat        = "EvaluationStat"
	TypeEventMetadata         = "EventMetadata"
	TypeGarbageMetrics        = "GarbageMetrics"
	TypeIncompleteBuildLog    = "IncompleteBuildLog"
	TypeInstanceName          = "InstanceName"
	TypeInvocationFiles       = "InvocationFiles"
	TypeInvocationTarget      = "InvocationTarget"
	TypeMemoryMetrics         = "MemoryMetrics"
	TypeMetrics               = "Metrics"
	TypeMissDetail            = "MissDetail"
	TypeNetworkMetrics        = "NetworkMetrics"
	TypePackageLoadMetrics    = "PackageLoadMetrics"
	TypePackageMetrics        = "PackageMetrics"
	TypeRunnerCount           = "RunnerCount"
	TypeSourceControl         = "SourceControl"
	TypeSystemNetworkStats    = "SystemNetworkStats"
	TypeTarget                = "Target"
	TypeTargetKindMapping     = "TargetKindMapping"
	TypeTargetMetrics         = "TargetMetrics"
	TypeTestResult            = "TestResult"
	TypeTestSummary           = "TestSummary"
	TypeTimingMetrics         = "TimingMetrics"
)

// ActionMutation represents an operation that mutates the Action nodes in the graph.
type ActionMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int64
	label                   *string
	_type                   *string
	success                 *bool
	exit_code               *int32
	addexit_code            *int32
	command_line            *[]string
	appendcommand_line      []string
	start_time              *time.Time
	end_time                *time.Time
	failure_code            *string
	failure_message         *string
	stdout_hash             *string
	stdout_size_bytes       *int64
	addstdout_size_bytes    *int64
	stdout_hash_function    *string
	stderr_hash             *string
	stderr_size_bytes       *int64
	addstderr_size_bytes    *int64
	stderr_hash_function    *string
	clearedFields           map[string]struct{}
	bazel_invocation        *int64
	clearedbazel_invocation bool
	configuration           *int64
	clearedconfiguration    bool
	done                    bool
	oldValue                func(context.Context) (*Action, error)
	predicates              []predicate.Action
}

var _ ent.Mutation = (*ActionMutation)(nil)

// actionOption allows management of the mutation configuration using functional options.
type actionOption func(*ActionMutation)

// newActionMutation creates new mutation for the Action entity.
func newActionMutation(c config, op Op, opts ...actionOption) *ActionMutation {
	m := &ActionMutation{
		config:        c,
		op:            op,
		typ:           TypeAction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withActionID sets the ID field of the mutation.
func withActionID(id int64) actionOption {
	return func(m *ActionMutation) {
		var (
			err   error
			once  sync.Once
			value *Action
		)
		m.oldValue = func(ctx context.Context) (*Action, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Action.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAction sets the old Action of the mutation.
func withAction(node *Action) actionOption {
	return func(m *ActionMutation) {
		m.oldValue = func(context.Context) (*Action, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ActionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ActionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Action entities.
func (m *ActionMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ActionMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ActionMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Action.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBazelInvocationID sets the "bazel_invocation_id" field.
func (m *ActionMutation) SetBazelInvocationID(i int64) {
	m.bazel_invocation = &i
}

// BazelInvocationID returns the value of the "bazel_invocation_id" field in the mutation.
func (m *ActionMutation) BazelInvocationID() (r int64, exists bool) {
	v := m.bazel_invocation
	if v == nil {
		return
	}
	return *v, true
}

// OldBazelInvocationID returns the old "bazel_invocation_id" field's value of the Action entity.
// If the Action object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionMutation) OldBazelInvocationID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBazelInvocationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBazelInvocationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBazelInvocationID: %w", err)
	}
	return oldValue.BazelInvocationID, nil
}

// ResetBazelInvocationID resets all changes to the "bazel_invocation_id" field.
func (m *ActionMutation) ResetBazelInvocationID() {
	m.bazel_invocation = nil
}

// SetConfigurationID sets the "configuration_id" field.
func (m *ActionMutation) SetConfigurationID(i int64) {
	m.configuration = &i
}

// ConfigurationID returns the value of the "configuration_id" field in the mutation.
func (m *ActionMutation) ConfigurationID() (r int64, exists bool) {
	v := m.configuration
	if v == nil {
		return
	}
	return *v, true
}

// OldConfigurationID returns the old "configuration_id" field's value of the Action entity.
// If the Action object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionMutation) OldConfigurationID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfigurationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfigurationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfigurationID: %w", err)
	}
	return oldValue.ConfigurationID, nil
}

// ResetConfigurationID resets all changes to the "configuration_id" field.
func (m *ActionMutation) ResetConfigurationID() {
	m.configuration = nil
}

// SetLabel sets the "label" field.
func (m *ActionMutation) SetLabel(s string) {
	m.label = &s
}

// Label returns the value of the "label" field in the mutation.
func (m *ActionMutation) Label() (r string, exists bool) {
	v := m.label
	if v == nil {
		return
	}
	return *v, true
}

// OldLabel returns the old "label" field's value of the Action entity.
// If the Action object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionMutation) OldLabel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabel: %w", err)
	}
	return oldValue.Label, nil
}

// ResetLabel resets all changes to the "label" field.
func (m *ActionMutation) ResetLabel() {
	m.label = nil
}

// SetType sets the "type" field.
func (m *ActionMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ActionMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Action entity.
// If the Action object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *ActionMutation) ClearType() {
	m._type = nil
	m.clearedFields[action.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *ActionMutation) TypeCleared() bool {
	_, ok := m.clearedFields[action.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *ActionMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, action.FieldType)
}

// SetSuccess sets the "success" field.
func (m *ActionMutation) SetSuccess(b bool) {
	m.success = &b
}

// Success returns the value of the "success" field in the mutation.
func (m *ActionMutation) Success() (r bool, exists bool) {
	v := m.success
	if v == nil {
		return
	}
	return *v, true
}

// OldSuccess returns the old "success" field's value of the Action entity.
// If the Action object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionMutation) OldSuccess(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuccess is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuccess requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuccess: %w", err)
	}
	return oldValue.Success, nil
}

// ClearSuccess clears the value of the "success" field.
func (m *ActionMutation) ClearSuccess() {
	m.success = nil
	m.clearedFields[action.FieldSuccess] = struct{}{}
}

// SuccessCleared returns if the "success" field was cleared in this mutation.
func (m *ActionMutation) SuccessCleared() bool {
	_, ok := m.clearedFields[action.FieldSuccess]
	return ok
}

// ResetSuccess resets all changes to the "success" field.
func (m *ActionMutation) ResetSuccess() {
	m.success = nil
	delete(m.clearedFields, action.FieldSuccess)
}

// SetExitCode sets the "exit_code" field.
func (m *ActionMutation) SetExitCode(i int32) {
	m.exit_code = &i
	m.addexit_code = nil
}

// ExitCode returns the value of the "exit_code" field in the mutation.
func (m *ActionMutation) ExitCode() (r int32, exists bool) {
	v := m.exit_code
	if v == nil {
		return
	}
	return *v, true
}

// OldExitCode returns the old "exit_code" field's value of the Action entity.
// If the Action object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionMutation) OldExitCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExitCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExitCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExitCode: %w", err)
	}
	return oldValue.ExitCode, nil
}

// AddExitCode adds i to the "exit_code" field.
func (m *ActionMutation) AddExitCode(i int32) {
	if m.addexit_code != nil {
		*m.addexit_code += i
	} else {
		m.addexit_code = &i
	}
}

// AddedExitCode returns the value that was added to the "exit_code" field in this mutation.
func (m *ActionMutation) AddedExitCode() (r int32, exists bool) {
	v := m.addexit_code
	if v == nil {
		return
	}
	return *v, true
}

// ClearExitCode clears the value of the "exit_code" field.
func (m *ActionMutation) ClearExitCode() {
	m.exit_code = nil
	m.addexit_code = nil
	m.clearedFields[action.FieldExitCode] = struct{}{}
}

// ExitCodeCleared returns if the "exit_code" field was cleared in this mutation.
func (m *ActionMutation) ExitCodeCleared() bool {
	_, ok := m.clearedFields[action.FieldExitCode]
	return ok
}

// ResetExitCode resets all changes to the "exit_code" field.
func (m *ActionMutation) ResetExitCode() {
	m.exit_code = nil
	m.addexit_code = nil
	delete(m.clearedFields, action.FieldExitCode)
}

// SetCommandLine sets the "command_line" field.
func (m *ActionMutation) SetCommandLine(s []string) {
	m.command_line = &s
	m.appendcommand_line = nil
}

// CommandLine returns the value of the "command_line" field in the mutation.
func (m *ActionMutation) CommandLine() (r []string, exists bool) {
	v := m.command_line
	if v == nil {
		return
	}
	return *v, true
}

// OldCommandLine returns the old "command_line" field's value of the Action entity.
// If the Action object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionMutation) OldCommandLine(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommandLine is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommandLine requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommandLine: %w", err)
	}
	return oldValue.CommandLine, nil
}

// AppendCommandLine adds s to the "command_line" field.
func (m *ActionMutation) AppendCommandLine(s []string) {
	m.appendcommand_line = append(m.appendcommand_line, s...)
}

// AppendedCommandLine returns the list of values that were appended to the "command_line" field in this mutation.
func (m *ActionMutation) AppendedCommandLine() ([]string, bool) {
	if len(m.appendcommand_line) == 0 {
		return nil, false
	}
	return m.appendcommand_line, true
}

// ClearCommandLine clears the value of the "command_line" field.
func (m *ActionMutation) ClearCommandLine() {
	m.command_line = nil
	m.appendcommand_line = nil
	m.clearedFields[action.FieldCommandLine] = struct{}{}
}

// CommandLineCleared returns if the "command_line" field was cleared in this mutation.
func (m *ActionMutation) CommandLineCleared() bool {
	_, ok := m.clearedFields[action.FieldCommandLine]
	return ok
}

// ResetCommandLine resets all changes to the "command_line" field.
func (m *ActionMutation) ResetCommandLine() {
	m.command_line = nil
	m.appendcommand_line = nil
	delete(m.clearedFields, action.FieldCommandLine)
}

// SetStartTime sets the "start_time" field.
func (m *ActionMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *ActionMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the Action entity.
// If the Action object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ClearStartTime clears the value of the "start_time" field.
func (m *ActionMutation) ClearStartTime() {
	m.start_time = nil
	m.clearedFields[action.FieldStartTime] = struct{}{}
}

// StartTimeCleared returns if the "start_time" field was cleared in this mutation.
func (m *ActionMutation) StartTimeCleared() bool {
	_, ok := m.clearedFields[action.FieldStartTime]
	return ok
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *ActionMutation) ResetStartTime() {
	m.start_time = nil
	delete(m.clearedFields, action.FieldStartTime)
}

// SetEndTime sets the "end_time" field.
func (m *ActionMutation) SetEndTime(t time.Time) {
	m.end_time = &t
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *ActionMutation) EndTime() (r time.Time, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the Action entity.
// If the Action object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ClearEndTime clears the value of the "end_time" field.
func (m *ActionMutation) ClearEndTime() {
	m.end_time = nil
	m.clearedFields[action.FieldEndTime] = struct{}{}
}

// EndTimeCleared returns if the "end_time" field was cleared in this mutation.
func (m *ActionMutation) EndTimeCleared() bool {
	_, ok := m.clearedFields[action.FieldEndTime]
	return ok
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *ActionMutation) ResetEndTime() {
	m.end_time = nil
	delete(m.clearedFields, action.FieldEndTime)
}

// SetFailureCode sets the "failure_code" field.
func (m *ActionMutation) SetFailureCode(s string) {
	m.failure_code = &s
}

// FailureCode returns the value of the "failure_code" field in the mutation.
func (m *ActionMutation) FailureCode() (r string, exists bool) {
	v := m.failure_code
	if v == nil {
		return
	}
	return *v, true
}

// OldFailureCode returns the old "failure_code" field's value of the Action entity.
// If the Action object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionMutation) OldFailureCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFailureCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFailureCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFailureCode: %w", err)
	}
	return oldValue.FailureCode, nil
}

// ClearFailureCode clears the value of the "failure_code" field.
func (m *ActionMutation) ClearFailureCode() {
	m.failure_code = nil
	m.clearedFields[action.FieldFailureCode] = struct{}{}
}

// FailureCodeCleared returns if the "failure_code" field was cleared in this mutation.
func (m *ActionMutation) FailureCodeCleared() bool {
	_, ok := m.clearedFields[action.FieldFailureCode]
	return ok
}

// ResetFailureCode resets all changes to the "failure_code" field.
func (m *ActionMutation) ResetFailureCode() {
	m.failure_code = nil
	delete(m.clearedFields, action.FieldFailureCode)
}

// SetFailureMessage sets the "failure_message" field.
func (m *ActionMutation) SetFailureMessage(s string) {
	m.failure_message = &s
}

// FailureMessage returns the value of the "failure_message" field in the mutation.
func (m *ActionMutation) FailureMessage() (r string, exists bool) {
	v := m.failure_message
	if v == nil {
		return
	}
	return *v, true
}

// OldFailureMessage returns the old "failure_message" field's value of the Action entity.
// If the Action object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionMutation) OldFailureMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFailureMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFailureMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFailureMessage: %w", err)
	}
	return oldValue.FailureMessage, nil
}

// ClearFailureMessage clears the value of the "failure_message" field.
func (m *ActionMutation) ClearFailureMessage() {
	m.failure_message = nil
	m.clearedFields[action.FieldFailureMessage] = struct{}{}
}

// FailureMessageCleared returns if the "failure_message" field was cleared in this mutation.
func (m *ActionMutation) FailureMessageCleared() bool {
	_, ok := m.clearedFields[action.FieldFailureMessage]
	return ok
}

// ResetFailureMessage resets all changes to the "failure_message" field.
func (m *ActionMutation) ResetFailureMessage() {
	m.failure_message = nil
	delete(m.clearedFields, action.FieldFailureMessage)
}

// SetStdoutHash sets the "stdout_hash" field.
func (m *ActionMutation) SetStdoutHash(s string) {
	m.stdout_hash = &s
}

// StdoutHash returns the value of the "stdout_hash" field in the mutation.
func (m *ActionMutation) StdoutHash() (r string, exists bool) {
	v := m.stdout_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldStdoutHash returns the old "stdout_hash" field's value of the Action entity.
// If the Action object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionMutation) OldStdoutHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStdoutHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStdoutHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStdoutHash: %w", err)
	}
	return oldValue.StdoutHash, nil
}

// ClearStdoutHash clears the value of the "stdout_hash" field.
func (m *ActionMutation) ClearStdoutHash() {
	m.stdout_hash = nil
	m.clearedFields[action.FieldStdoutHash] = struct{}{}
}

// StdoutHashCleared returns if the "stdout_hash" field was cleared in this mutation.
func (m *ActionMutation) StdoutHashCleared() bool {
	_, ok := m.clearedFields[action.FieldStdoutHash]
	return ok
}

// ResetStdoutHash resets all changes to the "stdout_hash" field.
func (m *ActionMutation) ResetStdoutHash() {
	m.stdout_hash = nil
	delete(m.clearedFields, action.FieldStdoutHash)
}

// SetStdoutSizeBytes sets the "stdout_size_bytes" field.
func (m *ActionMutation) SetStdoutSizeBytes(i int64) {
	m.stdout_size_bytes = &i
	m.addstdout_size_bytes = nil
}

// StdoutSizeBytes returns the value of the "stdout_size_bytes" field in the mutation.
func (m *ActionMutation) StdoutSizeBytes() (r int64, exists bool) {
	v := m.stdout_size_bytes
	if v == nil {
		return
	}
	return *v, true
}

// OldStdoutSizeBytes returns the old "stdout_size_bytes" field's value of the Action entity.
// If the Action object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionMutation) OldStdoutSizeBytes(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStdoutSizeBytes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStdoutSizeBytes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStdoutSizeBytes: %w", err)
	}
	return oldValue.StdoutSizeBytes, nil
}

// AddStdoutSizeBytes adds i to the "stdout_size_bytes" field.
func (m *ActionMutation) AddStdoutSizeBytes(i int64) {
	if m.addstdout_size_bytes != nil {
		*m.addstdout_size_bytes += i
	} else {
		m.addstdout_size_bytes = &i
	}
}

// AddedStdoutSizeBytes returns the value that was added to the "stdout_size_bytes" field in this mutation.
func (m *ActionMutation) AddedStdoutSizeBytes() (r int64, exists bool) {
	v := m.addstdout_size_bytes
	if v == nil {
		return
	}
	return *v, true
}

// ClearStdoutSizeBytes clears the value of the "stdout_size_bytes" field.
func (m *ActionMutation) ClearStdoutSizeBytes() {
	m.stdout_size_bytes = nil
	m.addstdout_size_bytes = nil
	m.clearedFields[action.FieldStdoutSizeBytes] = struct{}{}
}

// StdoutSizeBytesCleared returns if the "stdout_size_bytes" field was cleared in this mutation.
func (m *ActionMutation) StdoutSizeBytesCleared() bool {
	_, ok := m.clearedFields[action.FieldStdoutSizeBytes]
	return ok
}

// ResetStdoutSizeBytes resets all changes to the "stdout_size_bytes" field.
func (m *ActionMutation) ResetStdoutSizeBytes() {
	m.stdout_size_bytes = nil
	m.addstdout_size_bytes = nil
	delete(m.clearedFields, action.FieldStdoutSizeBytes)
}

// SetStdoutHashFunction sets the "stdout_hash_function" field.
func (m *ActionMutation) SetStdoutHashFunction(s string) {
	m.stdout_hash_function = &s
}

// StdoutHashFunction returns the value of the "stdout_hash_function" field in the mutation.
func (m *ActionMutation) StdoutHashFunction() (r string, exists bool) {
	v := m.stdout_hash_function
	if v == nil {
		return
	}
	return *v, true
}

// OldStdoutHashFunction returns the old "stdout_hash_function" field's value of the Action entity.
// If the Action object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionMutation) OldStdoutHashFunction(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStdoutHashFunction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStdoutHashFunction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStdoutHashFunction: %w", err)
	}
	return oldValue.StdoutHashFunction, nil
}

// ClearStdoutHashFunction clears the value of the "stdout_hash_function" field.
func (m *ActionMutation) ClearStdoutHashFunction() {
	m.stdout_hash_function = nil
	m.clearedFields[action.FieldStdoutHashFunction] = struct{}{}
}

// StdoutHashFunctionCleared returns if the "stdout_hash_function" field was cleared in this mutation.
func (m *ActionMutation) StdoutHashFunctionCleared() bool {
	_, ok := m.clearedFields[action.FieldStdoutHashFunction]
	return ok
}

// ResetStdoutHashFunction resets all changes to the "stdout_hash_function" field.
func (m *ActionMutation) ResetStdoutHashFunction() {
	m.stdout_hash_function = nil
	delete(m.clearedFields, action.FieldStdoutHashFunction)
}

// SetStderrHash sets the "stderr_hash" field.
func (m *ActionMutation) SetStderrHash(s string) {
	m.stderr_hash = &s
}

// StderrHash returns the value of the "stderr_hash" field in the mutation.
func (m *ActionMutation) StderrHash() (r string, exists bool) {
	v := m.stderr_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldStderrHash returns the old "stderr_hash" field's value of the Action entity.
// If the Action object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionMutation) OldStderrHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStderrHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStderrHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStderrHash: %w", err)
	}
	return oldValue.StderrHash, nil
}

// ClearStderrHash clears the value of the "stderr_hash" field.
func (m *ActionMutation) ClearStderrHash() {
	m.stderr_hash = nil
	m.clearedFields[action.FieldStderrHash] = struct{}{}
}

// StderrHashCleared returns if the "stderr_hash" field was cleared in this mutation.
func (m *ActionMutation) StderrHashCleared() bool {
	_, ok := m.clearedFields[action.FieldStderrHash]
	return ok
}

// ResetStderrHash resets all changes to the "stderr_hash" field.
func (m *ActionMutation) ResetStderrHash() {
	m.stderr_hash = nil
	delete(m.clearedFields, action.FieldStderrHash)
}

// SetStderrSizeBytes sets the "stderr_size_bytes" field.
func (m *ActionMutation) SetStderrSizeBytes(i int64) {
	m.stderr_size_bytes = &i
	m.addstderr_size_bytes = nil
}

// StderrSizeBytes returns the value of the "stderr_size_bytes" field in the mutation.
func (m *ActionMutation) StderrSizeBytes() (r int64, exists bool) {
	v := m.stderr_size_bytes
	if v == nil {
		return
	}
	return *v, true
}

// OldStderrSizeBytes returns the old "stderr_size_bytes" field's value of the Action entity.
// If the Action object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionMutation) OldStderrSizeBytes(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStderrSizeBytes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStderrSizeBytes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStderrSizeBytes: %w", err)
	}
	return oldValue.StderrSizeBytes, nil
}

// AddStderrSizeBytes adds i to the "stderr_size_bytes" field.
func (m *ActionMutation) AddStderrSizeBytes(i int64) {
	if m.addstderr_size_bytes != nil {
		*m.addstderr_size_bytes += i
	} else {
		m.addstderr_size_bytes = &i
	}
}

// AddedStderrSizeBytes returns the value that was added to the "stderr_size_bytes" field in this mutation.
func (m *ActionMutation) AddedStderrSizeBytes() (r int64, exists bool) {
	v := m.addstderr_size_bytes
	if v == nil {
		return
	}
	return *v, true
}

// ClearStderrSizeBytes clears the value of the "stderr_size_bytes" field.
func (m *ActionMutation) ClearStderrSizeBytes() {
	m.stderr_size_bytes = nil
	m.addstderr_size_bytes = nil
	m.clearedFields[action.FieldStderrSizeBytes] = struct{}{}
}

// StderrSizeBytesCleared returns if the "stderr_size_bytes" field was cleared in this mutation.
func (m *ActionMutation) StderrSizeBytesCleared() bool {
	_, ok := m.clearedFields[action.FieldStderrSizeBytes]
	return ok
}

// ResetStderrSizeBytes resets all changes to the "stderr_size_bytes" field.
func (m *ActionMutation) ResetStderrSizeBytes() {
	m.stderr_size_bytes = nil
	m.addstderr_size_bytes = nil
	delete(m.clearedFields, action.FieldStderrSizeBytes)
}

// SetStderrHashFunction sets the "stderr_hash_function" field.
func (m *ActionMutation) SetStderrHashFunction(s string) {
	m.stderr_hash_function = &s
}

// StderrHashFunction returns the value of the "stderr_hash_function" field in the mutation.
func (m *ActionMutation) StderrHashFunction() (r string, exists bool) {
	v := m.stderr_hash_function
	if v == nil {
		return
	}
	return *v, true
}

// OldStderrHashFunction returns the old "stderr_hash_function" field's value of the Action entity.
// If the Action object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionMutation) OldStderrHashFunction(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStderrHashFunction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStderrHashFunction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStderrHashFunction: %w", err)
	}
	return oldValue.StderrHashFunction, nil
}

// ClearStderrHashFunction clears the value of the "stderr_hash_function" field.
func (m *ActionMutation) ClearStderrHashFunction() {
	m.stderr_hash_function = nil
	m.clearedFields[action.FieldStderrHashFunction] = struct{}{}
}

// StderrHashFunctionCleared returns if the "stderr_hash_function" field was cleared in this mutation.
func (m *ActionMutation) StderrHashFunctionCleared() bool {
	_, ok := m.clearedFields[action.FieldStderrHashFunction]
	return ok
}

// ResetStderrHashFunction resets all changes to the "stderr_hash_function" field.
func (m *ActionMutation) ResetStderrHashFunction() {
	m.stderr_hash_function = nil
	delete(m.clearedFields, action.FieldStderrHashFunction)
}

// ClearBazelInvocation clears the "bazel_invocation" edge to the BazelInvocation entity.
func (m *ActionMutation) ClearBazelInvocation() {
	m.clearedbazel_invocation = true
	m.clearedFields[action.FieldBazelInvocationID] = struct{}{}
}

// BazelInvocationCleared reports if the "bazel_invocation" edge to the BazelInvocation entity was cleared.
func (m *ActionMutation) BazelInvocationCleared() bool {
	return m.clearedbazel_invocation
}

// BazelInvocationIDs returns the "bazel_invocation" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BazelInvocationID instead. It exists only for internal usage by the builders.
func (m *ActionMutation) BazelInvocationIDs() (ids []int64) {
	if id := m.bazel_invocation; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBazelInvocation resets all changes to the "bazel_invocation" edge.
func (m *ActionMutation) ResetBazelInvocation() {
	m.bazel_invocation = nil
	m.clearedbazel_invocation = false
}

// ClearConfiguration clears the "configuration" edge to the Configuration entity.
func (m *ActionMutation) ClearConfiguration() {
	m.clearedconfiguration = true
	m.clearedFields[action.FieldConfigurationID] = struct{}{}
}

// ConfigurationCleared reports if the "configuration" edge to the Configuration entity was cleared.
func (m *ActionMutation) ConfigurationCleared() bool {
	return m.clearedconfiguration
}

// ConfigurationIDs returns the "configuration" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ConfigurationID instead. It exists only for internal usage by the builders.
func (m *ActionMutation) ConfigurationIDs() (ids []int64) {
	if id := m.configuration; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConfiguration resets all changes to the "configuration" edge.
func (m *ActionMutation) ResetConfiguration() {
	m.configuration = nil
	m.clearedconfiguration = false
}

// Where appends a list predicates to the ActionMutation builder.
func (m *ActionMutation) Where(ps ...predicate.Action) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ActionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ActionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Action, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ActionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ActionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Action).
func (m *ActionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ActionMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.bazel_invocation != nil {
		fields = append(fields, action.FieldBazelInvocationID)
	}
	if m.configuration != nil {
		fields = append(fields, action.FieldConfigurationID)
	}
	if m.label != nil {
		fields = append(fields, action.FieldLabel)
	}
	if m._type != nil {
		fields = append(fields, action.FieldType)
	}
	if m.success != nil {
		fields = append(fields, action.FieldSuccess)
	}
	if m.exit_code != nil {
		fields = append(fields, action.FieldExitCode)
	}
	if m.command_line != nil {
		fields = append(fields, action.FieldCommandLine)
	}
	if m.start_time != nil {
		fields = append(fields, action.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, action.FieldEndTime)
	}
	if m.failure_code != nil {
		fields = append(fields, action.FieldFailureCode)
	}
	if m.failure_message != nil {
		fields = append(fields, action.FieldFailureMessage)
	}
	if m.stdout_hash != nil {
		fields = append(fields, action.FieldStdoutHash)
	}
	if m.stdout_size_bytes != nil {
		fields = append(fields, action.FieldStdoutSizeBytes)
	}
	if m.stdout_hash_function != nil {
		fields = append(fields, action.FieldStdoutHashFunction)
	}
	if m.stderr_hash != nil {
		fields = append(fields, action.FieldStderrHash)
	}
	if m.stderr_size_bytes != nil {
		fields = append(fields, action.FieldStderrSizeBytes)
	}
	if m.stderr_hash_function != nil {
		fields = append(fields, action.FieldStderrHashFunction)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ActionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case action.FieldBazelInvocationID:
		return m.BazelInvocationID()
	case action.FieldConfigurationID:
		return m.ConfigurationID()
	case action.FieldLabel:
		return m.Label()
	case action.FieldType:
		return m.GetType()
	case action.FieldSuccess:
		return m.Success()
	case action.FieldExitCode:
		return m.ExitCode()
	case action.FieldCommandLine:
		return m.CommandLine()
	case action.FieldStartTime:
		return m.StartTime()
	case action.FieldEndTime:
		return m.EndTime()
	case action.FieldFailureCode:
		return m.FailureCode()
	case action.FieldFailureMessage:
		return m.FailureMessage()
	case action.FieldStdoutHash:
		return m.StdoutHash()
	case action.FieldStdoutSizeBytes:
		return m.StdoutSizeBytes()
	case action.FieldStdoutHashFunction:
		return m.StdoutHashFunction()
	case action.FieldStderrHash:
		return m.StderrHash()
	case action.FieldStderrSizeBytes:
		return m.StderrSizeBytes()
	case action.FieldStderrHashFunction:
		return m.StderrHashFunction()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ActionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case action.FieldBazelInvocationID:
		return m.OldBazelInvocationID(ctx)
	case action.FieldConfigurationID:
		return m.OldConfigurationID(ctx)
	case action.FieldLabel:
		return m.OldLabel(ctx)
	case action.FieldType:
		return m.OldType(ctx)
	case action.FieldSuccess:
		return m.OldSuccess(ctx)
	case action.FieldExitCode:
		return m.OldExitCode(ctx)
	case action.FieldCommandLine:
		return m.OldCommandLine(ctx)
	case action.FieldStartTime:
		return m.OldStartTime(ctx)
	case action.FieldEndTime:
		return m.OldEndTime(ctx)
	case action.FieldFailureCode:
		return m.OldFailureCode(ctx)
	case action.FieldFailureMessage:
		return m.OldFailureMessage(ctx)
	case action.FieldStdoutHash:
		return m.OldStdoutHash(ctx)
	case action.FieldStdoutSizeBytes:
		return m.OldStdoutSizeBytes(ctx)
	case action.FieldStdoutHashFunction:
		return m.OldStdoutHashFunction(ctx)
	case action.FieldStderrHash:
		return m.OldStderrHash(ctx)
	case action.FieldStderrSizeBytes:
		return m.OldStderrSizeBytes(ctx)
	case action.FieldStderrHashFunction:
		return m.OldStderrHashFunction(ctx)
	}
	return nil, fmt.Errorf("unknown Action field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case action.FieldBazelInvocationID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBazelInvocationID(v)
		return nil
	case action.FieldConfigurationID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfigurationID(v)
		return nil
	case action.FieldLabel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabel(v)
		return nil
	case action.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case action.FieldSuccess:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuccess(v)
		return nil
	case action.FieldExitCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExitCode(v)
		return nil
	case action.FieldCommandLine:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommandLine(v)
		return nil
	case action.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case action.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case action.FieldFailureCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFailureCode(v)
		return nil
	case action.FieldFailureMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFailureMessage(v)
		return nil
	case action.FieldStdoutHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStdoutHash(v)
		return nil
	case action.FieldStdoutSizeBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStdoutSizeBytes(v)
		return nil
	case action.FieldStdoutHashFunction:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStdoutHashFunction(v)
		return nil
	case action.FieldStderrHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStderrHash(v)
		return nil
	case action.FieldStderrSizeBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStderrSizeBytes(v)
		return nil
	case action.FieldStderrHashFunction:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStderrHashFunction(v)
		return nil
	}
	return fmt.Errorf("unknown Action field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ActionMutation) AddedFields() []string {
	var fields []string
	if m.addexit_code != nil {
		fields = append(fields, action.FieldExitCode)
	}
	if m.addstdout_size_bytes != nil {
		fields = append(fields, action.FieldStdoutSizeBytes)
	}
	if m.addstderr_size_bytes != nil {
		fields = append(fields, action.FieldStderrSizeBytes)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ActionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case action.FieldExitCode:
		return m.AddedExitCode()
	case action.FieldStdoutSizeBytes:
		return m.AddedStdoutSizeBytes()
	case action.FieldStderrSizeBytes:
		return m.AddedStderrSizeBytes()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case action.FieldExitCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExitCode(v)
		return nil
	case action.FieldStdoutSizeBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStdoutSizeBytes(v)
		return nil
	case action.FieldStderrSizeBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStderrSizeBytes(v)
		return nil
	}
	return fmt.Errorf("unknown Action numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ActionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(action.FieldType) {
		fields = append(fields, action.FieldType)
	}
	if m.FieldCleared(action.FieldSuccess) {
		fields = append(fields, action.FieldSuccess)
	}
	if m.FieldCleared(action.FieldExitCode) {
		fields = append(fields, action.FieldExitCode)
	}
	if m.FieldCleared(action.FieldCommandLine) {
		fields = append(fields, action.FieldCommandLine)
	}
	if m.FieldCleared(action.FieldStartTime) {
		fields = append(fields, action.FieldStartTime)
	}
	if m.FieldCleared(action.FieldEndTime) {
		fields = append(fields, action.FieldEndTime)
	}
	if m.FieldCleared(action.FieldFailureCode) {
		fields = append(fields, action.FieldFailureCode)
	}
	if m.FieldCleared(action.FieldFailureMessage) {
		fields = append(fields, action.FieldFailureMessage)
	}
	if m.FieldCleared(action.FieldStdoutHash) {
		fields = append(fields, action.FieldStdoutHash)
	}
	if m.FieldCleared(action.FieldStdoutSizeBytes) {
		fields = append(fields, action.FieldStdoutSizeBytes)
	}
	if m.FieldCleared(action.FieldStdoutHashFunction) {
		fields = append(fields, action.FieldStdoutHashFunction)
	}
	if m.FieldCleared(action.FieldStderrHash) {
		fields = append(fields, action.FieldStderrHash)
	}
	if m.FieldCleared(action.FieldStderrSizeBytes) {
		fields = append(fields, action.FieldStderrSizeBytes)
	}
	if m.FieldCleared(action.FieldStderrHashFunction) {
		fields = append(fields, action.FieldStderrHashFunction)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ActionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ActionMutation) ClearField(name string) error {
	switch name {
	case action.FieldType:
		m.ClearType()
		return nil
	case action.FieldSuccess:
		m.ClearSuccess()
		return nil
	case action.FieldExitCode:
		m.ClearExitCode()
		return nil
	case action.FieldCommandLine:
		m.ClearCommandLine()
		return nil
	case action.FieldStartTime:
		m.ClearStartTime()
		return nil
	case action.FieldEndTime:
		m.ClearEndTime()
		return nil
	case action.FieldFailureCode:
		m.ClearFailureCode()
		return nil
	case action.FieldFailureMessage:
		m.ClearFailureMessage()
		return nil
	case action.FieldStdoutHash:
		m.ClearStdoutHash()
		return nil
	case action.FieldStdoutSizeBytes:
		m.ClearStdoutSizeBytes()
		return nil
	case action.FieldStdoutHashFunction:
		m.ClearStdoutHashFunction()
		return nil
	case action.FieldStderrHash:
		m.ClearStderrHash()
		return nil
	case action.FieldStderrSizeBytes:
		m.ClearStderrSizeBytes()
		return nil
	case action.FieldStderrHashFunction:
		m.ClearStderrHashFunction()
		return nil
	}
	return fmt.Errorf("unknown Action nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ActionMutation) ResetField(name string) error {
	switch name {
	case action.FieldBazelInvocationID:
		m.ResetBazelInvocationID()
		return nil
	case action.FieldConfigurationID:
		m.ResetConfigurationID()
		return nil
	case action.FieldLabel:
		m.ResetLabel()
		return nil
	case action.FieldType:
		m.ResetType()
		return nil
	case action.FieldSuccess:
		m.ResetSuccess()
		return nil
	case action.FieldExitCode:
		m.ResetExitCode()
		return nil
	case action.FieldCommandLine:
		m.ResetCommandLine()
		return nil
	case action.FieldStartTime:
		m.ResetStartTime()
		return nil
	case action.FieldEndTime:
		m.ResetEndTime()
		return nil
	case action.FieldFailureCode:
		m.ResetFailureCode()
		return nil
	case action.FieldFailureMessage:
		m.ResetFailureMessage()
		return nil
	case action.FieldStdoutHash:
		m.ResetStdoutHash()
		return nil
	case action.FieldStdoutSizeBytes:
		m.ResetStdoutSizeBytes()
		return nil
	case action.FieldStdoutHashFunction:
		m.ResetStdoutHashFunction()
		return nil
	case action.FieldStderrHash:
		m.ResetStderrHash()
		return nil
	case action.FieldStderrSizeBytes:
		m.ResetStderrSizeBytes()
		return nil
	case action.FieldStderrHashFunction:
		m.ResetStderrHashFunction()
		return nil
	}
	return fmt.Errorf("unknown Action field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ActionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.bazel_invocation != nil {
		edges = append(edges, action.EdgeBazelInvocation)
	}
	if m.configuration != nil {
		edges = append(edges, action.EdgeConfiguration)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ActionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case action.EdgeBazelInvocation:
		if id := m.bazel_invocation; id != nil {
			return []ent.Value{*id}
		}
	case action.EdgeConfiguration:
		if id := m.configuration; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ActionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ActionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ActionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbazel_invocation {
		edges = append(edges, action.EdgeBazelInvocation)
	}
	if m.clearedconfiguration {
		edges = append(edges, action.EdgeConfiguration)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ActionMutation) EdgeCleared(name string) bool {
	switch name {
	case action.EdgeBazelInvocation:
		return m.clearedbazel_invocation
	case action.EdgeConfiguration:
		return m.clearedconfiguration
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ActionMutation) ClearEdge(name string) error {
	switch name {
	case action.EdgeBazelInvocation:
		m.ClearBazelInvocation()
		return nil
	case action.EdgeConfiguration:
		m.ClearConfiguration()
		return nil
	}
	return fmt.Errorf("unknown Action unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ActionMutation) ResetEdge(name string) error {
	switch name {
	case action.EdgeBazelInvocation:
		m.ResetBazelInvocation()
		return nil
	case action.EdgeConfiguration:
		m.ResetConfiguration()
		return nil
	}
	return fmt.Errorf("unknown Action edge %s", name)
}

// ActionCacheStatisticsMutation represents an operation that mutates the ActionCacheStatistics nodes in the graph.
type ActionCacheStatisticsMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int64
	size_in_bytes         *uint64
	addsize_in_bytes      *int64
	save_time_in_ms       *uint64
	addsave_time_in_ms    *int64
	load_time_in_ms       *int64
	addload_time_in_ms    *int64
	hits                  *int32
	addhits               *int32
	misses                *int32
	addmisses             *int32
	clearedFields         map[string]struct{}
	action_summary        *int64
	clearedaction_summary bool
	miss_details          map[int64]struct{}
	removedmiss_details   map[int64]struct{}
	clearedmiss_details   bool
	done                  bool
	oldValue              func(context.Context) (*ActionCacheStatistics, error)
	predicates            []predicate.ActionCacheStatistics
}

var _ ent.Mutation = (*ActionCacheStatisticsMutation)(nil)

// actioncachestatisticsOption allows management of the mutation configuration using functional options.
type actioncachestatisticsOption func(*ActionCacheStatisticsMutation)

// newActionCacheStatisticsMutation creates new mutation for the ActionCacheStatistics entity.
func newActionCacheStatisticsMutation(c config, op Op, opts ...actioncachestatisticsOption) *ActionCacheStatisticsMutation {
	m := &ActionCacheStatisticsMutation{
		config:        c,
		op:            op,
		typ:           TypeActionCacheStatistics,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withActionCacheStatisticsID sets the ID field of the mutation.
func withActionCacheStatisticsID(id int64) actioncachestatisticsOption {
	return func(m *ActionCacheStatisticsMutation) {
		var (
			err   error
			once  sync.Once
			value *ActionCacheStatistics
		)
		m.oldValue = func(ctx context.Context) (*ActionCacheStatistics, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ActionCacheStatistics.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withActionCacheStatistics sets the old ActionCacheStatistics of the mutation.
func withActionCacheStatistics(node *ActionCacheStatistics) actioncachestatisticsOption {
	return func(m *ActionCacheStatisticsMutation) {
		m.oldValue = func(context.Context) (*ActionCacheStatistics, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ActionCacheStatisticsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ActionCacheStatisticsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ActionCacheStatistics entities.
func (m *ActionCacheStatisticsMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ActionCacheStatisticsMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ActionCacheStatisticsMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ActionCacheStatistics.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSizeInBytes sets the "size_in_bytes" field.
func (m *ActionCacheStatisticsMutation) SetSizeInBytes(u uint64) {
	m.size_in_bytes = &u
	m.addsize_in_bytes = nil
}

// SizeInBytes returns the value of the "size_in_bytes" field in the mutation.
func (m *ActionCacheStatisticsMutation) SizeInBytes() (r uint64, exists bool) {
	v := m.size_in_bytes
	if v == nil {
		return
	}
	return *v, true
}

// OldSizeInBytes returns the old "size_in_bytes" field's value of the ActionCacheStatistics entity.
// If the ActionCacheStatistics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionCacheStatisticsMutation) OldSizeInBytes(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSizeInBytes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSizeInBytes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSizeInBytes: %w", err)
	}
	return oldValue.SizeInBytes, nil
}

// AddSizeInBytes adds u to the "size_in_bytes" field.
func (m *ActionCacheStatisticsMutation) AddSizeInBytes(u int64) {
	if m.addsize_in_bytes != nil {
		*m.addsize_in_bytes += u
	} else {
		m.addsize_in_bytes = &u
	}
}

// AddedSizeInBytes returns the value that was added to the "size_in_bytes" field in this mutation.
func (m *ActionCacheStatisticsMutation) AddedSizeInBytes() (r int64, exists bool) {
	v := m.addsize_in_bytes
	if v == nil {
		return
	}
	return *v, true
}

// ClearSizeInBytes clears the value of the "size_in_bytes" field.
func (m *ActionCacheStatisticsMutation) ClearSizeInBytes() {
	m.size_in_bytes = nil
	m.addsize_in_bytes = nil
	m.clearedFields[actioncachestatistics.FieldSizeInBytes] = struct{}{}
}

// SizeInBytesCleared returns if the "size_in_bytes" field was cleared in this mutation.
func (m *ActionCacheStatisticsMutation) SizeInBytesCleared() bool {
	_, ok := m.clearedFields[actioncachestatistics.FieldSizeInBytes]
	return ok
}

// ResetSizeInBytes resets all changes to the "size_in_bytes" field.
func (m *ActionCacheStatisticsMutation) ResetSizeInBytes() {
	m.size_in_bytes = nil
	m.addsize_in_bytes = nil
	delete(m.clearedFields, actioncachestatistics.FieldSizeInBytes)
}

// SetSaveTimeInMs sets the "save_time_in_ms" field.
func (m *ActionCacheStatisticsMutation) SetSaveTimeInMs(u uint64) {
	m.save_time_in_ms = &u
	m.addsave_time_in_ms = nil
}

// SaveTimeInMs returns the value of the "save_time_in_ms" field in the mutation.
func (m *ActionCacheStatisticsMutation) SaveTimeInMs() (r uint64, exists bool) {
	v := m.save_time_in_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldSaveTimeInMs returns the old "save_time_in_ms" field's value of the ActionCacheStatistics entity.
// If the ActionCacheStatistics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionCacheStatisticsMutation) OldSaveTimeInMs(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSaveTimeInMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSaveTimeInMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSaveTimeInMs: %w", err)
	}
	return oldValue.SaveTimeInMs, nil
}

// AddSaveTimeInMs adds u to the "save_time_in_ms" field.
func (m *ActionCacheStatisticsMutation) AddSaveTimeInMs(u int64) {
	if m.addsave_time_in_ms != nil {
		*m.addsave_time_in_ms += u
	} else {
		m.addsave_time_in_ms = &u
	}
}

// AddedSaveTimeInMs returns the value that was added to the "save_time_in_ms" field in this mutation.
func (m *ActionCacheStatisticsMutation) AddedSaveTimeInMs() (r int64, exists bool) {
	v := m.addsave_time_in_ms
	if v == nil {
		return
	}
	return *v, true
}

// ClearSaveTimeInMs clears the value of the "save_time_in_ms" field.
func (m *ActionCacheStatisticsMutation) ClearSaveTimeInMs() {
	m.save_time_in_ms = nil
	m.addsave_time_in_ms = nil
	m.clearedFields[actioncachestatistics.FieldSaveTimeInMs] = struct{}{}
}

// SaveTimeInMsCleared returns if the "save_time_in_ms" field was cleared in this mutation.
func (m *ActionCacheStatisticsMutation) SaveTimeInMsCleared() bool {
	_, ok := m.clearedFields[actioncachestatistics.FieldSaveTimeInMs]
	return ok
}

// ResetSaveTimeInMs resets all changes to the "save_time_in_ms" field.
func (m *ActionCacheStatisticsMutation) ResetSaveTimeInMs() {
	m.save_time_in_ms = nil
	m.addsave_time_in_ms = nil
	delete(m.clearedFields, actioncachestatistics.FieldSaveTimeInMs)
}

// SetLoadTimeInMs sets the "load_time_in_ms" field.
func (m *ActionCacheStatisticsMutation) SetLoadTimeInMs(i int64) {
	m.load_time_in_ms = &i
	m.addload_time_in_ms = nil
}

// LoadTimeInMs returns the value of the "load_time_in_ms" field in the mutation.
func (m *ActionCacheStatisticsMutation) LoadTimeInMs() (r int64, exists bool) {
	v := m.load_time_in_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldLoadTimeInMs returns the old "load_time_in_ms" field's value of the ActionCacheStatistics entity.
// If the ActionCacheStatistics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionCacheStatisticsMutation) OldLoadTimeInMs(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLoadTimeInMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLoadTimeInMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLoadTimeInMs: %w", err)
	}
	return oldValue.LoadTimeInMs, nil
}

// AddLoadTimeInMs adds i to the "load_time_in_ms" field.
func (m *ActionCacheStatisticsMutation) AddLoadTimeInMs(i int64) {
	if m.addload_time_in_ms != nil {
		*m.addload_time_in_ms += i
	} else {
		m.addload_time_in_ms = &i
	}
}

// AddedLoadTimeInMs returns the value that was added to the "load_time_in_ms" field in this mutation.
func (m *ActionCacheStatisticsMutation) AddedLoadTimeInMs() (r int64, exists bool) {
	v := m.addload_time_in_ms
	if v == nil {
		return
	}
	return *v, true
}

// ClearLoadTimeInMs clears the value of the "load_time_in_ms" field.
func (m *ActionCacheStatisticsMutation) ClearLoadTimeInMs() {
	m.load_time_in_ms = nil
	m.addload_time_in_ms = nil
	m.clearedFields[actioncachestatistics.FieldLoadTimeInMs] = struct{}{}
}

// LoadTimeInMsCleared returns if the "load_time_in_ms" field was cleared in this mutation.
func (m *ActionCacheStatisticsMutation) LoadTimeInMsCleared() bool {
	_, ok := m.clearedFields[actioncachestatistics.FieldLoadTimeInMs]
	return ok
}

// ResetLoadTimeInMs resets all changes to the "load_time_in_ms" field.
func (m *ActionCacheStatisticsMutation) ResetLoadTimeInMs() {
	m.load_time_in_ms = nil
	m.addload_time_in_ms = nil
	delete(m.clearedFields, actioncachestatistics.FieldLoadTimeInMs)
}

// SetHits sets the "hits" field.
func (m *ActionCacheStatisticsMutation) SetHits(i int32) {
	m.hits = &i
	m.addhits = nil
}

// Hits returns the value of the "hits" field in the mutation.
func (m *ActionCacheStatisticsMutation) Hits() (r int32, exists bool) {
	v := m.hits
	if v == nil {
		return
	}
	return *v, true
}

// OldHits returns the old "hits" field's value of the ActionCacheStatistics entity.
// If the ActionCacheStatistics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionCacheStatisticsMutation) OldHits(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHits: %w", err)
	}
	return oldValue.Hits, nil
}

// AddHits adds i to the "hits" field.
func (m *ActionCacheStatisticsMutation) AddHits(i int32) {
	if m.addhits != nil {
		*m.addhits += i
	} else {
		m.addhits = &i
	}
}

// AddedHits returns the value that was added to the "hits" field in this mutation.
func (m *ActionCacheStatisticsMutation) AddedHits() (r int32, exists bool) {
	v := m.addhits
	if v == nil {
		return
	}
	return *v, true
}

// ClearHits clears the value of the "hits" field.
func (m *ActionCacheStatisticsMutation) ClearHits() {
	m.hits = nil
	m.addhits = nil
	m.clearedFields[actioncachestatistics.FieldHits] = struct{}{}
}

// HitsCleared returns if the "hits" field was cleared in this mutation.
func (m *ActionCacheStatisticsMutation) HitsCleared() bool {
	_, ok := m.clearedFields[actioncachestatistics.FieldHits]
	return ok
}

// ResetHits resets all changes to the "hits" field.
func (m *ActionCacheStatisticsMutation) ResetHits() {
	m.hits = nil
	m.addhits = nil
	delete(m.clearedFields, actioncachestatistics.FieldHits)
}

// SetMisses sets the "misses" field.
func (m *ActionCacheStatisticsMutation) SetMisses(i int32) {
	m.misses = &i
	m.addmisses = nil
}

// Misses returns the value of the "misses" field in the mutation.
func (m *ActionCacheStatisticsMutation) Misses() (r int32, exists bool) {
	v := m.misses
	if v == nil {
		return
	}
	return *v, true
}

// OldMisses returns the old "misses" field's value of the ActionCacheStatistics entity.
// If the ActionCacheStatistics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionCacheStatisticsMutation) OldMisses(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMisses is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMisses requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMisses: %w", err)
	}
	return oldValue.Misses, nil
}

// AddMisses adds i to the "misses" field.
func (m *ActionCacheStatisticsMutation) AddMisses(i int32) {
	if m.addmisses != nil {
		*m.addmisses += i
	} else {
		m.addmisses = &i
	}
}

// AddedMisses returns the value that was added to the "misses" field in this mutation.
func (m *ActionCacheStatisticsMutation) AddedMisses() (r int32, exists bool) {
	v := m.addmisses
	if v == nil {
		return
	}
	return *v, true
}

// ClearMisses clears the value of the "misses" field.
func (m *ActionCacheStatisticsMutation) ClearMisses() {
	m.misses = nil
	m.addmisses = nil
	m.clearedFields[actioncachestatistics.FieldMisses] = struct{}{}
}

// MissesCleared returns if the "misses" field was cleared in this mutation.
func (m *ActionCacheStatisticsMutation) MissesCleared() bool {
	_, ok := m.clearedFields[actioncachestatistics.FieldMisses]
	return ok
}

// ResetMisses resets all changes to the "misses" field.
func (m *ActionCacheStatisticsMutation) ResetMisses() {
	m.misses = nil
	m.addmisses = nil
	delete(m.clearedFields, actioncachestatistics.FieldMisses)
}

// SetActionSummaryID sets the "action_summary" edge to the ActionSummary entity by id.
func (m *ActionCacheStatisticsMutation) SetActionSummaryID(id int64) {
	m.action_summary = &id
}

// ClearActionSummary clears the "action_summary" edge to the ActionSummary entity.
func (m *ActionCacheStatisticsMutation) ClearActionSummary() {
	m.clearedaction_summary = true
}

// ActionSummaryCleared reports if the "action_summary" edge to the ActionSummary entity was cleared.
func (m *ActionCacheStatisticsMutation) ActionSummaryCleared() bool {
	return m.clearedaction_summary
}

// ActionSummaryID returns the "action_summary" edge ID in the mutation.
func (m *ActionCacheStatisticsMutation) ActionSummaryID() (id int64, exists bool) {
	if m.action_summary != nil {
		return *m.action_summary, true
	}
	return
}

// ActionSummaryIDs returns the "action_summary" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ActionSummaryID instead. It exists only for internal usage by the builders.
func (m *ActionCacheStatisticsMutation) ActionSummaryIDs() (ids []int64) {
	if id := m.action_summary; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetActionSummary resets all changes to the "action_summary" edge.
func (m *ActionCacheStatisticsMutation) ResetActionSummary() {
	m.action_summary = nil
	m.clearedaction_summary = false
}

// AddMissDetailIDs adds the "miss_details" edge to the MissDetail entity by ids.
func (m *ActionCacheStatisticsMutation) AddMissDetailIDs(ids ...int64) {
	if m.miss_details == nil {
		m.miss_details = make(map[int64]struct{})
	}
	for i := range ids {
		m.miss_details[ids[i]] = struct{}{}
	}
}

// ClearMissDetails clears the "miss_details" edge to the MissDetail entity.
func (m *ActionCacheStatisticsMutation) ClearMissDetails() {
	m.clearedmiss_details = true
}

// MissDetailsCleared reports if the "miss_details" edge to the MissDetail entity was cleared.
func (m *ActionCacheStatisticsMutation) MissDetailsCleared() bool {
	return m.clearedmiss_details
}

// RemoveMissDetailIDs removes the "miss_details" edge to the MissDetail entity by IDs.
func (m *ActionCacheStatisticsMutation) RemoveMissDetailIDs(ids ...int64) {
	if m.removedmiss_details == nil {
		m.removedmiss_details = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.miss_details, ids[i])
		m.removedmiss_details[ids[i]] = struct{}{}
	}
}

// RemovedMissDetails returns the removed IDs of the "miss_details" edge to the MissDetail entity.
func (m *ActionCacheStatisticsMutation) RemovedMissDetailsIDs() (ids []int64) {
	for id := range m.removedmiss_details {
		ids = append(ids, id)
	}
	return
}

// MissDetailsIDs returns the "miss_details" edge IDs in the mutation.
func (m *ActionCacheStatisticsMutation) MissDetailsIDs() (ids []int64) {
	for id := range m.miss_details {
		ids = append(ids, id)
	}
	return
}

// ResetMissDetails resets all changes to the "miss_details" edge.
func (m *ActionCacheStatisticsMutation) ResetMissDetails() {
	m.miss_details = nil
	m.clearedmiss_details = false
	m.removedmiss_details = nil
}

// Where appends a list predicates to the ActionCacheStatisticsMutation builder.
func (m *ActionCacheStatisticsMutation) Where(ps ...predicate.ActionCacheStatistics) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ActionCacheStatisticsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ActionCacheStatisticsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ActionCacheStatistics, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ActionCacheStatisticsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ActionCacheStatisticsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ActionCacheStatistics).
func (m *ActionCacheStatisticsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ActionCacheStatisticsMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.size_in_bytes != nil {
		fields = append(fields, actioncachestatistics.FieldSizeInBytes)
	}
	if m.save_time_in_ms != nil {
		fields = append(fields, actioncachestatistics.FieldSaveTimeInMs)
	}
	if m.load_time_in_ms != nil {
		fields = append(fields, actioncachestatistics.FieldLoadTimeInMs)
	}
	if m.hits != nil {
		fields = append(fields, actioncachestatistics.FieldHits)
	}
	if m.misses != nil {
		fields = append(fields, actioncachestatistics.FieldMisses)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ActionCacheStatisticsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case actioncachestatistics.FieldSizeInBytes:
		return m.SizeInBytes()
	case actioncachestatistics.FieldSaveTimeInMs:
		return m.SaveTimeInMs()
	case actioncachestatistics.FieldLoadTimeInMs:
		return m.LoadTimeInMs()
	case actioncachestatistics.FieldHits:
		return m.Hits()
	case actioncachestatistics.FieldMisses:
		return m.Misses()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ActionCacheStatisticsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case actioncachestatistics.FieldSizeInBytes:
		return m.OldSizeInBytes(ctx)
	case actioncachestatistics.FieldSaveTimeInMs:
		return m.OldSaveTimeInMs(ctx)
	case actioncachestatistics.FieldLoadTimeInMs:
		return m.OldLoadTimeInMs(ctx)
	case actioncachestatistics.FieldHits:
		return m.OldHits(ctx)
	case actioncachestatistics.FieldMisses:
		return m.OldMisses(ctx)
	}
	return nil, fmt.Errorf("unknown ActionCacheStatistics field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActionCacheStatisticsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case actioncachestatistics.FieldSizeInBytes:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSizeInBytes(v)
		return nil
	case actioncachestatistics.FieldSaveTimeInMs:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSaveTimeInMs(v)
		return nil
	case actioncachestatistics.FieldLoadTimeInMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLoadTimeInMs(v)
		return nil
	case actioncachestatistics.FieldHits:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHits(v)
		return nil
	case actioncachestatistics.FieldMisses:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMisses(v)
		return nil
	}
	return fmt.Errorf("unknown ActionCacheStatistics field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ActionCacheStatisticsMutation) AddedFields() []string {
	var fields []string
	if m.addsize_in_bytes != nil {
		fields = append(fields, actioncachestatistics.FieldSizeInBytes)
	}
	if m.addsave_time_in_ms != nil {
		fields = append(fields, actioncachestatistics.FieldSaveTimeInMs)
	}
	if m.addload_time_in_ms != nil {
		fields = append(fields, actioncachestatistics.FieldLoadTimeInMs)
	}
	if m.addhits != nil {
		fields = append(fields, actioncachestatistics.FieldHits)
	}
	if m.addmisses != nil {
		fields = append(fields, actioncachestatistics.FieldMisses)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ActionCacheStatisticsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case actioncachestatistics.FieldSizeInBytes:
		return m.AddedSizeInBytes()
	case actioncachestatistics.FieldSaveTimeInMs:
		return m.AddedSaveTimeInMs()
	case actioncachestatistics.FieldLoadTimeInMs:
		return m.AddedLoadTimeInMs()
	case actioncachestatistics.FieldHits:
		return m.AddedHits()
	case actioncachestatistics.FieldMisses:
		return m.AddedMisses()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActionCacheStatisticsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case actioncachestatistics.FieldSizeInBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSizeInBytes(v)
		return nil
	case actioncachestatistics.FieldSaveTimeInMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSaveTimeInMs(v)
		return nil
	case actioncachestatistics.FieldLoadTimeInMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLoadTimeInMs(v)
		return nil
	case actioncachestatistics.FieldHits:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHits(v)
		return nil
	case actioncachestatistics.FieldMisses:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMisses(v)
		return nil
	}
	return fmt.Errorf("unknown ActionCacheStatistics numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ActionCacheStatisticsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(actioncachestatistics.FieldSizeInBytes) {
		fields = append(fields, actioncachestatistics.FieldSizeInBytes)
	}
	if m.FieldCleared(actioncachestatistics.FieldSaveTimeInMs) {
		fields = append(fields, actioncachestatistics.FieldSaveTimeInMs)
	}
	if m.FieldCleared(actioncachestatistics.FieldLoadTimeInMs) {
		fields = append(fields, actioncachestatistics.FieldLoadTimeInMs)
	}
	if m.FieldCleared(actioncachestatistics.FieldHits) {
		fields = append(fields, actioncachestatistics.FieldHits)
	}
	if m.FieldCleared(actioncachestatistics.FieldMisses) {
		fields = append(fields, actioncachestatistics.FieldMisses)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ActionCacheStatisticsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ActionCacheStatisticsMutation) ClearField(name string) error {
	switch name {
	case actioncachestatistics.FieldSizeInBytes:
		m.ClearSizeInBytes()
		return nil
	case actioncachestatistics.FieldSaveTimeInMs:
		m.ClearSaveTimeInMs()
		return nil
	case actioncachestatistics.FieldLoadTimeInMs:
		m.ClearLoadTimeInMs()
		return nil
	case actioncachestatistics.FieldHits:
		m.ClearHits()
		return nil
	case actioncachestatistics.FieldMisses:
		m.ClearMisses()
		return nil
	}
	return fmt.Errorf("unknown ActionCacheStatistics nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ActionCacheStatisticsMutation) ResetField(name string) error {
	switch name {
	case actioncachestatistics.FieldSizeInBytes:
		m.ResetSizeInBytes()
		return nil
	case actioncachestatistics.FieldSaveTimeInMs:
		m.ResetSaveTimeInMs()
		return nil
	case actioncachestatistics.FieldLoadTimeInMs:
		m.ResetLoadTimeInMs()
		return nil
	case actioncachestatistics.FieldHits:
		m.ResetHits()
		return nil
	case actioncachestatistics.FieldMisses:
		m.ResetMisses()
		return nil
	}
	return fmt.Errorf("unknown ActionCacheStatistics field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ActionCacheStatisticsMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.action_summary != nil {
		edges = append(edges, actioncachestatistics.EdgeActionSummary)
	}
	if m.miss_details != nil {
		edges = append(edges, actioncachestatistics.EdgeMissDetails)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ActionCacheStatisticsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case actioncachestatistics.EdgeActionSummary:
		if id := m.action_summary; id != nil {
			return []ent.Value{*id}
		}
	case actioncachestatistics.EdgeMissDetails:
		ids := make([]ent.Value, 0, len(m.miss_details))
		for id := range m.miss_details {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ActionCacheStatisticsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmiss_details != nil {
		edges = append(edges, actioncachestatistics.EdgeMissDetails)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ActionCacheStatisticsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case actioncachestatistics.EdgeMissDetails:
		ids := make([]ent.Value, 0, len(m.removedmiss_details))
		for id := range m.removedmiss_details {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ActionCacheStatisticsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedaction_summary {
		edges = append(edges, actioncachestatistics.EdgeActionSummary)
	}
	if m.clearedmiss_details {
		edges = append(edges, actioncachestatistics.EdgeMissDetails)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ActionCacheStatisticsMutation) EdgeCleared(name string) bool {
	switch name {
	case actioncachestatistics.EdgeActionSummary:
		return m.clearedaction_summary
	case actioncachestatistics.EdgeMissDetails:
		return m.clearedmiss_details
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ActionCacheStatisticsMutation) ClearEdge(name string) error {
	switch name {
	case actioncachestatistics.EdgeActionSummary:
		m.ClearActionSummary()
		return nil
	}
	return fmt.Errorf("unknown ActionCacheStatistics unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ActionCacheStatisticsMutation) ResetEdge(name string) error {
	switch name {
	case actioncachestatistics.EdgeActionSummary:
		m.ResetActionSummary()
		return nil
	case actioncachestatistics.EdgeMissDetails:
		m.ResetMissDetails()
		return nil
	}
	return fmt.Errorf("unknown ActionCacheStatistics edge %s", name)
}

// ActionDataMutation represents an operation that mutates the ActionData nodes in the graph.
type ActionDataMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int64
	mnemonic              *string
	actions_executed      *int64
	addactions_executed   *int64
	actions_created       *int64
	addactions_created    *int64
	first_started_ms      *int64
	addfirst_started_ms   *int64
	last_ended_ms         *int64
	addlast_ended_ms      *int64
	system_time           *int64
	addsystem_time        *int64
	user_time             *int64
	adduser_time          *int64
	clearedFields         map[string]struct{}
	action_summary        *int64
	clearedaction_summary bool
	done                  bool
	oldValue              func(context.Context) (*ActionData, error)
	predicates            []predicate.ActionData
}

var _ ent.Mutation = (*ActionDataMutation)(nil)

// actiondataOption allows management of the mutation configuration using functional options.
type actiondataOption func(*ActionDataMutation)

// newActionDataMutation creates new mutation for the ActionData entity.
func newActionDataMutation(c config, op Op, opts ...actiondataOption) *ActionDataMutation {
	m := &ActionDataMutation{
		config:        c,
		op:            op,
		typ:           TypeActionData,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withActionDataID sets the ID field of the mutation.
func withActionDataID(id int64) actiondataOption {
	return func(m *ActionDataMutation) {
		var (
			err   error
			once  sync.Once
			value *ActionData
		)
		m.oldValue = func(ctx context.Context) (*ActionData, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ActionData.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withActionData sets the old ActionData of the mutation.
func withActionData(node *ActionData) actiondataOption {
	return func(m *ActionDataMutation) {
		m.oldValue = func(context.Context) (*ActionData, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ActionDataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ActionDataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ActionData entities.
func (m *ActionDataMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ActionDataMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ActionDataMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ActionData.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetMnemonic sets the "mnemonic" field.
func (m *ActionDataMutation) SetMnemonic(s string) {
	m.mnemonic = &s
}

// Mnemonic returns the value of the "mnemonic" field in the mutation.
func (m *ActionDataMutation) Mnemonic() (r string, exists bool) {
	v := m.mnemonic
	if v == nil {
		return
	}
	return *v, true
}

// OldMnemonic returns the old "mnemonic" field's value of the ActionData entity.
// If the ActionData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionDataMutation) OldMnemonic(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMnemonic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMnemonic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMnemonic: %w", err)
	}
	return oldValue.Mnemonic, nil
}

// ClearMnemonic clears the value of the "mnemonic" field.
func (m *ActionDataMutation) ClearMnemonic() {
	m.mnemonic = nil
	m.clearedFields[actiondata.FieldMnemonic] = struct{}{}
}

// MnemonicCleared returns if the "mnemonic" field was cleared in this mutation.
func (m *ActionDataMutation) MnemonicCleared() bool {
	_, ok := m.clearedFields[actiondata.FieldMnemonic]
	return ok
}

// ResetMnemonic resets all changes to the "mnemonic" field.
func (m *ActionDataMutation) ResetMnemonic() {
	m.mnemonic = nil
	delete(m.clearedFields, actiondata.FieldMnemonic)
}

// SetActionsExecuted sets the "actions_executed" field.
func (m *ActionDataMutation) SetActionsExecuted(i int64) {
	m.actions_executed = &i
	m.addactions_executed = nil
}

// ActionsExecuted returns the value of the "actions_executed" field in the mutation.
func (m *ActionDataMutation) ActionsExecuted() (r int64, exists bool) {
	v := m.actions_executed
	if v == nil {
		return
	}
	return *v, true
}

// OldActionsExecuted returns the old "actions_executed" field's value of the ActionData entity.
// If the ActionData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionDataMutation) OldActionsExecuted(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActionsExecuted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActionsExecuted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActionsExecuted: %w", err)
	}
	return oldValue.ActionsExecuted, nil
}

// AddActionsExecuted adds i to the "actions_executed" field.
func (m *ActionDataMutation) AddActionsExecuted(i int64) {
	if m.addactions_executed != nil {
		*m.addactions_executed += i
	} else {
		m.addactions_executed = &i
	}
}

// AddedActionsExecuted returns the value that was added to the "actions_executed" field in this mutation.
func (m *ActionDataMutation) AddedActionsExecuted() (r int64, exists bool) {
	v := m.addactions_executed
	if v == nil {
		return
	}
	return *v, true
}

// ClearActionsExecuted clears the value of the "actions_executed" field.
func (m *ActionDataMutation) ClearActionsExecuted() {
	m.actions_executed = nil
	m.addactions_executed = nil
	m.clearedFields[actiondata.FieldActionsExecuted] = struct{}{}
}

// ActionsExecutedCleared returns if the "actions_executed" field was cleared in this mutation.
func (m *ActionDataMutation) ActionsExecutedCleared() bool {
	_, ok := m.clearedFields[actiondata.FieldActionsExecuted]
	return ok
}

// ResetActionsExecuted resets all changes to the "actions_executed" field.
func (m *ActionDataMutation) ResetActionsExecuted() {
	m.actions_executed = nil
	m.addactions_executed = nil
	delete(m.clearedFields, actiondata.FieldActionsExecuted)
}

// SetActionsCreated sets the "actions_created" field.
func (m *ActionDataMutation) SetActionsCreated(i int64) {
	m.actions_created = &i
	m.addactions_created = nil
}

// ActionsCreated returns the value of the "actions_created" field in the mutation.
func (m *ActionDataMutation) ActionsCreated() (r int64, exists bool) {
	v := m.actions_created
	if v == nil {
		return
	}
	return *v, true
}

// OldActionsCreated returns the old "actions_created" field's value of the ActionData entity.
// If the ActionData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionDataMutation) OldActionsCreated(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActionsCreated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActionsCreated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActionsCreated: %w", err)
	}
	return oldValue.ActionsCreated, nil
}

// AddActionsCreated adds i to the "actions_created" field.
func (m *ActionDataMutation) AddActionsCreated(i int64) {
	if m.addactions_created != nil {
		*m.addactions_created += i
	} else {
		m.addactions_created = &i
	}
}

// AddedActionsCreated returns the value that was added to the "actions_created" field in this mutation.
func (m *ActionDataMutation) AddedActionsCreated() (r int64, exists bool) {
	v := m.addactions_created
	if v == nil {
		return
	}
	return *v, true
}

// ClearActionsCreated clears the value of the "actions_created" field.
func (m *ActionDataMutation) ClearActionsCreated() {
	m.actions_created = nil
	m.addactions_created = nil
	m.clearedFields[actiondata.FieldActionsCreated] = struct{}{}
}

// ActionsCreatedCleared returns if the "actions_created" field was cleared in this mutation.
func (m *ActionDataMutation) ActionsCreatedCleared() bool {
	_, ok := m.clearedFields[actiondata.FieldActionsCreated]
	return ok
}

// ResetActionsCreated resets all changes to the "actions_created" field.
func (m *ActionDataMutation) ResetActionsCreated() {
	m.actions_created = nil
	m.addactions_created = nil
	delete(m.clearedFields, actiondata.FieldActionsCreated)
}

// SetFirstStartedMs sets the "first_started_ms" field.
func (m *ActionDataMutation) SetFirstStartedMs(i int64) {
	m.first_started_ms = &i
	m.addfirst_started_ms = nil
}

// FirstStartedMs returns the value of the "first_started_ms" field in the mutation.
func (m *ActionDataMutation) FirstStartedMs() (r int64, exists bool) {
	v := m.first_started_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstStartedMs returns the old "first_started_ms" field's value of the ActionData entity.
// If the ActionData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionDataMutation) OldFirstStartedMs(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstStartedMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstStartedMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstStartedMs: %w", err)
	}
	return oldValue.FirstStartedMs, nil
}

// AddFirstStartedMs adds i to the "first_started_ms" field.
func (m *ActionDataMutation) AddFirstStartedMs(i int64) {
	if m.addfirst_started_ms != nil {
		*m.addfirst_started_ms += i
	} else {
		m.addfirst_started_ms = &i
	}
}

// AddedFirstStartedMs returns the value that was added to the "first_started_ms" field in this mutation.
func (m *ActionDataMutation) AddedFirstStartedMs() (r int64, exists bool) {
	v := m.addfirst_started_ms
	if v == nil {
		return
	}
	return *v, true
}

// ClearFirstStartedMs clears the value of the "first_started_ms" field.
func (m *ActionDataMutation) ClearFirstStartedMs() {
	m.first_started_ms = nil
	m.addfirst_started_ms = nil
	m.clearedFields[actiondata.FieldFirstStartedMs] = struct{}{}
}

// FirstStartedMsCleared returns if the "first_started_ms" field was cleared in this mutation.
func (m *ActionDataMutation) FirstStartedMsCleared() bool {
	_, ok := m.clearedFields[actiondata.FieldFirstStartedMs]
	return ok
}

// ResetFirstStartedMs resets all changes to the "first_started_ms" field.
func (m *ActionDataMutation) ResetFirstStartedMs() {
	m.first_started_ms = nil
	m.addfirst_started_ms = nil
	delete(m.clearedFields, actiondata.FieldFirstStartedMs)
}

// SetLastEndedMs sets the "last_ended_ms" field.
func (m *ActionDataMutation) SetLastEndedMs(i int64) {
	m.last_ended_ms = &i
	m.addlast_ended_ms = nil
}

// LastEndedMs returns the value of the "last_ended_ms" field in the mutation.
func (m *ActionDataMutation) LastEndedMs() (r int64, exists bool) {
	v := m.last_ended_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldLastEndedMs returns the old "last_ended_ms" field's value of the ActionData entity.
// If the ActionData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionDataMutation) OldLastEndedMs(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastEndedMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastEndedMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastEndedMs: %w", err)
	}
	return oldValue.LastEndedMs, nil
}

// AddLastEndedMs adds i to the "last_ended_ms" field.
func (m *ActionDataMutation) AddLastEndedMs(i int64) {
	if m.addlast_ended_ms != nil {
		*m.addlast_ended_ms += i
	} else {
		m.addlast_ended_ms = &i
	}
}

// AddedLastEndedMs returns the value that was added to the "last_ended_ms" field in this mutation.
func (m *ActionDataMutation) AddedLastEndedMs() (r int64, exists bool) {
	v := m.addlast_ended_ms
	if v == nil {
		return
	}
	return *v, true
}

// ClearLastEndedMs clears the value of the "last_ended_ms" field.
func (m *ActionDataMutation) ClearLastEndedMs() {
	m.last_ended_ms = nil
	m.addlast_ended_ms = nil
	m.clearedFields[actiondata.FieldLastEndedMs] = struct{}{}
}

// LastEndedMsCleared returns if the "last_ended_ms" field was cleared in this mutation.
func (m *ActionDataMutation) LastEndedMsCleared() bool {
	_, ok := m.clearedFields[actiondata.FieldLastEndedMs]
	return ok
}

// ResetLastEndedMs resets all changes to the "last_ended_ms" field.
func (m *ActionDataMutation) ResetLastEndedMs() {
	m.last_ended_ms = nil
	m.addlast_ended_ms = nil
	delete(m.clearedFields, actiondata.FieldLastEndedMs)
}

// SetSystemTime sets the "system_time" field.
func (m *ActionDataMutation) SetSystemTime(i int64) {
	m.system_time = &i
	m.addsystem_time = nil
}

// SystemTime returns the value of the "system_time" field in the mutation.
func (m *ActionDataMutation) SystemTime() (r int64, exists bool) {
	v := m.system_time
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemTime returns the old "system_time" field's value of the ActionData entity.
// If the ActionData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionDataMutation) OldSystemTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemTime: %w", err)
	}
	return oldValue.SystemTime, nil
}

// AddSystemTime adds i to the "system_time" field.
func (m *ActionDataMutation) AddSystemTime(i int64) {
	if m.addsystem_time != nil {
		*m.addsystem_time += i
	} else {
		m.addsystem_time = &i
	}
}

// AddedSystemTime returns the value that was added to the "system_time" field in this mutation.
func (m *ActionDataMutation) AddedSystemTime() (r int64, exists bool) {
	v := m.addsystem_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearSystemTime clears the value of the "system_time" field.
func (m *ActionDataMutation) ClearSystemTime() {
	m.system_time = nil
	m.addsystem_time = nil
	m.clearedFields[actiondata.FieldSystemTime] = struct{}{}
}

// SystemTimeCleared returns if the "system_time" field was cleared in this mutation.
func (m *ActionDataMutation) SystemTimeCleared() bool {
	_, ok := m.clearedFields[actiondata.FieldSystemTime]
	return ok
}

// ResetSystemTime resets all changes to the "system_time" field.
func (m *ActionDataMutation) ResetSystemTime() {
	m.system_time = nil
	m.addsystem_time = nil
	delete(m.clearedFields, actiondata.FieldSystemTime)
}

// SetUserTime sets the "user_time" field.
func (m *ActionDataMutation) SetUserTime(i int64) {
	m.user_time = &i
	m.adduser_time = nil
}

// UserTime returns the value of the "user_time" field in the mutation.
func (m *ActionDataMutation) UserTime() (r int64, exists bool) {
	v := m.user_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUserTime returns the old "user_time" field's value of the ActionData entity.
// If the ActionData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionDataMutation) OldUserTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserTime: %w", err)
	}
	return oldValue.UserTime, nil
}

// AddUserTime adds i to the "user_time" field.
func (m *ActionDataMutation) AddUserTime(i int64) {
	if m.adduser_time != nil {
		*m.adduser_time += i
	} else {
		m.adduser_time = &i
	}
}

// AddedUserTime returns the value that was added to the "user_time" field in this mutation.
func (m *ActionDataMutation) AddedUserTime() (r int64, exists bool) {
	v := m.adduser_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearUserTime clears the value of the "user_time" field.
func (m *ActionDataMutation) ClearUserTime() {
	m.user_time = nil
	m.adduser_time = nil
	m.clearedFields[actiondata.FieldUserTime] = struct{}{}
}

// UserTimeCleared returns if the "user_time" field was cleared in this mutation.
func (m *ActionDataMutation) UserTimeCleared() bool {
	_, ok := m.clearedFields[actiondata.FieldUserTime]
	return ok
}

// ResetUserTime resets all changes to the "user_time" field.
func (m *ActionDataMutation) ResetUserTime() {
	m.user_time = nil
	m.adduser_time = nil
	delete(m.clearedFields, actiondata.FieldUserTime)
}

// SetActionSummaryID sets the "action_summary" edge to the ActionSummary entity by id.
func (m *ActionDataMutation) SetActionSummaryID(id int64) {
	m.action_summary = &id
}

// ClearActionSummary clears the "action_summary" edge to the ActionSummary entity.
func (m *ActionDataMutation) ClearActionSummary() {
	m.clearedaction_summary = true
}

// ActionSummaryCleared reports if the "action_summary" edge to the ActionSummary entity was cleared.
func (m *ActionDataMutation) ActionSummaryCleared() bool {
	return m.clearedaction_summary
}

// ActionSummaryID returns the "action_summary" edge ID in the mutation.
func (m *ActionDataMutation) ActionSummaryID() (id int64, exists bool) {
	if m.action_summary != nil {
		return *m.action_summary, true
	}
	return
}

// ActionSummaryIDs returns the "action_summary" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ActionSummaryID instead. It exists only for internal usage by the builders.
func (m *ActionDataMutation) ActionSummaryIDs() (ids []int64) {
	if id := m.action_summary; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetActionSummary resets all changes to the "action_summary" edge.
func (m *ActionDataMutation) ResetActionSummary() {
	m.action_summary = nil
	m.clearedaction_summary = false
}

// Where appends a list predicates to the ActionDataMutation builder.
func (m *ActionDataMutation) Where(ps ...predicate.ActionData) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ActionDataMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ActionDataMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ActionData, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ActionDataMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ActionDataMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ActionData).
func (m *ActionDataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ActionDataMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.mnemonic != nil {
		fields = append(fields, actiondata.FieldMnemonic)
	}
	if m.actions_executed != nil {
		fields = append(fields, actiondata.FieldActionsExecuted)
	}
	if m.actions_created != nil {
		fields = append(fields, actiondata.FieldActionsCreated)
	}
	if m.first_started_ms != nil {
		fields = append(fields, actiondata.FieldFirstStartedMs)
	}
	if m.last_ended_ms != nil {
		fields = append(fields, actiondata.FieldLastEndedMs)
	}
	if m.system_time != nil {
		fields = append(fields, actiondata.FieldSystemTime)
	}
	if m.user_time != nil {
		fields = append(fields, actiondata.FieldUserTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ActionDataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case actiondata.FieldMnemonic:
		return m.Mnemonic()
	case actiondata.FieldActionsExecuted:
		return m.ActionsExecuted()
	case actiondata.FieldActionsCreated:
		return m.ActionsCreated()
	case actiondata.FieldFirstStartedMs:
		return m.FirstStartedMs()
	case actiondata.FieldLastEndedMs:
		return m.LastEndedMs()
	case actiondata.FieldSystemTime:
		return m.SystemTime()
	case actiondata.FieldUserTime:
		return m.UserTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ActionDataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case actiondata.FieldMnemonic:
		return m.OldMnemonic(ctx)
	case actiondata.FieldActionsExecuted:
		return m.OldActionsExecuted(ctx)
	case actiondata.FieldActionsCreated:
		return m.OldActionsCreated(ctx)
	case actiondata.FieldFirstStartedMs:
		return m.OldFirstStartedMs(ctx)
	case actiondata.FieldLastEndedMs:
		return m.OldLastEndedMs(ctx)
	case actiondata.FieldSystemTime:
		return m.OldSystemTime(ctx)
	case actiondata.FieldUserTime:
		return m.OldUserTime(ctx)
	}
	return nil, fmt.Errorf("unknown ActionData field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActionDataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case actiondata.FieldMnemonic:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMnemonic(v)
		return nil
	case actiondata.FieldActionsExecuted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActionsExecuted(v)
		return nil
	case actiondata.FieldActionsCreated:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActionsCreated(v)
		return nil
	case actiondata.FieldFirstStartedMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstStartedMs(v)
		return nil
	case actiondata.FieldLastEndedMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastEndedMs(v)
		return nil
	case actiondata.FieldSystemTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemTime(v)
		return nil
	case actiondata.FieldUserTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserTime(v)
		return nil
	}
	return fmt.Errorf("unknown ActionData field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ActionDataMutation) AddedFields() []string {
	var fields []string
	if m.addactions_executed != nil {
		fields = append(fields, actiondata.FieldActionsExecuted)
	}
	if m.addactions_created != nil {
		fields = append(fields, actiondata.FieldActionsCreated)
	}
	if m.addfirst_started_ms != nil {
		fields = append(fields, actiondata.FieldFirstStartedMs)
	}
	if m.addlast_ended_ms != nil {
		fields = append(fields, actiondata.FieldLastEndedMs)
	}
	if m.addsystem_time != nil {
		fields = append(fields, actiondata.FieldSystemTime)
	}
	if m.adduser_time != nil {
		fields = append(fields, actiondata.FieldUserTime)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ActionDataMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case actiondata.FieldActionsExecuted:
		return m.AddedActionsExecuted()
	case actiondata.FieldActionsCreated:
		return m.AddedActionsCreated()
	case actiondata.FieldFirstStartedMs:
		return m.AddedFirstStartedMs()
	case actiondata.FieldLastEndedMs:
		return m.AddedLastEndedMs()
	case actiondata.FieldSystemTime:
		return m.AddedSystemTime()
	case actiondata.FieldUserTime:
		return m.AddedUserTime()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActionDataMutation) AddField(name string, value ent.Value) error {
	switch name {
	case actiondata.FieldActionsExecuted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddActionsExecuted(v)
		return nil
	case actiondata.FieldActionsCreated:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddActionsCreated(v)
		return nil
	case actiondata.FieldFirstStartedMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFirstStartedMs(v)
		return nil
	case actiondata.FieldLastEndedMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLastEndedMs(v)
		return nil
	case actiondata.FieldSystemTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSystemTime(v)
		return nil
	case actiondata.FieldUserTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserTime(v)
		return nil
	}
	return fmt.Errorf("unknown ActionData numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ActionDataMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(actiondata.FieldMnemonic) {
		fields = append(fields, actiondata.FieldMnemonic)
	}
	if m.FieldCleared(actiondata.FieldActionsExecuted) {
		fields = append(fields, actiondata.FieldActionsExecuted)
	}
	if m.FieldCleared(actiondata.FieldActionsCreated) {
		fields = append(fields, actiondata.FieldActionsCreated)
	}
	if m.FieldCleared(actiondata.FieldFirstStartedMs) {
		fields = append(fields, actiondata.FieldFirstStartedMs)
	}
	if m.FieldCleared(actiondata.FieldLastEndedMs) {
		fields = append(fields, actiondata.FieldLastEndedMs)
	}
	if m.FieldCleared(actiondata.FieldSystemTime) {
		fields = append(fields, actiondata.FieldSystemTime)
	}
	if m.FieldCleared(actiondata.FieldUserTime) {
		fields = append(fields, actiondata.FieldUserTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ActionDataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ActionDataMutation) ClearField(name string) error {
	switch name {
	case actiondata.FieldMnemonic:
		m.ClearMnemonic()
		return nil
	case actiondata.FieldActionsExecuted:
		m.ClearActionsExecuted()
		return nil
	case actiondata.FieldActionsCreated:
		m.ClearActionsCreated()
		return nil
	case actiondata.FieldFirstStartedMs:
		m.ClearFirstStartedMs()
		return nil
	case actiondata.FieldLastEndedMs:
		m.ClearLastEndedMs()
		return nil
	case actiondata.FieldSystemTime:
		m.ClearSystemTime()
		return nil
	case actiondata.FieldUserTime:
		m.ClearUserTime()
		return nil
	}
	return fmt.Errorf("unknown ActionData nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ActionDataMutation) ResetField(name string) error {
	switch name {
	case actiondata.FieldMnemonic:
		m.ResetMnemonic()
		return nil
	case actiondata.FieldActionsExecuted:
		m.ResetActionsExecuted()
		return nil
	case actiondata.FieldActionsCreated:
		m.ResetActionsCreated()
		return nil
	case actiondata.FieldFirstStartedMs:
		m.ResetFirstStartedMs()
		return nil
	case actiondata.FieldLastEndedMs:
		m.ResetLastEndedMs()
		return nil
	case actiondata.FieldSystemTime:
		m.ResetSystemTime()
		return nil
	case actiondata.FieldUserTime:
		m.ResetUserTime()
		return nil
	}
	return fmt.Errorf("unknown ActionData field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ActionDataMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.action_summary != nil {
		edges = append(edges, actiondata.EdgeActionSummary)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ActionDataMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case actiondata.EdgeActionSummary:
		if id := m.action_summary; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ActionDataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ActionDataMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ActionDataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedaction_summary {
		edges = append(edges, actiondata.EdgeActionSummary)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ActionDataMutation) EdgeCleared(name string) bool {
	switch name {
	case actiondata.EdgeActionSummary:
		return m.clearedaction_summary
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ActionDataMutation) ClearEdge(name string) error {
	switch name {
	case actiondata.EdgeActionSummary:
		m.ClearActionSummary()
		return nil
	}
	return fmt.Errorf("unknown ActionData unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ActionDataMutation) ResetEdge(name string) error {
	switch name {
	case actiondata.EdgeActionSummary:
		m.ResetActionSummary()
		return nil
	}
	return fmt.Errorf("unknown ActionData edge %s", name)
}

// ActionSummaryMutation represents an operation that mutates the ActionSummary nodes in the graph.
type ActionSummaryMutation struct {
	config
	op                                       Op
	typ                                      string
	id                                       *int64
	actions_created                          *int64
	addactions_created                       *int64
	actions_created_not_including_aspects    *int64
	addactions_created_not_including_aspects *int64
	actions_executed                         *int64
	addactions_executed                      *int64
	remote_cache_hits                        *int64
	addremote_cache_hits                     *int64
	clearedFields                            map[string]struct{}
	metrics                                  *int64
	clearedmetrics                           bool
	action_data                              map[int64]struct{}
	removedaction_data                       map[int64]struct{}
	clearedaction_data                       bool
	runner_count                             map[int64]struct{}
	removedrunner_count                      map[int64]struct{}
	clearedrunner_count                      bool
	action_cache_statistics                  *int64
	clearedaction_cache_statistics           bool
	done                                     bool
	oldValue                                 func(context.Context) (*ActionSummary, error)
	predicates                               []predicate.ActionSummary
}

var _ ent.Mutation = (*ActionSummaryMutation)(nil)

// actionsummaryOption allows management of the mutation configuration using functional options.
type actionsummaryOption func(*ActionSummaryMutation)

// newActionSummaryMutation creates new mutation for the ActionSummary entity.
func newActionSummaryMutation(c config, op Op, opts ...actionsummaryOption) *ActionSummaryMutation {
	m := &ActionSummaryMutation{
		config:        c,
		op:            op,
		typ:           TypeActionSummary,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withActionSummaryID sets the ID field of the mutation.
func withActionSummaryID(id int64) actionsummaryOption {
	return func(m *ActionSummaryMutation) {
		var (
			err   error
			once  sync.Once
			value *ActionSummary
		)
		m.oldValue = func(ctx context.Context) (*ActionSummary, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ActionSummary.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withActionSummary sets the old ActionSummary of the mutation.
func withActionSummary(node *ActionSummary) actionsummaryOption {
	return func(m *ActionSummaryMutation) {
		m.oldValue = func(context.Context) (*ActionSummary, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ActionSummaryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ActionSummaryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ActionSummary entities.
func (m *ActionSummaryMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ActionSummaryMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ActionSummaryMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ActionSummary.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetActionsCreated sets the "actions_created" field.
func (m *ActionSummaryMutation) SetActionsCreated(i int64) {
	m.actions_created = &i
	m.addactions_created = nil
}

// ActionsCreated returns the value of the "actions_created" field in the mutation.
func (m *ActionSummaryMutation) ActionsCreated() (r int64, exists bool) {
	v := m.actions_created
	if v == nil {
		return
	}
	return *v, true
}

// OldActionsCreated returns the old "actions_created" field's value of the ActionSummary entity.
// If the ActionSummary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionSummaryMutation) OldActionsCreated(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActionsCreated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActionsCreated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActionsCreated: %w", err)
	}
	return oldValue.ActionsCreated, nil
}

// AddActionsCreated adds i to the "actions_created" field.
func (m *ActionSummaryMutation) AddActionsCreated(i int64) {
	if m.addactions_created != nil {
		*m.addactions_created += i
	} else {
		m.addactions_created = &i
	}
}

// AddedActionsCreated returns the value that was added to the "actions_created" field in this mutation.
func (m *ActionSummaryMutation) AddedActionsCreated() (r int64, exists bool) {
	v := m.addactions_created
	if v == nil {
		return
	}
	return *v, true
}

// ClearActionsCreated clears the value of the "actions_created" field.
func (m *ActionSummaryMutation) ClearActionsCreated() {
	m.actions_created = nil
	m.addactions_created = nil
	m.clearedFields[actionsummary.FieldActionsCreated] = struct{}{}
}

// ActionsCreatedCleared returns if the "actions_created" field was cleared in this mutation.
func (m *ActionSummaryMutation) ActionsCreatedCleared() bool {
	_, ok := m.clearedFields[actionsummary.FieldActionsCreated]
	return ok
}

// ResetActionsCreated resets all changes to the "actions_created" field.
func (m *ActionSummaryMutation) ResetActionsCreated() {
	m.actions_created = nil
	m.addactions_created = nil
	delete(m.clearedFields, actionsummary.FieldActionsCreated)
}

// SetActionsCreatedNotIncludingAspects sets the "actions_created_not_including_aspects" field.
func (m *ActionSummaryMutation) SetActionsCreatedNotIncludingAspects(i int64) {
	m.actions_created_not_including_aspects = &i
	m.addactions_created_not_including_aspects = nil
}

// ActionsCreatedNotIncludingAspects returns the value of the "actions_created_not_including_aspects" field in the mutation.
func (m *ActionSummaryMutation) ActionsCreatedNotIncludingAspects() (r int64, exists bool) {
	v := m.actions_created_not_including_aspects
	if v == nil {
		return
	}
	return *v, true
}

// OldActionsCreatedNotIncludingAspects returns the old "actions_created_not_including_aspects" field's value of the ActionSummary entity.
// If the ActionSummary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionSummaryMutation) OldActionsCreatedNotIncludingAspects(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActionsCreatedNotIncludingAspects is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActionsCreatedNotIncludingAspects requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActionsCreatedNotIncludingAspects: %w", err)
	}
	return oldValue.ActionsCreatedNotIncludingAspects, nil
}

// AddActionsCreatedNotIncludingAspects adds i to the "actions_created_not_including_aspects" field.
func (m *ActionSummaryMutation) AddActionsCreatedNotIncludingAspects(i int64) {
	if m.addactions_created_not_including_aspects != nil {
		*m.addactions_created_not_including_aspects += i
	} else {
		m.addactions_created_not_including_aspects = &i
	}
}

// AddedActionsCreatedNotIncludingAspects returns the value that was added to the "actions_created_not_including_aspects" field in this mutation.
func (m *ActionSummaryMutation) AddedActionsCreatedNotIncludingAspects() (r int64, exists bool) {
	v := m.addactions_created_not_including_aspects
	if v == nil {
		return
	}
	return *v, true
}

// ClearActionsCreatedNotIncludingAspects clears the value of the "actions_created_not_including_aspects" field.
func (m *ActionSummaryMutation) ClearActionsCreatedNotIncludingAspects() {
	m.actions_created_not_including_aspects = nil
	m.addactions_created_not_including_aspects = nil
	m.clearedFields[actionsummary.FieldActionsCreatedNotIncludingAspects] = struct{}{}
}

// ActionsCreatedNotIncludingAspectsCleared returns if the "actions_created_not_including_aspects" field was cleared in this mutation.
func (m *ActionSummaryMutation) ActionsCreatedNotIncludingAspectsCleared() bool {
	_, ok := m.clearedFields[actionsummary.FieldActionsCreatedNotIncludingAspects]
	return ok
}

// ResetActionsCreatedNotIncludingAspects resets all changes to the "actions_created_not_including_aspects" field.
func (m *ActionSummaryMutation) ResetActionsCreatedNotIncludingAspects() {
	m.actions_created_not_including_aspects = nil
	m.addactions_created_not_including_aspects = nil
	delete(m.clearedFields, actionsummary.FieldActionsCreatedNotIncludingAspects)
}

// SetActionsExecuted sets the "actions_executed" field.
func (m *ActionSummaryMutation) SetActionsExecuted(i int64) {
	m.actions_executed = &i
	m.addactions_executed = nil
}

// ActionsExecuted returns the value of the "actions_executed" field in the mutation.
func (m *ActionSummaryMutation) ActionsExecuted() (r int64, exists bool) {
	v := m.actions_executed
	if v == nil {
		return
	}
	return *v, true
}

// OldActionsExecuted returns the old "actions_executed" field's value of the ActionSummary entity.
// If the ActionSummary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionSummaryMutation) OldActionsExecuted(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActionsExecuted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActionsExecuted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActionsExecuted: %w", err)
	}
	return oldValue.ActionsExecuted, nil
}

// AddActionsExecuted adds i to the "actions_executed" field.
func (m *ActionSummaryMutation) AddActionsExecuted(i int64) {
	if m.addactions_executed != nil {
		*m.addactions_executed += i
	} else {
		m.addactions_executed = &i
	}
}

// AddedActionsExecuted returns the value that was added to the "actions_executed" field in this mutation.
func (m *ActionSummaryMutation) AddedActionsExecuted() (r int64, exists bool) {
	v := m.addactions_executed
	if v == nil {
		return
	}
	return *v, true
}

// ClearActionsExecuted clears the value of the "actions_executed" field.
func (m *ActionSummaryMutation) ClearActionsExecuted() {
	m.actions_executed = nil
	m.addactions_executed = nil
	m.clearedFields[actionsummary.FieldActionsExecuted] = struct{}{}
}

// ActionsExecutedCleared returns if the "actions_executed" field was cleared in this mutation.
func (m *ActionSummaryMutation) ActionsExecutedCleared() bool {
	_, ok := m.clearedFields[actionsummary.FieldActionsExecuted]
	return ok
}

// ResetActionsExecuted resets all changes to the "actions_executed" field.
func (m *ActionSummaryMutation) ResetActionsExecuted() {
	m.actions_executed = nil
	m.addactions_executed = nil
	delete(m.clearedFields, actionsummary.FieldActionsExecuted)
}

// SetRemoteCacheHits sets the "remote_cache_hits" field.
func (m *ActionSummaryMutation) SetRemoteCacheHits(i int64) {
	m.remote_cache_hits = &i
	m.addremote_cache_hits = nil
}

// RemoteCacheHits returns the value of the "remote_cache_hits" field in the mutation.
func (m *ActionSummaryMutation) RemoteCacheHits() (r int64, exists bool) {
	v := m.remote_cache_hits
	if v == nil {
		return
	}
	return *v, true
}

// OldRemoteCacheHits returns the old "remote_cache_hits" field's value of the ActionSummary entity.
// If the ActionSummary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionSummaryMutation) OldRemoteCacheHits(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemoteCacheHits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemoteCacheHits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemoteCacheHits: %w", err)
	}
	return oldValue.RemoteCacheHits, nil
}

// AddRemoteCacheHits adds i to the "remote_cache_hits" field.
func (m *ActionSummaryMutation) AddRemoteCacheHits(i int64) {
	if m.addremote_cache_hits != nil {
		*m.addremote_cache_hits += i
	} else {
		m.addremote_cache_hits = &i
	}
}

// AddedRemoteCacheHits returns the value that was added to the "remote_cache_hits" field in this mutation.
func (m *ActionSummaryMutation) AddedRemoteCacheHits() (r int64, exists bool) {
	v := m.addremote_cache_hits
	if v == nil {
		return
	}
	return *v, true
}

// ClearRemoteCacheHits clears the value of the "remote_cache_hits" field.
func (m *ActionSummaryMutation) ClearRemoteCacheHits() {
	m.remote_cache_hits = nil
	m.addremote_cache_hits = nil
	m.clearedFields[actionsummary.FieldRemoteCacheHits] = struct{}{}
}

// RemoteCacheHitsCleared returns if the "remote_cache_hits" field was cleared in this mutation.
func (m *ActionSummaryMutation) RemoteCacheHitsCleared() bool {
	_, ok := m.clearedFields[actionsummary.FieldRemoteCacheHits]
	return ok
}

// ResetRemoteCacheHits resets all changes to the "remote_cache_hits" field.
func (m *ActionSummaryMutation) ResetRemoteCacheHits() {
	m.remote_cache_hits = nil
	m.addremote_cache_hits = nil
	delete(m.clearedFields, actionsummary.FieldRemoteCacheHits)
}

// SetMetricsID sets the "metrics" edge to the Metrics entity by id.
func (m *ActionSummaryMutation) SetMetricsID(id int64) {
	m.metrics = &id
}

// ClearMetrics clears the "metrics" edge to the Metrics entity.
func (m *ActionSummaryMutation) ClearMetrics() {
	m.clearedmetrics = true
}

// MetricsCleared reports if the "metrics" edge to the Metrics entity was cleared.
func (m *ActionSummaryMutation) MetricsCleared() bool {
	return m.clearedmetrics
}

// MetricsID returns the "metrics" edge ID in the mutation.
func (m *ActionSummaryMutation) MetricsID() (id int64, exists bool) {
	if m.metrics != nil {
		return *m.metrics, true
	}
	return
}

// MetricsIDs returns the "metrics" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MetricsID instead. It exists only for internal usage by the builders.
func (m *ActionSummaryMutation) MetricsIDs() (ids []int64) {
	if id := m.metrics; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMetrics resets all changes to the "metrics" edge.
func (m *ActionSummaryMutation) ResetMetrics() {
	m.metrics = nil
	m.clearedmetrics = false
}

// AddActionDatumIDs adds the "action_data" edge to the ActionData entity by ids.
func (m *ActionSummaryMutation) AddActionDatumIDs(ids ...int64) {
	if m.action_data == nil {
		m.action_data = make(map[int64]struct{})
	}
	for i := range ids {
		m.action_data[ids[i]] = struct{}{}
	}
}

// ClearActionData clears the "action_data" edge to the ActionData entity.
func (m *ActionSummaryMutation) ClearActionData() {
	m.clearedaction_data = true
}

// ActionDataCleared reports if the "action_data" edge to the ActionData entity was cleared.
func (m *ActionSummaryMutation) ActionDataCleared() bool {
	return m.clearedaction_data
}

// RemoveActionDatumIDs removes the "action_data" edge to the ActionData entity by IDs.
func (m *ActionSummaryMutation) RemoveActionDatumIDs(ids ...int64) {
	if m.removedaction_data == nil {
		m.removedaction_data = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.action_data, ids[i])
		m.removedaction_data[ids[i]] = struct{}{}
	}
}

// RemovedActionData returns the removed IDs of the "action_data" edge to the ActionData entity.
func (m *ActionSummaryMutation) RemovedActionDataIDs() (ids []int64) {
	for id := range m.removedaction_data {
		ids = append(ids, id)
	}
	return
}

// ActionDataIDs returns the "action_data" edge IDs in the mutation.
func (m *ActionSummaryMutation) ActionDataIDs() (ids []int64) {
	for id := range m.action_data {
		ids = append(ids, id)
	}
	return
}

// ResetActionData resets all changes to the "action_data" edge.
func (m *ActionSummaryMutation) ResetActionData() {
	m.action_data = nil
	m.clearedaction_data = false
	m.removedaction_data = nil
}

// AddRunnerCountIDs adds the "runner_count" edge to the RunnerCount entity by ids.
func (m *ActionSummaryMutation) AddRunnerCountIDs(ids ...int64) {
	if m.runner_count == nil {
		m.runner_count = make(map[int64]struct{})
	}
	for i := range ids {
		m.runner_count[ids[i]] = struct{}{}
	}
}

// ClearRunnerCount clears the "runner_count" edge to the RunnerCount entity.
func (m *ActionSummaryMutation) ClearRunnerCount() {
	m.clearedrunner_count = true
}

// RunnerCountCleared reports if the "runner_count" edge to the RunnerCount entity was cleared.
func (m *ActionSummaryMutation) RunnerCountCleared() bool {
	return m.clearedrunner_count
}

// RemoveRunnerCountIDs removes the "runner_count" edge to the RunnerCount entity by IDs.
func (m *ActionSummaryMutation) RemoveRunnerCountIDs(ids ...int64) {
	if m.removedrunner_count == nil {
		m.removedrunner_count = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.runner_count, ids[i])
		m.removedrunner_count[ids[i]] = struct{}{}
	}
}

// RemovedRunnerCount returns the removed IDs of the "runner_count" edge to the RunnerCount entity.
func (m *ActionSummaryMutation) RemovedRunnerCountIDs() (ids []int64) {
	for id := range m.removedrunner_count {
		ids = append(ids, id)
	}
	return
}

// RunnerCountIDs returns the "runner_count" edge IDs in the mutation.
func (m *ActionSummaryMutation) RunnerCountIDs() (ids []int64) {
	for id := range m.runner_count {
		ids = append(ids, id)
	}
	return
}

// ResetRunnerCount resets all changes to the "runner_count" edge.
func (m *ActionSummaryMutation) ResetRunnerCount() {
	m.runner_count = nil
	m.clearedrunner_count = false
	m.removedrunner_count = nil
}

// SetActionCacheStatisticsID sets the "action_cache_statistics" edge to the ActionCacheStatistics entity by id.
func (m *ActionSummaryMutation) SetActionCacheStatisticsID(id int64) {
	m.action_cache_statistics = &id
}

// ClearActionCacheStatistics clears the "action_cache_statistics" edge to the ActionCacheStatistics entity.
func (m *ActionSummaryMutation) ClearActionCacheStatistics() {
	m.clearedaction_cache_statistics = true
}

// ActionCacheStatisticsCleared reports if the "action_cache_statistics" edge to the ActionCacheStatistics entity was cleared.
func (m *ActionSummaryMutation) ActionCacheStatisticsCleared() bool {
	return m.clearedaction_cache_statistics
}

// ActionCacheStatisticsID returns the "action_cache_statistics" edge ID in the mutation.
func (m *ActionSummaryMutation) ActionCacheStatisticsID() (id int64, exists bool) {
	if m.action_cache_statistics != nil {
		return *m.action_cache_statistics, true
	}
	return
}

// ActionCacheStatisticsIDs returns the "action_cache_statistics" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ActionCacheStatisticsID instead. It exists only for internal usage by the builders.
func (m *ActionSummaryMutation) ActionCacheStatisticsIDs() (ids []int64) {
	if id := m.action_cache_statistics; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetActionCacheStatistics resets all changes to the "action_cache_statistics" edge.
func (m *ActionSummaryMutation) ResetActionCacheStatistics() {
	m.action_cache_statistics = nil
	m.clearedaction_cache_statistics = false
}

// Where appends a list predicates to the ActionSummaryMutation builder.
func (m *ActionSummaryMutation) Where(ps ...predicate.ActionSummary) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ActionSummaryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ActionSummaryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ActionSummary, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ActionSummaryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ActionSummaryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ActionSummary).
func (m *ActionSummaryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ActionSummaryMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.actions_created != nil {
		fields = append(fields, actionsummary.FieldActionsCreated)
	}
	if m.actions_created_not_including_aspects != nil {
		fields = append(fields, actionsummary.FieldActionsCreatedNotIncludingAspects)
	}
	if m.actions_executed != nil {
		fields = append(fields, actionsummary.FieldActionsExecuted)
	}
	if m.remote_cache_hits != nil {
		fields = append(fields, actionsummary.FieldRemoteCacheHits)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ActionSummaryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case actionsummary.FieldActionsCreated:
		return m.ActionsCreated()
	case actionsummary.FieldActionsCreatedNotIncludingAspects:
		return m.ActionsCreatedNotIncludingAspects()
	case actionsummary.FieldActionsExecuted:
		return m.ActionsExecuted()
	case actionsummary.FieldRemoteCacheHits:
		return m.RemoteCacheHits()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ActionSummaryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case actionsummary.FieldActionsCreated:
		return m.OldActionsCreated(ctx)
	case actionsummary.FieldActionsCreatedNotIncludingAspects:
		return m.OldActionsCreatedNotIncludingAspects(ctx)
	case actionsummary.FieldActionsExecuted:
		return m.OldActionsExecuted(ctx)
	case actionsummary.FieldRemoteCacheHits:
		return m.OldRemoteCacheHits(ctx)
	}
	return nil, fmt.Errorf("unknown ActionSummary field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActionSummaryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case actionsummary.FieldActionsCreated:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActionsCreated(v)
		return nil
	case actionsummary.FieldActionsCreatedNotIncludingAspects:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActionsCreatedNotIncludingAspects(v)
		return nil
	case actionsummary.FieldActionsExecuted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActionsExecuted(v)
		return nil
	case actionsummary.FieldRemoteCacheHits:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemoteCacheHits(v)
		return nil
	}
	return fmt.Errorf("unknown ActionSummary field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ActionSummaryMutation) AddedFields() []string {
	var fields []string
	if m.addactions_created != nil {
		fields = append(fields, actionsummary.FieldActionsCreated)
	}
	if m.addactions_created_not_including_aspects != nil {
		fields = append(fields, actionsummary.FieldActionsCreatedNotIncludingAspects)
	}
	if m.addactions_executed != nil {
		fields = append(fields, actionsummary.FieldActionsExecuted)
	}
	if m.addremote_cache_hits != nil {
		fields = append(fields, actionsummary.FieldRemoteCacheHits)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ActionSummaryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case actionsummary.FieldActionsCreated:
		return m.AddedActionsCreated()
	case actionsummary.FieldActionsCreatedNotIncludingAspects:
		return m.AddedActionsCreatedNotIncludingAspects()
	case actionsummary.FieldActionsExecuted:
		return m.AddedActionsExecuted()
	case actionsummary.FieldRemoteCacheHits:
		return m.AddedRemoteCacheHits()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActionSummaryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case actionsummary.FieldActionsCreated:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddActionsCreated(v)
		return nil
	case actionsummary.FieldActionsCreatedNotIncludingAspects:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddActionsCreatedNotIncludingAspects(v)
		return nil
	case actionsummary.FieldActionsExecuted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddActionsExecuted(v)
		return nil
	case actionsummary.FieldRemoteCacheHits:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRemoteCacheHits(v)
		return nil
	}
	return fmt.Errorf("unknown ActionSummary numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ActionSummaryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(actionsummary.FieldActionsCreated) {
		fields = append(fields, actionsummary.FieldActionsCreated)
	}
	if m.FieldCleared(actionsummary.FieldActionsCreatedNotIncludingAspects) {
		fields = append(fields, actionsummary.FieldActionsCreatedNotIncludingAspects)
	}
	if m.FieldCleared(actionsummary.FieldActionsExecuted) {
		fields = append(fields, actionsummary.FieldActionsExecuted)
	}
	if m.FieldCleared(actionsummary.FieldRemoteCacheHits) {
		fields = append(fields, actionsummary.FieldRemoteCacheHits)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ActionSummaryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ActionSummaryMutation) ClearField(name string) error {
	switch name {
	case actionsummary.FieldActionsCreated:
		m.ClearActionsCreated()
		return nil
	case actionsummary.FieldActionsCreatedNotIncludingAspects:
		m.ClearActionsCreatedNotIncludingAspects()
		return nil
	case actionsummary.FieldActionsExecuted:
		m.ClearActionsExecuted()
		return nil
	case actionsummary.FieldRemoteCacheHits:
		m.ClearRemoteCacheHits()
		return nil
	}
	return fmt.Errorf("unknown ActionSummary nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ActionSummaryMutation) ResetField(name string) error {
	switch name {
	case actionsummary.FieldActionsCreated:
		m.ResetActionsCreated()
		return nil
	case actionsummary.FieldActionsCreatedNotIncludingAspects:
		m.ResetActionsCreatedNotIncludingAspects()
		return nil
	case actionsummary.FieldActionsExecuted:
		m.ResetActionsExecuted()
		return nil
	case actionsummary.FieldRemoteCacheHits:
		m.ResetRemoteCacheHits()
		return nil
	}
	return fmt.Errorf("unknown ActionSummary field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ActionSummaryMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.metrics != nil {
		edges = append(edges, actionsummary.EdgeMetrics)
	}
	if m.action_data != nil {
		edges = append(edges, actionsummary.EdgeActionData)
	}
	if m.runner_count != nil {
		edges = append(edges, actionsummary.EdgeRunnerCount)
	}
	if m.action_cache_statistics != nil {
		edges = append(edges, actionsummary.EdgeActionCacheStatistics)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ActionSummaryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case actionsummary.EdgeMetrics:
		if id := m.metrics; id != nil {
			return []ent.Value{*id}
		}
	case actionsummary.EdgeActionData:
		ids := make([]ent.Value, 0, len(m.action_data))
		for id := range m.action_data {
			ids = append(ids, id)
		}
		return ids
	case actionsummary.EdgeRunnerCount:
		ids := make([]ent.Value, 0, len(m.runner_count))
		for id := range m.runner_count {
			ids = append(ids, id)
		}
		return ids
	case actionsummary.EdgeActionCacheStatistics:
		if id := m.action_cache_statistics; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ActionSummaryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedaction_data != nil {
		edges = append(edges, actionsummary.EdgeActionData)
	}
	if m.removedrunner_count != nil {
		edges = append(edges, actionsummary.EdgeRunnerCount)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ActionSummaryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case actionsummary.EdgeActionData:
		ids := make([]ent.Value, 0, len(m.removedaction_data))
		for id := range m.removedaction_data {
			ids = append(ids, id)
		}
		return ids
	case actionsummary.EdgeRunnerCount:
		ids := make([]ent.Value, 0, len(m.removedrunner_count))
		for id := range m.removedrunner_count {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ActionSummaryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedmetrics {
		edges = append(edges, actionsummary.EdgeMetrics)
	}
	if m.clearedaction_data {
		edges = append(edges, actionsummary.EdgeActionData)
	}
	if m.clearedrunner_count {
		edges = append(edges, actionsummary.EdgeRunnerCount)
	}
	if m.clearedaction_cache_statistics {
		edges = append(edges, actionsummary.EdgeActionCacheStatistics)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ActionSummaryMutation) EdgeCleared(name string) bool {
	switch name {
	case actionsummary.EdgeMetrics:
		return m.clearedmetrics
	case actionsummary.EdgeActionData:
		return m.clearedaction_data
	case actionsummary.EdgeRunnerCount:
		return m.clearedrunner_count
	case actionsummary.EdgeActionCacheStatistics:
		return m.clearedaction_cache_statistics
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ActionSummaryMutation) ClearEdge(name string) error {
	switch name {
	case actionsummary.EdgeMetrics:
		m.ClearMetrics()
		return nil
	case actionsummary.EdgeActionCacheStatistics:
		m.ClearActionCacheStatistics()
		return nil
	}
	return fmt.Errorf("unknown ActionSummary unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ActionSummaryMutation) ResetEdge(name string) error {
	switch name {
	case actionsummary.EdgeMetrics:
		m.ResetMetrics()
		return nil
	case actionsummary.EdgeActionData:
		m.ResetActionData()
		return nil
	case actionsummary.EdgeRunnerCount:
		m.ResetRunnerCount()
		return nil
	case actionsummary.EdgeActionCacheStatistics:
		m.ResetActionCacheStatistics()
		return nil
	}
	return fmt.Errorf("unknown ActionSummary edge %s", name)
}

// ArtifactMetricsMutation represents an operation that mutates the ArtifactMetrics nodes in the graph.
type ArtifactMetricsMutation struct {
	config
	op                                                  Op
	typ                                                 string
	id                                                  *int64
	source_artifacts_read_size_in_bytes                 *int64
	addsource_artifacts_read_size_in_bytes              *int64
	source_artifacts_read_count                         *int32
	addsource_artifacts_read_count                      *int32
	output_artifacts_seen_size_in_bytes                 *int64
	addoutput_artifacts_seen_size_in_bytes              *int64
	output_artifacts_seen_count                         *int32
	addoutput_artifacts_seen_count                      *int32
	output_artifacts_from_action_cache_size_in_bytes    *int64
	addoutput_artifacts_from_action_cache_size_in_bytes *int64
	output_artifacts_from_action_cache_count            *int32
	addoutput_artifacts_from_action_cache_count         *int32
	top_level_artifacts_size_in_bytes                   *int64
	addtop_level_artifacts_size_in_bytes                *int64
	top_level_artifacts_count                           *int32
	addtop_level_artifacts_count                        *int32
	clearedFields                                       map[string]struct{}
	metrics                                             *int64
	clearedmetrics                                      bool
	done                                                bool
	oldValue                                            func(context.Context) (*ArtifactMetrics, error)
	predicates                                          []predicate.ArtifactMetrics
}

var _ ent.Mutation = (*ArtifactMetricsMutation)(nil)

// artifactmetricsOption allows management of the mutation configuration using functional options.
type artifactmetricsOption func(*ArtifactMetricsMutation)

// newArtifactMetricsMutation creates new mutation for the ArtifactMetrics entity.
func newArtifactMetricsMutation(c config, op Op, opts ...artifactmetricsOption) *ArtifactMetricsMutation {
	m := &ArtifactMetricsMutation{
		config:        c,
		op:            op,
		typ:           TypeArtifactMetrics,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withArtifactMetricsID sets the ID field of the mutation.
func withArtifactMetricsID(id int64) artifactmetricsOption {
	return func(m *ArtifactMetricsMutation) {
		var (
			err   error
			once  sync.Once
			value *ArtifactMetrics
		)
		m.oldValue = func(ctx context.Context) (*ArtifactMetrics, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ArtifactMetrics.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withArtifactMetrics sets the old ArtifactMetrics of the mutation.
func withArtifactMetrics(node *ArtifactMetrics) artifactmetricsOption {
	return func(m *ArtifactMetricsMutation) {
		m.oldValue = func(context.Context) (*ArtifactMetrics, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ArtifactMetricsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ArtifactMetricsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ArtifactMetrics entities.
func (m *ArtifactMetricsMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ArtifactMetricsMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ArtifactMetricsMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ArtifactMetrics.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSourceArtifactsReadSizeInBytes sets the "source_artifacts_read_size_in_bytes" field.
func (m *ArtifactMetricsMutation) SetSourceArtifactsReadSizeInBytes(i int64) {
	m.source_artifacts_read_size_in_bytes = &i
	m.addsource_artifacts_read_size_in_bytes = nil
}

// SourceArtifactsReadSizeInBytes returns the value of the "source_artifacts_read_size_in_bytes" field in the mutation.
func (m *ArtifactMetricsMutation) SourceArtifactsReadSizeInBytes() (r int64, exists bool) {
	v := m.source_artifacts_read_size_in_bytes
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceArtifactsReadSizeInBytes returns the old "source_artifacts_read_size_in_bytes" field's value of the ArtifactMetrics entity.
// If the ArtifactMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMetricsMutation) OldSourceArtifactsReadSizeInBytes(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceArtifactsReadSizeInBytes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceArtifactsReadSizeInBytes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceArtifactsReadSizeInBytes: %w", err)
	}
	return oldValue.SourceArtifactsReadSizeInBytes, nil
}

// AddSourceArtifactsReadSizeInBytes adds i to the "source_artifacts_read_size_in_bytes" field.
func (m *ArtifactMetricsMutation) AddSourceArtifactsReadSizeInBytes(i int64) {
	if m.addsource_artifacts_read_size_in_bytes != nil {
		*m.addsource_artifacts_read_size_in_bytes += i
	} else {
		m.addsource_artifacts_read_size_in_bytes = &i
	}
}

// AddedSourceArtifactsReadSizeInBytes returns the value that was added to the "source_artifacts_read_size_in_bytes" field in this mutation.
func (m *ArtifactMetricsMutation) AddedSourceArtifactsReadSizeInBytes() (r int64, exists bool) {
	v := m.addsource_artifacts_read_size_in_bytes
	if v == nil {
		return
	}
	return *v, true
}

// ClearSourceArtifactsReadSizeInBytes clears the value of the "source_artifacts_read_size_in_bytes" field.
func (m *ArtifactMetricsMutation) ClearSourceArtifactsReadSizeInBytes() {
	m.source_artifacts_read_size_in_bytes = nil
	m.addsource_artifacts_read_size_in_bytes = nil
	m.clearedFields[artifactmetrics.FieldSourceArtifactsReadSizeInBytes] = struct{}{}
}

// SourceArtifactsReadSizeInBytesCleared returns if the "source_artifacts_read_size_in_bytes" field was cleared in this mutation.
func (m *ArtifactMetricsMutation) SourceArtifactsReadSizeInBytesCleared() bool {
	_, ok := m.clearedFields[artifactmetrics.FieldSourceArtifactsReadSizeInBytes]
	return ok
}

// ResetSourceArtifactsReadSizeInBytes resets all changes to the "source_artifacts_read_size_in_bytes" field.
func (m *ArtifactMetricsMutation) ResetSourceArtifactsReadSizeInBytes() {
	m.source_artifacts_read_size_in_bytes = nil
	m.addsource_artifacts_read_size_in_bytes = nil
	delete(m.clearedFields, artifactmetrics.FieldSourceArtifactsReadSizeInBytes)
}

// SetSourceArtifactsReadCount sets the "source_artifacts_read_count" field.
func (m *ArtifactMetricsMutation) SetSourceArtifactsReadCount(i int32) {
	m.source_artifacts_read_count = &i
	m.addsource_artifacts_read_count = nil
}

// SourceArtifactsReadCount returns the value of the "source_artifacts_read_count" field in the mutation.
func (m *ArtifactMetricsMutation) SourceArtifactsReadCount() (r int32, exists bool) {
	v := m.source_artifacts_read_count
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceArtifactsReadCount returns the old "source_artifacts_read_count" field's value of the ArtifactMetrics entity.
// If the ArtifactMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMetricsMutation) OldSourceArtifactsReadCount(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceArtifactsReadCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceArtifactsReadCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceArtifactsReadCount: %w", err)
	}
	return oldValue.SourceArtifactsReadCount, nil
}

// AddSourceArtifactsReadCount adds i to the "source_artifacts_read_count" field.
func (m *ArtifactMetricsMutation) AddSourceArtifactsReadCount(i int32) {
	if m.addsource_artifacts_read_count != nil {
		*m.addsource_artifacts_read_count += i
	} else {
		m.addsource_artifacts_read_count = &i
	}
}

// AddedSourceArtifactsReadCount returns the value that was added to the "source_artifacts_read_count" field in this mutation.
func (m *ArtifactMetricsMutation) AddedSourceArtifactsReadCount() (r int32, exists bool) {
	v := m.addsource_artifacts_read_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearSourceArtifactsReadCount clears the value of the "source_artifacts_read_count" field.
func (m *ArtifactMetricsMutation) ClearSourceArtifactsReadCount() {
	m.source_artifacts_read_count = nil
	m.addsource_artifacts_read_count = nil
	m.clearedFields[artifactmetrics.FieldSourceArtifactsReadCount] = struct{}{}
}

// SourceArtifactsReadCountCleared returns if the "source_artifacts_read_count" field was cleared in this mutation.
func (m *ArtifactMetricsMutation) SourceArtifactsReadCountCleared() bool {
	_, ok := m.clearedFields[artifactmetrics.FieldSourceArtifactsReadCount]
	return ok
}

// ResetSourceArtifactsReadCount resets all changes to the "source_artifacts_read_count" field.
func (m *ArtifactMetricsMutation) ResetSourceArtifactsReadCount() {
	m.source_artifacts_read_count = nil
	m.addsource_artifacts_read_count = nil
	delete(m.clearedFields, artifactmetrics.FieldSourceArtifactsReadCount)
}

// SetOutputArtifactsSeenSizeInBytes sets the "output_artifacts_seen_size_in_bytes" field.
func (m *ArtifactMetricsMutation) SetOutputArtifactsSeenSizeInBytes(i int64) {
	m.output_artifacts_seen_size_in_bytes = &i
	m.addoutput_artifacts_seen_size_in_bytes = nil
}

// OutputArtifactsSeenSizeInBytes returns the value of the "output_artifacts_seen_size_in_bytes" field in the mutation.
func (m *ArtifactMetricsMutation) OutputArtifactsSeenSizeInBytes() (r int64, exists bool) {
	v := m.output_artifacts_seen_size_in_bytes
	if v == nil {
		return
	}
	return *v, true
}

// OldOutputArtifactsSeenSizeInBytes returns the old "output_artifacts_seen_size_in_bytes" field's value of the ArtifactMetrics entity.
// If the ArtifactMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMetricsMutation) OldOutputArtifactsSeenSizeInBytes(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutputArtifactsSeenSizeInBytes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutputArtifactsSeenSizeInBytes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutputArtifactsSeenSizeInBytes: %w", err)
	}
	return oldValue.OutputArtifactsSeenSizeInBytes, nil
}

// AddOutputArtifactsSeenSizeInBytes adds i to the "output_artifacts_seen_size_in_bytes" field.
func (m *ArtifactMetricsMutation) AddOutputArtifactsSeenSizeInBytes(i int64) {
	if m.addoutput_artifacts_seen_size_in_bytes != nil {
		*m.addoutput_artifacts_seen_size_in_bytes += i
	} else {
		m.addoutput_artifacts_seen_size_in_bytes = &i
	}
}

// AddedOutputArtifactsSeenSizeInBytes returns the value that was added to the "output_artifacts_seen_size_in_bytes" field in this mutation.
func (m *ArtifactMetricsMutation) AddedOutputArtifactsSeenSizeInBytes() (r int64, exists bool) {
	v := m.addoutput_artifacts_seen_size_in_bytes
	if v == nil {
		return
	}
	return *v, true
}

// ClearOutputArtifactsSeenSizeInBytes clears the value of the "output_artifacts_seen_size_in_bytes" field.
func (m *ArtifactMetricsMutation) ClearOutputArtifactsSeenSizeInBytes() {
	m.output_artifacts_seen_size_in_bytes = nil
	m.addoutput_artifacts_seen_size_in_bytes = nil
	m.clearedFields[artifactmetrics.FieldOutputArtifactsSeenSizeInBytes] = struct{}{}
}

// OutputArtifactsSeenSizeInBytesCleared returns if the "output_artifacts_seen_size_in_bytes" field was cleared in this mutation.
func (m *ArtifactMetricsMutation) OutputArtifactsSeenSizeInBytesCleared() bool {
	_, ok := m.clearedFields[artifactmetrics.FieldOutputArtifactsSeenSizeInBytes]
	return ok
}

// ResetOutputArtifactsSeenSizeInBytes resets all changes to the "output_artifacts_seen_size_in_bytes" field.
func (m *ArtifactMetricsMutation) ResetOutputArtifactsSeenSizeInBytes() {
	m.output_artifacts_seen_size_in_bytes = nil
	m.addoutput_artifacts_seen_size_in_bytes = nil
	delete(m.clearedFields, artifactmetrics.FieldOutputArtifactsSeenSizeInBytes)
}

// SetOutputArtifactsSeenCount sets the "output_artifacts_seen_count" field.
func (m *ArtifactMetricsMutation) SetOutputArtifactsSeenCount(i int32) {
	m.output_artifacts_seen_count = &i
	m.addoutput_artifacts_seen_count = nil
}

// OutputArtifactsSeenCount returns the value of the "output_artifacts_seen_count" field in the mutation.
func (m *ArtifactMetricsMutation) OutputArtifactsSeenCount() (r int32, exists bool) {
	v := m.output_artifacts_seen_count
	if v == nil {
		return
	}
	return *v, true
}

// OldOutputArtifactsSeenCount returns the old "output_artifacts_seen_count" field's value of the ArtifactMetrics entity.
// If the ArtifactMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMetricsMutation) OldOutputArtifactsSeenCount(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutputArtifactsSeenCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutputArtifactsSeenCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutputArtifactsSeenCount: %w", err)
	}
	return oldValue.OutputArtifactsSeenCount, nil
}

// AddOutputArtifactsSeenCount adds i to the "output_artifacts_seen_count" field.
func (m *ArtifactMetricsMutation) AddOutputArtifactsSeenCount(i int32) {
	if m.addoutput_artifacts_seen_count != nil {
		*m.addoutput_artifacts_seen_count += i
	} else {
		m.addoutput_artifacts_seen_count = &i
	}
}

// AddedOutputArtifactsSeenCount returns the value that was added to the "output_artifacts_seen_count" field in this mutation.
func (m *ArtifactMetricsMutation) AddedOutputArtifactsSeenCount() (r int32, exists bool) {
	v := m.addoutput_artifacts_seen_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearOutputArtifactsSeenCount clears the value of the "output_artifacts_seen_count" field.
func (m *ArtifactMetricsMutation) ClearOutputArtifactsSeenCount() {
	m.output_artifacts_seen_count = nil
	m.addoutput_artifacts_seen_count = nil
	m.clearedFields[artifactmetrics.FieldOutputArtifactsSeenCount] = struct{}{}
}

// OutputArtifactsSeenCountCleared returns if the "output_artifacts_seen_count" field was cleared in this mutation.
func (m *ArtifactMetricsMutation) OutputArtifactsSeenCountCleared() bool {
	_, ok := m.clearedFields[artifactmetrics.FieldOutputArtifactsSeenCount]
	return ok
}

// ResetOutputArtifactsSeenCount resets all changes to the "output_artifacts_seen_count" field.
func (m *ArtifactMetricsMutation) ResetOutputArtifactsSeenCount() {
	m.output_artifacts_seen_count = nil
	m.addoutput_artifacts_seen_count = nil
	delete(m.clearedFields, artifactmetrics.FieldOutputArtifactsSeenCount)
}

// SetOutputArtifactsFromActionCacheSizeInBytes sets the "output_artifacts_from_action_cache_size_in_bytes" field.
func (m *ArtifactMetricsMutation) SetOutputArtifactsFromActionCacheSizeInBytes(i int64) {
	m.output_artifacts_from_action_cache_size_in_bytes = &i
	m.addoutput_artifacts_from_action_cache_size_in_bytes = nil
}

// OutputArtifactsFromActionCacheSizeInBytes returns the value of the "output_artifacts_from_action_cache_size_in_bytes" field in the mutation.
func (m *ArtifactMetricsMutation) OutputArtifactsFromActionCacheSizeInBytes() (r int64, exists bool) {
	v := m.output_artifacts_from_action_cache_size_in_bytes
	if v == nil {
		return
	}
	return *v, true
}

// OldOutputArtifactsFromActionCacheSizeInBytes returns the old "output_artifacts_from_action_cache_size_in_bytes" field's value of the ArtifactMetrics entity.
// If the ArtifactMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMetricsMutation) OldOutputArtifactsFromActionCacheSizeInBytes(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutputArtifactsFromActionCacheSizeInBytes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutputArtifactsFromActionCacheSizeInBytes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutputArtifactsFromActionCacheSizeInBytes: %w", err)
	}
	return oldValue.OutputArtifactsFromActionCacheSizeInBytes, nil
}

// AddOutputArtifactsFromActionCacheSizeInBytes adds i to the "output_artifacts_from_action_cache_size_in_bytes" field.
func (m *ArtifactMetricsMutation) AddOutputArtifactsFromActionCacheSizeInBytes(i int64) {
	if m.addoutput_artifacts_from_action_cache_size_in_bytes != nil {
		*m.addoutput_artifacts_from_action_cache_size_in_bytes += i
	} else {
		m.addoutput_artifacts_from_action_cache_size_in_bytes = &i
	}
}

// AddedOutputArtifactsFromActionCacheSizeInBytes returns the value that was added to the "output_artifacts_from_action_cache_size_in_bytes" field in this mutation.
func (m *ArtifactMetricsMutation) AddedOutputArtifactsFromActionCacheSizeInBytes() (r int64, exists bool) {
	v := m.addoutput_artifacts_from_action_cache_size_in_bytes
	if v == nil {
		return
	}
	return *v, true
}

// ClearOutputArtifactsFromActionCacheSizeInBytes clears the value of the "output_artifacts_from_action_cache_size_in_bytes" field.
func (m *ArtifactMetricsMutation) ClearOutputArtifactsFromActionCacheSizeInBytes() {
	m.output_artifacts_from_action_cache_size_in_bytes = nil
	m.addoutput_artifacts_from_action_cache_size_in_bytes = nil
	m.clearedFields[artifactmetrics.FieldOutputArtifactsFromActionCacheSizeInBytes] = struct{}{}
}

// OutputArtifactsFromActionCacheSizeInBytesCleared returns if the "output_artifacts_from_action_cache_size_in_bytes" field was cleared in this mutation.
func (m *ArtifactMetricsMutation) OutputArtifactsFromActionCacheSizeInBytesCleared() bool {
	_, ok := m.clearedFields[artifactmetrics.FieldOutputArtifactsFromActionCacheSizeInBytes]
	return ok
}

// ResetOutputArtifactsFromActionCacheSizeInBytes resets all changes to the "output_artifacts_from_action_cache_size_in_bytes" field.
func (m *ArtifactMetricsMutation) ResetOutputArtifactsFromActionCacheSizeInBytes() {
	m.output_artifacts_from_action_cache_size_in_bytes = nil
	m.addoutput_artifacts_from_action_cache_size_in_bytes = nil
	delete(m.clearedFields, artifactmetrics.FieldOutputArtifactsFromActionCacheSizeInBytes)
}

// SetOutputArtifactsFromActionCacheCount sets the "output_artifacts_from_action_cache_count" field.
func (m *ArtifactMetricsMutation) SetOutputArtifactsFromActionCacheCount(i int32) {
	m.output_artifacts_from_action_cache_count = &i
	m.addoutput_artifacts_from_action_cache_count = nil
}

// OutputArtifactsFromActionCacheCount returns the value of the "output_artifacts_from_action_cache_count" field in the mutation.
func (m *ArtifactMetricsMutation) OutputArtifactsFromActionCacheCount() (r int32, exists bool) {
	v := m.output_artifacts_from_action_cache_count
	if v == nil {
		return
	}
	return *v, true
}

// OldOutputArtifactsFromActionCacheCount returns the old "output_artifacts_from_action_cache_count" field's value of the ArtifactMetrics entity.
// If the ArtifactMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMetricsMutation) OldOutputArtifactsFromActionCacheCount(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutputArtifactsFromActionCacheCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutputArtifactsFromActionCacheCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutputArtifactsFromActionCacheCount: %w", err)
	}
	return oldValue.OutputArtifactsFromActionCacheCount, nil
}

// AddOutputArtifactsFromActionCacheCount adds i to the "output_artifacts_from_action_cache_count" field.
func (m *ArtifactMetricsMutation) AddOutputArtifactsFromActionCacheCount(i int32) {
	if m.addoutput_artifacts_from_action_cache_count != nil {
		*m.addoutput_artifacts_from_action_cache_count += i
	} else {
		m.addoutput_artifacts_from_action_cache_count = &i
	}
}

// AddedOutputArtifactsFromActionCacheCount returns the value that was added to the "output_artifacts_from_action_cache_count" field in this mutation.
func (m *ArtifactMetricsMutation) AddedOutputArtifactsFromActionCacheCount() (r int32, exists bool) {
	v := m.addoutput_artifacts_from_action_cache_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearOutputArtifactsFromActionCacheCount clears the value of the "output_artifacts_from_action_cache_count" field.
func (m *ArtifactMetricsMutation) ClearOutputArtifactsFromActionCacheCount() {
	m.output_artifacts_from_action_cache_count = nil
	m.addoutput_artifacts_from_action_cache_count = nil
	m.clearedFields[artifactmetrics.FieldOutputArtifactsFromActionCacheCount] = struct{}{}
}

// OutputArtifactsFromActionCacheCountCleared returns if the "output_artifacts_from_action_cache_count" field was cleared in this mutation.
func (m *ArtifactMetricsMutation) OutputArtifactsFromActionCacheCountCleared() bool {
	_, ok := m.clearedFields[artifactmetrics.FieldOutputArtifactsFromActionCacheCount]
	return ok
}

// ResetOutputArtifactsFromActionCacheCount resets all changes to the "output_artifacts_from_action_cache_count" field.
func (m *ArtifactMetricsMutation) ResetOutputArtifactsFromActionCacheCount() {
	m.output_artifacts_from_action_cache_count = nil
	m.addoutput_artifacts_from_action_cache_count = nil
	delete(m.clearedFields, artifactmetrics.FieldOutputArtifactsFromActionCacheCount)
}

// SetTopLevelArtifactsSizeInBytes sets the "top_level_artifacts_size_in_bytes" field.
func (m *ArtifactMetricsMutation) SetTopLevelArtifactsSizeInBytes(i int64) {
	m.top_level_artifacts_size_in_bytes = &i
	m.addtop_level_artifacts_size_in_bytes = nil
}

// TopLevelArtifactsSizeInBytes returns the value of the "top_level_artifacts_size_in_bytes" field in the mutation.
func (m *ArtifactMetricsMutation) TopLevelArtifactsSizeInBytes() (r int64, exists bool) {
	v := m.top_level_artifacts_size_in_bytes
	if v == nil {
		return
	}
	return *v, true
}

// OldTopLevelArtifactsSizeInBytes returns the old "top_level_artifacts_size_in_bytes" field's value of the ArtifactMetrics entity.
// If the ArtifactMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMetricsMutation) OldTopLevelArtifactsSizeInBytes(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTopLevelArtifactsSizeInBytes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTopLevelArtifactsSizeInBytes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTopLevelArtifactsSizeInBytes: %w", err)
	}
	return oldValue.TopLevelArtifactsSizeInBytes, nil
}

// AddTopLevelArtifactsSizeInBytes adds i to the "top_level_artifacts_size_in_bytes" field.
func (m *ArtifactMetricsMutation) AddTopLevelArtifactsSizeInBytes(i int64) {
	if m.addtop_level_artifacts_size_in_bytes != nil {
		*m.addtop_level_artifacts_size_in_bytes += i
	} else {
		m.addtop_level_artifacts_size_in_bytes = &i
	}
}

// AddedTopLevelArtifactsSizeInBytes returns the value that was added to the "top_level_artifacts_size_in_bytes" field in this mutation.
func (m *ArtifactMetricsMutation) AddedTopLevelArtifactsSizeInBytes() (r int64, exists bool) {
	v := m.addtop_level_artifacts_size_in_bytes
	if v == nil {
		return
	}
	return *v, true
}

// ClearTopLevelArtifactsSizeInBytes clears the value of the "top_level_artifacts_size_in_bytes" field.
func (m *ArtifactMetricsMutation) ClearTopLevelArtifactsSizeInBytes() {
	m.top_level_artifacts_size_in_bytes = nil
	m.addtop_level_artifacts_size_in_bytes = nil
	m.clearedFields[artifactmetrics.FieldTopLevelArtifactsSizeInBytes] = struct{}{}
}

// TopLevelArtifactsSizeInBytesCleared returns if the "top_level_artifacts_size_in_bytes" field was cleared in this mutation.
func (m *ArtifactMetricsMutation) TopLevelArtifactsSizeInBytesCleared() bool {
	_, ok := m.clearedFields[artifactmetrics.FieldTopLevelArtifactsSizeInBytes]
	return ok
}

// ResetTopLevelArtifactsSizeInBytes resets all changes to the "top_level_artifacts_size_in_bytes" field.
func (m *ArtifactMetricsMutation) ResetTopLevelArtifactsSizeInBytes() {
	m.top_level_artifacts_size_in_bytes = nil
	m.addtop_level_artifacts_size_in_bytes = nil
	delete(m.clearedFields, artifactmetrics.FieldTopLevelArtifactsSizeInBytes)
}

// SetTopLevelArtifactsCount sets the "top_level_artifacts_count" field.
func (m *ArtifactMetricsMutation) SetTopLevelArtifactsCount(i int32) {
	m.top_level_artifacts_count = &i
	m.addtop_level_artifacts_count = nil
}

// TopLevelArtifactsCount returns the value of the "top_level_artifacts_count" field in the mutation.
func (m *ArtifactMetricsMutation) TopLevelArtifactsCount() (r int32, exists bool) {
	v := m.top_level_artifacts_count
	if v == nil {
		return
	}
	return *v, true
}

// OldTopLevelArtifactsCount returns the old "top_level_artifacts_count" field's value of the ArtifactMetrics entity.
// If the ArtifactMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMetricsMutation) OldTopLevelArtifactsCount(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTopLevelArtifactsCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTopLevelArtifactsCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTopLevelArtifactsCount: %w", err)
	}
	return oldValue.TopLevelArtifactsCount, nil
}

// AddTopLevelArtifactsCount adds i to the "top_level_artifacts_count" field.
func (m *ArtifactMetricsMutation) AddTopLevelArtifactsCount(i int32) {
	if m.addtop_level_artifacts_count != nil {
		*m.addtop_level_artifacts_count += i
	} else {
		m.addtop_level_artifacts_count = &i
	}
}

// AddedTopLevelArtifactsCount returns the value that was added to the "top_level_artifacts_count" field in this mutation.
func (m *ArtifactMetricsMutation) AddedTopLevelArtifactsCount() (r int32, exists bool) {
	v := m.addtop_level_artifacts_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearTopLevelArtifactsCount clears the value of the "top_level_artifacts_count" field.
func (m *ArtifactMetricsMutation) ClearTopLevelArtifactsCount() {
	m.top_level_artifacts_count = nil
	m.addtop_level_artifacts_count = nil
	m.clearedFields[artifactmetrics.FieldTopLevelArtifactsCount] = struct{}{}
}

// TopLevelArtifactsCountCleared returns if the "top_level_artifacts_count" field was cleared in this mutation.
func (m *ArtifactMetricsMutation) TopLevelArtifactsCountCleared() bool {
	_, ok := m.clearedFields[artifactmetrics.FieldTopLevelArtifactsCount]
	return ok
}

// ResetTopLevelArtifactsCount resets all changes to the "top_level_artifacts_count" field.
func (m *ArtifactMetricsMutation) ResetTopLevelArtifactsCount() {
	m.top_level_artifacts_count = nil
	m.addtop_level_artifacts_count = nil
	delete(m.clearedFields, artifactmetrics.FieldTopLevelArtifactsCount)
}

// SetMetricsID sets the "metrics" edge to the Metrics entity by id.
func (m *ArtifactMetricsMutation) SetMetricsID(id int64) {
	m.metrics = &id
}

// ClearMetrics clears the "metrics" edge to the Metrics entity.
func (m *ArtifactMetricsMutation) ClearMetrics() {
	m.clearedmetrics = true
}

// MetricsCleared reports if the "metrics" edge to the Metrics entity was cleared.
func (m *ArtifactMetricsMutation) MetricsCleared() bool {
	return m.clearedmetrics
}

// MetricsID returns the "metrics" edge ID in the mutation.
func (m *ArtifactMetricsMutation) MetricsID() (id int64, exists bool) {
	if m.metrics != nil {
		return *m.metrics, true
	}
	return
}

// MetricsIDs returns the "metrics" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MetricsID instead. It exists only for internal usage by the builders.
func (m *ArtifactMetricsMutation) MetricsIDs() (ids []int64) {
	if id := m.metrics; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMetrics resets all changes to the "metrics" edge.
func (m *ArtifactMetricsMutation) ResetMetrics() {
	m.metrics = nil
	m.clearedmetrics = false
}

// Where appends a list predicates to the ArtifactMetricsMutation builder.
func (m *ArtifactMetricsMutation) Where(ps ...predicate.ArtifactMetrics) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ArtifactMetricsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ArtifactMetricsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ArtifactMetrics, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ArtifactMetricsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ArtifactMetricsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ArtifactMetrics).
func (m *ArtifactMetricsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ArtifactMetricsMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.source_artifacts_read_size_in_bytes != nil {
		fields = append(fields, artifactmetrics.FieldSourceArtifactsReadSizeInBytes)
	}
	if m.source_artifacts_read_count != nil {
		fields = append(fields, artifactmetrics.FieldSourceArtifactsReadCount)
	}
	if m.output_artifacts_seen_size_in_bytes != nil {
		fields = append(fields, artifactmetrics.FieldOutputArtifactsSeenSizeInBytes)
	}
	if m.output_artifacts_seen_count != nil {
		fields = append(fields, artifactmetrics.FieldOutputArtifactsSeenCount)
	}
	if m.output_artifacts_from_action_cache_size_in_bytes != nil {
		fields = append(fields, artifactmetrics.FieldOutputArtifactsFromActionCacheSizeInBytes)
	}
	if m.output_artifacts_from_action_cache_count != nil {
		fields = append(fields, artifactmetrics.FieldOutputArtifactsFromActionCacheCount)
	}
	if m.top_level_artifacts_size_in_bytes != nil {
		fields = append(fields, artifactmetrics.FieldTopLevelArtifactsSizeInBytes)
	}
	if m.top_level_artifacts_count != nil {
		fields = append(fields, artifactmetrics.FieldTopLevelArtifactsCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ArtifactMetricsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case artifactmetrics.FieldSourceArtifactsReadSizeInBytes:
		return m.SourceArtifactsReadSizeInBytes()
	case artifactmetrics.FieldSourceArtifactsReadCount:
		return m.SourceArtifactsReadCount()
	case artifactmetrics.FieldOutputArtifactsSeenSizeInBytes:
		return m.OutputArtifactsSeenSizeInBytes()
	case artifactmetrics.FieldOutputArtifactsSeenCount:
		return m.OutputArtifactsSeenCount()
	case artifactmetrics.FieldOutputArtifactsFromActionCacheSizeInBytes:
		return m.OutputArtifactsFromActionCacheSizeInBytes()
	case artifactmetrics.FieldOutputArtifactsFromActionCacheCount:
		return m.OutputArtifactsFromActionCacheCount()
	case artifactmetrics.FieldTopLevelArtifactsSizeInBytes:
		return m.TopLevelArtifactsSizeInBytes()
	case artifactmetrics.FieldTopLevelArtifactsCount:
		return m.TopLevelArtifactsCount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ArtifactMetricsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case artifactmetrics.FieldSourceArtifactsReadSizeInBytes:
		return m.OldSourceArtifactsReadSizeInBytes(ctx)
	case artifactmetrics.FieldSourceArtifactsReadCount:
		return m.OldSourceArtifactsReadCount(ctx)
	case artifactmetrics.FieldOutputArtifactsSeenSizeInBytes:
		return m.OldOutputArtifactsSeenSizeInBytes(ctx)
	case artifactmetrics.FieldOutputArtifactsSeenCount:
		return m.OldOutputArtifactsSeenCount(ctx)
	case artifactmetrics.FieldOutputArtifactsFromActionCacheSizeInBytes:
		return m.OldOutputArtifactsFromActionCacheSizeInBytes(ctx)
	case artifactmetrics.FieldOutputArtifactsFromActionCacheCount:
		return m.OldOutputArtifactsFromActionCacheCount(ctx)
	case artifactmetrics.FieldTopLevelArtifactsSizeInBytes:
		return m.OldTopLevelArtifactsSizeInBytes(ctx)
	case artifactmetrics.FieldTopLevelArtifactsCount:
		return m.OldTopLevelArtifactsCount(ctx)
	}
	return nil, fmt.Errorf("unknown ArtifactMetrics field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArtifactMetricsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case artifactmetrics.FieldSourceArtifactsReadSizeInBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceArtifactsReadSizeInBytes(v)
		return nil
	case artifactmetrics.FieldSourceArtifactsReadCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceArtifactsReadCount(v)
		return nil
	case artifactmetrics.FieldOutputArtifactsSeenSizeInBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutputArtifactsSeenSizeInBytes(v)
		return nil
	case artifactmetrics.FieldOutputArtifactsSeenCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutputArtifactsSeenCount(v)
		return nil
	case artifactmetrics.FieldOutputArtifactsFromActionCacheSizeInBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutputArtifactsFromActionCacheSizeInBytes(v)
		return nil
	case artifactmetrics.FieldOutputArtifactsFromActionCacheCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutputArtifactsFromActionCacheCount(v)
		return nil
	case artifactmetrics.FieldTopLevelArtifactsSizeInBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopLevelArtifactsSizeInBytes(v)
		return nil
	case artifactmetrics.FieldTopLevelArtifactsCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopLevelArtifactsCount(v)
		return nil
	}
	return fmt.Errorf("unknown ArtifactMetrics field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ArtifactMetricsMutation) AddedFields() []string {
	var fields []string
	if m.addsource_artifacts_read_size_in_bytes != nil {
		fields = append(fields, artifactmetrics.FieldSourceArtifactsReadSizeInBytes)
	}
	if m.addsource_artifacts_read_count != nil {
		fields = append(fields, artifactmetrics.FieldSourceArtifactsReadCount)
	}
	if m.addoutput_artifacts_seen_size_in_bytes != nil {
		fields = append(fields, artifactmetrics.FieldOutputArtifactsSeenSizeInBytes)
	}
	if m.addoutput_artifacts_seen_count != nil {
		fields = append(fields, artifactmetrics.FieldOutputArtifactsSeenCount)
	}
	if m.addoutput_artifacts_from_action_cache_size_in_bytes != nil {
		fields = append(fields, artifactmetrics.FieldOutputArtifactsFromActionCacheSizeInBytes)
	}
	if m.addoutput_artifacts_from_action_cache_count != nil {
		fields = append(fields, artifactmetrics.FieldOutputArtifactsFromActionCacheCount)
	}
	if m.addtop_level_artifacts_size_in_bytes != nil {
		fields = append(fields, artifactmetrics.FieldTopLevelArtifactsSizeInBytes)
	}
	if m.addtop_level_artifacts_count != nil {
		fields = append(fields, artifactmetrics.FieldTopLevelArtifactsCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ArtifactMetricsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case artifactmetrics.FieldSourceArtifactsReadSizeInBytes:
		return m.AddedSourceArtifactsReadSizeInBytes()
	case artifactmetrics.FieldSourceArtifactsReadCount:
		return m.AddedSourceArtifactsReadCount()
	case artifactmetrics.FieldOutputArtifactsSeenSizeInBytes:
		return m.AddedOutputArtifactsSeenSizeInBytes()
	case artifactmetrics.FieldOutputArtifactsSeenCount:
		return m.AddedOutputArtifactsSeenCount()
	case artifactmetrics.FieldOutputArtifactsFromActionCacheSizeInBytes:
		return m.AddedOutputArtifactsFromActionCacheSizeInBytes()
	case artifactmetrics.FieldOutputArtifactsFromActionCacheCount:
		return m.AddedOutputArtifactsFromActionCacheCount()
	case artifactmetrics.FieldTopLevelArtifactsSizeInBytes:
		return m.AddedTopLevelArtifactsSizeInBytes()
	case artifactmetrics.FieldTopLevelArtifactsCount:
		return m.AddedTopLevelArtifactsCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArtifactMetricsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case artifactmetrics.FieldSourceArtifactsReadSizeInBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSourceArtifactsReadSizeInBytes(v)
		return nil
	case artifactmetrics.FieldSourceArtifactsReadCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSourceArtifactsReadCount(v)
		return nil
	case artifactmetrics.FieldOutputArtifactsSeenSizeInBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOutputArtifactsSeenSizeInBytes(v)
		return nil
	case artifactmetrics.FieldOutputArtifactsSeenCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOutputArtifactsSeenCount(v)
		return nil
	case artifactmetrics.FieldOutputArtifactsFromActionCacheSizeInBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOutputArtifactsFromActionCacheSizeInBytes(v)
		return nil
	case artifactmetrics.FieldOutputArtifactsFromActionCacheCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOutputArtifactsFromActionCacheCount(v)
		return nil
	case artifactmetrics.FieldTopLevelArtifactsSizeInBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTopLevelArtifactsSizeInBytes(v)
		return nil
	case artifactmetrics.FieldTopLevelArtifactsCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTopLevelArtifactsCount(v)
		return nil
	}
	return fmt.Errorf("unknown ArtifactMetrics numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ArtifactMetricsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(artifactmetrics.FieldSourceArtifactsReadSizeInBytes) {
		fields = append(fields, artifactmetrics.FieldSourceArtifactsReadSizeInBytes)
	}
	if m.FieldCleared(artifactmetrics.FieldSourceArtifactsReadCount) {
		fields = append(fields, artifactmetrics.FieldSourceArtifactsReadCount)
	}
	if m.FieldCleared(artifactmetrics.FieldOutputArtifactsSeenSizeInBytes) {
		fields = append(fields, artifactmetrics.FieldOutputArtifactsSeenSizeInBytes)
	}
	if m.FieldCleared(artifactmetrics.FieldOutputArtifactsSeenCount) {
		fields = append(fields, artifactmetrics.FieldOutputArtifactsSeenCount)
	}
	if m.FieldCleared(artifactmetrics.FieldOutputArtifactsFromActionCacheSizeInBytes) {
		fields = append(fields, artifactmetrics.FieldOutputArtifactsFromActionCacheSizeInBytes)
	}
	if m.FieldCleared(artifactmetrics.FieldOutputArtifactsFromActionCacheCount) {
		fields = append(fields, artifactmetrics.FieldOutputArtifactsFromActionCacheCount)
	}
	if m.FieldCleared(artifactmetrics.FieldTopLevelArtifactsSizeInBytes) {
		fields = append(fields, artifactmetrics.FieldTopLevelArtifactsSizeInBytes)
	}
	if m.FieldCleared(artifactmetrics.FieldTopLevelArtifactsCount) {
		fields = append(fields, artifactmetrics.FieldTopLevelArtifactsCount)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ArtifactMetricsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ArtifactMetricsMutation) ClearField(name string) error {
	switch name {
	case artifactmetrics.FieldSourceArtifactsReadSizeInBytes:
		m.ClearSourceArtifactsReadSizeInBytes()
		return nil
	case artifactmetrics.FieldSourceArtifactsReadCount:
		m.ClearSourceArtifactsReadCount()
		return nil
	case artifactmetrics.FieldOutputArtifactsSeenSizeInBytes:
		m.ClearOutputArtifactsSeenSizeInBytes()
		return nil
	case artifactmetrics.FieldOutputArtifactsSeenCount:
		m.ClearOutputArtifactsSeenCount()
		return nil
	case artifactmetrics.FieldOutputArtifactsFromActionCacheSizeInBytes:
		m.ClearOutputArtifactsFromActionCacheSizeInBytes()
		return nil
	case artifactmetrics.FieldOutputArtifactsFromActionCacheCount:
		m.ClearOutputArtifactsFromActionCacheCount()
		return nil
	case artifactmetrics.FieldTopLevelArtifactsSizeInBytes:
		m.ClearTopLevelArtifactsSizeInBytes()
		return nil
	case artifactmetrics.FieldTopLevelArtifactsCount:
		m.ClearTopLevelArtifactsCount()
		return nil
	}
	return fmt.Errorf("unknown ArtifactMetrics nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ArtifactMetricsMutation) ResetField(name string) error {
	switch name {
	case artifactmetrics.FieldSourceArtifactsReadSizeInBytes:
		m.ResetSourceArtifactsReadSizeInBytes()
		return nil
	case artifactmetrics.FieldSourceArtifactsReadCount:
		m.ResetSourceArtifactsReadCount()
		return nil
	case artifactmetrics.FieldOutputArtifactsSeenSizeInBytes:
		m.ResetOutputArtifactsSeenSizeInBytes()
		return nil
	case artifactmetrics.FieldOutputArtifactsSeenCount:
		m.ResetOutputArtifactsSeenCount()
		return nil
	case artifactmetrics.FieldOutputArtifactsFromActionCacheSizeInBytes:
		m.ResetOutputArtifactsFromActionCacheSizeInBytes()
		return nil
	case artifactmetrics.FieldOutputArtifactsFromActionCacheCount:
		m.ResetOutputArtifactsFromActionCacheCount()
		return nil
	case artifactmetrics.FieldTopLevelArtifactsSizeInBytes:
		m.ResetTopLevelArtifactsSizeInBytes()
		return nil
	case artifactmetrics.FieldTopLevelArtifactsCount:
		m.ResetTopLevelArtifactsCount()
		return nil
	}
	return fmt.Errorf("unknown ArtifactMetrics field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ArtifactMetricsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.metrics != nil {
		edges = append(edges, artifactmetrics.EdgeMetrics)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ArtifactMetricsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case artifactmetrics.EdgeMetrics:
		if id := m.metrics; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ArtifactMetricsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ArtifactMetricsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ArtifactMetricsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmetrics {
		edges = append(edges, artifactmetrics.EdgeMetrics)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ArtifactMetricsMutation) EdgeCleared(name string) bool {
	switch name {
	case artifactmetrics.EdgeMetrics:
		return m.clearedmetrics
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ArtifactMetricsMutation) ClearEdge(name string) error {
	switch name {
	case artifactmetrics.EdgeMetrics:
		m.ClearMetrics()
		return nil
	}
	return fmt.Errorf("unknown ArtifactMetrics unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ArtifactMetricsMutation) ResetEdge(name string) error {
	switch name {
	case artifactmetrics.EdgeMetrics:
		m.ResetMetrics()
		return nil
	}
	return fmt.Errorf("unknown ArtifactMetrics edge %s", name)
}

// AuthenticatedUserMutation represents an operation that mutates the AuthenticatedUser nodes in the graph.
type AuthenticatedUserMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int64
	user_uuid                *uuid.UUID
	external_id              *string
	display_name             *string
	user_info                *map[string]interface{}
	clearedFields            map[string]struct{}
	bazel_invocations        map[int64]struct{}
	removedbazel_invocations map[int64]struct{}
	clearedbazel_invocations bool
	done                     bool
	oldValue                 func(context.Context) (*AuthenticatedUser, error)
	predicates               []predicate.AuthenticatedUser
}

var _ ent.Mutation = (*AuthenticatedUserMutation)(nil)

// authenticateduserOption allows management of the mutation configuration using functional options.
type authenticateduserOption func(*AuthenticatedUserMutation)

// newAuthenticatedUserMutation creates new mutation for the AuthenticatedUser entity.
func newAuthenticatedUserMutation(c config, op Op, opts ...authenticateduserOption) *AuthenticatedUserMutation {
	m := &AuthenticatedUserMutation{
		config:        c,
		op:            op,
		typ:           TypeAuthenticatedUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthenticatedUserID sets the ID field of the mutation.
func withAuthenticatedUserID(id int64) authenticateduserOption {
	return func(m *AuthenticatedUserMutation) {
		var (
			err   error
			once  sync.Once
			value *AuthenticatedUser
		)
		m.oldValue = func(ctx context.Context) (*AuthenticatedUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuthenticatedUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuthenticatedUser sets the old AuthenticatedUser of the mutation.
func withAuthenticatedUser(node *AuthenticatedUser) authenticateduserOption {
	return func(m *AuthenticatedUserMutation) {
		m.oldValue = func(context.Context) (*AuthenticatedUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthenticatedUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthenticatedUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AuthenticatedUser entities.
func (m *AuthenticatedUserMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuthenticatedUserMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuthenticatedUserMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuthenticatedUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserUUID sets the "user_uuid" field.
func (m *AuthenticatedUserMutation) SetUserUUID(u uuid.UUID) {
	m.user_uuid = &u
}

// UserUUID returns the value of the "user_uuid" field in the mutation.
func (m *AuthenticatedUserMutation) UserUUID() (r uuid.UUID, exists bool) {
	v := m.user_uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUserUUID returns the old "user_uuid" field's value of the AuthenticatedUser entity.
// If the AuthenticatedUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthenticatedUserMutation) OldUserUUID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserUUID: %w", err)
	}
	return oldValue.UserUUID, nil
}

// ResetUserUUID resets all changes to the "user_uuid" field.
func (m *AuthenticatedUserMutation) ResetUserUUID() {
	m.user_uuid = nil
}

// SetExternalID sets the "external_id" field.
func (m *AuthenticatedUserMutation) SetExternalID(s string) {
	m.external_id = &s
}

// ExternalID returns the value of the "external_id" field in the mutation.
func (m *AuthenticatedUserMutation) ExternalID() (r string, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old "external_id" field's value of the AuthenticatedUser entity.
// If the AuthenticatedUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthenticatedUserMutation) OldExternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ResetExternalID resets all changes to the "external_id" field.
func (m *AuthenticatedUserMutation) ResetExternalID() {
	m.external_id = nil
}

// SetDisplayName sets the "display_name" field.
func (m *AuthenticatedUserMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *AuthenticatedUserMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the AuthenticatedUser entity.
// If the AuthenticatedUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthenticatedUserMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *AuthenticatedUserMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[authenticateduser.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *AuthenticatedUserMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[authenticateduser.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *AuthenticatedUserMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, authenticateduser.FieldDisplayName)
}

// SetUserInfo sets the "user_info" field.
func (m *AuthenticatedUserMutation) SetUserInfo(value map[string]interface{}) {
	m.user_info = &value
}

// UserInfo returns the value of the "user_info" field in the mutation.
func (m *AuthenticatedUserMutation) UserInfo() (r map[string]interface{}, exists bool) {
	v := m.user_info
	if v == nil {
		return
	}
	return *v, true
}

// OldUserInfo returns the old "user_info" field's value of the AuthenticatedUser entity.
// If the AuthenticatedUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthenticatedUserMutation) OldUserInfo(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserInfo: %w", err)
	}
	return oldValue.UserInfo, nil
}

// ClearUserInfo clears the value of the "user_info" field.
func (m *AuthenticatedUserMutation) ClearUserInfo() {
	m.user_info = nil
	m.clearedFields[authenticateduser.FieldUserInfo] = struct{}{}
}

// UserInfoCleared returns if the "user_info" field was cleared in this mutation.
func (m *AuthenticatedUserMutation) UserInfoCleared() bool {
	_, ok := m.clearedFields[authenticateduser.FieldUserInfo]
	return ok
}

// ResetUserInfo resets all changes to the "user_info" field.
func (m *AuthenticatedUserMutation) ResetUserInfo() {
	m.user_info = nil
	delete(m.clearedFields, authenticateduser.FieldUserInfo)
}

// AddBazelInvocationIDs adds the "bazel_invocations" edge to the BazelInvocation entity by ids.
func (m *AuthenticatedUserMutation) AddBazelInvocationIDs(ids ...int64) {
	if m.bazel_invocations == nil {
		m.bazel_invocations = make(map[int64]struct{})
	}
	for i := range ids {
		m.bazel_invocations[ids[i]] = struct{}{}
	}
}

// ClearBazelInvocations clears the "bazel_invocations" edge to the BazelInvocation entity.
func (m *AuthenticatedUserMutation) ClearBazelInvocations() {
	m.clearedbazel_invocations = true
}

// BazelInvocationsCleared reports if the "bazel_invocations" edge to the BazelInvocation entity was cleared.
func (m *AuthenticatedUserMutation) BazelInvocationsCleared() bool {
	return m.clearedbazel_invocations
}

// RemoveBazelInvocationIDs removes the "bazel_invocations" edge to the BazelInvocation entity by IDs.
func (m *AuthenticatedUserMutation) RemoveBazelInvocationIDs(ids ...int64) {
	if m.removedbazel_invocations == nil {
		m.removedbazel_invocations = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.bazel_invocations, ids[i])
		m.removedbazel_invocations[ids[i]] = struct{}{}
	}
}

// RemovedBazelInvocations returns the removed IDs of the "bazel_invocations" edge to the BazelInvocation entity.
func (m *AuthenticatedUserMutation) RemovedBazelInvocationsIDs() (ids []int64) {
	for id := range m.removedbazel_invocations {
		ids = append(ids, id)
	}
	return
}

// BazelInvocationsIDs returns the "bazel_invocations" edge IDs in the mutation.
func (m *AuthenticatedUserMutation) BazelInvocationsIDs() (ids []int64) {
	for id := range m.bazel_invocations {
		ids = append(ids, id)
	}
	return
}

// ResetBazelInvocations resets all changes to the "bazel_invocations" edge.
func (m *AuthenticatedUserMutation) ResetBazelInvocations() {
	m.bazel_invocations = nil
	m.clearedbazel_invocations = false
	m.removedbazel_invocations = nil
}

// Where appends a list predicates to the AuthenticatedUserMutation builder.
func (m *AuthenticatedUserMutation) Where(ps ...predicate.AuthenticatedUser) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuthenticatedUserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuthenticatedUserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AuthenticatedUser, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuthenticatedUserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuthenticatedUserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AuthenticatedUser).
func (m *AuthenticatedUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuthenticatedUserMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.user_uuid != nil {
		fields = append(fields, authenticateduser.FieldUserUUID)
	}
	if m.external_id != nil {
		fields = append(fields, authenticateduser.FieldExternalID)
	}
	if m.display_name != nil {
		fields = append(fields, authenticateduser.FieldDisplayName)
	}
	if m.user_info != nil {
		fields = append(fields, authenticateduser.FieldUserInfo)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuthenticatedUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case authenticateduser.FieldUserUUID:
		return m.UserUUID()
	case authenticateduser.FieldExternalID:
		return m.ExternalID()
	case authenticateduser.FieldDisplayName:
		return m.DisplayName()
	case authenticateduser.FieldUserInfo:
		return m.UserInfo()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuthenticatedUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case authenticateduser.FieldUserUUID:
		return m.OldUserUUID(ctx)
	case authenticateduser.FieldExternalID:
		return m.OldExternalID(ctx)
	case authenticateduser.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case authenticateduser.FieldUserInfo:
		return m.OldUserInfo(ctx)
	}
	return nil, fmt.Errorf("unknown AuthenticatedUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthenticatedUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case authenticateduser.FieldUserUUID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserUUID(v)
		return nil
	case authenticateduser.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	case authenticateduser.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case authenticateduser.FieldUserInfo:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserInfo(v)
		return nil
	}
	return fmt.Errorf("unknown AuthenticatedUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuthenticatedUserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuthenticatedUserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthenticatedUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AuthenticatedUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuthenticatedUserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(authenticateduser.FieldDisplayName) {
		fields = append(fields, authenticateduser.FieldDisplayName)
	}
	if m.FieldCleared(authenticateduser.FieldUserInfo) {
		fields = append(fields, authenticateduser.FieldUserInfo)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuthenticatedUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthenticatedUserMutation) ClearField(name string) error {
	switch name {
	case authenticateduser.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case authenticateduser.FieldUserInfo:
		m.ClearUserInfo()
		return nil
	}
	return fmt.Errorf("unknown AuthenticatedUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuthenticatedUserMutation) ResetField(name string) error {
	switch name {
	case authenticateduser.FieldUserUUID:
		m.ResetUserUUID()
		return nil
	case authenticateduser.FieldExternalID:
		m.ResetExternalID()
		return nil
	case authenticateduser.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case authenticateduser.FieldUserInfo:
		m.ResetUserInfo()
		return nil
	}
	return fmt.Errorf("unknown AuthenticatedUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuthenticatedUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.bazel_invocations != nil {
		edges = append(edges, authenticateduser.EdgeBazelInvocations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuthenticatedUserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case authenticateduser.EdgeBazelInvocations:
		ids := make([]ent.Value, 0, len(m.bazel_invocations))
		for id := range m.bazel_invocations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuthenticatedUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedbazel_invocations != nil {
		edges = append(edges, authenticateduser.EdgeBazelInvocations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuthenticatedUserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case authenticateduser.EdgeBazelInvocations:
		ids := make([]ent.Value, 0, len(m.removedbazel_invocations))
		for id := range m.removedbazel_invocations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuthenticatedUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbazel_invocations {
		edges = append(edges, authenticateduser.EdgeBazelInvocations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuthenticatedUserMutation) EdgeCleared(name string) bool {
	switch name {
	case authenticateduser.EdgeBazelInvocations:
		return m.clearedbazel_invocations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuthenticatedUserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown AuthenticatedUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuthenticatedUserMutation) ResetEdge(name string) error {
	switch name {
	case authenticateduser.EdgeBazelInvocations:
		m.ResetBazelInvocations()
		return nil
	}
	return fmt.Errorf("unknown AuthenticatedUser edge %s", name)
}

// BazelInvocationMutation represents an operation that mutates the BazelInvocation nodes in the graph.
type BazelInvocationMutation struct {
	config
	op                                      Op
	typ                                     string
	id                                      *int64
	invocation_id                           *uuid.UUID
	started_at                              *time.Time
	ended_at                                *time.Time
	change_number                           *int
	addchange_number                        *int
	patchset_number                         *int
	addpatchset_number                      *int
	bep_completed                           *bool
	step_label                              *string
	user_email                              *string
	user_ldap                               *string
	hostname                                *string
	is_ci_worker                            *bool
	num_fetches                             *int64
	addnum_fetches                          *int64
	profile_name                            *string
	bazel_version                           *string
	exit_code_name                          *string
	exit_code_code                          *int32
	addexit_code_code                       *int32
	command_line_command                    *string
	command_line_executable                 *string
	command_line_residual                   *string
	command_line                            *[]string
	appendcommand_line                      []string
	explicit_command_line                   *[]string
	appendexplicit_command_line             []string
	startup_options                         *[]string
	appendstartup_options                   []string
	explicit_startup_options                *[]string
	appendexplicit_startup_options          []string
	processed_event_started                 *bool
	processed_event_build_metadata          *bool
	processed_event_options_parsed          *bool
	processed_event_build_finished          *bool
	processed_event_structured_command_line *bool
	processed_event_workspace_status        *bool
	clearedFields                           map[string]struct{}
	instance_name                           *int64
	clearedinstance_name                    bool
	build                                   *int64
	clearedbuild                            bool
	authenticated_user                      *int64
	clearedauthenticated_user               bool
	event_metadata                          *int64
	clearedevent_metadata                   bool
	connection_metadata                     map[int64]struct{}
	removedconnection_metadata              map[int64]struct{}
	clearedconnection_metadata              bool
	configurations                          map[int64]struct{}
	removedconfigurations                   map[int64]struct{}
	clearedconfigurations                   bool
	actions                                 map[int64]struct{}
	removedactions                          map[int64]struct{}
	clearedactions                          bool
	metrics                                 *int64
	clearedmetrics                          bool
	incomplete_build_logs                   map[int64]struct{}
	removedincomplete_build_logs            map[int64]struct{}
	clearedincomplete_build_logs            bool
	build_log_chunks                        map[int64]struct{}
	removedbuild_log_chunks                 map[int64]struct{}
	clearedbuild_log_chunks                 bool
	invocation_files                        map[int64]struct{}
	removedinvocation_files                 map[int64]struct{}
	clearedinvocation_files                 bool
	invocation_targets                      map[int64]struct{}
	removedinvocation_targets               map[int64]struct{}
	clearedinvocation_targets               bool
	target_kind_mappings                    map[int64]struct{}
	removedtarget_kind_mappings             map[int64]struct{}
	clearedtarget_kind_mappings             bool
	source_control                          *int64
	clearedsource_control                   bool
	done                                    bool
	oldValue                                func(context.Context) (*BazelInvocation, error)
	predicates                              []predicate.BazelInvocation
}

var _ ent.Mutation = (*BazelInvocationMutation)(nil)

// bazelinvocationOption allows management of the mutation configuration using functional options.
type bazelinvocationOption func(*BazelInvocationMutation)

// newBazelInvocationMutation creates new mutation for the BazelInvocation entity.
func newBazelInvocationMutation(c config, op Op, opts ...bazelinvocationOption) *BazelInvocationMutation {
	m := &BazelInvocationMutation{
		config:        c,
		op:            op,
		typ:           TypeBazelInvocation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBazelInvocationID sets the ID field of the mutation.
func withBazelInvocationID(id int64) bazelinvocationOption {
	return func(m *BazelInvocationMutation) {
		var (
			err   error
			once  sync.Once
			value *BazelInvocation
		)
		m.oldValue = func(ctx context.Context) (*BazelInvocation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BazelInvocation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBazelInvocation sets the old BazelInvocation of the mutation.
func withBazelInvocation(node *BazelInvocation) bazelinvocationOption {
	return func(m *BazelInvocationMutation) {
		m.oldValue = func(context.Context) (*BazelInvocation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BazelInvocationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BazelInvocationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BazelInvocation entities.
func (m *BazelInvocationMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BazelInvocationMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BazelInvocationMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BazelInvocation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetInvocationID sets the "invocation_id" field.
func (m *BazelInvocationMutation) SetInvocationID(u uuid.UUID) {
	m.invocation_id = &u
}

// InvocationID returns the value of the "invocation_id" field in the mutation.
func (m *BazelInvocationMutation) InvocationID() (r uuid.UUID, exists bool) {
	v := m.invocation_id
	if v == nil {
		return
	}
	return *v, true
}

// OldInvocationID returns the old "invocation_id" field's value of the BazelInvocation entity.
// If the BazelInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BazelInvocationMutation) OldInvocationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvocationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvocationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvocationID: %w", err)
	}
	return oldValue.InvocationID, nil
}

// ResetInvocationID resets all changes to the "invocation_id" field.
func (m *BazelInvocationMutation) ResetInvocationID() {
	m.invocation_id = nil
}

// SetStartedAt sets the "started_at" field.
func (m *BazelInvocationMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *BazelInvocationMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the BazelInvocation entity.
// If the BazelInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BazelInvocationMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ClearStartedAt clears the value of the "started_at" field.
func (m *BazelInvocationMutation) ClearStartedAt() {
	m.started_at = nil
	m.clearedFields[bazelinvocation.FieldStartedAt] = struct{}{}
}

// StartedAtCleared returns if the "started_at" field was cleared in this mutation.
func (m *BazelInvocationMutation) StartedAtCleared() bool {
	_, ok := m.clearedFields[bazelinvocation.FieldStartedAt]
	return ok
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *BazelInvocationMutation) ResetStartedAt() {
	m.started_at = nil
	delete(m.clearedFields, bazelinvocation.FieldStartedAt)
}

// SetEndedAt sets the "ended_at" field.
func (m *BazelInvocationMutation) SetEndedAt(t time.Time) {
	m.ended_at = &t
}

// EndedAt returns the value of the "ended_at" field in the mutation.
func (m *BazelInvocationMutation) EndedAt() (r time.Time, exists bool) {
	v := m.ended_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndedAt returns the old "ended_at" field's value of the BazelInvocation entity.
// If the BazelInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BazelInvocationMutation) OldEndedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndedAt: %w", err)
	}
	return oldValue.EndedAt, nil
}

// ClearEndedAt clears the value of the "ended_at" field.
func (m *BazelInvocationMutation) ClearEndedAt() {
	m.ended_at = nil
	m.clearedFields[bazelinvocation.FieldEndedAt] = struct{}{}
}

// EndedAtCleared returns if the "ended_at" field was cleared in this mutation.
func (m *BazelInvocationMutation) EndedAtCleared() bool {
	_, ok := m.clearedFields[bazelinvocation.FieldEndedAt]
	return ok
}

// ResetEndedAt resets all changes to the "ended_at" field.
func (m *BazelInvocationMutation) ResetEndedAt() {
	m.ended_at = nil
	delete(m.clearedFields, bazelinvocation.FieldEndedAt)
}

// SetChangeNumber sets the "change_number" field.
func (m *BazelInvocationMutation) SetChangeNumber(i int) {
	m.change_number = &i
	m.addchange_number = nil
}

// ChangeNumber returns the value of the "change_number" field in the mutation.
func (m *BazelInvocationMutation) ChangeNumber() (r int, exists bool) {
	v := m.change_number
	if v == nil {
		return
	}
	return *v, true
}

// OldChangeNumber returns the old "change_number" field's value of the BazelInvocation entity.
// If the BazelInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BazelInvocationMutation) OldChangeNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChangeNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChangeNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChangeNumber: %w", err)
	}
	return oldValue.ChangeNumber, nil
}

// AddChangeNumber adds i to the "change_number" field.
func (m *BazelInvocationMutation) AddChangeNumber(i int) {
	if m.addchange_number != nil {
		*m.addchange_number += i
	} else {
		m.addchange_number = &i
	}
}

// AddedChangeNumber returns the value that was added to the "change_number" field in this mutation.
func (m *BazelInvocationMutation) AddedChangeNumber() (r int, exists bool) {
	v := m.addchange_number
	if v == nil {
		return
	}
	return *v, true
}

// ClearChangeNumber clears the value of the "change_number" field.
func (m *BazelInvocationMutation) ClearChangeNumber() {
	m.change_number = nil
	m.addchange_number = nil
	m.clearedFields[bazelinvocation.FieldChangeNumber] = struct{}{}
}

// ChangeNumberCleared returns if the "change_number" field was cleared in this mutation.
func (m *BazelInvocationMutation) ChangeNumberCleared() bool {
	_, ok := m.clearedFields[bazelinvocation.FieldChangeNumber]
	return ok
}

// ResetChangeNumber resets all changes to the "change_number" field.
func (m *BazelInvocationMutation) ResetChangeNumber() {
	m.change_number = nil
	m.addchange_number = nil
	delete(m.clearedFields, bazelinvocation.FieldChangeNumber)
}

// SetPatchsetNumber sets the "patchset_number" field.
func (m *BazelInvocationMutation) SetPatchsetNumber(i int) {
	m.patchset_number = &i
	m.addpatchset_number = nil
}

// PatchsetNumber returns the value of the "patchset_number" field in the mutation.
func (m *BazelInvocationMutation) PatchsetNumber() (r int, exists bool) {
	v := m.patchset_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPatchsetNumber returns the old "patchset_number" field's value of the BazelInvocation entity.
// If the BazelInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BazelInvocationMutation) OldPatchsetNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPatchsetNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPatchsetNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatchsetNumber: %w", err)
	}
	return oldValue.PatchsetNumber, nil
}

// AddPatchsetNumber adds i to the "patchset_number" field.
func (m *BazelInvocationMutation) AddPatchsetNumber(i int) {
	if m.addpatchset_number != nil {
		*m.addpatchset_number += i
	} else {
		m.addpatchset_number = &i
	}
}

// AddedPatchsetNumber returns the value that was added to the "patchset_number" field in this mutation.
func (m *BazelInvocationMutation) AddedPatchsetNumber() (r int, exists bool) {
	v := m.addpatchset_number
	if v == nil {
		return
	}
	return *v, true
}

// ClearPatchsetNumber clears the value of the "patchset_number" field.
func (m *BazelInvocationMutation) ClearPatchsetNumber() {
	m.patchset_number = nil
	m.addpatchset_number = nil
	m.clearedFields[bazelinvocation.FieldPatchsetNumber] = struct{}{}
}

// PatchsetNumberCleared returns if the "patchset_number" field was cleared in this mutation.
func (m *BazelInvocationMutation) PatchsetNumberCleared() bool {
	_, ok := m.clearedFields[bazelinvocation.FieldPatchsetNumber]
	return ok
}

// ResetPatchsetNumber resets all changes to the "patchset_number" field.
func (m *BazelInvocationMutation) ResetPatchsetNumber() {
	m.patchset_number = nil
	m.addpatchset_number = nil
	delete(m.clearedFields, bazelinvocation.FieldPatchsetNumber)
}

// SetBepCompleted sets the "bep_completed" field.
func (m *BazelInvocationMutation) SetBepCompleted(b bool) {
	m.bep_completed = &b
}

// BepCompleted returns the value of the "bep_completed" field in the mutation.
func (m *BazelInvocationMutation) BepCompleted() (r bool, exists bool) {
	v := m.bep_completed
	if v == nil {
		return
	}
	return *v, true
}

// OldBepCompleted returns the old "bep_completed" field's value of the BazelInvocation entity.
// If the BazelInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BazelInvocationMutation) OldBepCompleted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBepCompleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBepCompleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBepCompleted: %w", err)
	}
	return oldValue.BepCompleted, nil
}

// ResetBepCompleted resets all changes to the "bep_completed" field.
func (m *BazelInvocationMutation) ResetBepCompleted() {
	m.bep_completed = nil
}

// SetStepLabel sets the "step_label" field.
func (m *BazelInvocationMutation) SetStepLabel(s string) {
	m.step_label = &s
}

// StepLabel returns the value of the "step_label" field in the mutation.
func (m *BazelInvocationMutation) StepLabel() (r string, exists bool) {
	v := m.step_label
	if v == nil {
		return
	}
	return *v, true
}

// OldStepLabel returns the old "step_label" field's value of the BazelInvocation entity.
// If the BazelInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BazelInvocationMutation) OldStepLabel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStepLabel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStepLabel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStepLabel: %w", err)
	}
	return oldValue.StepLabel, nil
}

// ClearStepLabel clears the value of the "step_label" field.
func (m *BazelInvocationMutation) ClearStepLabel() {
	m.step_label = nil
	m.clearedFields[bazelinvocation.FieldStepLabel] = struct{}{}
}

// StepLabelCleared returns if the "step_label" field was cleared in this mutation.
func (m *BazelInvocationMutation) StepLabelCleared() bool {
	_, ok := m.clearedFields[bazelinvocation.FieldStepLabel]
	return ok
}

// ResetStepLabel resets all changes to the "step_label" field.
func (m *BazelInvocationMutation) ResetStepLabel() {
	m.step_label = nil
	delete(m.clearedFields, bazelinvocation.FieldStepLabel)
}

// SetUserEmail sets the "user_email" field.
func (m *BazelInvocationMutation) SetUserEmail(s string) {
	m.user_email = &s
}

// UserEmail returns the value of the "user_email" field in the mutation.
func (m *BazelInvocationMutation) UserEmail() (r string, exists bool) {
	v := m.user_email
	if v == nil {
		return
	}
	return *v, true
}

// OldUserEmail returns the old "user_email" field's value of the BazelInvocation entity.
// If the BazelInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BazelInvocationMutation) OldUserEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserEmail: %w", err)
	}
	return oldValue.UserEmail, nil
}

// ClearUserEmail clears the value of the "user_email" field.
func (m *BazelInvocationMutation) ClearUserEmail() {
	m.user_email = nil
	m.clearedFields[bazelinvocation.FieldUserEmail] = struct{}{}
}

// UserEmailCleared returns if the "user_email" field was cleared in this mutation.
func (m *BazelInvocationMutation) UserEmailCleared() bool {
	_, ok := m.clearedFields[bazelinvocation.FieldUserEmail]
	return ok
}

// ResetUserEmail resets all changes to the "user_email" field.
func (m *BazelInvocationMutation) ResetUserEmail() {
	m.user_email = nil
	delete(m.clearedFields, bazelinvocation.FieldUserEmail)
}

// SetUserLdap sets the "user_ldap" field.
func (m *BazelInvocationMutation) SetUserLdap(s string) {
	m.user_ldap = &s
}

// UserLdap returns the value of the "user_ldap" field in the mutation.
func (m *BazelInvocationMutation) UserLdap() (r string, exists bool) {
	v := m.user_ldap
	if v == nil {
		return
	}
	return *v, true
}

// OldUserLdap returns the old "user_ldap" field's value of the BazelInvocation entity.
// If the BazelInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BazelInvocationMutation) OldUserLdap(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserLdap is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserLdap requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserLdap: %w", err)
	}
	return oldValue.UserLdap, nil
}

// ClearUserLdap clears the value of the "user_ldap" field.
func (m *BazelInvocationMutation) ClearUserLdap() {
	m.user_ldap = nil
	m.clearedFields[bazelinvocation.FieldUserLdap] = struct{}{}
}

// UserLdapCleared returns if the "user_ldap" field was cleared in this mutation.
func (m *BazelInvocationMutation) UserLdapCleared() bool {
	_, ok := m.clearedFields[bazelinvocation.FieldUserLdap]
	return ok
}

// ResetUserLdap resets all changes to the "user_ldap" field.
func (m *BazelInvocationMutation) ResetUserLdap() {
	m.user_ldap = nil
	delete(m.clearedFields, bazelinvocation.FieldUserLdap)
}

// SetHostname sets the "hostname" field.
func (m *BazelInvocationMutation) SetHostname(s string) {
	m.hostname = &s
}

// Hostname returns the value of the "hostname" field in the mutation.
func (m *BazelInvocationMutation) Hostname() (r string, exists bool) {
	v := m.hostname
	if v == nil {
		return
	}
	return *v, true
}

// OldHostname returns the old "hostname" field's value of the BazelInvocation entity.
// If the BazelInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BazelInvocationMutation) OldHostname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHostname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHostname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHostname: %w", err)
	}
	return oldValue.Hostname, nil
}

// ClearHostname clears the value of the "hostname" field.
func (m *BazelInvocationMutation) ClearHostname() {
	m.hostname = nil
	m.clearedFields[bazelinvocation.FieldHostname] = struct{}{}
}

// HostnameCleared returns if the "hostname" field was cleared in this mutation.
func (m *BazelInvocationMutation) HostnameCleared() bool {
	_, ok := m.clearedFields[bazelinvocation.FieldHostname]
	return ok
}

// ResetHostname resets all changes to the "hostname" field.
func (m *BazelInvocationMutation) ResetHostname() {
	m.hostname = nil
	delete(m.clearedFields, bazelinvocation.FieldHostname)
}

// SetIsCiWorker sets the "is_ci_worker" field.
func (m *BazelInvocationMutation) SetIsCiWorker(b bool) {
	m.is_ci_worker = &b
}

// IsCiWorker returns the value of the "is_ci_worker" field in the mutation.
func (m *BazelInvocationMutation) IsCiWorker() (r bool, exists bool) {
	v := m.is_ci_worker
	if v == nil {
		return
	}
	return *v, true
}

// OldIsCiWorker returns the old "is_ci_worker" field's value of the BazelInvocation entity.
// If the BazelInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BazelInvocationMutation) OldIsCiWorker(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsCiWorker is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsCiWorker requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsCiWorker: %w", err)
	}
	return oldValue.IsCiWorker, nil
}

// ClearIsCiWorker clears the value of the "is_ci_worker" field.
func (m *BazelInvocationMutation) ClearIsCiWorker() {
	m.is_ci_worker = nil
	m.clearedFields[bazelinvocation.FieldIsCiWorker] = struct{}{}
}

// IsCiWorkerCleared returns if the "is_ci_worker" field was cleared in this mutation.
func (m *BazelInvocationMutation) IsCiWorkerCleared() bool {
	_, ok := m.clearedFields[bazelinvocation.FieldIsCiWorker]
	return ok
}

// ResetIsCiWorker resets all changes to the "is_ci_worker" field.
func (m *BazelInvocationMutation) ResetIsCiWorker() {
	m.is_ci_worker = nil
	delete(m.clearedFields, bazelinvocation.FieldIsCiWorker)
}

// SetNumFetches sets the "num_fetches" field.
func (m *BazelInvocationMutation) SetNumFetches(i int64) {
	m.num_fetches = &i
	m.addnum_fetches = nil
}

// NumFetches returns the value of the "num_fetches" field in the mutation.
func (m *BazelInvocationMutation) NumFetches() (r int64, exists bool) {
	v := m.num_fetches
	if v == nil {
		return
	}
	return *v, true
}

// OldNumFetches returns the old "num_fetches" field's value of the BazelInvocation entity.
// If the BazelInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BazelInvocationMutation) OldNumFetches(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumFetches is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumFetches requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumFetches: %w", err)
	}
	return oldValue.NumFetches, nil
}

// AddNumFetches adds i to the "num_fetches" field.
func (m *BazelInvocationMutation) AddNumFetches(i int64) {
	if m.addnum_fetches != nil {
		*m.addnum_fetches += i
	} else {
		m.addnum_fetches = &i
	}
}

// AddedNumFetches returns the value that was added to the "num_fetches" field in this mutation.
func (m *BazelInvocationMutation) AddedNumFetches() (r int64, exists bool) {
	v := m.addnum_fetches
	if v == nil {
		return
	}
	return *v, true
}

// ClearNumFetches clears the value of the "num_fetches" field.
func (m *BazelInvocationMutation) ClearNumFetches() {
	m.num_fetches = nil
	m.addnum_fetches = nil
	m.clearedFields[bazelinvocation.FieldNumFetches] = struct{}{}
}

// NumFetchesCleared returns if the "num_fetches" field was cleared in this mutation.
func (m *BazelInvocationMutation) NumFetchesCleared() bool {
	_, ok := m.clearedFields[bazelinvocation.FieldNumFetches]
	return ok
}

// ResetNumFetches resets all changes to the "num_fetches" field.
func (m *BazelInvocationMutation) ResetNumFetches() {
	m.num_fetches = nil
	m.addnum_fetches = nil
	delete(m.clearedFields, bazelinvocation.FieldNumFetches)
}

// SetProfileName sets the "profile_name" field.
func (m *BazelInvocationMutation) SetProfileName(s string) {
	m.profile_name = &s
}

// ProfileName returns the value of the "profile_name" field in the mutation.
func (m *BazelInvocationMutation) ProfileName() (r string, exists bool) {
	v := m.profile_name
	if v == nil {
		return
	}
	return *v, true
}

// OldProfileName returns the old "profile_name" field's value of the BazelInvocation entity.
// If the BazelInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BazelInvocationMutation) OldProfileName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfileName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfileName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfileName: %w", err)
	}
	return oldValue.ProfileName, nil
}

// ClearProfileName clears the value of the "profile_name" field.
func (m *BazelInvocationMutation) ClearProfileName() {
	m.profile_name = nil
	m.clearedFields[bazelinvocation.FieldProfileName] = struct{}{}
}

// ProfileNameCleared returns if the "profile_name" field was cleared in this mutation.
func (m *BazelInvocationMutation) ProfileNameCleared() bool {
	_, ok := m.clearedFields[bazelinvocation.FieldProfileName]
	return ok
}

// ResetProfileName resets all changes to the "profile_name" field.
func (m *BazelInvocationMutation) ResetProfileName() {
	m.profile_name = nil
	delete(m.clearedFields, bazelinvocation.FieldProfileName)
}

// SetBazelVersion sets the "bazel_version" field.
func (m *BazelInvocationMutation) SetBazelVersion(s string) {
	m.bazel_version = &s
}

// BazelVersion returns the value of the "bazel_version" field in the mutation.
func (m *BazelInvocationMutation) BazelVersion() (r string, exists bool) {
	v := m.bazel_version
	if v == nil {
		return
	}
	return *v, true
}

// OldBazelVersion returns the old "bazel_version" field's value of the BazelInvocation entity.
// If the BazelInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BazelInvocationMutation) OldBazelVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBazelVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBazelVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBazelVersion: %w", err)
	}
	return oldValue.BazelVersion, nil
}

// ClearBazelVersion clears the value of the "bazel_version" field.
func (m *BazelInvocationMutation) ClearBazelVersion() {
	m.bazel_version = nil
	m.clearedFields[bazelinvocation.FieldBazelVersion] = struct{}{}
}

// BazelVersionCleared returns if the "bazel_version" field was cleared in this mutation.
func (m *BazelInvocationMutation) BazelVersionCleared() bool {
	_, ok := m.clearedFields[bazelinvocation.FieldBazelVersion]
	return ok
}

// ResetBazelVersion resets all changes to the "bazel_version" field.
func (m *BazelInvocationMutation) ResetBazelVersion() {
	m.bazel_version = nil
	delete(m.clearedFields, bazelinvocation.FieldBazelVersion)
}

// SetExitCodeName sets the "exit_code_name" field.
func (m *BazelInvocationMutation) SetExitCodeName(s string) {
	m.exit_code_name = &s
}

// ExitCodeName returns the value of the "exit_code_name" field in the mutation.
func (m *BazelInvocationMutation) ExitCodeName() (r string, exists bool) {
	v := m.exit_code_name
	if v == nil {
		return
	}
	return *v, true
}

// OldExitCodeName returns the old "exit_code_name" field's value of the BazelInvocation entity.
// If the BazelInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BazelInvocationMutation) OldExitCodeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExitCodeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExitCodeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExitCodeName: %w", err)
	}
	return oldValue.ExitCodeName, nil
}

// ClearExitCodeName clears the value of the "exit_code_name" field.
func (m *BazelInvocationMutation) ClearExitCodeName() {
	m.exit_code_name = nil
	m.clearedFields[bazelinvocation.FieldExitCodeName] = struct{}{}
}

// ExitCodeNameCleared returns if the "exit_code_name" field was cleared in this mutation.
func (m *BazelInvocationMutation) ExitCodeNameCleared() bool {
	_, ok := m.clearedFields[bazelinvocation.FieldExitCodeName]
	return ok
}

// ResetExitCodeName resets all changes to the "exit_code_name" field.
func (m *BazelInvocationMutation) ResetExitCodeName() {
	m.exit_code_name = nil
	delete(m.clearedFields, bazelinvocation.FieldExitCodeName)
}

// SetExitCodeCode sets the "exit_code_code" field.
func (m *BazelInvocationMutation) SetExitCodeCode(i int32) {
	m.exit_code_code = &i
	m.addexit_code_code = nil
}

// ExitCodeCode returns the value of the "exit_code_code" field in the mutation.
func (m *BazelInvocationMutation) ExitCodeCode() (r int32, exists bool) {
	v := m.exit_code_code
	if v == nil {
		return
	}
	return *v, true
}

// OldExitCodeCode returns the old "exit_code_code" field's value of the BazelInvocation entity.
// If the BazelInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BazelInvocationMutation) OldExitCodeCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExitCodeCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExitCodeCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExitCodeCode: %w", err)
	}
	return oldValue.ExitCodeCode, nil
}

// AddExitCodeCode adds i to the "exit_code_code" field.
func (m *BazelInvocationMutation) AddExitCodeCode(i int32) {
	if m.addexit_code_code != nil {
		*m.addexit_code_code += i
	} else {
		m.addexit_code_code = &i
	}
}

// AddedExitCodeCode returns the value that was added to the "exit_code_code" field in this mutation.
func (m *BazelInvocationMutation) AddedExitCodeCode() (r int32, exists bool) {
	v := m.addexit_code_code
	if v == nil {
		return
	}
	return *v, true
}

// ClearExitCodeCode clears the value of the "exit_code_code" field.
func (m *BazelInvocationMutation) ClearExitCodeCode() {
	m.exit_code_code = nil
	m.addexit_code_code = nil
	m.clearedFields[bazelinvocation.FieldExitCodeCode] = struct{}{}
}

// ExitCodeCodeCleared returns if the "exit_code_code" field was cleared in this mutation.
func (m *BazelInvocationMutation) ExitCodeCodeCleared() bool {
	_, ok := m.clearedFields[bazelinvocation.FieldExitCodeCode]
	return ok
}

// ResetExitCodeCode resets all changes to the "exit_code_code" field.
func (m *BazelInvocationMutation) ResetExitCodeCode() {
	m.exit_code_code = nil
	m.addexit_code_code = nil
	delete(m.clearedFields, bazelinvocation.FieldExitCodeCode)
}

// SetCommandLineCommand sets the "command_line_command" field.
func (m *BazelInvocationMutation) SetCommandLineCommand(s string) {
	m.command_line_command = &s
}

// CommandLineCommand returns the value of the "command_line_command" field in the mutation.
func (m *BazelInvocationMutation) CommandLineCommand() (r string, exists bool) {
	v := m.command_line_command
	if v == nil {
		return
	}
	return *v, true
}

// OldCommandLineCommand returns the old "command_line_command" field's value of the BazelInvocation entity.
// If the BazelInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BazelInvocationMutation) OldCommandLineCommand(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommandLineCommand is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommandLineCommand requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommandLineCommand: %w", err)
	}
	return oldValue.CommandLineCommand, nil
}

// ClearCommandLineCommand clears the value of the "command_line_command" field.
func (m *BazelInvocationMutation) ClearCommandLineCommand() {
	m.command_line_command = nil
	m.clearedFields[bazelinvocation.FieldCommandLineCommand] = struct{}{}
}

// CommandLineCommandCleared returns if the "command_line_command" field was cleared in this mutation.
func (m *BazelInvocationMutation) CommandLineCommandCleared() bool {
	_, ok := m.clearedFields[bazelinvocation.FieldCommandLineCommand]
	return ok
}

// ResetCommandLineCommand resets all changes to the "command_line_command" field.
func (m *BazelInvocationMutation) ResetCommandLineCommand() {
	m.command_line_command = nil
	delete(m.clearedFields, bazelinvocation.FieldCommandLineCommand)
}

// SetCommandLineExecutable sets the "command_line_executable" field.
func (m *BazelInvocationMutation) SetCommandLineExecutable(s string) {
	m.command_line_executable = &s
}

// CommandLineExecutable returns the value of the "command_line_executable" field in the mutation.
func (m *BazelInvocationMutation) CommandLineExecutable() (r string, exists bool) {
	v := m.command_line_executable
	if v == nil {
		return
	}
	return *v, true
}

// OldCommandLineExecutable returns the old "command_line_executable" field's value of the BazelInvocation entity.
// If the BazelInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BazelInvocationMutation) OldCommandLineExecutable(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommandLineExecutable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommandLineExecutable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommandLineExecutable: %w", err)
	}
	return oldValue.CommandLineExecutable, nil
}

// ClearCommandLineExecutable clears the value of the "command_line_executable" field.
func (m *BazelInvocationMutation) ClearCommandLineExecutable() {
	m.command_line_executable = nil
	m.clearedFields[bazelinvocation.FieldCommandLineExecutable] = struct{}{}
}

// CommandLineExecutableCleared returns if the "command_line_executable" field was cleared in this mutation.
func (m *BazelInvocationMutation) CommandLineExecutableCleared() bool {
	_, ok := m.clearedFields[bazelinvocation.FieldCommandLineExecutable]
	return ok
}

// ResetCommandLineExecutable resets all changes to the "command_line_executable" field.
func (m *BazelInvocationMutation) ResetCommandLineExecutable() {
	m.command_line_executable = nil
	delete(m.clearedFields, bazelinvocation.FieldCommandLineExecutable)
}

// SetCommandLineResidual sets the "command_line_residual" field.
func (m *BazelInvocationMutation) SetCommandLineResidual(s string) {
	m.command_line_residual = &s
}

// CommandLineResidual returns the value of the "command_line_residual" field in the mutation.
func (m *BazelInvocationMutation) CommandLineResidual() (r string, exists bool) {
	v := m.command_line_residual
	if v == nil {
		return
	}
	return *v, true
}

// OldCommandLineResidual returns the old "command_line_residual" field's value of the BazelInvocation entity.
// If the BazelInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BazelInvocationMutation) OldCommandLineResidual(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommandLineResidual is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommandLineResidual requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommandLineResidual: %w", err)
	}
	return oldValue.CommandLineResidual, nil
}

// ClearCommandLineResidual clears the value of the "command_line_residual" field.
func (m *BazelInvocationMutation) ClearCommandLineResidual() {
	m.command_line_residual = nil
	m.clearedFields[bazelinvocation.FieldCommandLineResidual] = struct{}{}
}

// CommandLineResidualCleared returns if the "command_line_residual" field was cleared in this mutation.
func (m *BazelInvocationMutation) CommandLineResidualCleared() bool {
	_, ok := m.clearedFields[bazelinvocation.FieldCommandLineResidual]
	return ok
}

// ResetCommandLineResidual resets all changes to the "command_line_residual" field.
func (m *BazelInvocationMutation) ResetCommandLineResidual() {
	m.command_line_residual = nil
	delete(m.clearedFields, bazelinvocation.FieldCommandLineResidual)
}

// SetCommandLine sets the "command_line" field.
func (m *BazelInvocationMutation) SetCommandLine(s []string) {
	m.command_line = &s
	m.appendcommand_line = nil
}

// CommandLine returns the value of the "command_line" field in the mutation.
func (m *BazelInvocationMutation) CommandLine() (r []string, exists bool) {
	v := m.command_line
	if v == nil {
		return
	}
	return *v, true
}

// OldCommandLine returns the old "command_line" field's value of the BazelInvocation entity.
// If the BazelInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BazelInvocationMutation) OldCommandLine(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommandLine is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommandLine requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommandLine: %w", err)
	}
	return oldValue.CommandLine, nil
}

// AppendCommandLine adds s to the "command_line" field.
func (m *BazelInvocationMutation) AppendCommandLine(s []string) {
	m.appendcommand_line = append(m.appendcommand_line, s...)
}

// AppendedCommandLine returns the list of values that were appended to the "command_line" field in this mutation.
func (m *BazelInvocationMutation) AppendedCommandLine() ([]string, bool) {
	if len(m.appendcommand_line) == 0 {
		return nil, false
	}
	return m.appendcommand_line, true
}

// ClearCommandLine clears the value of the "command_line" field.
func (m *BazelInvocationMutation) ClearCommandLine() {
	m.command_line = nil
	m.appendcommand_line = nil
	m.clearedFields[bazelinvocation.FieldCommandLine] = struct{}{}
}

// CommandLineCleared returns if the "command_line" field was cleared in this mutation.
func (m *BazelInvocationMutation) CommandLineCleared() bool {
	_, ok := m.clearedFields[bazelinvocation.FieldCommandLine]
	return ok
}

// ResetCommandLine resets all changes to the "command_line" field.
func (m *BazelInvocationMutation) ResetCommandLine() {
	m.command_line = nil
	m.appendcommand_line = nil
	delete(m.clearedFields, bazelinvocation.FieldCommandLine)
}

// SetExplicitCommandLine sets the "explicit_command_line" field.
func (m *BazelInvocationMutation) SetExplicitCommandLine(s []string) {
	m.explicit_command_line = &s
	m.appendexplicit_command_line = nil
}

// ExplicitCommandLine returns the value of the "explicit_command_line" field in the mutation.
func (m *BazelInvocationMutation) ExplicitCommandLine() (r []string, exists bool) {
	v := m.explicit_command_line
	if v == nil {
		return
	}
	return *v, true
}

// OldExplicitCommandLine returns the old "explicit_command_line" field's value of the BazelInvocation entity.
// If the BazelInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BazelInvocationMutation) OldExplicitCommandLine(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExplicitCommandLine is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExplicitCommandLine requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExplicitCommandLine: %w", err)
	}
	return oldValue.ExplicitCommandLine, nil
}

// AppendExplicitCommandLine adds s to the "explicit_command_line" field.
func (m *BazelInvocationMutation) AppendExplicitCommandLine(s []string) {
	m.appendexplicit_command_line = append(m.appendexplicit_command_line, s...)
}

// AppendedExplicitCommandLine returns the list of values that were appended to the "explicit_command_line" field in this mutation.
func (m *BazelInvocationMutation) AppendedExplicitCommandLine() ([]string, bool) {
	if len(m.appendexplicit_command_line) == 0 {
		return nil, false
	}
	return m.appendexplicit_command_line, true
}

// ClearExplicitCommandLine clears the value of the "explicit_command_line" field.
func (m *BazelInvocationMutation) ClearExplicitCommandLine() {
	m.explicit_command_line = nil
	m.appendexplicit_command_line = nil
	m.clearedFields[bazelinvocation.FieldExplicitCommandLine] = struct{}{}
}

// ExplicitCommandLineCleared returns if the "explicit_command_line" field was cleared in this mutation.
func (m *BazelInvocationMutation) ExplicitCommandLineCleared() bool {
	_, ok := m.clearedFields[bazelinvocation.FieldExplicitCommandLine]
	return ok
}

// ResetExplicitCommandLine resets all changes to the "explicit_command_line" field.
func (m *BazelInvocationMutation) ResetExplicitCommandLine() {
	m.explicit_command_line = nil
	m.appendexplicit_command_line = nil
	delete(m.clearedFields, bazelinvocation.FieldExplicitCommandLine)
}

// SetStartupOptions sets the "startup_options" field.
func (m *BazelInvocationMutation) SetStartupOptions(s []string) {
	m.startup_options = &s
	m.appendstartup_options = nil
}

// StartupOptions returns the value of the "startup_options" field in the mutation.
func (m *BazelInvocationMutation) StartupOptions() (r []string, exists bool) {
	v := m.startup_options
	if v == nil {
		return
	}
	return *v, true
}

// OldStartupOptions returns the old "startup_options" field's value of the BazelInvocation entity.
// If the BazelInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BazelInvocationMutation) OldStartupOptions(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartupOptions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartupOptions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartupOptions: %w", err)
	}
	return oldValue.StartupOptions, nil
}

// AppendStartupOptions adds s to the "startup_options" field.
func (m *BazelInvocationMutation) AppendStartupOptions(s []string) {
	m.appendstartup_options = append(m.appendstartup_options, s...)
}

// AppendedStartupOptions returns the list of values that were appended to the "startup_options" field in this mutation.
func (m *BazelInvocationMutation) AppendedStartupOptions() ([]string, bool) {
	if len(m.appendstartup_options) == 0 {
		return nil, false
	}
	return m.appendstartup_options, true
}

// ClearStartupOptions clears the value of the "startup_options" field.
func (m *BazelInvocationMutation) ClearStartupOptions() {
	m.startup_options = nil
	m.appendstartup_options = nil
	m.clearedFields[bazelinvocation.FieldStartupOptions] = struct{}{}
}

// StartupOptionsCleared returns if the "startup_options" field was cleared in this mutation.
func (m *BazelInvocationMutation) StartupOptionsCleared() bool {
	_, ok := m.clearedFields[bazelinvocation.FieldStartupOptions]
	return ok
}

// ResetStartupOptions resets all changes to the "startup_options" field.
func (m *BazelInvocationMutation) ResetStartupOptions() {
	m.startup_options = nil
	m.appendstartup_options = nil
	delete(m.clearedFields, bazelinvocation.FieldStartupOptions)
}

// SetExplicitStartupOptions sets the "explicit_startup_options" field.
func (m *BazelInvocationMutation) SetExplicitStartupOptions(s []string) {
	m.explicit_startup_options = &s
	m.appendexplicit_startup_options = nil
}

// ExplicitStartupOptions returns the value of the "explicit_startup_options" field in the mutation.
func (m *BazelInvocationMutation) ExplicitStartupOptions() (r []string, exists bool) {
	v := m.explicit_startup_options
	if v == nil {
		return
	}
	return *v, true
}

// OldExplicitStartupOptions returns the old "explicit_startup_options" field's value of the BazelInvocation entity.
// If the BazelInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BazelInvocationMutation) OldExplicitStartupOptions(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExplicitStartupOptions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExplicitStartupOptions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExplicitStartupOptions: %w", err)
	}
	return oldValue.ExplicitStartupOptions, nil
}

// AppendExplicitStartupOptions adds s to the "explicit_startup_options" field.
func (m *BazelInvocationMutation) AppendExplicitStartupOptions(s []string) {
	m.appendexplicit_startup_options = append(m.appendexplicit_startup_options, s...)
}

// AppendedExplicitStartupOptions returns the list of values that were appended to the "explicit_startup_options" field in this mutation.
func (m *BazelInvocationMutation) AppendedExplicitStartupOptions() ([]string, bool) {
	if len(m.appendexplicit_startup_options) == 0 {
		return nil, false
	}
	return m.appendexplicit_startup_options, true
}

// ClearExplicitStartupOptions clears the value of the "explicit_startup_options" field.
func (m *BazelInvocationMutation) ClearExplicitStartupOptions() {
	m.explicit_startup_options = nil
	m.appendexplicit_startup_options = nil
	m.clearedFields[bazelinvocation.FieldExplicitStartupOptions] = struct{}{}
}

// ExplicitStartupOptionsCleared returns if the "explicit_startup_options" field was cleared in this mutation.
func (m *BazelInvocationMutation) ExplicitStartupOptionsCleared() bool {
	_, ok := m.clearedFields[bazelinvocation.FieldExplicitStartupOptions]
	return ok
}

// ResetExplicitStartupOptions resets all changes to the "explicit_startup_options" field.
func (m *BazelInvocationMutation) ResetExplicitStartupOptions() {
	m.explicit_startup_options = nil
	m.appendexplicit_startup_options = nil
	delete(m.clearedFields, bazelinvocation.FieldExplicitStartupOptions)
}

// SetProcessedEventStarted sets the "processed_event_started" field.
func (m *BazelInvocationMutation) SetProcessedEventStarted(b bool) {
	m.processed_event_started = &b
}

// ProcessedEventStarted returns the value of the "processed_event_started" field in the mutation.
func (m *BazelInvocationMutation) ProcessedEventStarted() (r bool, exists bool) {
	v := m.processed_event_started
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessedEventStarted returns the old "processed_event_started" field's value of the BazelInvocation entity.
// If the BazelInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BazelInvocationMutation) OldProcessedEventStarted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessedEventStarted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessedEventStarted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessedEventStarted: %w", err)
	}
	return oldValue.ProcessedEventStarted, nil
}

// ResetProcessedEventStarted resets all changes to the "processed_event_started" field.
func (m *BazelInvocationMutation) ResetProcessedEventStarted() {
	m.processed_event_started = nil
}

// SetProcessedEventBuildMetadata sets the "processed_event_build_metadata" field.
func (m *BazelInvocationMutation) SetProcessedEventBuildMetadata(b bool) {
	m.processed_event_build_metadata = &b
}

// ProcessedEventBuildMetadata returns the value of the "processed_event_build_metadata" field in the mutation.
func (m *BazelInvocationMutation) ProcessedEventBuildMetadata() (r bool, exists bool) {
	v := m.processed_event_build_metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessedEventBuildMetadata returns the old "processed_event_build_metadata" field's value of the BazelInvocation entity.
// If the BazelInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BazelInvocationMutation) OldProcessedEventBuildMetadata(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessedEventBuildMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessedEventBuildMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessedEventBuildMetadata: %w", err)
	}
	return oldValue.ProcessedEventBuildMetadata, nil
}

// ResetProcessedEventBuildMetadata resets all changes to the "processed_event_build_metadata" field.
func (m *BazelInvocationMutation) ResetProcessedEventBuildMetadata() {
	m.processed_event_build_metadata = nil
}

// SetProcessedEventOptionsParsed sets the "processed_event_options_parsed" field.
func (m *BazelInvocationMutation) SetProcessedEventOptionsParsed(b bool) {
	m.processed_event_options_parsed = &b
}

// ProcessedEventOptionsParsed returns the value of the "processed_event_options_parsed" field in the mutation.
func (m *BazelInvocationMutation) ProcessedEventOptionsParsed() (r bool, exists bool) {
	v := m.processed_event_options_parsed
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessedEventOptionsParsed returns the old "processed_event_options_parsed" field's value of the BazelInvocation entity.
// If the BazelInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BazelInvocationMutation) OldProcessedEventOptionsParsed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessedEventOptionsParsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessedEventOptionsParsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessedEventOptionsParsed: %w", err)
	}
	return oldValue.ProcessedEventOptionsParsed, nil
}

// ResetProcessedEventOptionsParsed resets all changes to the "processed_event_options_parsed" field.
func (m *BazelInvocationMutation) ResetProcessedEventOptionsParsed() {
	m.processed_event_options_parsed = nil
}

// SetProcessedEventBuildFinished sets the "processed_event_build_finished" field.
func (m *BazelInvocationMutation) SetProcessedEventBuildFinished(b bool) {
	m.processed_event_build_finished = &b
}

// ProcessedEventBuildFinished returns the value of the "processed_event_build_finished" field in the mutation.
func (m *BazelInvocationMutation) ProcessedEventBuildFinished() (r bool, exists bool) {
	v := m.processed_event_build_finished
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessedEventBuildFinished returns the old "processed_event_build_finished" field's value of the BazelInvocation entity.
// If the BazelInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BazelInvocationMutation) OldProcessedEventBuildFinished(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessedEventBuildFinished is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessedEventBuildFinished requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessedEventBuildFinished: %w", err)
	}
	return oldValue.ProcessedEventBuildFinished, nil
}

// ResetProcessedEventBuildFinished resets all changes to the "processed_event_build_finished" field.
func (m *BazelInvocationMutation) ResetProcessedEventBuildFinished() {
	m.processed_event_build_finished = nil
}

// SetProcessedEventStructuredCommandLine sets the "processed_event_structured_command_line" field.
func (m *BazelInvocationMutation) SetProcessedEventStructuredCommandLine(b bool) {
	m.processed_event_structured_command_line = &b
}

// ProcessedEventStructuredCommandLine returns the value of the "processed_event_structured_command_line" field in the mutation.
func (m *BazelInvocationMutation) ProcessedEventStructuredCommandLine() (r bool, exists bool) {
	v := m.processed_event_structured_command_line
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessedEventStructuredCommandLine returns the old "processed_event_structured_command_line" field's value of the BazelInvocation entity.
// If the BazelInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BazelInvocationMutation) OldProcessedEventStructuredCommandLine(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessedEventStructuredCommandLine is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessedEventStructuredCommandLine requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessedEventStructuredCommandLine: %w", err)
	}
	return oldValue.ProcessedEventStructuredCommandLine, nil
}

// ResetProcessedEventStructuredCommandLine resets all changes to the "processed_event_structured_command_line" field.
func (m *BazelInvocationMutation) ResetProcessedEventStructuredCommandLine() {
	m.processed_event_structured_command_line = nil
}

// SetProcessedEventWorkspaceStatus sets the "processed_event_workspace_status" field.
func (m *BazelInvocationMutation) SetProcessedEventWorkspaceStatus(b bool) {
	m.processed_event_workspace_status = &b
}

// ProcessedEventWorkspaceStatus returns the value of the "processed_event_workspace_status" field in the mutation.
func (m *BazelInvocationMutation) ProcessedEventWorkspaceStatus() (r bool, exists bool) {
	v := m.processed_event_workspace_status
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessedEventWorkspaceStatus returns the old "processed_event_workspace_status" field's value of the BazelInvocation entity.
// If the BazelInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BazelInvocationMutation) OldProcessedEventWorkspaceStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessedEventWorkspaceStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessedEventWorkspaceStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessedEventWorkspaceStatus: %w", err)
	}
	return oldValue.ProcessedEventWorkspaceStatus, nil
}

// ResetProcessedEventWorkspaceStatus resets all changes to the "processed_event_workspace_status" field.
func (m *BazelInvocationMutation) ResetProcessedEventWorkspaceStatus() {
	m.processed_event_workspace_status = nil
}

// SetInstanceNameID sets the "instance_name" edge to the InstanceName entity by id.
func (m *BazelInvocationMutation) SetInstanceNameID(id int64) {
	m.instance_name = &id
}

// ClearInstanceName clears the "instance_name" edge to the InstanceName entity.
func (m *BazelInvocationMutation) ClearInstanceName() {
	m.clearedinstance_name = true
}

// InstanceNameCleared reports if the "instance_name" edge to the InstanceName entity was cleared.
func (m *BazelInvocationMutation) InstanceNameCleared() bool {
	return m.clearedinstance_name
}

// InstanceNameID returns the "instance_name" edge ID in the mutation.
func (m *BazelInvocationMutation) InstanceNameID() (id int64, exists bool) {
	if m.instance_name != nil {
		return *m.instance_name, true
	}
	return
}

// InstanceNameIDs returns the "instance_name" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InstanceNameID instead. It exists only for internal usage by the builders.
func (m *BazelInvocationMutation) InstanceNameIDs() (ids []int64) {
	if id := m.instance_name; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInstanceName resets all changes to the "instance_name" edge.
func (m *BazelInvocationMutation) ResetInstanceName() {
	m.instance_name = nil
	m.clearedinstance_name = false
}

// SetBuildID sets the "build" edge to the Build entity by id.
func (m *BazelInvocationMutation) SetBuildID(id int64) {
	m.build = &id
}

// ClearBuild clears the "build" edge to the Build entity.
func (m *BazelInvocationMutation) ClearBuild() {
	m.clearedbuild = true
}

// BuildCleared reports if the "build" edge to the Build entity was cleared.
func (m *BazelInvocationMutation) BuildCleared() bool {
	return m.clearedbuild
}

// BuildID returns the "build" edge ID in the mutation.
func (m *BazelInvocationMutation) BuildID() (id int64, exists bool) {
	if m.build != nil {
		return *m.build, true
	}
	return
}

// BuildIDs returns the "build" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BuildID instead. It exists only for internal usage by the builders.
func (m *BazelInvocationMutation) BuildIDs() (ids []int64) {
	if id := m.build; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBuild resets all changes to the "build" edge.
func (m *BazelInvocationMutation) ResetBuild() {
	m.build = nil
	m.clearedbuild = false
}

// SetAuthenticatedUserID sets the "authenticated_user" edge to the AuthenticatedUser entity by id.
func (m *BazelInvocationMutation) SetAuthenticatedUserID(id int64) {
	m.authenticated_user = &id
}

// ClearAuthenticatedUser clears the "authenticated_user" edge to the AuthenticatedUser entity.
func (m *BazelInvocationMutation) ClearAuthenticatedUser() {
	m.clearedauthenticated_user = true
}

// AuthenticatedUserCleared reports if the "authenticated_user" edge to the AuthenticatedUser entity was cleared.
func (m *BazelInvocationMutation) AuthenticatedUserCleared() bool {
	return m.clearedauthenticated_user
}

// AuthenticatedUserID returns the "authenticated_user" edge ID in the mutation.
func (m *BazelInvocationMutation) AuthenticatedUserID() (id int64, exists bool) {
	if m.authenticated_user != nil {
		return *m.authenticated_user, true
	}
	return
}

// AuthenticatedUserIDs returns the "authenticated_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AuthenticatedUserID instead. It exists only for internal usage by the builders.
func (m *BazelInvocationMutation) AuthenticatedUserIDs() (ids []int64) {
	if id := m.authenticated_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAuthenticatedUser resets all changes to the "authenticated_user" edge.
func (m *BazelInvocationMutation) ResetAuthenticatedUser() {
	m.authenticated_user = nil
	m.clearedauthenticated_user = false
}

// SetEventMetadataID sets the "event_metadata" edge to the EventMetadata entity by id.
func (m *BazelInvocationMutation) SetEventMetadataID(id int64) {
	m.event_metadata = &id
}

// ClearEventMetadata clears the "event_metadata" edge to the EventMetadata entity.
func (m *BazelInvocationMutation) ClearEventMetadata() {
	m.clearedevent_metadata = true
}

// EventMetadataCleared reports if the "event_metadata" edge to the EventMetadata entity was cleared.
func (m *BazelInvocationMutation) EventMetadataCleared() bool {
	return m.clearedevent_metadata
}

// EventMetadataID returns the "event_metadata" edge ID in the mutation.
func (m *BazelInvocationMutation) EventMetadataID() (id int64, exists bool) {
	if m.event_metadata != nil {
		return *m.event_metadata, true
	}
	return
}

// EventMetadataIDs returns the "event_metadata" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EventMetadataID instead. It exists only for internal usage by the builders.
func (m *BazelInvocationMutation) EventMetadataIDs() (ids []int64) {
	if id := m.event_metadata; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEventMetadata resets all changes to the "event_metadata" edge.
func (m *BazelInvocationMutation) ResetEventMetadata() {
	m.event_metadata = nil
	m.clearedevent_metadata = false
}

// AddConnectionMetadatumIDs adds the "connection_metadata" edge to the ConnectionMetadata entity by ids.
func (m *BazelInvocationMutation) AddConnectionMetadatumIDs(ids ...int64) {
	if m.connection_metadata == nil {
		m.connection_metadata = make(map[int64]struct{})
	}
	for i := range ids {
		m.connection_metadata[ids[i]] = struct{}{}
	}
}

// ClearConnectionMetadata clears the "connection_metadata" edge to the ConnectionMetadata entity.
func (m *BazelInvocationMutation) ClearConnectionMetadata() {
	m.clearedconnection_metadata = true
}

// ConnectionMetadataCleared reports if the "connection_metadata" edge to the ConnectionMetadata entity was cleared.
func (m *BazelInvocationMutation) ConnectionMetadataCleared() bool {
	return m.clearedconnection_metadata
}

// RemoveConnectionMetadatumIDs removes the "connection_metadata" edge to the ConnectionMetadata entity by IDs.
func (m *BazelInvocationMutation) RemoveConnectionMetadatumIDs(ids ...int64) {
	if m.removedconnection_metadata == nil {
		m.removedconnection_metadata = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.connection_metadata, ids[i])
		m.removedconnection_metadata[ids[i]] = struct{}{}
	}
}

// RemovedConnectionMetadata returns the removed IDs of the "connection_metadata" edge to the ConnectionMetadata entity.
func (m *BazelInvocationMutation) RemovedConnectionMetadataIDs() (ids []int64) {
	for id := range m.removedconnection_metadata {
		ids = append(ids, id)
	}
	return
}

// ConnectionMetadataIDs returns the "connection_metadata" edge IDs in the mutation.
func (m *BazelInvocationMutation) ConnectionMetadataIDs() (ids []int64) {
	for id := range m.connection_metadata {
		ids = append(ids, id)
	}
	return
}

// ResetConnectionMetadata resets all changes to the "connection_metadata" edge.
func (m *BazelInvocationMutation) ResetConnectionMetadata() {
	m.connection_metadata = nil
	m.clearedconnection_metadata = false
	m.removedconnection_metadata = nil
}

// AddConfigurationIDs adds the "configurations" edge to the Configuration entity by ids.
func (m *BazelInvocationMutation) AddConfigurationIDs(ids ...int64) {
	if m.configurations == nil {
		m.configurations = make(map[int64]struct{})
	}
	for i := range ids {
		m.configurations[ids[i]] = struct{}{}
	}
}

// ClearConfigurations clears the "configurations" edge to the Configuration entity.
func (m *BazelInvocationMutation) ClearConfigurations() {
	m.clearedconfigurations = true
}

// ConfigurationsCleared reports if the "configurations" edge to the Configuration entity was cleared.
func (m *BazelInvocationMutation) ConfigurationsCleared() bool {
	return m.clearedconfigurations
}

// RemoveConfigurationIDs removes the "configurations" edge to the Configuration entity by IDs.
func (m *BazelInvocationMutation) RemoveConfigurationIDs(ids ...int64) {
	if m.removedconfigurations == nil {
		m.removedconfigurations = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.configurations, ids[i])
		m.removedconfigurations[ids[i]] = struct{}{}
	}
}

// RemovedConfigurations returns the removed IDs of the "configurations" edge to the Configuration entity.
func (m *BazelInvocationMutation) RemovedConfigurationsIDs() (ids []int64) {
	for id := range m.removedconfigurations {
		ids = append(ids, id)
	}
	return
}

// ConfigurationsIDs returns the "configurations" edge IDs in the mutation.
func (m *BazelInvocationMutation) ConfigurationsIDs() (ids []int64) {
	for id := range m.configurations {
		ids = append(ids, id)
	}
	return
}

// ResetConfigurations resets all changes to the "configurations" edge.
func (m *BazelInvocationMutation) ResetConfigurations() {
	m.configurations = nil
	m.clearedconfigurations = false
	m.removedconfigurations = nil
}

// AddActionIDs adds the "actions" edge to the Action entity by ids.
func (m *BazelInvocationMutation) AddActionIDs(ids ...int64) {
	if m.actions == nil {
		m.actions = make(map[int64]struct{})
	}
	for i := range ids {
		m.actions[ids[i]] = struct{}{}
	}
}

// ClearActions clears the "actions" edge to the Action entity.
func (m *BazelInvocationMutation) ClearActions() {
	m.clearedactions = true
}

// ActionsCleared reports if the "actions" edge to the Action entity was cleared.
func (m *BazelInvocationMutation) ActionsCleared() bool {
	return m.clearedactions
}

// RemoveActionIDs removes the "actions" edge to the Action entity by IDs.
func (m *BazelInvocationMutation) RemoveActionIDs(ids ...int64) {
	if m.removedactions == nil {
		m.removedactions = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.actions, ids[i])
		m.removedactions[ids[i]] = struct{}{}
	}
}

// RemovedActions returns the removed IDs of the "actions" edge to the Action entity.
func (m *BazelInvocationMutation) RemovedActionsIDs() (ids []int64) {
	for id := range m.removedactions {
		ids = append(ids, id)
	}
	return
}

// ActionsIDs returns the "actions" edge IDs in the mutation.
func (m *BazelInvocationMutation) ActionsIDs() (ids []int64) {
	for id := range m.actions {
		ids = append(ids, id)
	}
	return
}

// ResetActions resets all changes to the "actions" edge.
func (m *BazelInvocationMutation) ResetActions() {
	m.actions = nil
	m.clearedactions = false
	m.removedactions = nil
}

// SetMetricsID sets the "metrics" edge to the Metrics entity by id.
func (m *BazelInvocationMutation) SetMetricsID(id int64) {
	m.metrics = &id
}

// ClearMetrics clears the "metrics" edge to the Metrics entity.
func (m *BazelInvocationMutation) ClearMetrics() {
	m.clearedmetrics = true
}

// MetricsCleared reports if the "metrics" edge to the Metrics entity was cleared.
func (m *BazelInvocationMutation) MetricsCleared() bool {
	return m.clearedmetrics
}

// MetricsID returns the "metrics" edge ID in the mutation.
func (m *BazelInvocationMutation) MetricsID() (id int64, exists bool) {
	if m.metrics != nil {
		return *m.metrics, true
	}
	return
}

// MetricsIDs returns the "metrics" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MetricsID instead. It exists only for internal usage by the builders.
func (m *BazelInvocationMutation) MetricsIDs() (ids []int64) {
	if id := m.metrics; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMetrics resets all changes to the "metrics" edge.
func (m *BazelInvocationMutation) ResetMetrics() {
	m.metrics = nil
	m.clearedmetrics = false
}

// AddIncompleteBuildLogIDs adds the "incomplete_build_logs" edge to the IncompleteBuildLog entity by ids.
func (m *BazelInvocationMutation) AddIncompleteBuildLogIDs(ids ...int64) {
	if m.incomplete_build_logs == nil {
		m.incomplete_build_logs = make(map[int64]struct{})
	}
	for i := range ids {
		m.incomplete_build_logs[ids[i]] = struct{}{}
	}
}

// ClearIncompleteBuildLogs clears the "incomplete_build_logs" edge to the IncompleteBuildLog entity.
func (m *BazelInvocationMutation) ClearIncompleteBuildLogs() {
	m.clearedincomplete_build_logs = true
}

// IncompleteBuildLogsCleared reports if the "incomplete_build_logs" edge to the IncompleteBuildLog entity was cleared.
func (m *BazelInvocationMutation) IncompleteBuildLogsCleared() bool {
	return m.clearedincomplete_build_logs
}

// RemoveIncompleteBuildLogIDs removes the "incomplete_build_logs" edge to the IncompleteBuildLog entity by IDs.
func (m *BazelInvocationMutation) RemoveIncompleteBuildLogIDs(ids ...int64) {
	if m.removedincomplete_build_logs == nil {
		m.removedincomplete_build_logs = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.incomplete_build_logs, ids[i])
		m.removedincomplete_build_logs[ids[i]] = struct{}{}
	}
}

// RemovedIncompleteBuildLogs returns the removed IDs of the "incomplete_build_logs" edge to the IncompleteBuildLog entity.
func (m *BazelInvocationMutation) RemovedIncompleteBuildLogsIDs() (ids []int64) {
	for id := range m.removedincomplete_build_logs {
		ids = append(ids, id)
	}
	return
}

// IncompleteBuildLogsIDs returns the "incomplete_build_logs" edge IDs in the mutation.
func (m *BazelInvocationMutation) IncompleteBuildLogsIDs() (ids []int64) {
	for id := range m.incomplete_build_logs {
		ids = append(ids, id)
	}
	return
}

// ResetIncompleteBuildLogs resets all changes to the "incomplete_build_logs" edge.
func (m *BazelInvocationMutation) ResetIncompleteBuildLogs() {
	m.incomplete_build_logs = nil
	m.clearedincomplete_build_logs = false
	m.removedincomplete_build_logs = nil
}

// AddBuildLogChunkIDs adds the "build_log_chunks" edge to the BuildLogChunk entity by ids.
func (m *BazelInvocationMutation) AddBuildLogChunkIDs(ids ...int64) {
	if m.build_log_chunks == nil {
		m.build_log_chunks = make(map[int64]struct{})
	}
	for i := range ids {
		m.build_log_chunks[ids[i]] = struct{}{}
	}
}

// ClearBuildLogChunks clears the "build_log_chunks" edge to the BuildLogChunk entity.
func (m *BazelInvocationMutation) ClearBuildLogChunks() {
	m.clearedbuild_log_chunks = true
}

// BuildLogChunksCleared reports if the "build_log_chunks" edge to the BuildLogChunk entity was cleared.
func (m *BazelInvocationMutation) BuildLogChunksCleared() bool {
	return m.clearedbuild_log_chunks
}

// RemoveBuildLogChunkIDs removes the "build_log_chunks" edge to the BuildLogChunk entity by IDs.
func (m *BazelInvocationMutation) RemoveBuildLogChunkIDs(ids ...int64) {
	if m.removedbuild_log_chunks == nil {
		m.removedbuild_log_chunks = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.build_log_chunks, ids[i])
		m.removedbuild_log_chunks[ids[i]] = struct{}{}
	}
}

// RemovedBuildLogChunks returns the removed IDs of the "build_log_chunks" edge to the BuildLogChunk entity.
func (m *BazelInvocationMutation) RemovedBuildLogChunksIDs() (ids []int64) {
	for id := range m.removedbuild_log_chunks {
		ids = append(ids, id)
	}
	return
}

// BuildLogChunksIDs returns the "build_log_chunks" edge IDs in the mutation.
func (m *BazelInvocationMutation) BuildLogChunksIDs() (ids []int64) {
	for id := range m.build_log_chunks {
		ids = append(ids, id)
	}
	return
}

// ResetBuildLogChunks resets all changes to the "build_log_chunks" edge.
func (m *BazelInvocationMutation) ResetBuildLogChunks() {
	m.build_log_chunks = nil
	m.clearedbuild_log_chunks = false
	m.removedbuild_log_chunks = nil
}

// AddInvocationFileIDs adds the "invocation_files" edge to the InvocationFiles entity by ids.
func (m *BazelInvocationMutation) AddInvocationFileIDs(ids ...int64) {
	if m.invocation_files == nil {
		m.invocation_files = make(map[int64]struct{})
	}
	for i := range ids {
		m.invocation_files[ids[i]] = struct{}{}
	}
}

// ClearInvocationFiles clears the "invocation_files" edge to the InvocationFiles entity.
func (m *BazelInvocationMutation) ClearInvocationFiles() {
	m.clearedinvocation_files = true
}

// InvocationFilesCleared reports if the "invocation_files" edge to the InvocationFiles entity was cleared.
func (m *BazelInvocationMutation) InvocationFilesCleared() bool {
	return m.clearedinvocation_files
}

// RemoveInvocationFileIDs removes the "invocation_files" edge to the InvocationFiles entity by IDs.
func (m *BazelInvocationMutation) RemoveInvocationFileIDs(ids ...int64) {
	if m.removedinvocation_files == nil {
		m.removedinvocation_files = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.invocation_files, ids[i])
		m.removedinvocation_files[ids[i]] = struct{}{}
	}
}

// RemovedInvocationFiles returns the removed IDs of the "invocation_files" edge to the InvocationFiles entity.
func (m *BazelInvocationMutation) RemovedInvocationFilesIDs() (ids []int64) {
	for id := range m.removedinvocation_files {
		ids = append(ids, id)
	}
	return
}

// InvocationFilesIDs returns the "invocation_files" edge IDs in the mutation.
func (m *BazelInvocationMutation) InvocationFilesIDs() (ids []int64) {
	for id := range m.invocation_files {
		ids = append(ids, id)
	}
	return
}

// ResetInvocationFiles resets all changes to the "invocation_files" edge.
func (m *BazelInvocationMutation) ResetInvocationFiles() {
	m.invocation_files = nil
	m.clearedinvocation_files = false
	m.removedinvocation_files = nil
}

// AddInvocationTargetIDs adds the "invocation_targets" edge to the InvocationTarget entity by ids.
func (m *BazelInvocationMutation) AddInvocationTargetIDs(ids ...int64) {
	if m.invocation_targets == nil {
		m.invocation_targets = make(map[int64]struct{})
	}
	for i := range ids {
		m.invocation_targets[ids[i]] = struct{}{}
	}
}

// ClearInvocationTargets clears the "invocation_targets" edge to the InvocationTarget entity.
func (m *BazelInvocationMutation) ClearInvocationTargets() {
	m.clearedinvocation_targets = true
}

// InvocationTargetsCleared reports if the "invocation_targets" edge to the InvocationTarget entity was cleared.
func (m *BazelInvocationMutation) InvocationTargetsCleared() bool {
	return m.clearedinvocation_targets
}

// RemoveInvocationTargetIDs removes the "invocation_targets" edge to the InvocationTarget entity by IDs.
func (m *BazelInvocationMutation) RemoveInvocationTargetIDs(ids ...int64) {
	if m.removedinvocation_targets == nil {
		m.removedinvocation_targets = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.invocation_targets, ids[i])
		m.removedinvocation_targets[ids[i]] = struct{}{}
	}
}

// RemovedInvocationTargets returns the removed IDs of the "invocation_targets" edge to the InvocationTarget entity.
func (m *BazelInvocationMutation) RemovedInvocationTargetsIDs() (ids []int64) {
	for id := range m.removedinvocation_targets {
		ids = append(ids, id)
	}
	return
}

// InvocationTargetsIDs returns the "invocation_targets" edge IDs in the mutation.
func (m *BazelInvocationMutation) InvocationTargetsIDs() (ids []int64) {
	for id := range m.invocation_targets {
		ids = append(ids, id)
	}
	return
}

// ResetInvocationTargets resets all changes to the "invocation_targets" edge.
func (m *BazelInvocationMutation) ResetInvocationTargets() {
	m.invocation_targets = nil
	m.clearedinvocation_targets = false
	m.removedinvocation_targets = nil
}

// AddTargetKindMappingIDs adds the "target_kind_mappings" edge to the TargetKindMapping entity by ids.
func (m *BazelInvocationMutation) AddTargetKindMappingIDs(ids ...int64) {
	if m.target_kind_mappings == nil {
		m.target_kind_mappings = make(map[int64]struct{})
	}
	for i := range ids {
		m.target_kind_mappings[ids[i]] = struct{}{}
	}
}

// ClearTargetKindMappings clears the "target_kind_mappings" edge to the TargetKindMapping entity.
func (m *BazelInvocationMutation) ClearTargetKindMappings() {
	m.clearedtarget_kind_mappings = true
}

// TargetKindMappingsCleared reports if the "target_kind_mappings" edge to the TargetKindMapping entity was cleared.
func (m *BazelInvocationMutation) TargetKindMappingsCleared() bool {
	return m.clearedtarget_kind_mappings
}

// RemoveTargetKindMappingIDs removes the "target_kind_mappings" edge to the TargetKindMapping entity by IDs.
func (m *BazelInvocationMutation) RemoveTargetKindMappingIDs(ids ...int64) {
	if m.removedtarget_kind_mappings == nil {
		m.removedtarget_kind_mappings = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.target_kind_mappings, ids[i])
		m.removedtarget_kind_mappings[ids[i]] = struct{}{}
	}
}

// RemovedTargetKindMappings returns the removed IDs of the "target_kind_mappings" edge to the TargetKindMapping entity.
func (m *BazelInvocationMutation) RemovedTargetKindMappingsIDs() (ids []int64) {
	for id := range m.removedtarget_kind_mappings {
		ids = append(ids, id)
	}
	return
}

// TargetKindMappingsIDs returns the "target_kind_mappings" edge IDs in the mutation.
func (m *BazelInvocationMutation) TargetKindMappingsIDs() (ids []int64) {
	for id := range m.target_kind_mappings {
		ids = append(ids, id)
	}
	return
}

// ResetTargetKindMappings resets all changes to the "target_kind_mappings" edge.
func (m *BazelInvocationMutation) ResetTargetKindMappings() {
	m.target_kind_mappings = nil
	m.clearedtarget_kind_mappings = false
	m.removedtarget_kind_mappings = nil
}

// SetSourceControlID sets the "source_control" edge to the SourceControl entity by id.
func (m *BazelInvocationMutation) SetSourceControlID(id int64) {
	m.source_control = &id
}

// ClearSourceControl clears the "source_control" edge to the SourceControl entity.
func (m *BazelInvocationMutation) ClearSourceControl() {
	m.clearedsource_control = true
}

// SourceControlCleared reports if the "source_control" edge to the SourceControl entity was cleared.
func (m *BazelInvocationMutation) SourceControlCleared() bool {
	return m.clearedsource_control
}

// SourceControlID returns the "source_control" edge ID in the mutation.
func (m *BazelInvocationMutation) SourceControlID() (id int64, exists bool) {
	if m.source_control != nil {
		return *m.source_control, true
	}
	return
}

// SourceControlIDs returns the "source_control" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SourceControlID instead. It exists only for internal usage by the builders.
func (m *BazelInvocationMutation) SourceControlIDs() (ids []int64) {
	if id := m.source_control; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSourceControl resets all changes to the "source_control" edge.
func (m *BazelInvocationMutation) ResetSourceControl() {
	m.source_control = nil
	m.clearedsource_control = false
}

// Where appends a list predicates to the BazelInvocationMutation builder.
func (m *BazelInvocationMutation) Where(ps ...predicate.BazelInvocation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BazelInvocationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BazelInvocationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BazelInvocation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BazelInvocationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BazelInvocationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BazelInvocation).
func (m *BazelInvocationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BazelInvocationMutation) Fields() []string {
	fields := make([]string, 0, 29)
	if m.invocation_id != nil {
		fields = append(fields, bazelinvocation.FieldInvocationID)
	}
	if m.started_at != nil {
		fields = append(fields, bazelinvocation.FieldStartedAt)
	}
	if m.ended_at != nil {
		fields = append(fields, bazelinvocation.FieldEndedAt)
	}
	if m.change_number != nil {
		fields = append(fields, bazelinvocation.FieldChangeNumber)
	}
	if m.patchset_number != nil {
		fields = append(fields, bazelinvocation.FieldPatchsetNumber)
	}
	if m.bep_completed != nil {
		fields = append(fields, bazelinvocation.FieldBepCompleted)
	}
	if m.step_label != nil {
		fields = append(fields, bazelinvocation.FieldStepLabel)
	}
	if m.user_email != nil {
		fields = append(fields, bazelinvocation.FieldUserEmail)
	}
	if m.user_ldap != nil {
		fields = append(fields, bazelinvocation.FieldUserLdap)
	}
	if m.hostname != nil {
		fields = append(fields, bazelinvocation.FieldHostname)
	}
	if m.is_ci_worker != nil {
		fields = append(fields, bazelinvocation.FieldIsCiWorker)
	}
	if m.num_fetches != nil {
		fields = append(fields, bazelinvocation.FieldNumFetches)
	}
	if m.profile_name != nil {
		fields = append(fields, bazelinvocation.FieldProfileName)
	}
	if m.bazel_version != nil {
		fields = append(fields, bazelinvocation.FieldBazelVersion)
	}
	if m.exit_code_name != nil {
		fields = append(fields, bazelinvocation.FieldExitCodeName)
	}
	if m.exit_code_code != nil {
		fields = append(fields, bazelinvocation.FieldExitCodeCode)
	}
	if m.command_line_command != nil {
		fields = append(fields, bazelinvocation.FieldCommandLineCommand)
	}
	if m.command_line_executable != nil {
		fields = append(fields, bazelinvocation.FieldCommandLineExecutable)
	}
	if m.command_line_residual != nil {
		fields = append(fields, bazelinvocation.FieldCommandLineResidual)
	}
	if m.command_line != nil {
		fields = append(fields, bazelinvocation.FieldCommandLine)
	}
	if m.explicit_command_line != nil {
		fields = append(fields, bazelinvocation.FieldExplicitCommandLine)
	}
	if m.startup_options != nil {
		fields = append(fields, bazelinvocation.FieldStartupOptions)
	}
	if m.explicit_startup_options != nil {
		fields = append(fields, bazelinvocation.FieldExplicitStartupOptions)
	}
	if m.processed_event_started != nil {
		fields = append(fields, bazelinvocation.FieldProcessedEventStarted)
	}
	if m.processed_event_build_metadata != nil {
		fields = append(fields, bazelinvocation.FieldProcessedEventBuildMetadata)
	}
	if m.processed_event_options_parsed != nil {
		fields = append(fields, bazelinvocation.FieldProcessedEventOptionsParsed)
	}
	if m.processed_event_build_finished != nil {
		fields = append(fields, bazelinvocation.FieldProcessedEventBuildFinished)
	}
	if m.processed_event_structured_command_line != nil {
		fields = append(fields, bazelinvocation.FieldProcessedEventStructuredCommandLine)
	}
	if m.processed_event_workspace_status != nil {
		fields = append(fields, bazelinvocation.FieldProcessedEventWorkspaceStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BazelInvocationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bazelinvocation.FieldInvocationID:
		return m.InvocationID()
	case bazelinvocation.FieldStartedAt:
		return m.StartedAt()
	case bazelinvocation.FieldEndedAt:
		return m.EndedAt()
	case bazelinvocation.FieldChangeNumber:
		return m.ChangeNumber()
	case bazelinvocation.FieldPatchsetNumber:
		return m.PatchsetNumber()
	case bazelinvocation.FieldBepCompleted:
		return m.BepCompleted()
	case bazelinvocation.FieldStepLabel:
		return m.StepLabel()
	case bazelinvocation.FieldUserEmail:
		return m.UserEmail()
	case bazelinvocation.FieldUserLdap:
		return m.UserLdap()
	case bazelinvocation.FieldHostname:
		return m.Hostname()
	case bazelinvocation.FieldIsCiWorker:
		return m.IsCiWorker()
	case bazelinvocation.FieldNumFetches:
		return m.NumFetches()
	case bazelinvocation.FieldProfileName:
		return m.ProfileName()
	case bazelinvocation.FieldBazelVersion:
		return m.BazelVersion()
	case bazelinvocation.FieldExitCodeName:
		return m.ExitCodeName()
	case bazelinvocation.FieldExitCodeCode:
		return m.ExitCodeCode()
	case bazelinvocation.FieldCommandLineCommand:
		return m.CommandLineCommand()
	case bazelinvocation.FieldCommandLineExecutable:
		return m.CommandLineExecutable()
	case bazelinvocation.FieldCommandLineResidual:
		return m.CommandLineResidual()
	case bazelinvocation.FieldCommandLine:
		return m.CommandLine()
	case bazelinvocation.FieldExplicitCommandLine:
		return m.ExplicitCommandLine()
	case bazelinvocation.FieldStartupOptions:
		return m.StartupOptions()
	case bazelinvocation.FieldExplicitStartupOptions:
		return m.ExplicitStartupOptions()
	case bazelinvocation.FieldProcessedEventStarted:
		return m.ProcessedEventStarted()
	case bazelinvocation.FieldProcessedEventBuildMetadata:
		return m.ProcessedEventBuildMetadata()
	case bazelinvocation.FieldProcessedEventOptionsParsed:
		return m.ProcessedEventOptionsParsed()
	case bazelinvocation.FieldProcessedEventBuildFinished:
		return m.ProcessedEventBuildFinished()
	case bazelinvocation.FieldProcessedEventStructuredCommandLine:
		return m.ProcessedEventStructuredCommandLine()
	case bazelinvocation.FieldProcessedEventWorkspaceStatus:
		return m.ProcessedEventWorkspaceStatus()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BazelInvocationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bazelinvocation.FieldInvocationID:
		return m.OldInvocationID(ctx)
	case bazelinvocation.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case bazelinvocation.FieldEndedAt:
		return m.OldEndedAt(ctx)
	case bazelinvocation.FieldChangeNumber:
		return m.OldChangeNumber(ctx)
	case bazelinvocation.FieldPatchsetNumber:
		return m.OldPatchsetNumber(ctx)
	case bazelinvocation.FieldBepCompleted:
		return m.OldBepCompleted(ctx)
	case bazelinvocation.FieldStepLabel:
		return m.OldStepLabel(ctx)
	case bazelinvocation.FieldUserEmail:
		return m.OldUserEmail(ctx)
	case bazelinvocation.FieldUserLdap:
		return m.OldUserLdap(ctx)
	case bazelinvocation.FieldHostname:
		return m.OldHostname(ctx)
	case bazelinvocation.FieldIsCiWorker:
		return m.OldIsCiWorker(ctx)
	case bazelinvocation.FieldNumFetches:
		return m.OldNumFetches(ctx)
	case bazelinvocation.FieldProfileName:
		return m.OldProfileName(ctx)
	case bazelinvocation.FieldBazelVersion:
		return m.OldBazelVersion(ctx)
	case bazelinvocation.FieldExitCodeName:
		return m.OldExitCodeName(ctx)
	case bazelinvocation.FieldExitCodeCode:
		return m.OldExitCodeCode(ctx)
	case bazelinvocation.FieldCommandLineCommand:
		return m.OldCommandLineCommand(ctx)
	case bazelinvocation.FieldCommandLineExecutable:
		return m.OldCommandLineExecutable(ctx)
	case bazelinvocation.FieldCommandLineResidual:
		return m.OldCommandLineResidual(ctx)
	case bazelinvocation.FieldCommandLine:
		return m.OldCommandLine(ctx)
	case bazelinvocation.FieldExplicitCommandLine:
		return m.OldExplicitCommandLine(ctx)
	case bazelinvocation.FieldStartupOptions:
		return m.OldStartupOptions(ctx)
	case bazelinvocation.FieldExplicitStartupOptions:
		return m.OldExplicitStartupOptions(ctx)
	case bazelinvocation.FieldProcessedEventStarted:
		return m.OldProcessedEventStarted(ctx)
	case bazelinvocation.FieldProcessedEventBuildMetadata:
		return m.OldProcessedEventBuildMetadata(ctx)
	case bazelinvocation.FieldProcessedEventOptionsParsed:
		return m.OldProcessedEventOptionsParsed(ctx)
	case bazelinvocation.FieldProcessedEventBuildFinished:
		return m.OldProcessedEventBuildFinished(ctx)
	case bazelinvocation.FieldProcessedEventStructuredCommandLine:
		return m.OldProcessedEventStructuredCommandLine(ctx)
	case bazelinvocation.FieldProcessedEventWorkspaceStatus:
		return m.OldProcessedEventWorkspaceStatus(ctx)
	}
	return nil, fmt.Errorf("unknown BazelInvocation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BazelInvocationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bazelinvocation.FieldInvocationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvocationID(v)
		return nil
	case bazelinvocation.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case bazelinvocation.FieldEndedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndedAt(v)
		return nil
	case bazelinvocation.FieldChangeNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChangeNumber(v)
		return nil
	case bazelinvocation.FieldPatchsetNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatchsetNumber(v)
		return nil
	case bazelinvocation.FieldBepCompleted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBepCompleted(v)
		return nil
	case bazelinvocation.FieldStepLabel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStepLabel(v)
		return nil
	case bazelinvocation.FieldUserEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserEmail(v)
		return nil
	case bazelinvocation.FieldUserLdap:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserLdap(v)
		return nil
	case bazelinvocation.FieldHostname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHostname(v)
		return nil
	case bazelinvocation.FieldIsCiWorker:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsCiWorker(v)
		return nil
	case bazelinvocation.FieldNumFetches:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumFetches(v)
		return nil
	case bazelinvocation.FieldProfileName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfileName(v)
		return nil
	case bazelinvocation.FieldBazelVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBazelVersion(v)
		return nil
	case bazelinvocation.FieldExitCodeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExitCodeName(v)
		return nil
	case bazelinvocation.FieldExitCodeCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExitCodeCode(v)
		return nil
	case bazelinvocation.FieldCommandLineCommand:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommandLineCommand(v)
		return nil
	case bazelinvocation.FieldCommandLineExecutable:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommandLineExecutable(v)
		return nil
	case bazelinvocation.FieldCommandLineResidual:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommandLineResidual(v)
		return nil
	case bazelinvocation.FieldCommandLine:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommandLine(v)
		return nil
	case bazelinvocation.FieldExplicitCommandLine:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExplicitCommandLine(v)
		return nil
	case bazelinvocation.FieldStartupOptions:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartupOptions(v)
		return nil
	case bazelinvocation.FieldExplicitStartupOptions:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExplicitStartupOptions(v)
		return nil
	case bazelinvocation.FieldProcessedEventStarted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessedEventStarted(v)
		return nil
	case bazelinvocation.FieldProcessedEventBuildMetadata:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessedEventBuildMetadata(v)
		return nil
	case bazelinvocation.FieldProcessedEventOptionsParsed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessedEventOptionsParsed(v)
		return nil
	case bazelinvocation.FieldProcessedEventBuildFinished:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessedEventBuildFinished(v)
		return nil
	case bazelinvocation.FieldProcessedEventStructuredCommandLine:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessedEventStructuredCommandLine(v)
		return nil
	case bazelinvocation.FieldProcessedEventWorkspaceStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessedEventWorkspaceStatus(v)
		return nil
	}
	return fmt.Errorf("unknown BazelInvocation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BazelInvocationMutation) AddedFields() []string {
	var fields []string
	if m.addchange_number != nil {
		fields = append(fields, bazelinvocation.FieldChangeNumber)
	}
	if m.addpatchset_number != nil {
		fields = append(fields, bazelinvocation.FieldPatchsetNumber)
	}
	if m.addnum_fetches != nil {
		fields = append(fields, bazelinvocation.FieldNumFetches)
	}
	if m.addexit_code_code != nil {
		fields = append(fields, bazelinvocation.FieldExitCodeCode)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BazelInvocationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case bazelinvocation.FieldChangeNumber:
		return m.AddedChangeNumber()
	case bazelinvocation.FieldPatchsetNumber:
		return m.AddedPatchsetNumber()
	case bazelinvocation.FieldNumFetches:
		return m.AddedNumFetches()
	case bazelinvocation.FieldExitCodeCode:
		return m.AddedExitCodeCode()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BazelInvocationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case bazelinvocation.FieldChangeNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChangeNumber(v)
		return nil
	case bazelinvocation.FieldPatchsetNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPatchsetNumber(v)
		return nil
	case bazelinvocation.FieldNumFetches:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumFetches(v)
		return nil
	case bazelinvocation.FieldExitCodeCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExitCodeCode(v)
		return nil
	}
	return fmt.Errorf("unknown BazelInvocation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BazelInvocationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(bazelinvocation.FieldStartedAt) {
		fields = append(fields, bazelinvocation.FieldStartedAt)
	}
	if m.FieldCleared(bazelinvocation.FieldEndedAt) {
		fields = append(fields, bazelinvocation.FieldEndedAt)
	}
	if m.FieldCleared(bazelinvocation.FieldChangeNumber) {
		fields = append(fields, bazelinvocation.FieldChangeNumber)
	}
	if m.FieldCleared(bazelinvocation.FieldPatchsetNumber) {
		fields = append(fields, bazelinvocation.FieldPatchsetNumber)
	}
	if m.FieldCleared(bazelinvocation.FieldStepLabel) {
		fields = append(fields, bazelinvocation.FieldStepLabel)
	}
	if m.FieldCleared(bazelinvocation.FieldUserEmail) {
		fields = append(fields, bazelinvocation.FieldUserEmail)
	}
	if m.FieldCleared(bazelinvocation.FieldUserLdap) {
		fields = append(fields, bazelinvocation.FieldUserLdap)
	}
	if m.FieldCleared(bazelinvocation.FieldHostname) {
		fields = append(fields, bazelinvocation.FieldHostname)
	}
	if m.FieldCleared(bazelinvocation.FieldIsCiWorker) {
		fields = append(fields, bazelinvocation.FieldIsCiWorker)
	}
	if m.FieldCleared(bazelinvocation.FieldNumFetches) {
		fields = append(fields, bazelinvocation.FieldNumFetches)
	}
	if m.FieldCleared(bazelinvocation.FieldProfileName) {
		fields = append(fields, bazelinvocation.FieldProfileName)
	}
	if m.FieldCleared(bazelinvocation.FieldBazelVersion) {
		fields = append(fields, bazelinvocation.FieldBazelVersion)
	}
	if m.FieldCleared(bazelinvocation.FieldExitCodeName) {
		fields = append(fields, bazelinvocation.FieldExitCodeName)
	}
	if m.FieldCleared(bazelinvocation.FieldExitCodeCode) {
		fields = append(fields, bazelinvocation.FieldExitCodeCode)
	}
	if m.FieldCleared(bazelinvocation.FieldCommandLineCommand) {
		fields = append(fields, bazelinvocation.FieldCommandLineCommand)
	}
	if m.FieldCleared(bazelinvocation.FieldCommandLineExecutable) {
		fields = append(fields, bazelinvocation.FieldCommandLineExecutable)
	}
	if m.FieldCleared(bazelinvocation.FieldCommandLineResidual) {
		fields = append(fields, bazelinvocation.FieldCommandLineResidual)
	}
	if m.FieldCleared(bazelinvocation.FieldCommandLine) {
		fields = append(fields, bazelinvocation.FieldCommandLine)
	}
	if m.FieldCleared(bazelinvocation.FieldExplicitCommandLine) {
		fields = append(fields, bazelinvocation.FieldExplicitCommandLine)
	}
	if m.FieldCleared(bazelinvocation.FieldStartupOptions) {
		fields = append(fields, bazelinvocation.FieldStartupOptions)
	}
	if m.FieldCleared(bazelinvocation.FieldExplicitStartupOptions) {
		fields = append(fields, bazelinvocation.FieldExplicitStartupOptions)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BazelInvocationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BazelInvocationMutation) ClearField(name string) error {
	switch name {
	case bazelinvocation.FieldStartedAt:
		m.ClearStartedAt()
		return nil
	case bazelinvocation.FieldEndedAt:
		m.ClearEndedAt()
		return nil
	case bazelinvocation.FieldChangeNumber:
		m.ClearChangeNumber()
		return nil
	case bazelinvocation.FieldPatchsetNumber:
		m.ClearPatchsetNumber()
		return nil
	case bazelinvocation.FieldStepLabel:
		m.ClearStepLabel()
		return nil
	case bazelinvocation.FieldUserEmail:
		m.ClearUserEmail()
		return nil
	case bazelinvocation.FieldUserLdap:
		m.ClearUserLdap()
		return nil
	case bazelinvocation.FieldHostname:
		m.ClearHostname()
		return nil
	case bazelinvocation.FieldIsCiWorker:
		m.ClearIsCiWorker()
		return nil
	case bazelinvocation.FieldNumFetches:
		m.ClearNumFetches()
		return nil
	case bazelinvocation.FieldProfileName:
		m.ClearProfileName()
		return nil
	case bazelinvocation.FieldBazelVersion:
		m.ClearBazelVersion()
		return nil
	case bazelinvocation.FieldExitCodeName:
		m.ClearExitCodeName()
		return nil
	case bazelinvocation.FieldExitCodeCode:
		m.ClearExitCodeCode()
		return nil
	case bazelinvocation.FieldCommandLineCommand:
		m.ClearCommandLineCommand()
		return nil
	case bazelinvocation.FieldCommandLineExecutable:
		m.ClearCommandLineExecutable()
		return nil
	case bazelinvocation.FieldCommandLineResidual:
		m.ClearCommandLineResidual()
		return nil
	case bazelinvocation.FieldCommandLine:
		m.ClearCommandLine()
		return nil
	case bazelinvocation.FieldExplicitCommandLine:
		m.ClearExplicitCommandLine()
		return nil
	case bazelinvocation.FieldStartupOptions:
		m.ClearStartupOptions()
		return nil
	case bazelinvocation.FieldExplicitStartupOptions:
		m.ClearExplicitStartupOptions()
		return nil
	}
	return fmt.Errorf("unknown BazelInvocation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BazelInvocationMutation) ResetField(name string) error {
	switch name {
	case bazelinvocation.FieldInvocationID:
		m.ResetInvocationID()
		return nil
	case bazelinvocation.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case bazelinvocation.FieldEndedAt:
		m.ResetEndedAt()
		return nil
	case bazelinvocation.FieldChangeNumber:
		m.ResetChangeNumber()
		return nil
	case bazelinvocation.FieldPatchsetNumber:
		m.ResetPatchsetNumber()
		return nil
	case bazelinvocation.FieldBepCompleted:
		m.ResetBepCompleted()
		return nil
	case bazelinvocation.FieldStepLabel:
		m.ResetStepLabel()
		return nil
	case bazelinvocation.FieldUserEmail:
		m.ResetUserEmail()
		return nil
	case bazelinvocation.FieldUserLdap:
		m.ResetUserLdap()
		return nil
	case bazelinvocation.FieldHostname:
		m.ResetHostname()
		return nil
	case bazelinvocation.FieldIsCiWorker:
		m.ResetIsCiWorker()
		return nil
	case bazelinvocation.FieldNumFetches:
		m.ResetNumFetches()
		return nil
	case bazelinvocation.FieldProfileName:
		m.ResetProfileName()
		return nil
	case bazelinvocation.FieldBazelVersion:
		m.ResetBazelVersion()
		return nil
	case bazelinvocation.FieldExitCodeName:
		m.ResetExitCodeName()
		return nil
	case bazelinvocation.FieldExitCodeCode:
		m.ResetExitCodeCode()
		return nil
	case bazelinvocation.FieldCommandLineCommand:
		m.ResetCommandLineCommand()
		return nil
	case bazelinvocation.FieldCommandLineExecutable:
		m.ResetCommandLineExecutable()
		return nil
	case bazelinvocation.FieldCommandLineResidual:
		m.ResetCommandLineResidual()
		return nil
	case bazelinvocation.FieldCommandLine:
		m.ResetCommandLine()
		return nil
	case bazelinvocation.FieldExplicitCommandLine:
		m.ResetExplicitCommandLine()
		return nil
	case bazelinvocation.FieldStartupOptions:
		m.ResetStartupOptions()
		return nil
	case bazelinvocation.FieldExplicitStartupOptions:
		m.ResetExplicitStartupOptions()
		return nil
	case bazelinvocation.FieldProcessedEventStarted:
		m.ResetProcessedEventStarted()
		return nil
	case bazelinvocation.FieldProcessedEventBuildMetadata:
		m.ResetProcessedEventBuildMetadata()
		return nil
	case bazelinvocation.FieldProcessedEventOptionsParsed:
		m.ResetProcessedEventOptionsParsed()
		return nil
	case bazelinvocation.FieldProcessedEventBuildFinished:
		m.ResetProcessedEventBuildFinished()
		return nil
	case bazelinvocation.FieldProcessedEventStructuredCommandLine:
		m.ResetProcessedEventStructuredCommandLine()
		return nil
	case bazelinvocation.FieldProcessedEventWorkspaceStatus:
		m.ResetProcessedEventWorkspaceStatus()
		return nil
	}
	return fmt.Errorf("unknown BazelInvocation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BazelInvocationMutation) AddedEdges() []string {
	edges := make([]string, 0, 14)
	if m.instance_name != nil {
		edges = append(edges, bazelinvocation.EdgeInstanceName)
	}
	if m.build != nil {
		edges = append(edges, bazelinvocation.EdgeBuild)
	}
	if m.authenticated_user != nil {
		edges = append(edges, bazelinvocation.EdgeAuthenticatedUser)
	}
	if m.event_metadata != nil {
		edges = append(edges, bazelinvocation.EdgeEventMetadata)
	}
	if m.connection_metadata != nil {
		edges = append(edges, bazelinvocation.EdgeConnectionMetadata)
	}
	if m.configurations != nil {
		edges = append(edges, bazelinvocation.EdgeConfigurations)
	}
	if m.actions != nil {
		edges = append(edges, bazelinvocation.EdgeActions)
	}
	if m.metrics != nil {
		edges = append(edges, bazelinvocation.EdgeMetrics)
	}
	if m.incomplete_build_logs != nil {
		edges = append(edges, bazelinvocation.EdgeIncompleteBuildLogs)
	}
	if m.build_log_chunks != nil {
		edges = append(edges, bazelinvocation.EdgeBuildLogChunks)
	}
	if m.invocation_files != nil {
		edges = append(edges, bazelinvocation.EdgeInvocationFiles)
	}
	if m.invocation_targets != nil {
		edges = append(edges, bazelinvocation.EdgeInvocationTargets)
	}
	if m.target_kind_mappings != nil {
		edges = append(edges, bazelinvocation.EdgeTargetKindMappings)
	}
	if m.source_control != nil {
		edges = append(edges, bazelinvocation.EdgeSourceControl)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BazelInvocationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bazelinvocation.EdgeInstanceName:
		if id := m.instance_name; id != nil {
			return []ent.Value{*id}
		}
	case bazelinvocation.EdgeBuild:
		if id := m.build; id != nil {
			return []ent.Value{*id}
		}
	case bazelinvocation.EdgeAuthenticatedUser:
		if id := m.authenticated_user; id != nil {
			return []ent.Value{*id}
		}
	case bazelinvocation.EdgeEventMetadata:
		if id := m.event_metadata; id != nil {
			return []ent.Value{*id}
		}
	case bazelinvocation.EdgeConnectionMetadata:
		ids := make([]ent.Value, 0, len(m.connection_metadata))
		for id := range m.connection_metadata {
			ids = append(ids, id)
		}
		return ids
	case bazelinvocation.EdgeConfigurations:
		ids := make([]ent.Value, 0, len(m.configurations))
		for id := range m.configurations {
			ids = append(ids, id)
		}
		return ids
	case bazelinvocation.EdgeActions:
		ids := make([]ent.Value, 0, len(m.actions))
		for id := range m.actions {
			ids = append(ids, id)
		}
		return ids
	case bazelinvocation.EdgeMetrics:
		if id := m.metrics; id != nil {
			return []ent.Value{*id}
		}
	case bazelinvocation.EdgeIncompleteBuildLogs:
		ids := make([]ent.Value, 0, len(m.incomplete_build_logs))
		for id := range m.incomplete_build_logs {
			ids = append(ids, id)
		}
		return ids
	case bazelinvocation.EdgeBuildLogChunks:
		ids := make([]ent.Value, 0, len(m.build_log_chunks))
		for id := range m.build_log_chunks {
			ids = append(ids, id)
		}
		return ids
	case bazelinvocation.EdgeInvocationFiles:
		ids := make([]ent.Value, 0, len(m.invocation_files))
		for id := range m.invocation_files {
			ids = append(ids, id)
		}
		return ids
	case bazelinvocation.EdgeInvocationTargets:
		ids := make([]ent.Value, 0, len(m.invocation_targets))
		for id := range m.invocation_targets {
			ids = append(ids, id)
		}
		return ids
	case bazelinvocation.EdgeTargetKindMappings:
		ids := make([]ent.Value, 0, len(m.target_kind_mappings))
		for id := range m.target_kind_mappings {
			ids = append(ids, id)
		}
		return ids
	case bazelinvocation.EdgeSourceControl:
		if id := m.source_control; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BazelInvocationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 14)
	if m.removedconnection_metadata != nil {
		edges = append(edges, bazelinvocation.EdgeConnectionMetadata)
	}
	if m.removedconfigurations != nil {
		edges = append(edges, bazelinvocation.EdgeConfigurations)
	}
	if m.removedactions != nil {
		edges = append(edges, bazelinvocation.EdgeActions)
	}
	if m.removedincomplete_build_logs != nil {
		edges = append(edges, bazelinvocation.EdgeIncompleteBuildLogs)
	}
	if m.removedbuild_log_chunks != nil {
		edges = append(edges, bazelinvocation.EdgeBuildLogChunks)
	}
	if m.removedinvocation_files != nil {
		edges = append(edges, bazelinvocation.EdgeInvocationFiles)
	}
	if m.removedinvocation_targets != nil {
		edges = append(edges, bazelinvocation.EdgeInvocationTargets)
	}
	if m.removedtarget_kind_mappings != nil {
		edges = append(edges, bazelinvocation.EdgeTargetKindMappings)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BazelInvocationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case bazelinvocation.EdgeConnectionMetadata:
		ids := make([]ent.Value, 0, len(m.removedconnection_metadata))
		for id := range m.removedconnection_metadata {
			ids = append(ids, id)
		}
		return ids
	case bazelinvocation.EdgeConfigurations:
		ids := make([]ent.Value, 0, len(m.removedconfigurations))
		for id := range m.removedconfigurations {
			ids = append(ids, id)
		}
		return ids
	case bazelinvocation.EdgeActions:
		ids := make([]ent.Value, 0, len(m.removedactions))
		for id := range m.removedactions {
			ids = append(ids, id)
		}
		return ids
	case bazelinvocation.EdgeIncompleteBuildLogs:
		ids := make([]ent.Value, 0, len(m.removedincomplete_build_logs))
		for id := range m.removedincomplete_build_logs {
			ids = append(ids, id)
		}
		return ids
	case bazelinvocation.EdgeBuildLogChunks:
		ids := make([]ent.Value, 0, len(m.removedbuild_log_chunks))
		for id := range m.removedbuild_log_chunks {
			ids = append(ids, id)
		}
		return ids
	case bazelinvocation.EdgeInvocationFiles:
		ids := make([]ent.Value, 0, len(m.removedinvocation_files))
		for id := range m.removedinvocation_files {
			ids = append(ids, id)
		}
		return ids
	case bazelinvocation.EdgeInvocationTargets:
		ids := make([]ent.Value, 0, len(m.removedinvocation_targets))
		for id := range m.removedinvocation_targets {
			ids = append(ids, id)
		}
		return ids
	case bazelinvocation.EdgeTargetKindMappings:
		ids := make([]ent.Value, 0, len(m.removedtarget_kind_mappings))
		for id := range m.removedtarget_kind_mappings {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BazelInvocationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 14)
	if m.clearedinstance_name {
		edges = append(edges, bazelinvocation.EdgeInstanceName)
	}
	if m.clearedbuild {
		edges = append(edges, bazelinvocation.EdgeBuild)
	}
	if m.clearedauthenticated_user {
		edges = append(edges, bazelinvocation.EdgeAuthenticatedUser)
	}
	if m.clearedevent_metadata {
		edges = append(edges, bazelinvocation.EdgeEventMetadata)
	}
	if m.clearedconnection_metadata {
		edges = append(edges, bazelinvocation.EdgeConnectionMetadata)
	}
	if m.clearedconfigurations {
		edges = append(edges, bazelinvocation.EdgeConfigurations)
	}
	if m.clearedactions {
		edges = append(edges, bazelinvocation.EdgeActions)
	}
	if m.clearedmetrics {
		edges = append(edges, bazelinvocation.EdgeMetrics)
	}
	if m.clearedincomplete_build_logs {
		edges = append(edges, bazelinvocation.EdgeIncompleteBuildLogs)
	}
	if m.clearedbuild_log_chunks {
		edges = append(edges, bazelinvocation.EdgeBuildLogChunks)
	}
	if m.clearedinvocation_files {
		edges = append(edges, bazelinvocation.EdgeInvocationFiles)
	}
	if m.clearedinvocation_targets {
		edges = append(edges, bazelinvocation.EdgeInvocationTargets)
	}
	if m.clearedtarget_kind_mappings {
		edges = append(edges, bazelinvocation.EdgeTargetKindMappings)
	}
	if m.clearedsource_control {
		edges = append(edges, bazelinvocation.EdgeSourceControl)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BazelInvocationMutation) EdgeCleared(name string) bool {
	switch name {
	case bazelinvocation.EdgeInstanceName:
		return m.clearedinstance_name
	case bazelinvocation.EdgeBuild:
		return m.clearedbuild
	case bazelinvocation.EdgeAuthenticatedUser:
		return m.clearedauthenticated_user
	case bazelinvocation.EdgeEventMetadata:
		return m.clearedevent_metadata
	case bazelinvocation.EdgeConnectionMetadata:
		return m.clearedconnection_metadata
	case bazelinvocation.EdgeConfigurations:
		return m.clearedconfigurations
	case bazelinvocation.EdgeActions:
		return m.clearedactions
	case bazelinvocation.EdgeMetrics:
		return m.clearedmetrics
	case bazelinvocation.EdgeIncompleteBuildLogs:
		return m.clearedincomplete_build_logs
	case bazelinvocation.EdgeBuildLogChunks:
		return m.clearedbuild_log_chunks
	case bazelinvocation.EdgeInvocationFiles:
		return m.clearedinvocation_files
	case bazelinvocation.EdgeInvocationTargets:
		return m.clearedinvocation_targets
	case bazelinvocation.EdgeTargetKindMappings:
		return m.clearedtarget_kind_mappings
	case bazelinvocation.EdgeSourceControl:
		return m.clearedsource_control
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BazelInvocationMutation) ClearEdge(name string) error {
	switch name {
	case bazelinvocation.EdgeInstanceName:
		m.ClearInstanceName()
		return nil
	case bazelinvocation.EdgeBuild:
		m.ClearBuild()
		return nil
	case bazelinvocation.EdgeAuthenticatedUser:
		m.ClearAuthenticatedUser()
		return nil
	case bazelinvocation.EdgeEventMetadata:
		m.ClearEventMetadata()
		return nil
	case bazelinvocation.EdgeMetrics:
		m.ClearMetrics()
		return nil
	case bazelinvocation.EdgeSourceControl:
		m.ClearSourceControl()
		return nil
	}
	return fmt.Errorf("unknown BazelInvocation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BazelInvocationMutation) ResetEdge(name string) error {
	switch name {
	case bazelinvocation.EdgeInstanceName:
		m.ResetInstanceName()
		return nil
	case bazelinvocation.EdgeBuild:
		m.ResetBuild()
		return nil
	case bazelinvocation.EdgeAuthenticatedUser:
		m.ResetAuthenticatedUser()
		return nil
	case bazelinvocation.EdgeEventMetadata:
		m.ResetEventMetadata()
		return nil
	case bazelinvocation.EdgeConnectionMetadata:
		m.ResetConnectionMetadata()
		return nil
	case bazelinvocation.EdgeConfigurations:
		m.ResetConfigurations()
		return nil
	case bazelinvocation.EdgeActions:
		m.ResetActions()
		return nil
	case bazelinvocation.EdgeMetrics:
		m.ResetMetrics()
		return nil
	case bazelinvocation.EdgeIncompleteBuildLogs:
		m.ResetIncompleteBuildLogs()
		return nil
	case bazelinvocation.EdgeBuildLogChunks:
		m.ResetBuildLogChunks()
		return nil
	case bazelinvocation.EdgeInvocationFiles:
		m.ResetInvocationFiles()
		return nil
	case bazelinvocation.EdgeInvocationTargets:
		m.ResetInvocationTargets()
		return nil
	case bazelinvocation.EdgeTargetKindMappings:
		m.ResetTargetKindMappings()
		return nil
	case bazelinvocation.EdgeSourceControl:
		m.ResetSourceControl()
		return nil
	}
	return fmt.Errorf("unknown BazelInvocation edge %s", name)
}

// BuildMutation represents an operation that mutates the Build nodes in the graph.
type BuildMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int64
	build_url            *string
	build_uuid           *uuid.UUID
	timestamp            *time.Time
	clearedFields        map[string]struct{}
	instance_name        *int64
	clearedinstance_name bool
	invocations          map[int64]struct{}
	removedinvocations   map[int64]struct{}
	clearedinvocations   bool
	done                 bool
	oldValue             func(context.Context) (*Build, error)
	predicates           []predicate.Build
}

var _ ent.Mutation = (*BuildMutation)(nil)

// buildOption allows management of the mutation configuration using functional options.
type buildOption func(*BuildMutation)

// newBuildMutation creates new mutation for the Build entity.
func newBuildMutation(c config, op Op, opts ...buildOption) *BuildMutation {
	m := &BuildMutation{
		config:        c,
		op:            op,
		typ:           TypeBuild,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBuildID sets the ID field of the mutation.
func withBuildID(id int64) buildOption {
	return func(m *BuildMutation) {
		var (
			err   error
			once  sync.Once
			value *Build
		)
		m.oldValue = func(ctx context.Context) (*Build, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Build.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBuild sets the old Build of the mutation.
func withBuild(node *Build) buildOption {
	return func(m *BuildMutation) {
		m.oldValue = func(context.Context) (*Build, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BuildMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BuildMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Build entities.
func (m *BuildMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BuildMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BuildMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Build.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBuildURL sets the "build_url" field.
func (m *BuildMutation) SetBuildURL(s string) {
	m.build_url = &s
}

// BuildURL returns the value of the "build_url" field in the mutation.
func (m *BuildMutation) BuildURL() (r string, exists bool) {
	v := m.build_url
	if v == nil {
		return
	}
	return *v, true
}

// OldBuildURL returns the old "build_url" field's value of the Build entity.
// If the Build object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuildMutation) OldBuildURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBuildURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBuildURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBuildURL: %w", err)
	}
	return oldValue.BuildURL, nil
}

// ResetBuildURL resets all changes to the "build_url" field.
func (m *BuildMutation) ResetBuildURL() {
	m.build_url = nil
}

// SetBuildUUID sets the "build_uuid" field.
func (m *BuildMutation) SetBuildUUID(u uuid.UUID) {
	m.build_uuid = &u
}

// BuildUUID returns the value of the "build_uuid" field in the mutation.
func (m *BuildMutation) BuildUUID() (r uuid.UUID, exists bool) {
	v := m.build_uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldBuildUUID returns the old "build_uuid" field's value of the Build entity.
// If the Build object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuildMutation) OldBuildUUID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBuildUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBuildUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBuildUUID: %w", err)
	}
	return oldValue.BuildUUID, nil
}

// ResetBuildUUID resets all changes to the "build_uuid" field.
func (m *BuildMutation) ResetBuildUUID() {
	m.build_uuid = nil
}

// SetTimestamp sets the "timestamp" field.
func (m *BuildMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *BuildMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the Build entity.
// If the Build object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuildMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *BuildMutation) ResetTimestamp() {
	m.timestamp = nil
}

// SetInstanceNameID sets the "instance_name" edge to the InstanceName entity by id.
func (m *BuildMutation) SetInstanceNameID(id int64) {
	m.instance_name = &id
}

// ClearInstanceName clears the "instance_name" edge to the InstanceName entity.
func (m *BuildMutation) ClearInstanceName() {
	m.clearedinstance_name = true
}

// InstanceNameCleared reports if the "instance_name" edge to the InstanceName entity was cleared.
func (m *BuildMutation) InstanceNameCleared() bool {
	return m.clearedinstance_name
}

// InstanceNameID returns the "instance_name" edge ID in the mutation.
func (m *BuildMutation) InstanceNameID() (id int64, exists bool) {
	if m.instance_name != nil {
		return *m.instance_name, true
	}
	return
}

// InstanceNameIDs returns the "instance_name" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InstanceNameID instead. It exists only for internal usage by the builders.
func (m *BuildMutation) InstanceNameIDs() (ids []int64) {
	if id := m.instance_name; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInstanceName resets all changes to the "instance_name" edge.
func (m *BuildMutation) ResetInstanceName() {
	m.instance_name = nil
	m.clearedinstance_name = false
}

// AddInvocationIDs adds the "invocations" edge to the BazelInvocation entity by ids.
func (m *BuildMutation) AddInvocationIDs(ids ...int64) {
	if m.invocations == nil {
		m.invocations = make(map[int64]struct{})
	}
	for i := range ids {
		m.invocations[ids[i]] = struct{}{}
	}
}

// ClearInvocations clears the "invocations" edge to the BazelInvocation entity.
func (m *BuildMutation) ClearInvocations() {
	m.clearedinvocations = true
}

// InvocationsCleared reports if the "invocations" edge to the BazelInvocation entity was cleared.
func (m *BuildMutation) InvocationsCleared() bool {
	return m.clearedinvocations
}

// RemoveInvocationIDs removes the "invocations" edge to the BazelInvocation entity by IDs.
func (m *BuildMutation) RemoveInvocationIDs(ids ...int64) {
	if m.removedinvocations == nil {
		m.removedinvocations = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.invocations, ids[i])
		m.removedinvocations[ids[i]] = struct{}{}
	}
}

// RemovedInvocations returns the removed IDs of the "invocations" edge to the BazelInvocation entity.
func (m *BuildMutation) RemovedInvocationsIDs() (ids []int64) {
	for id := range m.removedinvocations {
		ids = append(ids, id)
	}
	return
}

// InvocationsIDs returns the "invocations" edge IDs in the mutation.
func (m *BuildMutation) InvocationsIDs() (ids []int64) {
	for id := range m.invocations {
		ids = append(ids, id)
	}
	return
}

// ResetInvocations resets all changes to the "invocations" edge.
func (m *BuildMutation) ResetInvocations() {
	m.invocations = nil
	m.clearedinvocations = false
	m.removedinvocations = nil
}

// Where appends a list predicates to the BuildMutation builder.
func (m *BuildMutation) Where(ps ...predicate.Build) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BuildMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BuildMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Build, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BuildMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BuildMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Build).
func (m *BuildMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BuildMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.build_url != nil {
		fields = append(fields, build.FieldBuildURL)
	}
	if m.build_uuid != nil {
		fields = append(fields, build.FieldBuildUUID)
	}
	if m.timestamp != nil {
		fields = append(fields, build.FieldTimestamp)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BuildMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case build.FieldBuildURL:
		return m.BuildURL()
	case build.FieldBuildUUID:
		return m.BuildUUID()
	case build.FieldTimestamp:
		return m.Timestamp()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BuildMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case build.FieldBuildURL:
		return m.OldBuildURL(ctx)
	case build.FieldBuildUUID:
		return m.OldBuildUUID(ctx)
	case build.FieldTimestamp:
		return m.OldTimestamp(ctx)
	}
	return nil, fmt.Errorf("unknown Build field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BuildMutation) SetField(name string, value ent.Value) error {
	switch name {
	case build.FieldBuildURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBuildURL(v)
		return nil
	case build.FieldBuildUUID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBuildUUID(v)
		return nil
	case build.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	}
	return fmt.Errorf("unknown Build field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BuildMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BuildMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BuildMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Build numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BuildMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BuildMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BuildMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Build nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BuildMutation) ResetField(name string) error {
	switch name {
	case build.FieldBuildURL:
		m.ResetBuildURL()
		return nil
	case build.FieldBuildUUID:
		m.ResetBuildUUID()
		return nil
	case build.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	}
	return fmt.Errorf("unknown Build field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BuildMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.instance_name != nil {
		edges = append(edges, build.EdgeInstanceName)
	}
	if m.invocations != nil {
		edges = append(edges, build.EdgeInvocations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BuildMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case build.EdgeInstanceName:
		if id := m.instance_name; id != nil {
			return []ent.Value{*id}
		}
	case build.EdgeInvocations:
		ids := make([]ent.Value, 0, len(m.invocations))
		for id := range m.invocations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BuildMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedinvocations != nil {
		edges = append(edges, build.EdgeInvocations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BuildMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case build.EdgeInvocations:
		ids := make([]ent.Value, 0, len(m.removedinvocations))
		for id := range m.removedinvocations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BuildMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedinstance_name {
		edges = append(edges, build.EdgeInstanceName)
	}
	if m.clearedinvocations {
		edges = append(edges, build.EdgeInvocations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BuildMutation) EdgeCleared(name string) bool {
	switch name {
	case build.EdgeInstanceName:
		return m.clearedinstance_name
	case build.EdgeInvocations:
		return m.clearedinvocations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BuildMutation) ClearEdge(name string) error {
	switch name {
	case build.EdgeInstanceName:
		m.ClearInstanceName()
		return nil
	}
	return fmt.Errorf("unknown Build unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BuildMutation) ResetEdge(name string) error {
	switch name {
	case build.EdgeInstanceName:
		m.ResetInstanceName()
		return nil
	case build.EdgeInvocations:
		m.ResetInvocations()
		return nil
	}
	return fmt.Errorf("unknown Build edge %s", name)
}

// BuildGraphMetricsMutation represents an operation that mutates the BuildGraphMetrics nodes in the graph.
type BuildGraphMetricsMutation struct {
	config
	op                                                 Op
	typ                                                string
	id                                                 *int64
	action_lookup_value_count                          *int32
	addaction_lookup_value_count                       *int32
	action_lookup_value_count_not_including_aspects    *int32
	addaction_lookup_value_count_not_including_aspects *int32
	action_count                                       *int32
	addaction_count                                    *int32
	action_count_not_including_aspects                 *int32
	addaction_count_not_including_aspects              *int32
	input_file_configured_target_count                 *int32
	addinput_file_configured_target_count              *int32
	output_file_configured_target_count                *int32
	addoutput_file_configured_target_count             *int32
	other_configured_target_count                      *int32
	addother_configured_target_count                   *int32
	output_artifact_count                              *int32
	addoutput_artifact_count                           *int32
	post_invocation_skyframe_node_count                *int32
	addpost_invocation_skyframe_node_count             *int32
	clearedFields                                      map[string]struct{}
	metrics                                            *int64
	clearedmetrics                                     bool
	dirtied_values                                     *int64
	cleareddirtied_values                              bool
	changed_values                                     *int64
	clearedchanged_values                              bool
	built_values                                       *int64
	clearedbuilt_values                                bool
	cleaned_values                                     *int64
	clearedcleaned_values                              bool
	evaluated_values                                   *int64
	clearedevaluated_values                            bool
	done                                               bool
	oldValue                                           func(context.Context) (*BuildGraphMetrics, error)
	predicates                                         []predicate.BuildGraphMetrics
}

var _ ent.Mutation = (*BuildGraphMetricsMutation)(nil)

// buildgraphmetricsOption allows management of the mutation configuration using functional options.
type buildgraphmetricsOption func(*BuildGraphMetricsMutation)

// newBuildGraphMetricsMutation creates new mutation for the BuildGraphMetrics entity.
func newBuildGraphMetricsMutation(c config, op Op, opts ...buildgraphmetricsOption) *BuildGraphMetricsMutation {
	m := &BuildGraphMetricsMutation{
		config:        c,
		op:            op,
		typ:           TypeBuildGraphMetrics,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBuildGraphMetricsID sets the ID field of the mutation.
func withBuildGraphMetricsID(id int64) buildgraphmetricsOption {
	return func(m *BuildGraphMetricsMutation) {
		var (
			err   error
			once  sync.Once
			value *BuildGraphMetrics
		)
		m.oldValue = func(ctx context.Context) (*BuildGraphMetrics, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BuildGraphMetrics.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBuildGraphMetrics sets the old BuildGraphMetrics of the mutation.
func withBuildGraphMetrics(node *BuildGraphMetrics) buildgraphmetricsOption {
	return func(m *BuildGraphMetricsMutation) {
		m.oldValue = func(context.Context) (*BuildGraphMetrics, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BuildGraphMetricsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BuildGraphMetricsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BuildGraphMetrics entities.
func (m *BuildGraphMetricsMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BuildGraphMetricsMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BuildGraphMetricsMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BuildGraphMetrics.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetActionLookupValueCount sets the "action_lookup_value_count" field.
func (m *BuildGraphMetricsMutation) SetActionLookupValueCount(i int32) {
	m.action_lookup_value_count = &i
	m.addaction_lookup_value_count = nil
}

// ActionLookupValueCount returns the value of the "action_lookup_value_count" field in the mutation.
func (m *BuildGraphMetricsMutation) ActionLookupValueCount() (r int32, exists bool) {
	v := m.action_lookup_value_count
	if v == nil {
		return
	}
	return *v, true
}

// OldActionLookupValueCount returns the old "action_lookup_value_count" field's value of the BuildGraphMetrics entity.
// If the BuildGraphMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuildGraphMetricsMutation) OldActionLookupValueCount(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActionLookupValueCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActionLookupValueCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActionLookupValueCount: %w", err)
	}
	return oldValue.ActionLookupValueCount, nil
}

// AddActionLookupValueCount adds i to the "action_lookup_value_count" field.
func (m *BuildGraphMetricsMutation) AddActionLookupValueCount(i int32) {
	if m.addaction_lookup_value_count != nil {
		*m.addaction_lookup_value_count += i
	} else {
		m.addaction_lookup_value_count = &i
	}
}

// AddedActionLookupValueCount returns the value that was added to the "action_lookup_value_count" field in this mutation.
func (m *BuildGraphMetricsMutation) AddedActionLookupValueCount() (r int32, exists bool) {
	v := m.addaction_lookup_value_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearActionLookupValueCount clears the value of the "action_lookup_value_count" field.
func (m *BuildGraphMetricsMutation) ClearActionLookupValueCount() {
	m.action_lookup_value_count = nil
	m.addaction_lookup_value_count = nil
	m.clearedFields[buildgraphmetrics.FieldActionLookupValueCount] = struct{}{}
}

// ActionLookupValueCountCleared returns if the "action_lookup_value_count" field was cleared in this mutation.
func (m *BuildGraphMetricsMutation) ActionLookupValueCountCleared() bool {
	_, ok := m.clearedFields[buildgraphmetrics.FieldActionLookupValueCount]
	return ok
}

// ResetActionLookupValueCount resets all changes to the "action_lookup_value_count" field.
func (m *BuildGraphMetricsMutation) ResetActionLookupValueCount() {
	m.action_lookup_value_count = nil
	m.addaction_lookup_value_count = nil
	delete(m.clearedFields, buildgraphmetrics.FieldActionLookupValueCount)
}

// SetActionLookupValueCountNotIncludingAspects sets the "action_lookup_value_count_not_including_aspects" field.
func (m *BuildGraphMetricsMutation) SetActionLookupValueCountNotIncludingAspects(i int32) {
	m.action_lookup_value_count_not_including_aspects = &i
	m.addaction_lookup_value_count_not_including_aspects = nil
}

// ActionLookupValueCountNotIncludingAspects returns the value of the "action_lookup_value_count_not_including_aspects" field in the mutation.
func (m *BuildGraphMetricsMutation) ActionLookupValueCountNotIncludingAspects() (r int32, exists bool) {
	v := m.action_lookup_value_count_not_including_aspects
	if v == nil {
		return
	}
	return *v, true
}

// OldActionLookupValueCountNotIncludingAspects returns the old "action_lookup_value_count_not_including_aspects" field's value of the BuildGraphMetrics entity.
// If the BuildGraphMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuildGraphMetricsMutation) OldActionLookupValueCountNotIncludingAspects(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActionLookupValueCountNotIncludingAspects is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActionLookupValueCountNotIncludingAspects requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActionLookupValueCountNotIncludingAspects: %w", err)
	}
	return oldValue.ActionLookupValueCountNotIncludingAspects, nil
}

// AddActionLookupValueCountNotIncludingAspects adds i to the "action_lookup_value_count_not_including_aspects" field.
func (m *BuildGraphMetricsMutation) AddActionLookupValueCountNotIncludingAspects(i int32) {
	if m.addaction_lookup_value_count_not_including_aspects != nil {
		*m.addaction_lookup_value_count_not_including_aspects += i
	} else {
		m.addaction_lookup_value_count_not_including_aspects = &i
	}
}

// AddedActionLookupValueCountNotIncludingAspects returns the value that was added to the "action_lookup_value_count_not_including_aspects" field in this mutation.
func (m *BuildGraphMetricsMutation) AddedActionLookupValueCountNotIncludingAspects() (r int32, exists bool) {
	v := m.addaction_lookup_value_count_not_including_aspects
	if v == nil {
		return
	}
	return *v, true
}

// ClearActionLookupValueCountNotIncludingAspects clears the value of the "action_lookup_value_count_not_including_aspects" field.
func (m *BuildGraphMetricsMutation) ClearActionLookupValueCountNotIncludingAspects() {
	m.action_lookup_value_count_not_including_aspects = nil
	m.addaction_lookup_value_count_not_including_aspects = nil
	m.clearedFields[buildgraphmetrics.FieldActionLookupValueCountNotIncludingAspects] = struct{}{}
}

// ActionLookupValueCountNotIncludingAspectsCleared returns if the "action_lookup_value_count_not_including_aspects" field was cleared in this mutation.
func (m *BuildGraphMetricsMutation) ActionLookupValueCountNotIncludingAspectsCleared() bool {
	_, ok := m.clearedFields[buildgraphmetrics.FieldActionLookupValueCountNotIncludingAspects]
	return ok
}

// ResetActionLookupValueCountNotIncludingAspects resets all changes to the "action_lookup_value_count_not_including_aspects" field.
func (m *BuildGraphMetricsMutation) ResetActionLookupValueCountNotIncludingAspects() {
	m.action_lookup_value_count_not_including_aspects = nil
	m.addaction_lookup_value_count_not_including_aspects = nil
	delete(m.clearedFields, buildgraphmetrics.FieldActionLookupValueCountNotIncludingAspects)
}

// SetActionCount sets the "action_count" field.
func (m *BuildGraphMetricsMutation) SetActionCount(i int32) {
	m.action_count = &i
	m.addaction_count = nil
}

// ActionCount returns the value of the "action_count" field in the mutation.
func (m *BuildGraphMetricsMutation) ActionCount() (r int32, exists bool) {
	v := m.action_count
	if v == nil {
		return
	}
	return *v, true
}

// OldActionCount returns the old "action_count" field's value of the BuildGraphMetrics entity.
// If the BuildGraphMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuildGraphMetricsMutation) OldActionCount(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActionCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActionCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActionCount: %w", err)
	}
	return oldValue.ActionCount, nil
}

// AddActionCount adds i to the "action_count" field.
func (m *BuildGraphMetricsMutation) AddActionCount(i int32) {
	if m.addaction_count != nil {
		*m.addaction_count += i
	} else {
		m.addaction_count = &i
	}
}

// AddedActionCount returns the value that was added to the "action_count" field in this mutation.
func (m *BuildGraphMetricsMutation) AddedActionCount() (r int32, exists bool) {
	v := m.addaction_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearActionCount clears the value of the "action_count" field.
func (m *BuildGraphMetricsMutation) ClearActionCount() {
	m.action_count = nil
	m.addaction_count = nil
	m.clearedFields[buildgraphmetrics.FieldActionCount] = struct{}{}
}

// ActionCountCleared returns if the "action_count" field was cleared in this mutation.
func (m *BuildGraphMetricsMutation) ActionCountCleared() bool {
	_, ok := m.clearedFields[buildgraphmetrics.FieldActionCount]
	return ok
}

// ResetActionCount resets all changes to the "action_count" field.
func (m *BuildGraphMetricsMutation) ResetActionCount() {
	m.action_count = nil
	m.addaction_count = nil
	delete(m.clearedFields, buildgraphmetrics.FieldActionCount)
}

// SetActionCountNotIncludingAspects sets the "action_count_not_including_aspects" field.
func (m *BuildGraphMetricsMutation) SetActionCountNotIncludingAspects(i int32) {
	m.action_count_not_including_aspects = &i
	m.addaction_count_not_including_aspects = nil
}

// ActionCountNotIncludingAspects returns the value of the "action_count_not_including_aspects" field in the mutation.
func (m *BuildGraphMetricsMutation) ActionCountNotIncludingAspects() (r int32, exists bool) {
	v := m.action_count_not_including_aspects
	if v == nil {
		return
	}
	return *v, true
}

// OldActionCountNotIncludingAspects returns the old "action_count_not_including_aspects" field's value of the BuildGraphMetrics entity.
// If the BuildGraphMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuildGraphMetricsMutation) OldActionCountNotIncludingAspects(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActionCountNotIncludingAspects is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActionCountNotIncludingAspects requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActionCountNotIncludingAspects: %w", err)
	}
	return oldValue.ActionCountNotIncludingAspects, nil
}

// AddActionCountNotIncludingAspects adds i to the "action_count_not_including_aspects" field.
func (m *BuildGraphMetricsMutation) AddActionCountNotIncludingAspects(i int32) {
	if m.addaction_count_not_including_aspects != nil {
		*m.addaction_count_not_including_aspects += i
	} else {
		m.addaction_count_not_including_aspects = &i
	}
}

// AddedActionCountNotIncludingAspects returns the value that was added to the "action_count_not_including_aspects" field in this mutation.
func (m *BuildGraphMetricsMutation) AddedActionCountNotIncludingAspects() (r int32, exists bool) {
	v := m.addaction_count_not_including_aspects
	if v == nil {
		return
	}
	return *v, true
}

// ClearActionCountNotIncludingAspects clears the value of the "action_count_not_including_aspects" field.
func (m *BuildGraphMetricsMutation) ClearActionCountNotIncludingAspects() {
	m.action_count_not_including_aspects = nil
	m.addaction_count_not_including_aspects = nil
	m.clearedFields[buildgraphmetrics.FieldActionCountNotIncludingAspects] = struct{}{}
}

// ActionCountNotIncludingAspectsCleared returns if the "action_count_not_including_aspects" field was cleared in this mutation.
func (m *BuildGraphMetricsMutation) ActionCountNotIncludingAspectsCleared() bool {
	_, ok := m.clearedFields[buildgraphmetrics.FieldActionCountNotIncludingAspects]
	return ok
}

// ResetActionCountNotIncludingAspects resets all changes to the "action_count_not_including_aspects" field.
func (m *BuildGraphMetricsMutation) ResetActionCountNotIncludingAspects() {
	m.action_count_not_including_aspects = nil
	m.addaction_count_not_including_aspects = nil
	delete(m.clearedFields, buildgraphmetrics.FieldActionCountNotIncludingAspects)
}

// SetInputFileConfiguredTargetCount sets the "input_file_configured_target_count" field.
func (m *BuildGraphMetricsMutation) SetInputFileConfiguredTargetCount(i int32) {
	m.input_file_configured_target_count = &i
	m.addinput_file_configured_target_count = nil
}

// InputFileConfiguredTargetCount returns the value of the "input_file_configured_target_count" field in the mutation.
func (m *BuildGraphMetricsMutation) InputFileConfiguredTargetCount() (r int32, exists bool) {
	v := m.input_file_configured_target_count
	if v == nil {
		return
	}
	return *v, true
}

// OldInputFileConfiguredTargetCount returns the old "input_file_configured_target_count" field's value of the BuildGraphMetrics entity.
// If the BuildGraphMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuildGraphMetricsMutation) OldInputFileConfiguredTargetCount(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInputFileConfiguredTargetCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInputFileConfiguredTargetCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInputFileConfiguredTargetCount: %w", err)
	}
	return oldValue.InputFileConfiguredTargetCount, nil
}

// AddInputFileConfiguredTargetCount adds i to the "input_file_configured_target_count" field.
func (m *BuildGraphMetricsMutation) AddInputFileConfiguredTargetCount(i int32) {
	if m.addinput_file_configured_target_count != nil {
		*m.addinput_file_configured_target_count += i
	} else {
		m.addinput_file_configured_target_count = &i
	}
}

// AddedInputFileConfiguredTargetCount returns the value that was added to the "input_file_configured_target_count" field in this mutation.
func (m *BuildGraphMetricsMutation) AddedInputFileConfiguredTargetCount() (r int32, exists bool) {
	v := m.addinput_file_configured_target_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearInputFileConfiguredTargetCount clears the value of the "input_file_configured_target_count" field.
func (m *BuildGraphMetricsMutation) ClearInputFileConfiguredTargetCount() {
	m.input_file_configured_target_count = nil
	m.addinput_file_configured_target_count = nil
	m.clearedFields[buildgraphmetrics.FieldInputFileConfiguredTargetCount] = struct{}{}
}

// InputFileConfiguredTargetCountCleared returns if the "input_file_configured_target_count" field was cleared in this mutation.
func (m *BuildGraphMetricsMutation) InputFileConfiguredTargetCountCleared() bool {
	_, ok := m.clearedFields[buildgraphmetrics.FieldInputFileConfiguredTargetCount]
	return ok
}

// ResetInputFileConfiguredTargetCount resets all changes to the "input_file_configured_target_count" field.
func (m *BuildGraphMetricsMutation) ResetInputFileConfiguredTargetCount() {
	m.input_file_configured_target_count = nil
	m.addinput_file_configured_target_count = nil
	delete(m.clearedFields, buildgraphmetrics.FieldInputFileConfiguredTargetCount)
}

// SetOutputFileConfiguredTargetCount sets the "output_file_configured_target_count" field.
func (m *BuildGraphMetricsMutation) SetOutputFileConfiguredTargetCount(i int32) {
	m.output_file_configured_target_count = &i
	m.addoutput_file_configured_target_count = nil
}

// OutputFileConfiguredTargetCount returns the value of the "output_file_configured_target_count" field in the mutation.
func (m *BuildGraphMetricsMutation) OutputFileConfiguredTargetCount() (r int32, exists bool) {
	v := m.output_file_configured_target_count
	if v == nil {
		return
	}
	return *v, true
}

// OldOutputFileConfiguredTargetCount returns the old "output_file_configured_target_count" field's value of the BuildGraphMetrics entity.
// If the BuildGraphMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuildGraphMetricsMutation) OldOutputFileConfiguredTargetCount(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutputFileConfiguredTargetCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutputFileConfiguredTargetCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutputFileConfiguredTargetCount: %w", err)
	}
	return oldValue.OutputFileConfiguredTargetCount, nil
}

// AddOutputFileConfiguredTargetCount adds i to the "output_file_configured_target_count" field.
func (m *BuildGraphMetricsMutation) AddOutputFileConfiguredTargetCount(i int32) {
	if m.addoutput_file_configured_target_count != nil {
		*m.addoutput_file_configured_target_count += i
	} else {
		m.addoutput_file_configured_target_count = &i
	}
}

// AddedOutputFileConfiguredTargetCount returns the value that was added to the "output_file_configured_target_count" field in this mutation.
func (m *BuildGraphMetricsMutation) AddedOutputFileConfiguredTargetCount() (r int32, exists bool) {
	v := m.addoutput_file_configured_target_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearOutputFileConfiguredTargetCount clears the value of the "output_file_configured_target_count" field.
func (m *BuildGraphMetricsMutation) ClearOutputFileConfiguredTargetCount() {
	m.output_file_configured_target_count = nil
	m.addoutput_file_configured_target_count = nil
	m.clearedFields[buildgraphmetrics.FieldOutputFileConfiguredTargetCount] = struct{}{}
}

// OutputFileConfiguredTargetCountCleared returns if the "output_file_configured_target_count" field was cleared in this mutation.
func (m *BuildGraphMetricsMutation) OutputFileConfiguredTargetCountCleared() bool {
	_, ok := m.clearedFields[buildgraphmetrics.FieldOutputFileConfiguredTargetCount]
	return ok
}

// ResetOutputFileConfiguredTargetCount resets all changes to the "output_file_configured_target_count" field.
func (m *BuildGraphMetricsMutation) ResetOutputFileConfiguredTargetCount() {
	m.output_file_configured_target_count = nil
	m.addoutput_file_configured_target_count = nil
	delete(m.clearedFields, buildgraphmetrics.FieldOutputFileConfiguredTargetCount)
}

// SetOtherConfiguredTargetCount sets the "other_configured_target_count" field.
func (m *BuildGraphMetricsMutation) SetOtherConfiguredTargetCount(i int32) {
	m.other_configured_target_count = &i
	m.addother_configured_target_count = nil
}

// OtherConfiguredTargetCount returns the value of the "other_configured_target_count" field in the mutation.
func (m *BuildGraphMetricsMutation) OtherConfiguredTargetCount() (r int32, exists bool) {
	v := m.other_configured_target_count
	if v == nil {
		return
	}
	return *v, true
}

// OldOtherConfiguredTargetCount returns the old "other_configured_target_count" field's value of the BuildGraphMetrics entity.
// If the BuildGraphMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuildGraphMetricsMutation) OldOtherConfiguredTargetCount(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOtherConfiguredTargetCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOtherConfiguredTargetCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOtherConfiguredTargetCount: %w", err)
	}
	return oldValue.OtherConfiguredTargetCount, nil
}

// AddOtherConfiguredTargetCount adds i to the "other_configured_target_count" field.
func (m *BuildGraphMetricsMutation) AddOtherConfiguredTargetCount(i int32) {
	if m.addother_configured_target_count != nil {
		*m.addother_configured_target_count += i
	} else {
		m.addother_configured_target_count = &i
	}
}

// AddedOtherConfiguredTargetCount returns the value that was added to the "other_configured_target_count" field in this mutation.
func (m *BuildGraphMetricsMutation) AddedOtherConfiguredTargetCount() (r int32, exists bool) {
	v := m.addother_configured_target_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearOtherConfiguredTargetCount clears the value of the "other_configured_target_count" field.
func (m *BuildGraphMetricsMutation) ClearOtherConfiguredTargetCount() {
	m.other_configured_target_count = nil
	m.addother_configured_target_count = nil
	m.clearedFields[buildgraphmetrics.FieldOtherConfiguredTargetCount] = struct{}{}
}

// OtherConfiguredTargetCountCleared returns if the "other_configured_target_count" field was cleared in this mutation.
func (m *BuildGraphMetricsMutation) OtherConfiguredTargetCountCleared() bool {
	_, ok := m.clearedFields[buildgraphmetrics.FieldOtherConfiguredTargetCount]
	return ok
}

// ResetOtherConfiguredTargetCount resets all changes to the "other_configured_target_count" field.
func (m *BuildGraphMetricsMutation) ResetOtherConfiguredTargetCount() {
	m.other_configured_target_count = nil
	m.addother_configured_target_count = nil
	delete(m.clearedFields, buildgraphmetrics.FieldOtherConfiguredTargetCount)
}

// SetOutputArtifactCount sets the "output_artifact_count" field.
func (m *BuildGraphMetricsMutation) SetOutputArtifactCount(i int32) {
	m.output_artifact_count = &i
	m.addoutput_artifact_count = nil
}

// OutputArtifactCount returns the value of the "output_artifact_count" field in the mutation.
func (m *BuildGraphMetricsMutation) OutputArtifactCount() (r int32, exists bool) {
	v := m.output_artifact_count
	if v == nil {
		return
	}
	return *v, true
}

// OldOutputArtifactCount returns the old "output_artifact_count" field's value of the BuildGraphMetrics entity.
// If the BuildGraphMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuildGraphMetricsMutation) OldOutputArtifactCount(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutputArtifactCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutputArtifactCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutputArtifactCount: %w", err)
	}
	return oldValue.OutputArtifactCount, nil
}

// AddOutputArtifactCount adds i to the "output_artifact_count" field.
func (m *BuildGraphMetricsMutation) AddOutputArtifactCount(i int32) {
	if m.addoutput_artifact_count != nil {
		*m.addoutput_artifact_count += i
	} else {
		m.addoutput_artifact_count = &i
	}
}

// AddedOutputArtifactCount returns the value that was added to the "output_artifact_count" field in this mutation.
func (m *BuildGraphMetricsMutation) AddedOutputArtifactCount() (r int32, exists bool) {
	v := m.addoutput_artifact_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearOutputArtifactCount clears the value of the "output_artifact_count" field.
func (m *BuildGraphMetricsMutation) ClearOutputArtifactCount() {
	m.output_artifact_count = nil
	m.addoutput_artifact_count = nil
	m.clearedFields[buildgraphmetrics.FieldOutputArtifactCount] = struct{}{}
}

// OutputArtifactCountCleared returns if the "output_artifact_count" field was cleared in this mutation.
func (m *BuildGraphMetricsMutation) OutputArtifactCountCleared() bool {
	_, ok := m.clearedFields[buildgraphmetrics.FieldOutputArtifactCount]
	return ok
}

// ResetOutputArtifactCount resets all changes to the "output_artifact_count" field.
func (m *BuildGraphMetricsMutation) ResetOutputArtifactCount() {
	m.output_artifact_count = nil
	m.addoutput_artifact_count = nil
	delete(m.clearedFields, buildgraphmetrics.FieldOutputArtifactCount)
}

// SetPostInvocationSkyframeNodeCount sets the "post_invocation_skyframe_node_count" field.
func (m *BuildGraphMetricsMutation) SetPostInvocationSkyframeNodeCount(i int32) {
	m.post_invocation_skyframe_node_count = &i
	m.addpost_invocation_skyframe_node_count = nil
}

// PostInvocationSkyframeNodeCount returns the value of the "post_invocation_skyframe_node_count" field in the mutation.
func (m *BuildGraphMetricsMutation) PostInvocationSkyframeNodeCount() (r int32, exists bool) {
	v := m.post_invocation_skyframe_node_count
	if v == nil {
		return
	}
	return *v, true
}

// OldPostInvocationSkyframeNodeCount returns the old "post_invocation_skyframe_node_count" field's value of the BuildGraphMetrics entity.
// If the BuildGraphMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuildGraphMetricsMutation) OldPostInvocationSkyframeNodeCount(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostInvocationSkyframeNodeCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostInvocationSkyframeNodeCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostInvocationSkyframeNodeCount: %w", err)
	}
	return oldValue.PostInvocationSkyframeNodeCount, nil
}

// AddPostInvocationSkyframeNodeCount adds i to the "post_invocation_skyframe_node_count" field.
func (m *BuildGraphMetricsMutation) AddPostInvocationSkyframeNodeCount(i int32) {
	if m.addpost_invocation_skyframe_node_count != nil {
		*m.addpost_invocation_skyframe_node_count += i
	} else {
		m.addpost_invocation_skyframe_node_count = &i
	}
}

// AddedPostInvocationSkyframeNodeCount returns the value that was added to the "post_invocation_skyframe_node_count" field in this mutation.
func (m *BuildGraphMetricsMutation) AddedPostInvocationSkyframeNodeCount() (r int32, exists bool) {
	v := m.addpost_invocation_skyframe_node_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearPostInvocationSkyframeNodeCount clears the value of the "post_invocation_skyframe_node_count" field.
func (m *BuildGraphMetricsMutation) ClearPostInvocationSkyframeNodeCount() {
	m.post_invocation_skyframe_node_count = nil
	m.addpost_invocation_skyframe_node_count = nil
	m.clearedFields[buildgraphmetrics.FieldPostInvocationSkyframeNodeCount] = struct{}{}
}

// PostInvocationSkyframeNodeCountCleared returns if the "post_invocation_skyframe_node_count" field was cleared in this mutation.
func (m *BuildGraphMetricsMutation) PostInvocationSkyframeNodeCountCleared() bool {
	_, ok := m.clearedFields[buildgraphmetrics.FieldPostInvocationSkyframeNodeCount]
	return ok
}

// ResetPostInvocationSkyframeNodeCount resets all changes to the "post_invocation_skyframe_node_count" field.
func (m *BuildGraphMetricsMutation) ResetPostInvocationSkyframeNodeCount() {
	m.post_invocation_skyframe_node_count = nil
	m.addpost_invocation_skyframe_node_count = nil
	delete(m.clearedFields, buildgraphmetrics.FieldPostInvocationSkyframeNodeCount)
}

// SetMetricsID sets the "metrics" edge to the Metrics entity by id.
func (m *BuildGraphMetricsMutation) SetMetricsID(id int64) {
	m.metrics = &id
}

// ClearMetrics clears the "metrics" edge to the Metrics entity.
func (m *BuildGraphMetricsMutation) ClearMetrics() {
	m.clearedmetrics = true
}

// MetricsCleared reports if the "metrics" edge to the Metrics entity was cleared.
func (m *BuildGraphMetricsMutation) MetricsCleared() bool {
	return m.clearedmetrics
}

// MetricsID returns the "metrics" edge ID in the mutation.
func (m *BuildGraphMetricsMutation) MetricsID() (id int64, exists bool) {
	if m.metrics != nil {
		return *m.metrics, true
	}
	return
}

// MetricsIDs returns the "metrics" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MetricsID instead. It exists only for internal usage by the builders.
func (m *BuildGraphMetricsMutation) MetricsIDs() (ids []int64) {
	if id := m.metrics; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMetrics resets all changes to the "metrics" edge.
func (m *BuildGraphMetricsMutation) ResetMetrics() {
	m.metrics = nil
	m.clearedmetrics = false
}

// SetDirtiedValuesID sets the "dirtied_values" edge to the EvaluationStat entity by id.
func (m *BuildGraphMetricsMutation) SetDirtiedValuesID(id int64) {
	m.dirtied_values = &id
}

// ClearDirtiedValues clears the "dirtied_values" edge to the EvaluationStat entity.
func (m *BuildGraphMetricsMutation) ClearDirtiedValues() {
	m.cleareddirtied_values = true
}

// DirtiedValuesCleared reports if the "dirtied_values" edge to the EvaluationStat entity was cleared.
func (m *BuildGraphMetricsMutation) DirtiedValuesCleared() bool {
	return m.cleareddirtied_values
}

// DirtiedValuesID returns the "dirtied_values" edge ID in the mutation.
func (m *BuildGraphMetricsMutation) DirtiedValuesID() (id int64, exists bool) {
	if m.dirtied_values != nil {
		return *m.dirtied_values, true
	}
	return
}

// DirtiedValuesIDs returns the "dirtied_values" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DirtiedValuesID instead. It exists only for internal usage by the builders.
func (m *BuildGraphMetricsMutation) DirtiedValuesIDs() (ids []int64) {
	if id := m.dirtied_values; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDirtiedValues resets all changes to the "dirtied_values" edge.
func (m *BuildGraphMetricsMutation) ResetDirtiedValues() {
	m.dirtied_values = nil
	m.cleareddirtied_values = false
}

// SetChangedValuesID sets the "changed_values" edge to the EvaluationStat entity by id.
func (m *BuildGraphMetricsMutation) SetChangedValuesID(id int64) {
	m.changed_values = &id
}

// ClearChangedValues clears the "changed_values" edge to the EvaluationStat entity.
func (m *BuildGraphMetricsMutation) ClearChangedValues() {
	m.clearedchanged_values = true
}

// ChangedValuesCleared reports if the "changed_values" edge to the EvaluationStat entity was cleared.
func (m *BuildGraphMetricsMutation) ChangedValuesCleared() bool {
	return m.clearedchanged_values
}

// ChangedValuesID returns the "changed_values" edge ID in the mutation.
func (m *BuildGraphMetricsMutation) ChangedValuesID() (id int64, exists bool) {
	if m.changed_values != nil {
		return *m.changed_values, true
	}
	return
}

// ChangedValuesIDs returns the "changed_values" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChangedValuesID instead. It exists only for internal usage by the builders.
func (m *BuildGraphMetricsMutation) ChangedValuesIDs() (ids []int64) {
	if id := m.changed_values; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChangedValues resets all changes to the "changed_values" edge.
func (m *BuildGraphMetricsMutation) ResetChangedValues() {
	m.changed_values = nil
	m.clearedchanged_values = false
}

// SetBuiltValuesID sets the "built_values" edge to the EvaluationStat entity by id.
func (m *BuildGraphMetricsMutation) SetBuiltValuesID(id int64) {
	m.built_values = &id
}

// ClearBuiltValues clears the "built_values" edge to the EvaluationStat entity.
func (m *BuildGraphMetricsMutation) ClearBuiltValues() {
	m.clearedbuilt_values = true
}

// BuiltValuesCleared reports if the "built_values" edge to the EvaluationStat entity was cleared.
func (m *BuildGraphMetricsMutation) BuiltValuesCleared() bool {
	return m.clearedbuilt_values
}

// BuiltValuesID returns the "built_values" edge ID in the mutation.
func (m *BuildGraphMetricsMutation) BuiltValuesID() (id int64, exists bool) {
	if m.built_values != nil {
		return *m.built_values, true
	}
	return
}

// BuiltValuesIDs returns the "built_values" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BuiltValuesID instead. It exists only for internal usage by the builders.
func (m *BuildGraphMetricsMutation) BuiltValuesIDs() (ids []int64) {
	if id := m.built_values; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBuiltValues resets all changes to the "built_values" edge.
func (m *BuildGraphMetricsMutation) ResetBuiltValues() {
	m.built_values = nil
	m.clearedbuilt_values = false
}

// SetCleanedValuesID sets the "cleaned_values" edge to the EvaluationStat entity by id.
func (m *BuildGraphMetricsMutation) SetCleanedValuesID(id int64) {
	m.cleaned_values = &id
}

// ClearCleanedValues clears the "cleaned_values" edge to the EvaluationStat entity.
func (m *BuildGraphMetricsMutation) ClearCleanedValues() {
	m.clearedcleaned_values = true
}

// CleanedValuesCleared reports if the "cleaned_values" edge to the EvaluationStat entity was cleared.
func (m *BuildGraphMetricsMutation) CleanedValuesCleared() bool {
	return m.clearedcleaned_values
}

// CleanedValuesID returns the "cleaned_values" edge ID in the mutation.
func (m *BuildGraphMetricsMutation) CleanedValuesID() (id int64, exists bool) {
	if m.cleaned_values != nil {
		return *m.cleaned_values, true
	}
	return
}

// CleanedValuesIDs returns the "cleaned_values" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CleanedValuesID instead. It exists only for internal usage by the builders.
func (m *BuildGraphMetricsMutation) CleanedValuesIDs() (ids []int64) {
	if id := m.cleaned_values; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCleanedValues resets all changes to the "cleaned_values" edge.
func (m *BuildGraphMetricsMutation) ResetCleanedValues() {
	m.cleaned_values = nil
	m.clearedcleaned_values = false
}

// SetEvaluatedValuesID sets the "evaluated_values" edge to the EvaluationStat entity by id.
func (m *BuildGraphMetricsMutation) SetEvaluatedValuesID(id int64) {
	m.evaluated_values = &id
}

// ClearEvaluatedValues clears the "evaluated_values" edge to the EvaluationStat entity.
func (m *BuildGraphMetricsMutation) ClearEvaluatedValues() {
	m.clearedevaluated_values = true
}

// EvaluatedValuesCleared reports if the "evaluated_values" edge to the EvaluationStat entity was cleared.
func (m *BuildGraphMetricsMutation) EvaluatedValuesCleared() bool {
	return m.clearedevaluated_values
}

// EvaluatedValuesID returns the "evaluated_values" edge ID in the mutation.
func (m *BuildGraphMetricsMutation) EvaluatedValuesID() (id int64, exists bool) {
	if m.evaluated_values != nil {
		return *m.evaluated_values, true
	}
	return
}

// EvaluatedValuesIDs returns the "evaluated_values" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EvaluatedValuesID instead. It exists only for internal usage by the builders.
func (m *BuildGraphMetricsMutation) EvaluatedValuesIDs() (ids []int64) {
	if id := m.evaluated_values; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEvaluatedValues resets all changes to the "evaluated_values" edge.
func (m *BuildGraphMetricsMutation) ResetEvaluatedValues() {
	m.evaluated_values = nil
	m.clearedevaluated_values = false
}

// Where appends a list predicates to the BuildGraphMetricsMutation builder.
func (m *BuildGraphMetricsMutation) Where(ps ...predicate.BuildGraphMetrics) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BuildGraphMetricsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BuildGraphMetricsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BuildGraphMetrics, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BuildGraphMetricsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BuildGraphMetricsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BuildGraphMetrics).
func (m *BuildGraphMetricsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BuildGraphMetricsMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.action_lookup_value_count != nil {
		fields = append(fields, buildgraphmetrics.FieldActionLookupValueCount)
	}
	if m.action_lookup_value_count_not_including_aspects != nil {
		fields = append(fields, buildgraphmetrics.FieldActionLookupValueCountNotIncludingAspects)
	}
	if m.action_count != nil {
		fields = append(fields, buildgraphmetrics.FieldActionCount)
	}
	if m.action_count_not_including_aspects != nil {
		fields = append(fields, buildgraphmetrics.FieldActionCountNotIncludingAspects)
	}
	if m.input_file_configured_target_count != nil {
		fields = append(fields, buildgraphmetrics.FieldInputFileConfiguredTargetCount)
	}
	if m.output_file_configured_target_count != nil {
		fields = append(fields, buildgraphmetrics.FieldOutputFileConfiguredTargetCount)
	}
	if m.other_configured_target_count != nil {
		fields = append(fields, buildgraphmetrics.FieldOtherConfiguredTargetCount)
	}
	if m.output_artifact_count != nil {
		fields = append(fields, buildgraphmetrics.FieldOutputArtifactCount)
	}
	if m.post_invocation_skyframe_node_count != nil {
		fields = append(fields, buildgraphmetrics.FieldPostInvocationSkyframeNodeCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BuildGraphMetricsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case buildgraphmetrics.FieldActionLookupValueCount:
		return m.ActionLookupValueCount()
	case buildgraphmetrics.FieldActionLookupValueCountNotIncludingAspects:
		return m.ActionLookupValueCountNotIncludingAspects()
	case buildgraphmetrics.FieldActionCount:
		return m.ActionCount()
	case buildgraphmetrics.FieldActionCountNotIncludingAspects:
		return m.ActionCountNotIncludingAspects()
	case buildgraphmetrics.FieldInputFileConfiguredTargetCount:
		return m.InputFileConfiguredTargetCount()
	case buildgraphmetrics.FieldOutputFileConfiguredTargetCount:
		return m.OutputFileConfiguredTargetCount()
	case buildgraphmetrics.FieldOtherConfiguredTargetCount:
		return m.OtherConfiguredTargetCount()
	case buildgraphmetrics.FieldOutputArtifactCount:
		return m.OutputArtifactCount()
	case buildgraphmetrics.FieldPostInvocationSkyframeNodeCount:
		return m.PostInvocationSkyframeNodeCount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BuildGraphMetricsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case buildgraphmetrics.FieldActionLookupValueCount:
		return m.OldActionLookupValueCount(ctx)
	case buildgraphmetrics.FieldActionLookupValueCountNotIncludingAspects:
		return m.OldActionLookupValueCountNotIncludingAspects(ctx)
	case buildgraphmetrics.FieldActionCount:
		return m.OldActionCount(ctx)
	case buildgraphmetrics.FieldActionCountNotIncludingAspects:
		return m.OldActionCountNotIncludingAspects(ctx)
	case buildgraphmetrics.FieldInputFileConfiguredTargetCount:
		return m.OldInputFileConfiguredTargetCount(ctx)
	case buildgraphmetrics.FieldOutputFileConfiguredTargetCount:
		return m.OldOutputFileConfiguredTargetCount(ctx)
	case buildgraphmetrics.FieldOtherConfiguredTargetCount:
		return m.OldOtherConfiguredTargetCount(ctx)
	case buildgraphmetrics.FieldOutputArtifactCount:
		return m.OldOutputArtifactCount(ctx)
	case buildgraphmetrics.FieldPostInvocationSkyframeNodeCount:
		return m.OldPostInvocationSkyframeNodeCount(ctx)
	}
	return nil, fmt.Errorf("unknown BuildGraphMetrics field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BuildGraphMetricsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case buildgraphmetrics.FieldActionLookupValueCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActionLookupValueCount(v)
		return nil
	case buildgraphmetrics.FieldActionLookupValueCountNotIncludingAspects:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActionLookupValueCountNotIncludingAspects(v)
		return nil
	case buildgraphmetrics.FieldActionCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActionCount(v)
		return nil
	case buildgraphmetrics.FieldActionCountNotIncludingAspects:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActionCountNotIncludingAspects(v)
		return nil
	case buildgraphmetrics.FieldInputFileConfiguredTargetCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInputFileConfiguredTargetCount(v)
		return nil
	case buildgraphmetrics.FieldOutputFileConfiguredTargetCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutputFileConfiguredTargetCount(v)
		return nil
	case buildgraphmetrics.FieldOtherConfiguredTargetCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOtherConfiguredTargetCount(v)
		return nil
	case buildgraphmetrics.FieldOutputArtifactCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutputArtifactCount(v)
		return nil
	case buildgraphmetrics.FieldPostInvocationSkyframeNodeCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostInvocationSkyframeNodeCount(v)
		return nil
	}
	return fmt.Errorf("unknown BuildGraphMetrics field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BuildGraphMetricsMutation) AddedFields() []string {
	var fields []string
	if m.addaction_lookup_value_count != nil {
		fields = append(fields, buildgraphmetrics.FieldActionLookupValueCount)
	}
	if m.addaction_lookup_value_count_not_including_aspects != nil {
		fields = append(fields, buildgraphmetrics.FieldActionLookupValueCountNotIncludingAspects)
	}
	if m.addaction_count != nil {
		fields = append(fields, buildgraphmetrics.FieldActionCount)
	}
	if m.addaction_count_not_including_aspects != nil {
		fields = append(fields, buildgraphmetrics.FieldActionCountNotIncludingAspects)
	}
	if m.addinput_file_configured_target_count != nil {
		fields = append(fields, buildgraphmetrics.FieldInputFileConfiguredTargetCount)
	}
	if m.addoutput_file_configured_target_count != nil {
		fields = append(fields, buildgraphmetrics.FieldOutputFileConfiguredTargetCount)
	}
	if m.addother_configured_target_count != nil {
		fields = append(fields, buildgraphmetrics.FieldOtherConfiguredTargetCount)
	}
	if m.addoutput_artifact_count != nil {
		fields = append(fields, buildgraphmetrics.FieldOutputArtifactCount)
	}
	if m.addpost_invocation_skyframe_node_count != nil {
		fields = append(fields, buildgraphmetrics.FieldPostInvocationSkyframeNodeCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BuildGraphMetricsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case buildgraphmetrics.FieldActionLookupValueCount:
		return m.AddedActionLookupValueCount()
	case buildgraphmetrics.FieldActionLookupValueCountNotIncludingAspects:
		return m.AddedActionLookupValueCountNotIncludingAspects()
	case buildgraphmetrics.FieldActionCount:
		return m.AddedActionCount()
	case buildgraphmetrics.FieldActionCountNotIncludingAspects:
		return m.AddedActionCountNotIncludingAspects()
	case buildgraphmetrics.FieldInputFileConfiguredTargetCount:
		return m.AddedInputFileConfiguredTargetCount()
	case buildgraphmetrics.FieldOutputFileConfiguredTargetCount:
		return m.AddedOutputFileConfiguredTargetCount()
	case buildgraphmetrics.FieldOtherConfiguredTargetCount:
		return m.AddedOtherConfiguredTargetCount()
	case buildgraphmetrics.FieldOutputArtifactCount:
		return m.AddedOutputArtifactCount()
	case buildgraphmetrics.FieldPostInvocationSkyframeNodeCount:
		return m.AddedPostInvocationSkyframeNodeCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BuildGraphMetricsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case buildgraphmetrics.FieldActionLookupValueCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddActionLookupValueCount(v)
		return nil
	case buildgraphmetrics.FieldActionLookupValueCountNotIncludingAspects:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddActionLookupValueCountNotIncludingAspects(v)
		return nil
	case buildgraphmetrics.FieldActionCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddActionCount(v)
		return nil
	case buildgraphmetrics.FieldActionCountNotIncludingAspects:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddActionCountNotIncludingAspects(v)
		return nil
	case buildgraphmetrics.FieldInputFileConfiguredTargetCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInputFileConfiguredTargetCount(v)
		return nil
	case buildgraphmetrics.FieldOutputFileConfiguredTargetCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOutputFileConfiguredTargetCount(v)
		return nil
	case buildgraphmetrics.FieldOtherConfiguredTargetCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOtherConfiguredTargetCount(v)
		return nil
	case buildgraphmetrics.FieldOutputArtifactCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOutputArtifactCount(v)
		return nil
	case buildgraphmetrics.FieldPostInvocationSkyframeNodeCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPostInvocationSkyframeNodeCount(v)
		return nil
	}
	return fmt.Errorf("unknown BuildGraphMetrics numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BuildGraphMetricsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(buildgraphmetrics.FieldActionLookupValueCount) {
		fields = append(fields, buildgraphmetrics.FieldActionLookupValueCount)
	}
	if m.FieldCleared(buildgraphmetrics.FieldActionLookupValueCountNotIncludingAspects) {
		fields = append(fields, buildgraphmetrics.FieldActionLookupValueCountNotIncludingAspects)
	}
	if m.FieldCleared(buildgraphmetrics.FieldActionCount) {
		fields = append(fields, buildgraphmetrics.FieldActionCount)
	}
	if m.FieldCleared(buildgraphmetrics.FieldActionCountNotIncludingAspects) {
		fields = append(fields, buildgraphmetrics.FieldActionCountNotIncludingAspects)
	}
	if m.FieldCleared(buildgraphmetrics.FieldInputFileConfiguredTargetCount) {
		fields = append(fields, buildgraphmetrics.FieldInputFileConfiguredTargetCount)
	}
	if m.FieldCleared(buildgraphmetrics.FieldOutputFileConfiguredTargetCount) {
		fields = append(fields, buildgraphmetrics.FieldOutputFileConfiguredTargetCount)
	}
	if m.FieldCleared(buildgraphmetrics.FieldOtherConfiguredTargetCount) {
		fields = append(fields, buildgraphmetrics.FieldOtherConfiguredTargetCount)
	}
	if m.FieldCleared(buildgraphmetrics.FieldOutputArtifactCount) {
		fields = append(fields, buildgraphmetrics.FieldOutputArtifactCount)
	}
	if m.FieldCleared(buildgraphmetrics.FieldPostInvocationSkyframeNodeCount) {
		fields = append(fields, buildgraphmetrics.FieldPostInvocationSkyframeNodeCount)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BuildGraphMetricsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BuildGraphMetricsMutation) ClearField(name string) error {
	switch name {
	case buildgraphmetrics.FieldActionLookupValueCount:
		m.ClearActionLookupValueCount()
		return nil
	case buildgraphmetrics.FieldActionLookupValueCountNotIncludingAspects:
		m.ClearActionLookupValueCountNotIncludingAspects()
		return nil
	case buildgraphmetrics.FieldActionCount:
		m.ClearActionCount()
		return nil
	case buildgraphmetrics.FieldActionCountNotIncludingAspects:
		m.ClearActionCountNotIncludingAspects()
		return nil
	case buildgraphmetrics.FieldInputFileConfiguredTargetCount:
		m.ClearInputFileConfiguredTargetCount()
		return nil
	case buildgraphmetrics.FieldOutputFileConfiguredTargetCount:
		m.ClearOutputFileConfiguredTargetCount()
		return nil
	case buildgraphmetrics.FieldOtherConfiguredTargetCount:
		m.ClearOtherConfiguredTargetCount()
		return nil
	case buildgraphmetrics.FieldOutputArtifactCount:
		m.ClearOutputArtifactCount()
		return nil
	case buildgraphmetrics.FieldPostInvocationSkyframeNodeCount:
		m.ClearPostInvocationSkyframeNodeCount()
		return nil
	}
	return fmt.Errorf("unknown BuildGraphMetrics nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BuildGraphMetricsMutation) ResetField(name string) error {
	switch name {
	case buildgraphmetrics.FieldActionLookupValueCount:
		m.ResetActionLookupValueCount()
		return nil
	case buildgraphmetrics.FieldActionLookupValueCountNotIncludingAspects:
		m.ResetActionLookupValueCountNotIncludingAspects()
		return nil
	case buildgraphmetrics.FieldActionCount:
		m.ResetActionCount()
		return nil
	case buildgraphmetrics.FieldActionCountNotIncludingAspects:
		m.ResetActionCountNotIncludingAspects()
		return nil
	case buildgraphmetrics.FieldInputFileConfiguredTargetCount:
		m.ResetInputFileConfiguredTargetCount()
		return nil
	case buildgraphmetrics.FieldOutputFileConfiguredTargetCount:
		m.ResetOutputFileConfiguredTargetCount()
		return nil
	case buildgraphmetrics.FieldOtherConfiguredTargetCount:
		m.ResetOtherConfiguredTargetCount()
		return nil
	case buildgraphmetrics.FieldOutputArtifactCount:
		m.ResetOutputArtifactCount()
		return nil
	case buildgraphmetrics.FieldPostInvocationSkyframeNodeCount:
		m.ResetPostInvocationSkyframeNodeCount()
		return nil
	}
	return fmt.Errorf("unknown BuildGraphMetrics field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BuildGraphMetricsMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.metrics != nil {
		edges = append(edges, buildgraphmetrics.EdgeMetrics)
	}
	if m.dirtied_values != nil {
		edges = append(edges, buildgraphmetrics.EdgeDirtiedValues)
	}
	if m.changed_values != nil {
		edges = append(edges, buildgraphmetrics.EdgeChangedValues)
	}
	if m.built_values != nil {
		edges = append(edges, buildgraphmetrics.EdgeBuiltValues)
	}
	if m.cleaned_values != nil {
		edges = append(edges, buildgraphmetrics.EdgeCleanedValues)
	}
	if m.evaluated_values != nil {
		edges = append(edges, buildgraphmetrics.EdgeEvaluatedValues)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BuildGraphMetricsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case buildgraphmetrics.EdgeMetrics:
		if id := m.metrics; id != nil {
			return []ent.Value{*id}
		}
	case buildgraphmetrics.EdgeDirtiedValues:
		if id := m.dirtied_values; id != nil {
			return []ent.Value{*id}
		}
	case buildgraphmetrics.EdgeChangedValues:
		if id := m.changed_values; id != nil {
			return []ent.Value{*id}
		}
	case buildgraphmetrics.EdgeBuiltValues:
		if id := m.built_values; id != nil {
			return []ent.Value{*id}
		}
	case buildgraphmetrics.EdgeCleanedValues:
		if id := m.cleaned_values; id != nil {
			return []ent.Value{*id}
		}
	case buildgraphmetrics.EdgeEvaluatedValues:
		if id := m.evaluated_values; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BuildGraphMetricsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BuildGraphMetricsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BuildGraphMetricsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedmetrics {
		edges = append(edges, buildgraphmetrics.EdgeMetrics)
	}
	if m.cleareddirtied_values {
		edges = append(edges, buildgraphmetrics.EdgeDirtiedValues)
	}
	if m.clearedchanged_values {
		edges = append(edges, buildgraphmetrics.EdgeChangedValues)
	}
	if m.clearedbuilt_values {
		edges = append(edges, buildgraphmetrics.EdgeBuiltValues)
	}
	if m.clearedcleaned_values {
		edges = append(edges, buildgraphmetrics.EdgeCleanedValues)
	}
	if m.clearedevaluated_values {
		edges = append(edges, buildgraphmetrics.EdgeEvaluatedValues)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BuildGraphMetricsMutation) EdgeCleared(name string) bool {
	switch name {
	case buildgraphmetrics.EdgeMetrics:
		return m.clearedmetrics
	case buildgraphmetrics.EdgeDirtiedValues:
		return m.cleareddirtied_values
	case buildgraphmetrics.EdgeChangedValues:
		return m.clearedchanged_values
	case buildgraphmetrics.EdgeBuiltValues:
		return m.clearedbuilt_values
	case buildgraphmetrics.EdgeCleanedValues:
		return m.clearedcleaned_values
	case buildgraphmetrics.EdgeEvaluatedValues:
		return m.clearedevaluated_values
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BuildGraphMetricsMutation) ClearEdge(name string) error {
	switch name {
	case buildgraphmetrics.EdgeMetrics:
		m.ClearMetrics()
		return nil
	case buildgraphmetrics.EdgeDirtiedValues:
		m.ClearDirtiedValues()
		return nil
	case buildgraphmetrics.EdgeChangedValues:
		m.ClearChangedValues()
		return nil
	case buildgraphmetrics.EdgeBuiltValues:
		m.ClearBuiltValues()
		return nil
	case buildgraphmetrics.EdgeCleanedValues:
		m.ClearCleanedValues()
		return nil
	case buildgraphmetrics.EdgeEvaluatedValues:
		m.ClearEvaluatedValues()
		return nil
	}
	return fmt.Errorf("unknown BuildGraphMetrics unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BuildGraphMetricsMutation) ResetEdge(name string) error {
	switch name {
	case buildgraphmetrics.EdgeMetrics:
		m.ResetMetrics()
		return nil
	case buildgraphmetrics.EdgeDirtiedValues:
		m.ResetDirtiedValues()
		return nil
	case buildgraphmetrics.EdgeChangedValues:
		m.ResetChangedValues()
		return nil
	case buildgraphmetrics.EdgeBuiltValues:
		m.ResetBuiltValues()
		return nil
	case buildgraphmetrics.EdgeCleanedValues:
		m.ResetCleanedValues()
		return nil
	case buildgraphmetrics.EdgeEvaluatedValues:
		m.ResetEvaluatedValues()
		return nil
	}
	return fmt.Errorf("unknown BuildGraphMetrics edge %s", name)
}

// BuildLogChunkMutation represents an operation that mutates the BuildLogChunk nodes in the graph.
type BuildLogChunkMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int64
	data                    *[]byte
	chunk_index             *int
	addchunk_index          *int
	first_line_index        *int64
	addfirst_line_index     *int64
	last_line_index         *int64
	addlast_line_index      *int64
	clearedFields           map[string]struct{}
	bazel_invocation        *int64
	clearedbazel_invocation bool
	done                    bool
	oldValue                func(context.Context) (*BuildLogChunk, error)
	predicates              []predicate.BuildLogChunk
}

var _ ent.Mutation = (*BuildLogChunkMutation)(nil)

// buildlogchunkOption allows management of the mutation configuration using functional options.
type buildlogchunkOption func(*BuildLogChunkMutation)

// newBuildLogChunkMutation creates new mutation for the BuildLogChunk entity.
func newBuildLogChunkMutation(c config, op Op, opts ...buildlogchunkOption) *BuildLogChunkMutation {
	m := &BuildLogChunkMutation{
		config:        c,
		op:            op,
		typ:           TypeBuildLogChunk,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBuildLogChunkID sets the ID field of the mutation.
func withBuildLogChunkID(id int64) buildlogchunkOption {
	return func(m *BuildLogChunkMutation) {
		var (
			err   error
			once  sync.Once
			value *BuildLogChunk
		)
		m.oldValue = func(ctx context.Context) (*BuildLogChunk, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BuildLogChunk.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBuildLogChunk sets the old BuildLogChunk of the mutation.
func withBuildLogChunk(node *BuildLogChunk) buildlogchunkOption {
	return func(m *BuildLogChunkMutation) {
		m.oldValue = func(context.Context) (*BuildLogChunk, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BuildLogChunkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BuildLogChunkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BuildLogChunk entities.
func (m *BuildLogChunkMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BuildLogChunkMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BuildLogChunkMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BuildLogChunk.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetData sets the "data" field.
func (m *BuildLogChunkMutation) SetData(b []byte) {
	m.data = &b
}

// Data returns the value of the "data" field in the mutation.
func (m *BuildLogChunkMutation) Data() (r []byte, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the BuildLogChunk entity.
// If the BuildLogChunk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuildLogChunkMutation) OldData(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ResetData resets all changes to the "data" field.
func (m *BuildLogChunkMutation) ResetData() {
	m.data = nil
}

// SetChunkIndex sets the "chunk_index" field.
func (m *BuildLogChunkMutation) SetChunkIndex(i int) {
	m.chunk_index = &i
	m.addchunk_index = nil
}

// ChunkIndex returns the value of the "chunk_index" field in the mutation.
func (m *BuildLogChunkMutation) ChunkIndex() (r int, exists bool) {
	v := m.chunk_index
	if v == nil {
		return
	}
	return *v, true
}

// OldChunkIndex returns the old "chunk_index" field's value of the BuildLogChunk entity.
// If the BuildLogChunk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuildLogChunkMutation) OldChunkIndex(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChunkIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChunkIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChunkIndex: %w", err)
	}
	return oldValue.ChunkIndex, nil
}

// AddChunkIndex adds i to the "chunk_index" field.
func (m *BuildLogChunkMutation) AddChunkIndex(i int) {
	if m.addchunk_index != nil {
		*m.addchunk_index += i
	} else {
		m.addchunk_index = &i
	}
}

// AddedChunkIndex returns the value that was added to the "chunk_index" field in this mutation.
func (m *BuildLogChunkMutation) AddedChunkIndex() (r int, exists bool) {
	v := m.addchunk_index
	if v == nil {
		return
	}
	return *v, true
}

// ResetChunkIndex resets all changes to the "chunk_index" field.
func (m *BuildLogChunkMutation) ResetChunkIndex() {
	m.chunk_index = nil
	m.addchunk_index = nil
}

// SetFirstLineIndex sets the "first_line_index" field.
func (m *BuildLogChunkMutation) SetFirstLineIndex(i int64) {
	m.first_line_index = &i
	m.addfirst_line_index = nil
}

// FirstLineIndex returns the value of the "first_line_index" field in the mutation.
func (m *BuildLogChunkMutation) FirstLineIndex() (r int64, exists bool) {
	v := m.first_line_index
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstLineIndex returns the old "first_line_index" field's value of the BuildLogChunk entity.
// If the BuildLogChunk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuildLogChunkMutation) OldFirstLineIndex(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstLineIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstLineIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstLineIndex: %w", err)
	}
	return oldValue.FirstLineIndex, nil
}

// AddFirstLineIndex adds i to the "first_line_index" field.
func (m *BuildLogChunkMutation) AddFirstLineIndex(i int64) {
	if m.addfirst_line_index != nil {
		*m.addfirst_line_index += i
	} else {
		m.addfirst_line_index = &i
	}
}

// AddedFirstLineIndex returns the value that was added to the "first_line_index" field in this mutation.
func (m *BuildLogChunkMutation) AddedFirstLineIndex() (r int64, exists bool) {
	v := m.addfirst_line_index
	if v == nil {
		return
	}
	return *v, true
}

// ResetFirstLineIndex resets all changes to the "first_line_index" field.
func (m *BuildLogChunkMutation) ResetFirstLineIndex() {
	m.first_line_index = nil
	m.addfirst_line_index = nil
}

// SetLastLineIndex sets the "last_line_index" field.
func (m *BuildLogChunkMutation) SetLastLineIndex(i int64) {
	m.last_line_index = &i
	m.addlast_line_index = nil
}

// LastLineIndex returns the value of the "last_line_index" field in the mutation.
func (m *BuildLogChunkMutation) LastLineIndex() (r int64, exists bool) {
	v := m.last_line_index
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLineIndex returns the old "last_line_index" field's value of the BuildLogChunk entity.
// If the BuildLogChunk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuildLogChunkMutation) OldLastLineIndex(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLineIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLineIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLineIndex: %w", err)
	}
	return oldValue.LastLineIndex, nil
}

// AddLastLineIndex adds i to the "last_line_index" field.
func (m *BuildLogChunkMutation) AddLastLineIndex(i int64) {
	if m.addlast_line_index != nil {
		*m.addlast_line_index += i
	} else {
		m.addlast_line_index = &i
	}
}

// AddedLastLineIndex returns the value that was added to the "last_line_index" field in this mutation.
func (m *BuildLogChunkMutation) AddedLastLineIndex() (r int64, exists bool) {
	v := m.addlast_line_index
	if v == nil {
		return
	}
	return *v, true
}

// ResetLastLineIndex resets all changes to the "last_line_index" field.
func (m *BuildLogChunkMutation) ResetLastLineIndex() {
	m.last_line_index = nil
	m.addlast_line_index = nil
}

// SetBazelInvocationID sets the "bazel_invocation" edge to the BazelInvocation entity by id.
func (m *BuildLogChunkMutation) SetBazelInvocationID(id int64) {
	m.bazel_invocation = &id
}

// ClearBazelInvocation clears the "bazel_invocation" edge to the BazelInvocation entity.
func (m *BuildLogChunkMutation) ClearBazelInvocation() {
	m.clearedbazel_invocation = true
}

// BazelInvocationCleared reports if the "bazel_invocation" edge to the BazelInvocation entity was cleared.
func (m *BuildLogChunkMutation) BazelInvocationCleared() bool {
	return m.clearedbazel_invocation
}

// BazelInvocationID returns the "bazel_invocation" edge ID in the mutation.
func (m *BuildLogChunkMutation) BazelInvocationID() (id int64, exists bool) {
	if m.bazel_invocation != nil {
		return *m.bazel_invocation, true
	}
	return
}

// BazelInvocationIDs returns the "bazel_invocation" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BazelInvocationID instead. It exists only for internal usage by the builders.
func (m *BuildLogChunkMutation) BazelInvocationIDs() (ids []int64) {
	if id := m.bazel_invocation; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBazelInvocation resets all changes to the "bazel_invocation" edge.
func (m *BuildLogChunkMutation) ResetBazelInvocation() {
	m.bazel_invocation = nil
	m.clearedbazel_invocation = false
}

// Where appends a list predicates to the BuildLogChunkMutation builder.
func (m *BuildLogChunkMutation) Where(ps ...predicate.BuildLogChunk) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BuildLogChunkMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BuildLogChunkMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BuildLogChunk, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BuildLogChunkMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BuildLogChunkMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BuildLogChunk).
func (m *BuildLogChunkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BuildLogChunkMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.data != nil {
		fields = append(fields, buildlogchunk.FieldData)
	}
	if m.chunk_index != nil {
		fields = append(fields, buildlogchunk.FieldChunkIndex)
	}
	if m.first_line_index != nil {
		fields = append(fields, buildlogchunk.FieldFirstLineIndex)
	}
	if m.last_line_index != nil {
		fields = append(fields, buildlogchunk.FieldLastLineIndex)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BuildLogChunkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case buildlogchunk.FieldData:
		return m.Data()
	case buildlogchunk.FieldChunkIndex:
		return m.ChunkIndex()
	case buildlogchunk.FieldFirstLineIndex:
		return m.FirstLineIndex()
	case buildlogchunk.FieldLastLineIndex:
		return m.LastLineIndex()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BuildLogChunkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case buildlogchunk.FieldData:
		return m.OldData(ctx)
	case buildlogchunk.FieldChunkIndex:
		return m.OldChunkIndex(ctx)
	case buildlogchunk.FieldFirstLineIndex:
		return m.OldFirstLineIndex(ctx)
	case buildlogchunk.FieldLastLineIndex:
		return m.OldLastLineIndex(ctx)
	}
	return nil, fmt.Errorf("unknown BuildLogChunk field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BuildLogChunkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case buildlogchunk.FieldData:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	case buildlogchunk.FieldChunkIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChunkIndex(v)
		return nil
	case buildlogchunk.FieldFirstLineIndex:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstLineIndex(v)
		return nil
	case buildlogchunk.FieldLastLineIndex:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLineIndex(v)
		return nil
	}
	return fmt.Errorf("unknown BuildLogChunk field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BuildLogChunkMutation) AddedFields() []string {
	var fields []string
	if m.addchunk_index != nil {
		fields = append(fields, buildlogchunk.FieldChunkIndex)
	}
	if m.addfirst_line_index != nil {
		fields = append(fields, buildlogchunk.FieldFirstLineIndex)
	}
	if m.addlast_line_index != nil {
		fields = append(fields, buildlogchunk.FieldLastLineIndex)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BuildLogChunkMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case buildlogchunk.FieldChunkIndex:
		return m.AddedChunkIndex()
	case buildlogchunk.FieldFirstLineIndex:
		return m.AddedFirstLineIndex()
	case buildlogchunk.FieldLastLineIndex:
		return m.AddedLastLineIndex()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BuildLogChunkMutation) AddField(name string, value ent.Value) error {
	switch name {
	case buildlogchunk.FieldChunkIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChunkIndex(v)
		return nil
	case buildlogchunk.FieldFirstLineIndex:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFirstLineIndex(v)
		return nil
	case buildlogchunk.FieldLastLineIndex:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLastLineIndex(v)
		return nil
	}
	return fmt.Errorf("unknown BuildLogChunk numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BuildLogChunkMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BuildLogChunkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BuildLogChunkMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BuildLogChunk nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BuildLogChunkMutation) ResetField(name string) error {
	switch name {
	case buildlogchunk.FieldData:
		m.ResetData()
		return nil
	case buildlogchunk.FieldChunkIndex:
		m.ResetChunkIndex()
		return nil
	case buildlogchunk.FieldFirstLineIndex:
		m.ResetFirstLineIndex()
		return nil
	case buildlogchunk.FieldLastLineIndex:
		m.ResetLastLineIndex()
		return nil
	}
	return fmt.Errorf("unknown BuildLogChunk field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BuildLogChunkMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.bazel_invocation != nil {
		edges = append(edges, buildlogchunk.EdgeBazelInvocation)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BuildLogChunkMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case buildlogchunk.EdgeBazelInvocation:
		if id := m.bazel_invocation; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BuildLogChunkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BuildLogChunkMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BuildLogChunkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbazel_invocation {
		edges = append(edges, buildlogchunk.EdgeBazelInvocation)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BuildLogChunkMutation) EdgeCleared(name string) bool {
	switch name {
	case buildlogchunk.EdgeBazelInvocation:
		return m.clearedbazel_invocation
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BuildLogChunkMutation) ClearEdge(name string) error {
	switch name {
	case buildlogchunk.EdgeBazelInvocation:
		m.ClearBazelInvocation()
		return nil
	}
	return fmt.Errorf("unknown BuildLogChunk unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BuildLogChunkMutation) ResetEdge(name string) error {
	switch name {
	case buildlogchunk.EdgeBazelInvocation:
		m.ResetBazelInvocation()
		return nil
	}
	return fmt.Errorf("unknown BuildLogChunk edge %s", name)
}

// ConfigurationMutation represents an operation that mutates the Configuration nodes in the graph.
type ConfigurationMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int64
	configuration_id          *string
	mnemonic                  *string
	platform_name             *string
	cpu                       *string
	make_variables            *map[string]string
	is_tool                   *bool
	clearedFields             map[string]struct{}
	bazel_invocation          *int64
	clearedbazel_invocation   bool
	invocation_targets        map[int64]struct{}
	removedinvocation_targets map[int64]struct{}
	clearedinvocation_targets bool
	actions                   map[int64]struct{}
	removedactions            map[int64]struct{}
	clearedactions            bool
	done                      bool
	oldValue                  func(context.Context) (*Configuration, error)
	predicates                []predicate.Configuration
}

var _ ent.Mutation = (*ConfigurationMutation)(nil)

// configurationOption allows management of the mutation configuration using functional options.
type configurationOption func(*ConfigurationMutation)

// newConfigurationMutation creates new mutation for the Configuration entity.
func newConfigurationMutation(c config, op Op, opts ...configurationOption) *ConfigurationMutation {
	m := &ConfigurationMutation{
		config:        c,
		op:            op,
		typ:           TypeConfiguration,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConfigurationID sets the ID field of the mutation.
func withConfigurationID(id int64) configurationOption {
	return func(m *ConfigurationMutation) {
		var (
			err   error
			once  sync.Once
			value *Configuration
		)
		m.oldValue = func(ctx context.Context) (*Configuration, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Configuration.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConfiguration sets the old Configuration of the mutation.
func withConfiguration(node *Configuration) configurationOption {
	return func(m *ConfigurationMutation) {
		m.oldValue = func(context.Context) (*Configuration, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConfigurationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConfigurationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Configuration entities.
func (m *ConfigurationMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ConfigurationMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ConfigurationMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Configuration.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetConfigurationID sets the "configuration_id" field.
func (m *ConfigurationMutation) SetConfigurationID(s string) {
	m.configuration_id = &s
}

// ConfigurationID returns the value of the "configuration_id" field in the mutation.
func (m *ConfigurationMutation) ConfigurationID() (r string, exists bool) {
	v := m.configuration_id
	if v == nil {
		return
	}
	return *v, true
}

// OldConfigurationID returns the old "configuration_id" field's value of the Configuration entity.
// If the Configuration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationMutation) OldConfigurationID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfigurationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfigurationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfigurationID: %w", err)
	}
	return oldValue.ConfigurationID, nil
}

// ResetConfigurationID resets all changes to the "configuration_id" field.
func (m *ConfigurationMutation) ResetConfigurationID() {
	m.configuration_id = nil
}

// SetMnemonic sets the "mnemonic" field.
func (m *ConfigurationMutation) SetMnemonic(s string) {
	m.mnemonic = &s
}

// Mnemonic returns the value of the "mnemonic" field in the mutation.
func (m *ConfigurationMutation) Mnemonic() (r string, exists bool) {
	v := m.mnemonic
	if v == nil {
		return
	}
	return *v, true
}

// OldMnemonic returns the old "mnemonic" field's value of the Configuration entity.
// If the Configuration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationMutation) OldMnemonic(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMnemonic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMnemonic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMnemonic: %w", err)
	}
	return oldValue.Mnemonic, nil
}

// ClearMnemonic clears the value of the "mnemonic" field.
func (m *ConfigurationMutation) ClearMnemonic() {
	m.mnemonic = nil
	m.clearedFields[configuration.FieldMnemonic] = struct{}{}
}

// MnemonicCleared returns if the "mnemonic" field was cleared in this mutation.
func (m *ConfigurationMutation) MnemonicCleared() bool {
	_, ok := m.clearedFields[configuration.FieldMnemonic]
	return ok
}

// ResetMnemonic resets all changes to the "mnemonic" field.
func (m *ConfigurationMutation) ResetMnemonic() {
	m.mnemonic = nil
	delete(m.clearedFields, configuration.FieldMnemonic)
}

// SetPlatformName sets the "platform_name" field.
func (m *ConfigurationMutation) SetPlatformName(s string) {
	m.platform_name = &s
}

// PlatformName returns the value of the "platform_name" field in the mutation.
func (m *ConfigurationMutation) PlatformName() (r string, exists bool) {
	v := m.platform_name
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatformName returns the old "platform_name" field's value of the Configuration entity.
// If the Configuration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationMutation) OldPlatformName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatformName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatformName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatformName: %w", err)
	}
	return oldValue.PlatformName, nil
}

// ClearPlatformName clears the value of the "platform_name" field.
func (m *ConfigurationMutation) ClearPlatformName() {
	m.platform_name = nil
	m.clearedFields[configuration.FieldPlatformName] = struct{}{}
}

// PlatformNameCleared returns if the "platform_name" field was cleared in this mutation.
func (m *ConfigurationMutation) PlatformNameCleared() bool {
	_, ok := m.clearedFields[configuration.FieldPlatformName]
	return ok
}

// ResetPlatformName resets all changes to the "platform_name" field.
func (m *ConfigurationMutation) ResetPlatformName() {
	m.platform_name = nil
	delete(m.clearedFields, configuration.FieldPlatformName)
}

// SetCPU sets the "cpu" field.
func (m *ConfigurationMutation) SetCPU(s string) {
	m.cpu = &s
}

// CPU returns the value of the "cpu" field in the mutation.
func (m *ConfigurationMutation) CPU() (r string, exists bool) {
	v := m.cpu
	if v == nil {
		return
	}
	return *v, true
}

// OldCPU returns the old "cpu" field's value of the Configuration entity.
// If the Configuration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationMutation) OldCPU(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCPU is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCPU requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCPU: %w", err)
	}
	return oldValue.CPU, nil
}

// ClearCPU clears the value of the "cpu" field.
func (m *ConfigurationMutation) ClearCPU() {
	m.cpu = nil
	m.clearedFields[configuration.FieldCPU] = struct{}{}
}

// CPUCleared returns if the "cpu" field was cleared in this mutation.
func (m *ConfigurationMutation) CPUCleared() bool {
	_, ok := m.clearedFields[configuration.FieldCPU]
	return ok
}

// ResetCPU resets all changes to the "cpu" field.
func (m *ConfigurationMutation) ResetCPU() {
	m.cpu = nil
	delete(m.clearedFields, configuration.FieldCPU)
}

// SetMakeVariables sets the "make_variables" field.
func (m *ConfigurationMutation) SetMakeVariables(value map[string]string) {
	m.make_variables = &value
}

// MakeVariables returns the value of the "make_variables" field in the mutation.
func (m *ConfigurationMutation) MakeVariables() (r map[string]string, exists bool) {
	v := m.make_variables
	if v == nil {
		return
	}
	return *v, true
}

// OldMakeVariables returns the old "make_variables" field's value of the Configuration entity.
// If the Configuration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationMutation) OldMakeVariables(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMakeVariables is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMakeVariables requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMakeVariables: %w", err)
	}
	return oldValue.MakeVariables, nil
}

// ClearMakeVariables clears the value of the "make_variables" field.
func (m *ConfigurationMutation) ClearMakeVariables() {
	m.make_variables = nil
	m.clearedFields[configuration.FieldMakeVariables] = struct{}{}
}

// MakeVariablesCleared returns if the "make_variables" field was cleared in this mutation.
func (m *ConfigurationMutation) MakeVariablesCleared() bool {
	_, ok := m.clearedFields[configuration.FieldMakeVariables]
	return ok
}

// ResetMakeVariables resets all changes to the "make_variables" field.
func (m *ConfigurationMutation) ResetMakeVariables() {
	m.make_variables = nil
	delete(m.clearedFields, configuration.FieldMakeVariables)
}

// SetIsTool sets the "is_tool" field.
func (m *ConfigurationMutation) SetIsTool(b bool) {
	m.is_tool = &b
}

// IsTool returns the value of the "is_tool" field in the mutation.
func (m *ConfigurationMutation) IsTool() (r bool, exists bool) {
	v := m.is_tool
	if v == nil {
		return
	}
	return *v, true
}

// OldIsTool returns the old "is_tool" field's value of the Configuration entity.
// If the Configuration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationMutation) OldIsTool(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsTool is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsTool requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsTool: %w", err)
	}
	return oldValue.IsTool, nil
}

// ClearIsTool clears the value of the "is_tool" field.
func (m *ConfigurationMutation) ClearIsTool() {
	m.is_tool = nil
	m.clearedFields[configuration.FieldIsTool] = struct{}{}
}

// IsToolCleared returns if the "is_tool" field was cleared in this mutation.
func (m *ConfigurationMutation) IsToolCleared() bool {
	_, ok := m.clearedFields[configuration.FieldIsTool]
	return ok
}

// ResetIsTool resets all changes to the "is_tool" field.
func (m *ConfigurationMutation) ResetIsTool() {
	m.is_tool = nil
	delete(m.clearedFields, configuration.FieldIsTool)
}

// SetBazelInvocationID sets the "bazel_invocation_id" field.
func (m *ConfigurationMutation) SetBazelInvocationID(i int64) {
	m.bazel_invocation = &i
}

// BazelInvocationID returns the value of the "bazel_invocation_id" field in the mutation.
func (m *ConfigurationMutation) BazelInvocationID() (r int64, exists bool) {
	v := m.bazel_invocation
	if v == nil {
		return
	}
	return *v, true
}

// OldBazelInvocationID returns the old "bazel_invocation_id" field's value of the Configuration entity.
// If the Configuration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationMutation) OldBazelInvocationID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBazelInvocationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBazelInvocationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBazelInvocationID: %w", err)
	}
	return oldValue.BazelInvocationID, nil
}

// ResetBazelInvocationID resets all changes to the "bazel_invocation_id" field.
func (m *ConfigurationMutation) ResetBazelInvocationID() {
	m.bazel_invocation = nil
}

// ClearBazelInvocation clears the "bazel_invocation" edge to the BazelInvocation entity.
func (m *ConfigurationMutation) ClearBazelInvocation() {
	m.clearedbazel_invocation = true
	m.clearedFields[configuration.FieldBazelInvocationID] = struct{}{}
}

// BazelInvocationCleared reports if the "bazel_invocation" edge to the BazelInvocation entity was cleared.
func (m *ConfigurationMutation) BazelInvocationCleared() bool {
	return m.clearedbazel_invocation
}

// BazelInvocationIDs returns the "bazel_invocation" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BazelInvocationID instead. It exists only for internal usage by the builders.
func (m *ConfigurationMutation) BazelInvocationIDs() (ids []int64) {
	if id := m.bazel_invocation; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBazelInvocation resets all changes to the "bazel_invocation" edge.
func (m *ConfigurationMutation) ResetBazelInvocation() {
	m.bazel_invocation = nil
	m.clearedbazel_invocation = false
}

// AddInvocationTargetIDs adds the "invocation_targets" edge to the InvocationTarget entity by ids.
func (m *ConfigurationMutation) AddInvocationTargetIDs(ids ...int64) {
	if m.invocation_targets == nil {
		m.invocation_targets = make(map[int64]struct{})
	}
	for i := range ids {
		m.invocation_targets[ids[i]] = struct{}{}
	}
}

// ClearInvocationTargets clears the "invocation_targets" edge to the InvocationTarget entity.
func (m *ConfigurationMutation) ClearInvocationTargets() {
	m.clearedinvocation_targets = true
}

// InvocationTargetsCleared reports if the "invocation_targets" edge to the InvocationTarget entity was cleared.
func (m *ConfigurationMutation) InvocationTargetsCleared() bool {
	return m.clearedinvocation_targets
}

// RemoveInvocationTargetIDs removes the "invocation_targets" edge to the InvocationTarget entity by IDs.
func (m *ConfigurationMutation) RemoveInvocationTargetIDs(ids ...int64) {
	if m.removedinvocation_targets == nil {
		m.removedinvocation_targets = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.invocation_targets, ids[i])
		m.removedinvocation_targets[ids[i]] = struct{}{}
	}
}

// RemovedInvocationTargets returns the removed IDs of the "invocation_targets" edge to the InvocationTarget entity.
func (m *ConfigurationMutation) RemovedInvocationTargetsIDs() (ids []int64) {
	for id := range m.removedinvocation_targets {
		ids = append(ids, id)
	}
	return
}

// InvocationTargetsIDs returns the "invocation_targets" edge IDs in the mutation.
func (m *ConfigurationMutation) InvocationTargetsIDs() (ids []int64) {
	for id := range m.invocation_targets {
		ids = append(ids, id)
	}
	return
}

// ResetInvocationTargets resets all changes to the "invocation_targets" edge.
func (m *ConfigurationMutation) ResetInvocationTargets() {
	m.invocation_targets = nil
	m.clearedinvocation_targets = false
	m.removedinvocation_targets = nil
}

// AddActionIDs adds the "actions" edge to the Action entity by ids.
func (m *ConfigurationMutation) AddActionIDs(ids ...int64) {
	if m.actions == nil {
		m.actions = make(map[int64]struct{})
	}
	for i := range ids {
		m.actions[ids[i]] = struct{}{}
	}
}

// ClearActions clears the "actions" edge to the Action entity.
func (m *ConfigurationMutation) ClearActions() {
	m.clearedactions = true
}

// ActionsCleared reports if the "actions" edge to the Action entity was cleared.
func (m *ConfigurationMutation) ActionsCleared() bool {
	return m.clearedactions
}

// RemoveActionIDs removes the "actions" edge to the Action entity by IDs.
func (m *ConfigurationMutation) RemoveActionIDs(ids ...int64) {
	if m.removedactions == nil {
		m.removedactions = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.actions, ids[i])
		m.removedactions[ids[i]] = struct{}{}
	}
}

// RemovedActions returns the removed IDs of the "actions" edge to the Action entity.
func (m *ConfigurationMutation) RemovedActionsIDs() (ids []int64) {
	for id := range m.removedactions {
		ids = append(ids, id)
	}
	return
}

// ActionsIDs returns the "actions" edge IDs in the mutation.
func (m *ConfigurationMutation) ActionsIDs() (ids []int64) {
	for id := range m.actions {
		ids = append(ids, id)
	}
	return
}

// ResetActions resets all changes to the "actions" edge.
func (m *ConfigurationMutation) ResetActions() {
	m.actions = nil
	m.clearedactions = false
	m.removedactions = nil
}

// Where appends a list predicates to the ConfigurationMutation builder.
func (m *ConfigurationMutation) Where(ps ...predicate.Configuration) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ConfigurationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ConfigurationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Configuration, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ConfigurationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ConfigurationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Configuration).
func (m *ConfigurationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ConfigurationMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.configuration_id != nil {
		fields = append(fields, configuration.FieldConfigurationID)
	}
	if m.mnemonic != nil {
		fields = append(fields, configuration.FieldMnemonic)
	}
	if m.platform_name != nil {
		fields = append(fields, configuration.FieldPlatformName)
	}
	if m.cpu != nil {
		fields = append(fields, configuration.FieldCPU)
	}
	if m.make_variables != nil {
		fields = append(fields, configuration.FieldMakeVariables)
	}
	if m.is_tool != nil {
		fields = append(fields, configuration.FieldIsTool)
	}
	if m.bazel_invocation != nil {
		fields = append(fields, configuration.FieldBazelInvocationID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ConfigurationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case configuration.FieldConfigurationID:
		return m.ConfigurationID()
	case configuration.FieldMnemonic:
		return m.Mnemonic()
	case configuration.FieldPlatformName:
		return m.PlatformName()
	case configuration.FieldCPU:
		return m.CPU()
	case configuration.FieldMakeVariables:
		return m.MakeVariables()
	case configuration.FieldIsTool:
		return m.IsTool()
	case configuration.FieldBazelInvocationID:
		return m.BazelInvocationID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ConfigurationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case configuration.FieldConfigurationID:
		return m.OldConfigurationID(ctx)
	case configuration.FieldMnemonic:
		return m.OldMnemonic(ctx)
	case configuration.FieldPlatformName:
		return m.OldPlatformName(ctx)
	case configuration.FieldCPU:
		return m.OldCPU(ctx)
	case configuration.FieldMakeVariables:
		return m.OldMakeVariables(ctx)
	case configuration.FieldIsTool:
		return m.OldIsTool(ctx)
	case configuration.FieldBazelInvocationID:
		return m.OldBazelInvocationID(ctx)
	}
	return nil, fmt.Errorf("unknown Configuration field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConfigurationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case configuration.FieldConfigurationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfigurationID(v)
		return nil
	case configuration.FieldMnemonic:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMnemonic(v)
		return nil
	case configuration.FieldPlatformName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatformName(v)
		return nil
	case configuration.FieldCPU:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCPU(v)
		return nil
	case configuration.FieldMakeVariables:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMakeVariables(v)
		return nil
	case configuration.FieldIsTool:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsTool(v)
		return nil
	case configuration.FieldBazelInvocationID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBazelInvocationID(v)
		return nil
	}
	return fmt.Errorf("unknown Configuration field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ConfigurationMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ConfigurationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConfigurationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Configuration numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ConfigurationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(configuration.FieldMnemonic) {
		fields = append(fields, configuration.FieldMnemonic)
	}
	if m.FieldCleared(configuration.FieldPlatformName) {
		fields = append(fields, configuration.FieldPlatformName)
	}
	if m.FieldCleared(configuration.FieldCPU) {
		fields = append(fields, configuration.FieldCPU)
	}
	if m.FieldCleared(configuration.FieldMakeVariables) {
		fields = append(fields, configuration.FieldMakeVariables)
	}
	if m.FieldCleared(configuration.FieldIsTool) {
		fields = append(fields, configuration.FieldIsTool)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ConfigurationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConfigurationMutation) ClearField(name string) error {
	switch name {
	case configuration.FieldMnemonic:
		m.ClearMnemonic()
		return nil
	case configuration.FieldPlatformName:
		m.ClearPlatformName()
		return nil
	case configuration.FieldCPU:
		m.ClearCPU()
		return nil
	case configuration.FieldMakeVariables:
		m.ClearMakeVariables()
		return nil
	case configuration.FieldIsTool:
		m.ClearIsTool()
		return nil
	}
	return fmt.Errorf("unknown Configuration nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ConfigurationMutation) ResetField(name string) error {
	switch name {
	case configuration.FieldConfigurationID:
		m.ResetConfigurationID()
		return nil
	case configuration.FieldMnemonic:
		m.ResetMnemonic()
		return nil
	case configuration.FieldPlatformName:
		m.ResetPlatformName()
		return nil
	case configuration.FieldCPU:
		m.ResetCPU()
		return nil
	case configuration.FieldMakeVariables:
		m.ResetMakeVariables()
		return nil
	case configuration.FieldIsTool:
		m.ResetIsTool()
		return nil
	case configuration.FieldBazelInvocationID:
		m.ResetBazelInvocationID()
		return nil
	}
	return fmt.Errorf("unknown Configuration field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ConfigurationMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.bazel_invocation != nil {
		edges = append(edges, configuration.EdgeBazelInvocation)
	}
	if m.invocation_targets != nil {
		edges = append(edges, configuration.EdgeInvocationTargets)
	}
	if m.actions != nil {
		edges = append(edges, configuration.EdgeActions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ConfigurationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case configuration.EdgeBazelInvocation:
		if id := m.bazel_invocation; id != nil {
			return []ent.Value{*id}
		}
	case configuration.EdgeInvocationTargets:
		ids := make([]ent.Value, 0, len(m.invocation_targets))
		for id := range m.invocation_targets {
			ids = append(ids, id)
		}
		return ids
	case configuration.EdgeActions:
		ids := make([]ent.Value, 0, len(m.actions))
		for id := range m.actions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ConfigurationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedinvocation_targets != nil {
		edges = append(edges, configuration.EdgeInvocationTargets)
	}
	if m.removedactions != nil {
		edges = append(edges, configuration.EdgeActions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ConfigurationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case configuration.EdgeInvocationTargets:
		ids := make([]ent.Value, 0, len(m.removedinvocation_targets))
		for id := range m.removedinvocation_targets {
			ids = append(ids, id)
		}
		return ids
	case configuration.EdgeActions:
		ids := make([]ent.Value, 0, len(m.removedactions))
		for id := range m.removedactions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ConfigurationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedbazel_invocation {
		edges = append(edges, configuration.EdgeBazelInvocation)
	}
	if m.clearedinvocation_targets {
		edges = append(edges, configuration.EdgeInvocationTargets)
	}
	if m.clearedactions {
		edges = append(edges, configuration.EdgeActions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ConfigurationMutation) EdgeCleared(name string) bool {
	switch name {
	case configuration.EdgeBazelInvocation:
		return m.clearedbazel_invocation
	case configuration.EdgeInvocationTargets:
		return m.clearedinvocation_targets
	case configuration.EdgeActions:
		return m.clearedactions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ConfigurationMutation) ClearEdge(name string) error {
	switch name {
	case configuration.EdgeBazelInvocation:
		m.ClearBazelInvocation()
		return nil
	}
	return fmt.Errorf("unknown Configuration unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ConfigurationMutation) ResetEdge(name string) error {
	switch name {
	case configuration.EdgeBazelInvocation:
		m.ResetBazelInvocation()
		return nil
	case configuration.EdgeInvocationTargets:
		m.ResetInvocationTargets()
		return nil
	case configuration.EdgeActions:
		m.ResetActions()
		return nil
	}
	return fmt.Errorf("unknown Configuration edge %s", name)
}

// ConnectionMetadataMutation represents an operation that mutates the ConnectionMetadata nodes in the graph.
type ConnectionMetadataMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int64
	connection_last_open_at *time.Time
	clearedFields           map[string]struct{}
	bazel_invocation        *int64
	clearedbazel_invocation bool
	done                    bool
	oldValue                func(context.Context) (*ConnectionMetadata, error)
	predicates              []predicate.ConnectionMetadata
}

var _ ent.Mutation = (*ConnectionMetadataMutation)(nil)

// connectionmetadataOption allows management of the mutation configuration using functional options.
type connectionmetadataOption func(*ConnectionMetadataMutation)

// newConnectionMetadataMutation creates new mutation for the ConnectionMetadata entity.
func newConnectionMetadataMutation(c config, op Op, opts ...connectionmetadataOption) *ConnectionMetadataMutation {
	m := &ConnectionMetadataMutation{
		config:        c,
		op:            op,
		typ:           TypeConnectionMetadata,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConnectionMetadataID sets the ID field of the mutation.
func withConnectionMetadataID(id int64) connectionmetadataOption {
	return func(m *ConnectionMetadataMutation) {
		var (
			err   error
			once  sync.Once
			value *ConnectionMetadata
		)
		m.oldValue = func(ctx context.Context) (*ConnectionMetadata, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ConnectionMetadata.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConnectionMetadata sets the old ConnectionMetadata of the mutation.
func withConnectionMetadata(node *ConnectionMetadata) connectionmetadataOption {
	return func(m *ConnectionMetadataMutation) {
		m.oldValue = func(context.Context) (*ConnectionMetadata, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConnectionMetadataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConnectionMetadataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ConnectionMetadata entities.
func (m *ConnectionMetadataMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ConnectionMetadataMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ConnectionMetadataMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ConnectionMetadata.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetConnectionLastOpenAt sets the "connection_last_open_at" field.
func (m *ConnectionMetadataMutation) SetConnectionLastOpenAt(t time.Time) {
	m.connection_last_open_at = &t
}

// ConnectionLastOpenAt returns the value of the "connection_last_open_at" field in the mutation.
func (m *ConnectionMetadataMutation) ConnectionLastOpenAt() (r time.Time, exists bool) {
	v := m.connection_last_open_at
	if v == nil {
		return
	}
	return *v, true
}

// OldConnectionLastOpenAt returns the old "connection_last_open_at" field's value of the ConnectionMetadata entity.
// If the ConnectionMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectionMetadataMutation) OldConnectionLastOpenAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConnectionLastOpenAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConnectionLastOpenAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConnectionLastOpenAt: %w", err)
	}
	return oldValue.ConnectionLastOpenAt, nil
}

// ResetConnectionLastOpenAt resets all changes to the "connection_last_open_at" field.
func (m *ConnectionMetadataMutation) ResetConnectionLastOpenAt() {
	m.connection_last_open_at = nil
}

// SetBazelInvocationID sets the "bazel_invocation" edge to the BazelInvocation entity by id.
func (m *ConnectionMetadataMutation) SetBazelInvocationID(id int64) {
	m.bazel_invocation = &id
}

// ClearBazelInvocation clears the "bazel_invocation" edge to the BazelInvocation entity.
func (m *ConnectionMetadataMutation) ClearBazelInvocation() {
	m.clearedbazel_invocation = true
}

// BazelInvocationCleared reports if the "bazel_invocation" edge to the BazelInvocation entity was cleared.
func (m *ConnectionMetadataMutation) BazelInvocationCleared() bool {
	return m.clearedbazel_invocation
}

// BazelInvocationID returns the "bazel_invocation" edge ID in the mutation.
func (m *ConnectionMetadataMutation) BazelInvocationID() (id int64, exists bool) {
	if m.bazel_invocation != nil {
		return *m.bazel_invocation, true
	}
	return
}

// BazelInvocationIDs returns the "bazel_invocation" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BazelInvocationID instead. It exists only for internal usage by the builders.
func (m *ConnectionMetadataMutation) BazelInvocationIDs() (ids []int64) {
	if id := m.bazel_invocation; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBazelInvocation resets all changes to the "bazel_invocation" edge.
func (m *ConnectionMetadataMutation) ResetBazelInvocation() {
	m.bazel_invocation = nil
	m.clearedbazel_invocation = false
}

// Where appends a list predicates to the ConnectionMetadataMutation builder.
func (m *ConnectionMetadataMutation) Where(ps ...predicate.ConnectionMetadata) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ConnectionMetadataMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ConnectionMetadataMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ConnectionMetadata, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ConnectionMetadataMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ConnectionMetadataMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ConnectionMetadata).
func (m *ConnectionMetadataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ConnectionMetadataMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.connection_last_open_at != nil {
		fields = append(fields, connectionmetadata.FieldConnectionLastOpenAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ConnectionMetadataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case connectionmetadata.FieldConnectionLastOpenAt:
		return m.ConnectionLastOpenAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ConnectionMetadataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case connectionmetadata.FieldConnectionLastOpenAt:
		return m.OldConnectionLastOpenAt(ctx)
	}
	return nil, fmt.Errorf("unknown ConnectionMetadata field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConnectionMetadataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case connectionmetadata.FieldConnectionLastOpenAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConnectionLastOpenAt(v)
		return nil
	}
	return fmt.Errorf("unknown ConnectionMetadata field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ConnectionMetadataMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ConnectionMetadataMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConnectionMetadataMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ConnectionMetadata numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ConnectionMetadataMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ConnectionMetadataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConnectionMetadataMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ConnectionMetadata nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ConnectionMetadataMutation) ResetField(name string) error {
	switch name {
	case connectionmetadata.FieldConnectionLastOpenAt:
		m.ResetConnectionLastOpenAt()
		return nil
	}
	return fmt.Errorf("unknown ConnectionMetadata field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ConnectionMetadataMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.bazel_invocation != nil {
		edges = append(edges, connectionmetadata.EdgeBazelInvocation)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ConnectionMetadataMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case connectionmetadata.EdgeBazelInvocation:
		if id := m.bazel_invocation; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ConnectionMetadataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ConnectionMetadataMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ConnectionMetadataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbazel_invocation {
		edges = append(edges, connectionmetadata.EdgeBazelInvocation)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ConnectionMetadataMutation) EdgeCleared(name string) bool {
	switch name {
	case connectionmetadata.EdgeBazelInvocation:
		return m.clearedbazel_invocation
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ConnectionMetadataMutation) ClearEdge(name string) error {
	switch name {
	case connectionmetadata.EdgeBazelInvocation:
		m.ClearBazelInvocation()
		return nil
	}
	return fmt.Errorf("unknown ConnectionMetadata unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ConnectionMetadataMutation) ResetEdge(name string) error {
	switch name {
	case connectionmetadata.EdgeBazelInvocation:
		m.ResetBazelInvocation()
		return nil
	}
	return fmt.Errorf("unknown ConnectionMetadata edge %s", name)
}

// CumulativeMetricsMutation represents an operation that mutates the CumulativeMetrics nodes in the graph.
type CumulativeMetricsMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	num_analyses    *int32
	addnum_analyses *int32
	num_builds      *int32
	addnum_builds   *int32
	clearedFields   map[string]struct{}
	metrics         *int64
	clearedmetrics  bool
	done            bool
	oldValue        func(context.Context) (*CumulativeMetrics, error)
	predicates      []predicate.CumulativeMetrics
}

var _ ent.Mutation = (*CumulativeMetricsMutation)(nil)

// cumulativemetricsOption allows management of the mutation configuration using functional options.
type cumulativemetricsOption func(*CumulativeMetricsMutation)

// newCumulativeMetricsMutation creates new mutation for the CumulativeMetrics entity.
func newCumulativeMetricsMutation(c config, op Op, opts ...cumulativemetricsOption) *CumulativeMetricsMutation {
	m := &CumulativeMetricsMutation{
		config:        c,
		op:            op,
		typ:           TypeCumulativeMetrics,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCumulativeMetricsID sets the ID field of the mutation.
func withCumulativeMetricsID(id int64) cumulativemetricsOption {
	return func(m *CumulativeMetricsMutation) {
		var (
			err   error
			once  sync.Once
			value *CumulativeMetrics
		)
		m.oldValue = func(ctx context.Context) (*CumulativeMetrics, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CumulativeMetrics.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCumulativeMetrics sets the old CumulativeMetrics of the mutation.
func withCumulativeMetrics(node *CumulativeMetrics) cumulativemetricsOption {
	return func(m *CumulativeMetricsMutation) {
		m.oldValue = func(context.Context) (*CumulativeMetrics, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CumulativeMetricsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CumulativeMetricsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CumulativeMetrics entities.
func (m *CumulativeMetricsMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CumulativeMetricsMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CumulativeMetricsMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CumulativeMetrics.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNumAnalyses sets the "num_analyses" field.
func (m *CumulativeMetricsMutation) SetNumAnalyses(i int32) {
	m.num_analyses = &i
	m.addnum_analyses = nil
}

// NumAnalyses returns the value of the "num_analyses" field in the mutation.
func (m *CumulativeMetricsMutation) NumAnalyses() (r int32, exists bool) {
	v := m.num_analyses
	if v == nil {
		return
	}
	return *v, true
}

// OldNumAnalyses returns the old "num_analyses" field's value of the CumulativeMetrics entity.
// If the CumulativeMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CumulativeMetricsMutation) OldNumAnalyses(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumAnalyses is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumAnalyses requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumAnalyses: %w", err)
	}
	return oldValue.NumAnalyses, nil
}

// AddNumAnalyses adds i to the "num_analyses" field.
func (m *CumulativeMetricsMutation) AddNumAnalyses(i int32) {
	if m.addnum_analyses != nil {
		*m.addnum_analyses += i
	} else {
		m.addnum_analyses = &i
	}
}

// AddedNumAnalyses returns the value that was added to the "num_analyses" field in this mutation.
func (m *CumulativeMetricsMutation) AddedNumAnalyses() (r int32, exists bool) {
	v := m.addnum_analyses
	if v == nil {
		return
	}
	return *v, true
}

// ClearNumAnalyses clears the value of the "num_analyses" field.
func (m *CumulativeMetricsMutation) ClearNumAnalyses() {
	m.num_analyses = nil
	m.addnum_analyses = nil
	m.clearedFields[cumulativemetrics.FieldNumAnalyses] = struct{}{}
}

// NumAnalysesCleared returns if the "num_analyses" field was cleared in this mutation.
func (m *CumulativeMetricsMutation) NumAnalysesCleared() bool {
	_, ok := m.clearedFields[cumulativemetrics.FieldNumAnalyses]
	return ok
}

// ResetNumAnalyses resets all changes to the "num_analyses" field.
func (m *CumulativeMetricsMutation) ResetNumAnalyses() {
	m.num_analyses = nil
	m.addnum_analyses = nil
	delete(m.clearedFields, cumulativemetrics.FieldNumAnalyses)
}

// SetNumBuilds sets the "num_builds" field.
func (m *CumulativeMetricsMutation) SetNumBuilds(i int32) {
	m.num_builds = &i
	m.addnum_builds = nil
}

// NumBuilds returns the value of the "num_builds" field in the mutation.
func (m *CumulativeMetricsMutation) NumBuilds() (r int32, exists bool) {
	v := m.num_builds
	if v == nil {
		return
	}
	return *v, true
}

// OldNumBuilds returns the old "num_builds" field's value of the CumulativeMetrics entity.
// If the CumulativeMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CumulativeMetricsMutation) OldNumBuilds(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumBuilds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumBuilds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumBuilds: %w", err)
	}
	return oldValue.NumBuilds, nil
}

// AddNumBuilds adds i to the "num_builds" field.
func (m *CumulativeMetricsMutation) AddNumBuilds(i int32) {
	if m.addnum_builds != nil {
		*m.addnum_builds += i
	} else {
		m.addnum_builds = &i
	}
}

// AddedNumBuilds returns the value that was added to the "num_builds" field in this mutation.
func (m *CumulativeMetricsMutation) AddedNumBuilds() (r int32, exists bool) {
	v := m.addnum_builds
	if v == nil {
		return
	}
	return *v, true
}

// ClearNumBuilds clears the value of the "num_builds" field.
func (m *CumulativeMetricsMutation) ClearNumBuilds() {
	m.num_builds = nil
	m.addnum_builds = nil
	m.clearedFields[cumulativemetrics.FieldNumBuilds] = struct{}{}
}

// NumBuildsCleared returns if the "num_builds" field was cleared in this mutation.
func (m *CumulativeMetricsMutation) NumBuildsCleared() bool {
	_, ok := m.clearedFields[cumulativemetrics.FieldNumBuilds]
	return ok
}

// ResetNumBuilds resets all changes to the "num_builds" field.
func (m *CumulativeMetricsMutation) ResetNumBuilds() {
	m.num_builds = nil
	m.addnum_builds = nil
	delete(m.clearedFields, cumulativemetrics.FieldNumBuilds)
}

// SetMetricsID sets the "metrics" edge to the Metrics entity by id.
func (m *CumulativeMetricsMutation) SetMetricsID(id int64) {
	m.metrics = &id
}

// ClearMetrics clears the "metrics" edge to the Metrics entity.
func (m *CumulativeMetricsMutation) ClearMetrics() {
	m.clearedmetrics = true
}

// MetricsCleared reports if the "metrics" edge to the Metrics entity was cleared.
func (m *CumulativeMetricsMutation) MetricsCleared() bool {
	return m.clearedmetrics
}

// MetricsID returns the "metrics" edge ID in the mutation.
func (m *CumulativeMetricsMutation) MetricsID() (id int64, exists bool) {
	if m.metrics != nil {
		return *m.metrics, true
	}
	return
}

// MetricsIDs returns the "metrics" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MetricsID instead. It exists only for internal usage by the builders.
func (m *CumulativeMetricsMutation) MetricsIDs() (ids []int64) {
	if id := m.metrics; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMetrics resets all changes to the "metrics" edge.
func (m *CumulativeMetricsMutation) ResetMetrics() {
	m.metrics = nil
	m.clearedmetrics = false
}

// Where appends a list predicates to the CumulativeMetricsMutation builder.
func (m *CumulativeMetricsMutation) Where(ps ...predicate.CumulativeMetrics) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CumulativeMetricsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CumulativeMetricsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CumulativeMetrics, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CumulativeMetricsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CumulativeMetricsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CumulativeMetrics).
func (m *CumulativeMetricsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CumulativeMetricsMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.num_analyses != nil {
		fields = append(fields, cumulativemetrics.FieldNumAnalyses)
	}
	if m.num_builds != nil {
		fields = append(fields, cumulativemetrics.FieldNumBuilds)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CumulativeMetricsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cumulativemetrics.FieldNumAnalyses:
		return m.NumAnalyses()
	case cumulativemetrics.FieldNumBuilds:
		return m.NumBuilds()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CumulativeMetricsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cumulativemetrics.FieldNumAnalyses:
		return m.OldNumAnalyses(ctx)
	case cumulativemetrics.FieldNumBuilds:
		return m.OldNumBuilds(ctx)
	}
	return nil, fmt.Errorf("unknown CumulativeMetrics field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CumulativeMetricsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cumulativemetrics.FieldNumAnalyses:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumAnalyses(v)
		return nil
	case cumulativemetrics.FieldNumBuilds:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumBuilds(v)
		return nil
	}
	return fmt.Errorf("unknown CumulativeMetrics field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CumulativeMetricsMutation) AddedFields() []string {
	var fields []string
	if m.addnum_analyses != nil {
		fields = append(fields, cumulativemetrics.FieldNumAnalyses)
	}
	if m.addnum_builds != nil {
		fields = append(fields, cumulativemetrics.FieldNumBuilds)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CumulativeMetricsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case cumulativemetrics.FieldNumAnalyses:
		return m.AddedNumAnalyses()
	case cumulativemetrics.FieldNumBuilds:
		return m.AddedNumBuilds()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CumulativeMetricsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case cumulativemetrics.FieldNumAnalyses:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumAnalyses(v)
		return nil
	case cumulativemetrics.FieldNumBuilds:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumBuilds(v)
		return nil
	}
	return fmt.Errorf("unknown CumulativeMetrics numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CumulativeMetricsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(cumulativemetrics.FieldNumAnalyses) {
		fields = append(fields, cumulativemetrics.FieldNumAnalyses)
	}
	if m.FieldCleared(cumulativemetrics.FieldNumBuilds) {
		fields = append(fields, cumulativemetrics.FieldNumBuilds)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CumulativeMetricsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CumulativeMetricsMutation) ClearField(name string) error {
	switch name {
	case cumulativemetrics.FieldNumAnalyses:
		m.ClearNumAnalyses()
		return nil
	case cumulativemetrics.FieldNumBuilds:
		m.ClearNumBuilds()
		return nil
	}
	return fmt.Errorf("unknown CumulativeMetrics nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CumulativeMetricsMutation) ResetField(name string) error {
	switch name {
	case cumulativemetrics.FieldNumAnalyses:
		m.ResetNumAnalyses()
		return nil
	case cumulativemetrics.FieldNumBuilds:
		m.ResetNumBuilds()
		return nil
	}
	return fmt.Errorf("unknown CumulativeMetrics field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CumulativeMetricsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.metrics != nil {
		edges = append(edges, cumulativemetrics.EdgeMetrics)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CumulativeMetricsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case cumulativemetrics.EdgeMetrics:
		if id := m.metrics; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CumulativeMetricsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CumulativeMetricsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CumulativeMetricsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmetrics {
		edges = append(edges, cumulativemetrics.EdgeMetrics)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CumulativeMetricsMutation) EdgeCleared(name string) bool {
	switch name {
	case cumulativemetrics.EdgeMetrics:
		return m.clearedmetrics
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CumulativeMetricsMutation) ClearEdge(name string) error {
	switch name {
	case cumulativemetrics.EdgeMetrics:
		m.ClearMetrics()
		return nil
	}
	return fmt.Errorf("unknown CumulativeMetrics unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CumulativeMetricsMutation) ResetEdge(name string) error {
	switch name {
	case cumulativemetrics.EdgeMetrics:
		m.ResetMetrics()
		return nil
	}
	return fmt.Errorf("unknown CumulativeMetrics edge %s", name)
}

// EvaluationStatMutation represents an operation that mutates the EvaluationStat nodes in the graph.
type EvaluationStatMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int64
	skyfunction_name           *string
	count                      *int64
	addcount                   *int64
	clearedFields              map[string]struct{}
	build_graph_metrics        *int64
	clearedbuild_graph_metrics bool
	done                       bool
	oldValue                   func(context.Context) (*EvaluationStat, error)
	predicates                 []predicate.EvaluationStat
}

var _ ent.Mutation = (*EvaluationStatMutation)(nil)

// evaluationstatOption allows management of the mutation configuration using functional options.
type evaluationstatOption func(*EvaluationStatMutation)

// newEvaluationStatMutation creates new mutation for the EvaluationStat entity.
func newEvaluationStatMutation(c config, op Op, opts ...evaluationstatOption) *EvaluationStatMutation {
	m := &EvaluationStatMutation{
		config:        c,
		op:            op,
		typ:           TypeEvaluationStat,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEvaluationStatID sets the ID field of the mutation.
func withEvaluationStatID(id int64) evaluationstatOption {
	return func(m *EvaluationStatMutation) {
		var (
			err   error
			once  sync.Once
			value *EvaluationStat
		)
		m.oldValue = func(ctx context.Context) (*EvaluationStat, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EvaluationStat.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEvaluationStat sets the old EvaluationStat of the mutation.
func withEvaluationStat(node *EvaluationStat) evaluationstatOption {
	return func(m *EvaluationStatMutation) {
		m.oldValue = func(context.Context) (*EvaluationStat, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EvaluationStatMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EvaluationStatMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EvaluationStat entities.
func (m *EvaluationStatMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EvaluationStatMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EvaluationStatMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EvaluationStat.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSkyfunctionName sets the "skyfunction_name" field.
func (m *EvaluationStatMutation) SetSkyfunctionName(s string) {
	m.skyfunction_name = &s
}

// SkyfunctionName returns the value of the "skyfunction_name" field in the mutation.
func (m *EvaluationStatMutation) SkyfunctionName() (r string, exists bool) {
	v := m.skyfunction_name
	if v == nil {
		return
	}
	return *v, true
}

// OldSkyfunctionName returns the old "skyfunction_name" field's value of the EvaluationStat entity.
// If the EvaluationStat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EvaluationStatMutation) OldSkyfunctionName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSkyfunctionName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSkyfunctionName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkyfunctionName: %w", err)
	}
	return oldValue.SkyfunctionName, nil
}

// ClearSkyfunctionName clears the value of the "skyfunction_name" field.
func (m *EvaluationStatMutation) ClearSkyfunctionName() {
	m.skyfunction_name = nil
	m.clearedFields[evaluationstat.FieldSkyfunctionName] = struct{}{}
}

// SkyfunctionNameCleared returns if the "skyfunction_name" field was cleared in this mutation.
func (m *EvaluationStatMutation) SkyfunctionNameCleared() bool {
	_, ok := m.clearedFields[evaluationstat.FieldSkyfunctionName]
	return ok
}

// ResetSkyfunctionName resets all changes to the "skyfunction_name" field.
func (m *EvaluationStatMutation) ResetSkyfunctionName() {
	m.skyfunction_name = nil
	delete(m.clearedFields, evaluationstat.FieldSkyfunctionName)
}

// SetCount sets the "count" field.
func (m *EvaluationStatMutation) SetCount(i int64) {
	m.count = &i
	m.addcount = nil
}

// Count returns the value of the "count" field in the mutation.
func (m *EvaluationStatMutation) Count() (r int64, exists bool) {
	v := m.count
	if v == nil {
		return
	}
	return *v, true
}

// OldCount returns the old "count" field's value of the EvaluationStat entity.
// If the EvaluationStat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EvaluationStatMutation) OldCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCount: %w", err)
	}
	return oldValue.Count, nil
}

// AddCount adds i to the "count" field.
func (m *EvaluationStatMutation) AddCount(i int64) {
	if m.addcount != nil {
		*m.addcount += i
	} else {
		m.addcount = &i
	}
}

// AddedCount returns the value that was added to the "count" field in this mutation.
func (m *EvaluationStatMutation) AddedCount() (r int64, exists bool) {
	v := m.addcount
	if v == nil {
		return
	}
	return *v, true
}

// ClearCount clears the value of the "count" field.
func (m *EvaluationStatMutation) ClearCount() {
	m.count = nil
	m.addcount = nil
	m.clearedFields[evaluationstat.FieldCount] = struct{}{}
}

// CountCleared returns if the "count" field was cleared in this mutation.
func (m *EvaluationStatMutation) CountCleared() bool {
	_, ok := m.clearedFields[evaluationstat.FieldCount]
	return ok
}

// ResetCount resets all changes to the "count" field.
func (m *EvaluationStatMutation) ResetCount() {
	m.count = nil
	m.addcount = nil
	delete(m.clearedFields, evaluationstat.FieldCount)
}

// SetBuildGraphMetricsID sets the "build_graph_metrics" edge to the BuildGraphMetrics entity by id.
func (m *EvaluationStatMutation) SetBuildGraphMetricsID(id int64) {
	m.build_graph_metrics = &id
}

// ClearBuildGraphMetrics clears the "build_graph_metrics" edge to the BuildGraphMetrics entity.
func (m *EvaluationStatMutation) ClearBuildGraphMetrics() {
	m.clearedbuild_graph_metrics = true
}

// BuildGraphMetricsCleared reports if the "build_graph_metrics" edge to the BuildGraphMetrics entity was cleared.
func (m *EvaluationStatMutation) BuildGraphMetricsCleared() bool {
	return m.clearedbuild_graph_metrics
}

// BuildGraphMetricsID returns the "build_graph_metrics" edge ID in the mutation.
func (m *EvaluationStatMutation) BuildGraphMetricsID() (id int64, exists bool) {
	if m.build_graph_metrics != nil {
		return *m.build_graph_metrics, true
	}
	return
}

// BuildGraphMetricsIDs returns the "build_graph_metrics" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BuildGraphMetricsID instead. It exists only for internal usage by the builders.
func (m *EvaluationStatMutation) BuildGraphMetricsIDs() (ids []int64) {
	if id := m.build_graph_metrics; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBuildGraphMetrics resets all changes to the "build_graph_metrics" edge.
func (m *EvaluationStatMutation) ResetBuildGraphMetrics() {
	m.build_graph_metrics = nil
	m.clearedbuild_graph_metrics = false
}

// Where appends a list predicates to the EvaluationStatMutation builder.
func (m *EvaluationStatMutation) Where(ps ...predicate.EvaluationStat) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EvaluationStatMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EvaluationStatMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EvaluationStat, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EvaluationStatMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EvaluationStatMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EvaluationStat).
func (m *EvaluationStatMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EvaluationStatMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.skyfunction_name != nil {
		fields = append(fields, evaluationstat.FieldSkyfunctionName)
	}
	if m.count != nil {
		fields = append(fields, evaluationstat.FieldCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EvaluationStatMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case evaluationstat.FieldSkyfunctionName:
		return m.SkyfunctionName()
	case evaluationstat.FieldCount:
		return m.Count()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EvaluationStatMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case evaluationstat.FieldSkyfunctionName:
		return m.OldSkyfunctionName(ctx)
	case evaluationstat.FieldCount:
		return m.OldCount(ctx)
	}
	return nil, fmt.Errorf("unknown EvaluationStat field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EvaluationStatMutation) SetField(name string, value ent.Value) error {
	switch name {
	case evaluationstat.FieldSkyfunctionName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkyfunctionName(v)
		return nil
	case evaluationstat.FieldCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCount(v)
		return nil
	}
	return fmt.Errorf("unknown EvaluationStat field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EvaluationStatMutation) AddedFields() []string {
	var fields []string
	if m.addcount != nil {
		fields = append(fields, evaluationstat.FieldCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EvaluationStatMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case evaluationstat.FieldCount:
		return m.AddedCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EvaluationStatMutation) AddField(name string, value ent.Value) error {
	switch name {
	case evaluationstat.FieldCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCount(v)
		return nil
	}
	return fmt.Errorf("unknown EvaluationStat numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EvaluationStatMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(evaluationstat.FieldSkyfunctionName) {
		fields = append(fields, evaluationstat.FieldSkyfunctionName)
	}
	if m.FieldCleared(evaluationstat.FieldCount) {
		fields = append(fields, evaluationstat.FieldCount)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EvaluationStatMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EvaluationStatMutation) ClearField(name string) error {
	switch name {
	case evaluationstat.FieldSkyfunctionName:
		m.ClearSkyfunctionName()
		return nil
	case evaluationstat.FieldCount:
		m.ClearCount()
		return nil
	}
	return fmt.Errorf("unknown EvaluationStat nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EvaluationStatMutation) ResetField(name string) error {
	switch name {
	case evaluationstat.FieldSkyfunctionName:
		m.ResetSkyfunctionName()
		return nil
	case evaluationstat.FieldCount:
		m.ResetCount()
		return nil
	}
	return fmt.Errorf("unknown EvaluationStat field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EvaluationStatMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.build_graph_metrics != nil {
		edges = append(edges, evaluationstat.EdgeBuildGraphMetrics)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EvaluationStatMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case evaluationstat.EdgeBuildGraphMetrics:
		if id := m.build_graph_metrics; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EvaluationStatMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EvaluationStatMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EvaluationStatMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbuild_graph_metrics {
		edges = append(edges, evaluationstat.EdgeBuildGraphMetrics)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EvaluationStatMutation) EdgeCleared(name string) bool {
	switch name {
	case evaluationstat.EdgeBuildGraphMetrics:
		return m.clearedbuild_graph_metrics
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EvaluationStatMutation) ClearEdge(name string) error {
	switch name {
	case evaluationstat.EdgeBuildGraphMetrics:
		m.ClearBuildGraphMetrics()
		return nil
	}
	return fmt.Errorf("unknown EvaluationStat unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EvaluationStatMutation) ResetEdge(name string) error {
	switch name {
	case evaluationstat.EdgeBuildGraphMetrics:
		m.ResetBuildGraphMetrics()
		return nil
	}
	return fmt.Errorf("unknown EvaluationStat edge %s", name)
}

// EventMetadataMutation represents an operation that mutates the EventMetadata nodes in the graph.
type EventMetadataMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int64
	handled                 *[]byte
	event_received_at       *time.Time
	version                 *int64
	addversion              *int64
	clearedFields           map[string]struct{}
	bazel_invocation        *int64
	clearedbazel_invocation bool
	done                    bool
	oldValue                func(context.Context) (*EventMetadata, error)
	predicates              []predicate.EventMetadata
}

var _ ent.Mutation = (*EventMetadataMutation)(nil)

// eventmetadataOption allows management of the mutation configuration using functional options.
type eventmetadataOption func(*EventMetadataMutation)

// newEventMetadataMutation creates new mutation for the EventMetadata entity.
func newEventMetadataMutation(c config, op Op, opts ...eventmetadataOption) *EventMetadataMutation {
	m := &EventMetadataMutation{
		config:        c,
		op:            op,
		typ:           TypeEventMetadata,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEventMetadataID sets the ID field of the mutation.
func withEventMetadataID(id int64) eventmetadataOption {
	return func(m *EventMetadataMutation) {
		var (
			err   error
			once  sync.Once
			value *EventMetadata
		)
		m.oldValue = func(ctx context.Context) (*EventMetadata, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EventMetadata.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEventMetadata sets the old EventMetadata of the mutation.
func withEventMetadata(node *EventMetadata) eventmetadataOption {
	return func(m *EventMetadataMutation) {
		m.oldValue = func(context.Context) (*EventMetadata, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EventMetadataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EventMetadataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EventMetadata entities.
func (m *EventMetadataMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EventMetadataMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EventMetadataMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EventMetadata.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHandled sets the "handled" field.
func (m *EventMetadataMutation) SetHandled(b []byte) {
	m.handled = &b
}

// Handled returns the value of the "handled" field in the mutation.
func (m *EventMetadataMutation) Handled() (r []byte, exists bool) {
	v := m.handled
	if v == nil {
		return
	}
	return *v, true
}

// OldHandled returns the old "handled" field's value of the EventMetadata entity.
// If the EventMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMetadataMutation) OldHandled(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHandled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHandled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHandled: %w", err)
	}
	return oldValue.Handled, nil
}

// ResetHandled resets all changes to the "handled" field.
func (m *EventMetadataMutation) ResetHandled() {
	m.handled = nil
}

// SetEventReceivedAt sets the "event_received_at" field.
func (m *EventMetadataMutation) SetEventReceivedAt(t time.Time) {
	m.event_received_at = &t
}

// EventReceivedAt returns the value of the "event_received_at" field in the mutation.
func (m *EventMetadataMutation) EventReceivedAt() (r time.Time, exists bool) {
	v := m.event_received_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEventReceivedAt returns the old "event_received_at" field's value of the EventMetadata entity.
// If the EventMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMetadataMutation) OldEventReceivedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventReceivedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventReceivedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventReceivedAt: %w", err)
	}
	return oldValue.EventReceivedAt, nil
}

// ResetEventReceivedAt resets all changes to the "event_received_at" field.
func (m *EventMetadataMutation) ResetEventReceivedAt() {
	m.event_received_at = nil
}

// SetVersion sets the "version" field.
func (m *EventMetadataMutation) SetVersion(i int64) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *EventMetadataMutation) Version() (r int64, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the EventMetadata entity.
// If the EventMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMetadataMutation) OldVersion(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *EventMetadataMutation) AddVersion(i int64) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *EventMetadataMutation) AddedVersion() (r int64, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *EventMetadataMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetBazelInvocationID sets the "bazel_invocation_id" field.
func (m *EventMetadataMutation) SetBazelInvocationID(i int64) {
	m.bazel_invocation = &i
}

// BazelInvocationID returns the value of the "bazel_invocation_id" field in the mutation.
func (m *EventMetadataMutation) BazelInvocationID() (r int64, exists bool) {
	v := m.bazel_invocation
	if v == nil {
		return
	}
	return *v, true
}

// OldBazelInvocationID returns the old "bazel_invocation_id" field's value of the EventMetadata entity.
// If the EventMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMetadataMutation) OldBazelInvocationID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBazelInvocationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBazelInvocationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBazelInvocationID: %w", err)
	}
	return oldValue.BazelInvocationID, nil
}

// ResetBazelInvocationID resets all changes to the "bazel_invocation_id" field.
func (m *EventMetadataMutation) ResetBazelInvocationID() {
	m.bazel_invocation = nil
}

// ClearBazelInvocation clears the "bazel_invocation" edge to the BazelInvocation entity.
func (m *EventMetadataMutation) ClearBazelInvocation() {
	m.clearedbazel_invocation = true
	m.clearedFields[eventmetadata.FieldBazelInvocationID] = struct{}{}
}

// BazelInvocationCleared reports if the "bazel_invocation" edge to the BazelInvocation entity was cleared.
func (m *EventMetadataMutation) BazelInvocationCleared() bool {
	return m.clearedbazel_invocation
}

// BazelInvocationIDs returns the "bazel_invocation" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BazelInvocationID instead. It exists only for internal usage by the builders.
func (m *EventMetadataMutation) BazelInvocationIDs() (ids []int64) {
	if id := m.bazel_invocation; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBazelInvocation resets all changes to the "bazel_invocation" edge.
func (m *EventMetadataMutation) ResetBazelInvocation() {
	m.bazel_invocation = nil
	m.clearedbazel_invocation = false
}

// Where appends a list predicates to the EventMetadataMutation builder.
func (m *EventMetadataMutation) Where(ps ...predicate.EventMetadata) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EventMetadataMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EventMetadataMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EventMetadata, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EventMetadataMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EventMetadataMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EventMetadata).
func (m *EventMetadataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EventMetadataMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.handled != nil {
		fields = append(fields, eventmetadata.FieldHandled)
	}
	if m.event_received_at != nil {
		fields = append(fields, eventmetadata.FieldEventReceivedAt)
	}
	if m.version != nil {
		fields = append(fields, eventmetadata.FieldVersion)
	}
	if m.bazel_invocation != nil {
		fields = append(fields, eventmetadata.FieldBazelInvocationID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EventMetadataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case eventmetadata.FieldHandled:
		return m.Handled()
	case eventmetadata.FieldEventReceivedAt:
		return m.EventReceivedAt()
	case eventmetadata.FieldVersion:
		return m.Version()
	case eventmetadata.FieldBazelInvocationID:
		return m.BazelInvocationID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EventMetadataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case eventmetadata.FieldHandled:
		return m.OldHandled(ctx)
	case eventmetadata.FieldEventReceivedAt:
		return m.OldEventReceivedAt(ctx)
	case eventmetadata.FieldVersion:
		return m.OldVersion(ctx)
	case eventmetadata.FieldBazelInvocationID:
		return m.OldBazelInvocationID(ctx)
	}
	return nil, fmt.Errorf("unknown EventMetadata field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventMetadataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case eventmetadata.FieldHandled:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHandled(v)
		return nil
	case eventmetadata.FieldEventReceivedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventReceivedAt(v)
		return nil
	case eventmetadata.FieldVersion:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case eventmetadata.FieldBazelInvocationID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBazelInvocationID(v)
		return nil
	}
	return fmt.Errorf("unknown EventMetadata field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EventMetadataMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, eventmetadata.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EventMetadataMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case eventmetadata.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventMetadataMutation) AddField(name string, value ent.Value) error {
	switch name {
	case eventmetadata.FieldVersion:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown EventMetadata numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EventMetadataMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EventMetadataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EventMetadataMutation) ClearField(name string) error {
	return fmt.Errorf("unknown EventMetadata nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EventMetadataMutation) ResetField(name string) error {
	switch name {
	case eventmetadata.FieldHandled:
		m.ResetHandled()
		return nil
	case eventmetadata.FieldEventReceivedAt:
		m.ResetEventReceivedAt()
		return nil
	case eventmetadata.FieldVersion:
		m.ResetVersion()
		return nil
	case eventmetadata.FieldBazelInvocationID:
		m.ResetBazelInvocationID()
		return nil
	}
	return fmt.Errorf("unknown EventMetadata field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EventMetadataMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.bazel_invocation != nil {
		edges = append(edges, eventmetadata.EdgeBazelInvocation)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EventMetadataMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case eventmetadata.EdgeBazelInvocation:
		if id := m.bazel_invocation; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EventMetadataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EventMetadataMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EventMetadataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbazel_invocation {
		edges = append(edges, eventmetadata.EdgeBazelInvocation)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EventMetadataMutation) EdgeCleared(name string) bool {
	switch name {
	case eventmetadata.EdgeBazelInvocation:
		return m.clearedbazel_invocation
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EventMetadataMutation) ClearEdge(name string) error {
	switch name {
	case eventmetadata.EdgeBazelInvocation:
		m.ClearBazelInvocation()
		return nil
	}
	return fmt.Errorf("unknown EventMetadata unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EventMetadataMutation) ResetEdge(name string) error {
	switch name {
	case eventmetadata.EdgeBazelInvocation:
		m.ResetBazelInvocation()
		return nil
	}
	return fmt.Errorf("unknown EventMetadata edge %s", name)
}

// GarbageMetricsMutation represents an operation that mutates the GarbageMetrics nodes in the graph.
type GarbageMetricsMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int64
	_type                 *string
	garbage_collected     *int64
	addgarbage_collected  *int64
	clearedFields         map[string]struct{}
	memory_metrics        *int64
	clearedmemory_metrics bool
	done                  bool
	oldValue              func(context.Context) (*GarbageMetrics, error)
	predicates            []predicate.GarbageMetrics
}

var _ ent.Mutation = (*GarbageMetricsMutation)(nil)

// garbagemetricsOption allows management of the mutation configuration using functional options.
type garbagemetricsOption func(*GarbageMetricsMutation)

// newGarbageMetricsMutation creates new mutation for the GarbageMetrics entity.
func newGarbageMetricsMutation(c config, op Op, opts ...garbagemetricsOption) *GarbageMetricsMutation {
	m := &GarbageMetricsMutation{
		config:        c,
		op:            op,
		typ:           TypeGarbageMetrics,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGarbageMetricsID sets the ID field of the mutation.
func withGarbageMetricsID(id int64) garbagemetricsOption {
	return func(m *GarbageMetricsMutation) {
		var (
			err   error
			once  sync.Once
			value *GarbageMetrics
		)
		m.oldValue = func(ctx context.Context) (*GarbageMetrics, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GarbageMetrics.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGarbageMetrics sets the old GarbageMetrics of the mutation.
func withGarbageMetrics(node *GarbageMetrics) garbagemetricsOption {
	return func(m *GarbageMetricsMutation) {
		m.oldValue = func(context.Context) (*GarbageMetrics, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GarbageMetricsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GarbageMetricsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GarbageMetrics entities.
func (m *GarbageMetricsMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GarbageMetricsMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GarbageMetricsMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GarbageMetrics.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *GarbageMetricsMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *GarbageMetricsMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the GarbageMetrics entity.
// If the GarbageMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GarbageMetricsMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *GarbageMetricsMutation) ClearType() {
	m._type = nil
	m.clearedFields[garbagemetrics.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *GarbageMetricsMutation) TypeCleared() bool {
	_, ok := m.clearedFields[garbagemetrics.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *GarbageMetricsMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, garbagemetrics.FieldType)
}

// SetGarbageCollected sets the "garbage_collected" field.
func (m *GarbageMetricsMutation) SetGarbageCollected(i int64) {
	m.garbage_collected = &i
	m.addgarbage_collected = nil
}

// GarbageCollected returns the value of the "garbage_collected" field in the mutation.
func (m *GarbageMetricsMutation) GarbageCollected() (r int64, exists bool) {
	v := m.garbage_collected
	if v == nil {
		return
	}
	return *v, true
}

// OldGarbageCollected returns the old "garbage_collected" field's value of the GarbageMetrics entity.
// If the GarbageMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GarbageMetricsMutation) OldGarbageCollected(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGarbageCollected is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGarbageCollected requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGarbageCollected: %w", err)
	}
	return oldValue.GarbageCollected, nil
}

// AddGarbageCollected adds i to the "garbage_collected" field.
func (m *GarbageMetricsMutation) AddGarbageCollected(i int64) {
	if m.addgarbage_collected != nil {
		*m.addgarbage_collected += i
	} else {
		m.addgarbage_collected = &i
	}
}

// AddedGarbageCollected returns the value that was added to the "garbage_collected" field in this mutation.
func (m *GarbageMetricsMutation) AddedGarbageCollected() (r int64, exists bool) {
	v := m.addgarbage_collected
	if v == nil {
		return
	}
	return *v, true
}

// ClearGarbageCollected clears the value of the "garbage_collected" field.
func (m *GarbageMetricsMutation) ClearGarbageCollected() {
	m.garbage_collected = nil
	m.addgarbage_collected = nil
	m.clearedFields[garbagemetrics.FieldGarbageCollected] = struct{}{}
}

// GarbageCollectedCleared returns if the "garbage_collected" field was cleared in this mutation.
func (m *GarbageMetricsMutation) GarbageCollectedCleared() bool {
	_, ok := m.clearedFields[garbagemetrics.FieldGarbageCollected]
	return ok
}

// ResetGarbageCollected resets all changes to the "garbage_collected" field.
func (m *GarbageMetricsMutation) ResetGarbageCollected() {
	m.garbage_collected = nil
	m.addgarbage_collected = nil
	delete(m.clearedFields, garbagemetrics.FieldGarbageCollected)
}

// SetMemoryMetricsID sets the "memory_metrics" edge to the MemoryMetrics entity by id.
func (m *GarbageMetricsMutation) SetMemoryMetricsID(id int64) {
	m.memory_metrics = &id
}

// ClearMemoryMetrics clears the "memory_metrics" edge to the MemoryMetrics entity.
func (m *GarbageMetricsMutation) ClearMemoryMetrics() {
	m.clearedmemory_metrics = true
}

// MemoryMetricsCleared reports if the "memory_metrics" edge to the MemoryMetrics entity was cleared.
func (m *GarbageMetricsMutation) MemoryMetricsCleared() bool {
	return m.clearedmemory_metrics
}

// MemoryMetricsID returns the "memory_metrics" edge ID in the mutation.
func (m *GarbageMetricsMutation) MemoryMetricsID() (id int64, exists bool) {
	if m.memory_metrics != nil {
		return *m.memory_metrics, true
	}
	return
}

// MemoryMetricsIDs returns the "memory_metrics" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MemoryMetricsID instead. It exists only for internal usage by the builders.
func (m *GarbageMetricsMutation) MemoryMetricsIDs() (ids []int64) {
	if id := m.memory_metrics; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMemoryMetrics resets all changes to the "memory_metrics" edge.
func (m *GarbageMetricsMutation) ResetMemoryMetrics() {
	m.memory_metrics = nil
	m.clearedmemory_metrics = false
}

// Where appends a list predicates to the GarbageMetricsMutation builder.
func (m *GarbageMetricsMutation) Where(ps ...predicate.GarbageMetrics) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GarbageMetricsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GarbageMetricsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GarbageMetrics, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GarbageMetricsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GarbageMetricsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GarbageMetrics).
func (m *GarbageMetricsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GarbageMetricsMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._type != nil {
		fields = append(fields, garbagemetrics.FieldType)
	}
	if m.garbage_collected != nil {
		fields = append(fields, garbagemetrics.FieldGarbageCollected)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GarbageMetricsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case garbagemetrics.FieldType:
		return m.GetType()
	case garbagemetrics.FieldGarbageCollected:
		return m.GarbageCollected()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GarbageMetricsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case garbagemetrics.FieldType:
		return m.OldType(ctx)
	case garbagemetrics.FieldGarbageCollected:
		return m.OldGarbageCollected(ctx)
	}
	return nil, fmt.Errorf("unknown GarbageMetrics field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GarbageMetricsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case garbagemetrics.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case garbagemetrics.FieldGarbageCollected:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGarbageCollected(v)
		return nil
	}
	return fmt.Errorf("unknown GarbageMetrics field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GarbageMetricsMutation) AddedFields() []string {
	var fields []string
	if m.addgarbage_collected != nil {
		fields = append(fields, garbagemetrics.FieldGarbageCollected)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GarbageMetricsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case garbagemetrics.FieldGarbageCollected:
		return m.AddedGarbageCollected()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GarbageMetricsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case garbagemetrics.FieldGarbageCollected:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGarbageCollected(v)
		return nil
	}
	return fmt.Errorf("unknown GarbageMetrics numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GarbageMetricsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(garbagemetrics.FieldType) {
		fields = append(fields, garbagemetrics.FieldType)
	}
	if m.FieldCleared(garbagemetrics.FieldGarbageCollected) {
		fields = append(fields, garbagemetrics.FieldGarbageCollected)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GarbageMetricsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GarbageMetricsMutation) ClearField(name string) error {
	switch name {
	case garbagemetrics.FieldType:
		m.ClearType()
		return nil
	case garbagemetrics.FieldGarbageCollected:
		m.ClearGarbageCollected()
		return nil
	}
	return fmt.Errorf("unknown GarbageMetrics nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GarbageMetricsMutation) ResetField(name string) error {
	switch name {
	case garbagemetrics.FieldType:
		m.ResetType()
		return nil
	case garbagemetrics.FieldGarbageCollected:
		m.ResetGarbageCollected()
		return nil
	}
	return fmt.Errorf("unknown GarbageMetrics field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GarbageMetricsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.memory_metrics != nil {
		edges = append(edges, garbagemetrics.EdgeMemoryMetrics)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GarbageMetricsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case garbagemetrics.EdgeMemoryMetrics:
		if id := m.memory_metrics; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GarbageMetricsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GarbageMetricsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GarbageMetricsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmemory_metrics {
		edges = append(edges, garbagemetrics.EdgeMemoryMetrics)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GarbageMetricsMutation) EdgeCleared(name string) bool {
	switch name {
	case garbagemetrics.EdgeMemoryMetrics:
		return m.clearedmemory_metrics
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GarbageMetricsMutation) ClearEdge(name string) error {
	switch name {
	case garbagemetrics.EdgeMemoryMetrics:
		m.ClearMemoryMetrics()
		return nil
	}
	return fmt.Errorf("unknown GarbageMetrics unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GarbageMetricsMutation) ResetEdge(name string) error {
	switch name {
	case garbagemetrics.EdgeMemoryMetrics:
		m.ResetMemoryMetrics()
		return nil
	}
	return fmt.Errorf("unknown GarbageMetrics edge %s", name)
}

// IncompleteBuildLogMutation represents an operation that mutates the IncompleteBuildLog nodes in the graph.
type IncompleteBuildLogMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int64
	snippet_id              *int32
	addsnippet_id           *int32
	log_snippet             *[]byte
	clearedFields           map[string]struct{}
	bazel_invocation        *int64
	clearedbazel_invocation bool
	done                    bool
	oldValue                func(context.Context) (*IncompleteBuildLog, error)
	predicates              []predicate.IncompleteBuildLog
}

var _ ent.Mutation = (*IncompleteBuildLogMutation)(nil)

// incompletebuildlogOption allows management of the mutation configuration using functional options.
type incompletebuildlogOption func(*IncompleteBuildLogMutation)

// newIncompleteBuildLogMutation creates new mutation for the IncompleteBuildLog entity.
func newIncompleteBuildLogMutation(c config, op Op, opts ...incompletebuildlogOption) *IncompleteBuildLogMutation {
	m := &IncompleteBuildLogMutation{
		config:        c,
		op:            op,
		typ:           TypeIncompleteBuildLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIncompleteBuildLogID sets the ID field of the mutation.
func withIncompleteBuildLogID(id int64) incompletebuildlogOption {
	return func(m *IncompleteBuildLogMutation) {
		var (
			err   error
			once  sync.Once
			value *IncompleteBuildLog
		)
		m.oldValue = func(ctx context.Context) (*IncompleteBuildLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IncompleteBuildLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIncompleteBuildLog sets the old IncompleteBuildLog of the mutation.
func withIncompleteBuildLog(node *IncompleteBuildLog) incompletebuildlogOption {
	return func(m *IncompleteBuildLogMutation) {
		m.oldValue = func(context.Context) (*IncompleteBuildLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IncompleteBuildLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IncompleteBuildLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IncompleteBuildLog entities.
func (m *IncompleteBuildLogMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IncompleteBuildLogMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IncompleteBuildLogMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IncompleteBuildLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSnippetID sets the "snippet_id" field.
func (m *IncompleteBuildLogMutation) SetSnippetID(i int32) {
	m.snippet_id = &i
	m.addsnippet_id = nil
}

// SnippetID returns the value of the "snippet_id" field in the mutation.
func (m *IncompleteBuildLogMutation) SnippetID() (r int32, exists bool) {
	v := m.snippet_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSnippetID returns the old "snippet_id" field's value of the IncompleteBuildLog entity.
// If the IncompleteBuildLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncompleteBuildLogMutation) OldSnippetID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSnippetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSnippetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSnippetID: %w", err)
	}
	return oldValue.SnippetID, nil
}

// AddSnippetID adds i to the "snippet_id" field.
func (m *IncompleteBuildLogMutation) AddSnippetID(i int32) {
	if m.addsnippet_id != nil {
		*m.addsnippet_id += i
	} else {
		m.addsnippet_id = &i
	}
}

// AddedSnippetID returns the value that was added to the "snippet_id" field in this mutation.
func (m *IncompleteBuildLogMutation) AddedSnippetID() (r int32, exists bool) {
	v := m.addsnippet_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetSnippetID resets all changes to the "snippet_id" field.
func (m *IncompleteBuildLogMutation) ResetSnippetID() {
	m.snippet_id = nil
	m.addsnippet_id = nil
}

// SetLogSnippet sets the "log_snippet" field.
func (m *IncompleteBuildLogMutation) SetLogSnippet(b []byte) {
	m.log_snippet = &b
}

// LogSnippet returns the value of the "log_snippet" field in the mutation.
func (m *IncompleteBuildLogMutation) LogSnippet() (r []byte, exists bool) {
	v := m.log_snippet
	if v == nil {
		return
	}
	return *v, true
}

// OldLogSnippet returns the old "log_snippet" field's value of the IncompleteBuildLog entity.
// If the IncompleteBuildLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncompleteBuildLogMutation) OldLogSnippet(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogSnippet is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogSnippet requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogSnippet: %w", err)
	}
	return oldValue.LogSnippet, nil
}

// ResetLogSnippet resets all changes to the "log_snippet" field.
func (m *IncompleteBuildLogMutation) ResetLogSnippet() {
	m.log_snippet = nil
}

// SetBazelInvocationID sets the "bazel_invocation_id" field.
func (m *IncompleteBuildLogMutation) SetBazelInvocationID(i int64) {
	m.bazel_invocation = &i
}

// BazelInvocationID returns the value of the "bazel_invocation_id" field in the mutation.
func (m *IncompleteBuildLogMutation) BazelInvocationID() (r int64, exists bool) {
	v := m.bazel_invocation
	if v == nil {
		return
	}
	return *v, true
}

// OldBazelInvocationID returns the old "bazel_invocation_id" field's value of the IncompleteBuildLog entity.
// If the IncompleteBuildLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncompleteBuildLogMutation) OldBazelInvocationID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBazelInvocationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBazelInvocationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBazelInvocationID: %w", err)
	}
	return oldValue.BazelInvocationID, nil
}

// ResetBazelInvocationID resets all changes to the "bazel_invocation_id" field.
func (m *IncompleteBuildLogMutation) ResetBazelInvocationID() {
	m.bazel_invocation = nil
}

// ClearBazelInvocation clears the "bazel_invocation" edge to the BazelInvocation entity.
func (m *IncompleteBuildLogMutation) ClearBazelInvocation() {
	m.clearedbazel_invocation = true
	m.clearedFields[incompletebuildlog.FieldBazelInvocationID] = struct{}{}
}

// BazelInvocationCleared reports if the "bazel_invocation" edge to the BazelInvocation entity was cleared.
func (m *IncompleteBuildLogMutation) BazelInvocationCleared() bool {
	return m.clearedbazel_invocation
}

// BazelInvocationIDs returns the "bazel_invocation" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BazelInvocationID instead. It exists only for internal usage by the builders.
func (m *IncompleteBuildLogMutation) BazelInvocationIDs() (ids []int64) {
	if id := m.bazel_invocation; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBazelInvocation resets all changes to the "bazel_invocation" edge.
func (m *IncompleteBuildLogMutation) ResetBazelInvocation() {
	m.bazel_invocation = nil
	m.clearedbazel_invocation = false
}

// Where appends a list predicates to the IncompleteBuildLogMutation builder.
func (m *IncompleteBuildLogMutation) Where(ps ...predicate.IncompleteBuildLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IncompleteBuildLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IncompleteBuildLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IncompleteBuildLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IncompleteBuildLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IncompleteBuildLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IncompleteBuildLog).
func (m *IncompleteBuildLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IncompleteBuildLogMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.snippet_id != nil {
		fields = append(fields, incompletebuildlog.FieldSnippetID)
	}
	if m.log_snippet != nil {
		fields = append(fields, incompletebuildlog.FieldLogSnippet)
	}
	if m.bazel_invocation != nil {
		fields = append(fields, incompletebuildlog.FieldBazelInvocationID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IncompleteBuildLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case incompletebuildlog.FieldSnippetID:
		return m.SnippetID()
	case incompletebuildlog.FieldLogSnippet:
		return m.LogSnippet()
	case incompletebuildlog.FieldBazelInvocationID:
		return m.BazelInvocationID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IncompleteBuildLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case incompletebuildlog.FieldSnippetID:
		return m.OldSnippetID(ctx)
	case incompletebuildlog.FieldLogSnippet:
		return m.OldLogSnippet(ctx)
	case incompletebuildlog.FieldBazelInvocationID:
		return m.OldBazelInvocationID(ctx)
	}
	return nil, fmt.Errorf("unknown IncompleteBuildLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncompleteBuildLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case incompletebuildlog.FieldSnippetID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSnippetID(v)
		return nil
	case incompletebuildlog.FieldLogSnippet:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogSnippet(v)
		return nil
	case incompletebuildlog.FieldBazelInvocationID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBazelInvocationID(v)
		return nil
	}
	return fmt.Errorf("unknown IncompleteBuildLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IncompleteBuildLogMutation) AddedFields() []string {
	var fields []string
	if m.addsnippet_id != nil {
		fields = append(fields, incompletebuildlog.FieldSnippetID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IncompleteBuildLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case incompletebuildlog.FieldSnippetID:
		return m.AddedSnippetID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncompleteBuildLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case incompletebuildlog.FieldSnippetID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSnippetID(v)
		return nil
	}
	return fmt.Errorf("unknown IncompleteBuildLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IncompleteBuildLogMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IncompleteBuildLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IncompleteBuildLogMutation) ClearField(name string) error {
	return fmt.Errorf("unknown IncompleteBuildLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IncompleteBuildLogMutation) ResetField(name string) error {
	switch name {
	case incompletebuildlog.FieldSnippetID:
		m.ResetSnippetID()
		return nil
	case incompletebuildlog.FieldLogSnippet:
		m.ResetLogSnippet()
		return nil
	case incompletebuildlog.FieldBazelInvocationID:
		m.ResetBazelInvocationID()
		return nil
	}
	return fmt.Errorf("unknown IncompleteBuildLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IncompleteBuildLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.bazel_invocation != nil {
		edges = append(edges, incompletebuildlog.EdgeBazelInvocation)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IncompleteBuildLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case incompletebuildlog.EdgeBazelInvocation:
		if id := m.bazel_invocation; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IncompleteBuildLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IncompleteBuildLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IncompleteBuildLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbazel_invocation {
		edges = append(edges, incompletebuildlog.EdgeBazelInvocation)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IncompleteBuildLogMutation) EdgeCleared(name string) bool {
	switch name {
	case incompletebuildlog.EdgeBazelInvocation:
		return m.clearedbazel_invocation
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IncompleteBuildLogMutation) ClearEdge(name string) error {
	switch name {
	case incompletebuildlog.EdgeBazelInvocation:
		m.ClearBazelInvocation()
		return nil
	}
	return fmt.Errorf("unknown IncompleteBuildLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IncompleteBuildLogMutation) ResetEdge(name string) error {
	switch name {
	case incompletebuildlog.EdgeBazelInvocation:
		m.ResetBazelInvocation()
		return nil
	}
	return fmt.Errorf("unknown IncompleteBuildLog edge %s", name)
}

// InstanceNameMutation represents an operation that mutates the InstanceName nodes in the graph.
type InstanceNameMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int64
	name                     *string
	clearedFields            map[string]struct{}
	bazel_invocations        map[int64]struct{}
	removedbazel_invocations map[int64]struct{}
	clearedbazel_invocations bool
	builds                   map[int64]struct{}
	removedbuilds            map[int64]struct{}
	clearedbuilds            bool
	targets                  map[int64]struct{}
	removedtargets           map[int64]struct{}
	clearedtargets           bool
	done                     bool
	oldValue                 func(context.Context) (*InstanceName, error)
	predicates               []predicate.InstanceName
}

var _ ent.Mutation = (*InstanceNameMutation)(nil)

// instancenameOption allows management of the mutation configuration using functional options.
type instancenameOption func(*InstanceNameMutation)

// newInstanceNameMutation creates new mutation for the InstanceName entity.
func newInstanceNameMutation(c config, op Op, opts ...instancenameOption) *InstanceNameMutation {
	m := &InstanceNameMutation{
		config:        c,
		op:            op,
		typ:           TypeInstanceName,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInstanceNameID sets the ID field of the mutation.
func withInstanceNameID(id int64) instancenameOption {
	return func(m *InstanceNameMutation) {
		var (
			err   error
			once  sync.Once
			value *InstanceName
		)
		m.oldValue = func(ctx context.Context) (*InstanceName, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InstanceName.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInstanceName sets the old InstanceName of the mutation.
func withInstanceName(node *InstanceName) instancenameOption {
	return func(m *InstanceNameMutation) {
		m.oldValue = func(context.Context) (*InstanceName, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InstanceNameMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InstanceNameMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of InstanceName entities.
func (m *InstanceNameMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InstanceNameMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InstanceNameMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InstanceName.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *InstanceNameMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *InstanceNameMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the InstanceName entity.
// If the InstanceName object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceNameMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *InstanceNameMutation) ResetName() {
	m.name = nil
}

// AddBazelInvocationIDs adds the "bazel_invocations" edge to the BazelInvocation entity by ids.
func (m *InstanceNameMutation) AddBazelInvocationIDs(ids ...int64) {
	if m.bazel_invocations == nil {
		m.bazel_invocations = make(map[int64]struct{})
	}
	for i := range ids {
		m.bazel_invocations[ids[i]] = struct{}{}
	}
}

// ClearBazelInvocations clears the "bazel_invocations" edge to the BazelInvocation entity.
func (m *InstanceNameMutation) ClearBazelInvocations() {
	m.clearedbazel_invocations = true
}

// BazelInvocationsCleared reports if the "bazel_invocations" edge to the BazelInvocation entity was cleared.
func (m *InstanceNameMutation) BazelInvocationsCleared() bool {
	return m.clearedbazel_invocations
}

// RemoveBazelInvocationIDs removes the "bazel_invocations" edge to the BazelInvocation entity by IDs.
func (m *InstanceNameMutation) RemoveBazelInvocationIDs(ids ...int64) {
	if m.removedbazel_invocations == nil {
		m.removedbazel_invocations = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.bazel_invocations, ids[i])
		m.removedbazel_invocations[ids[i]] = struct{}{}
	}
}

// RemovedBazelInvocations returns the removed IDs of the "bazel_invocations" edge to the BazelInvocation entity.
func (m *InstanceNameMutation) RemovedBazelInvocationsIDs() (ids []int64) {
	for id := range m.removedbazel_invocations {
		ids = append(ids, id)
	}
	return
}

// BazelInvocationsIDs returns the "bazel_invocations" edge IDs in the mutation.
func (m *InstanceNameMutation) BazelInvocationsIDs() (ids []int64) {
	for id := range m.bazel_invocations {
		ids = append(ids, id)
	}
	return
}

// ResetBazelInvocations resets all changes to the "bazel_invocations" edge.
func (m *InstanceNameMutation) ResetBazelInvocations() {
	m.bazel_invocations = nil
	m.clearedbazel_invocations = false
	m.removedbazel_invocations = nil
}

// AddBuildIDs adds the "builds" edge to the Build entity by ids.
func (m *InstanceNameMutation) AddBuildIDs(ids ...int64) {
	if m.builds == nil {
		m.builds = make(map[int64]struct{})
	}
	for i := range ids {
		m.builds[ids[i]] = struct{}{}
	}
}

// ClearBuilds clears the "builds" edge to the Build entity.
func (m *InstanceNameMutation) ClearBuilds() {
	m.clearedbuilds = true
}

// BuildsCleared reports if the "builds" edge to the Build entity was cleared.
func (m *InstanceNameMutation) BuildsCleared() bool {
	return m.clearedbuilds
}

// RemoveBuildIDs removes the "builds" edge to the Build entity by IDs.
func (m *InstanceNameMutation) RemoveBuildIDs(ids ...int64) {
	if m.removedbuilds == nil {
		m.removedbuilds = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.builds, ids[i])
		m.removedbuilds[ids[i]] = struct{}{}
	}
}

// RemovedBuilds returns the removed IDs of the "builds" edge to the Build entity.
func (m *InstanceNameMutation) RemovedBuildsIDs() (ids []int64) {
	for id := range m.removedbuilds {
		ids = append(ids, id)
	}
	return
}

// BuildsIDs returns the "builds" edge IDs in the mutation.
func (m *InstanceNameMutation) BuildsIDs() (ids []int64) {
	for id := range m.builds {
		ids = append(ids, id)
	}
	return
}

// ResetBuilds resets all changes to the "builds" edge.
func (m *InstanceNameMutation) ResetBuilds() {
	m.builds = nil
	m.clearedbuilds = false
	m.removedbuilds = nil
}

// AddTargetIDs adds the "targets" edge to the Target entity by ids.
func (m *InstanceNameMutation) AddTargetIDs(ids ...int64) {
	if m.targets == nil {
		m.targets = make(map[int64]struct{})
	}
	for i := range ids {
		m.targets[ids[i]] = struct{}{}
	}
}

// ClearTargets clears the "targets" edge to the Target entity.
func (m *InstanceNameMutation) ClearTargets() {
	m.clearedtargets = true
}

// TargetsCleared reports if the "targets" edge to the Target entity was cleared.
func (m *InstanceNameMutation) TargetsCleared() bool {
	return m.clearedtargets
}

// RemoveTargetIDs removes the "targets" edge to the Target entity by IDs.
func (m *InstanceNameMutation) RemoveTargetIDs(ids ...int64) {
	if m.removedtargets == nil {
		m.removedtargets = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.targets, ids[i])
		m.removedtargets[ids[i]] = struct{}{}
	}
}

// RemovedTargets returns the removed IDs of the "targets" edge to the Target entity.
func (m *InstanceNameMutation) RemovedTargetsIDs() (ids []int64) {
	for id := range m.removedtargets {
		ids = append(ids, id)
	}
	return
}

// TargetsIDs returns the "targets" edge IDs in the mutation.
func (m *InstanceNameMutation) TargetsIDs() (ids []int64) {
	for id := range m.targets {
		ids = append(ids, id)
	}
	return
}

// ResetTargets resets all changes to the "targets" edge.
func (m *InstanceNameMutation) ResetTargets() {
	m.targets = nil
	m.clearedtargets = false
	m.removedtargets = nil
}

// Where appends a list predicates to the InstanceNameMutation builder.
func (m *InstanceNameMutation) Where(ps ...predicate.InstanceName) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InstanceNameMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InstanceNameMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.InstanceName, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InstanceNameMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InstanceNameMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (InstanceName).
func (m *InstanceNameMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InstanceNameMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, instancename.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InstanceNameMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case instancename.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InstanceNameMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case instancename.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown InstanceName field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InstanceNameMutation) SetField(name string, value ent.Value) error {
	switch name {
	case instancename.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown InstanceName field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InstanceNameMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InstanceNameMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InstanceNameMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown InstanceName numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InstanceNameMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InstanceNameMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InstanceNameMutation) ClearField(name string) error {
	return fmt.Errorf("unknown InstanceName nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InstanceNameMutation) ResetField(name string) error {
	switch name {
	case instancename.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown InstanceName field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InstanceNameMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.bazel_invocations != nil {
		edges = append(edges, instancename.EdgeBazelInvocations)
	}
	if m.builds != nil {
		edges = append(edges, instancename.EdgeBuilds)
	}
	if m.targets != nil {
		edges = append(edges, instancename.EdgeTargets)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InstanceNameMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case instancename.EdgeBazelInvocations:
		ids := make([]ent.Value, 0, len(m.bazel_invocations))
		for id := range m.bazel_invocations {
			ids = append(ids, id)
		}
		return ids
	case instancename.EdgeBuilds:
		ids := make([]ent.Value, 0, len(m.builds))
		for id := range m.builds {
			ids = append(ids, id)
		}
		return ids
	case instancename.EdgeTargets:
		ids := make([]ent.Value, 0, len(m.targets))
		for id := range m.targets {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InstanceNameMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedbazel_invocations != nil {
		edges = append(edges, instancename.EdgeBazelInvocations)
	}
	if m.removedbuilds != nil {
		edges = append(edges, instancename.EdgeBuilds)
	}
	if m.removedtargets != nil {
		edges = append(edges, instancename.EdgeTargets)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InstanceNameMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case instancename.EdgeBazelInvocations:
		ids := make([]ent.Value, 0, len(m.removedbazel_invocations))
		for id := range m.removedbazel_invocations {
			ids = append(ids, id)
		}
		return ids
	case instancename.EdgeBuilds:
		ids := make([]ent.Value, 0, len(m.removedbuilds))
		for id := range m.removedbuilds {
			ids = append(ids, id)
		}
		return ids
	case instancename.EdgeTargets:
		ids := make([]ent.Value, 0, len(m.removedtargets))
		for id := range m.removedtargets {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InstanceNameMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedbazel_invocations {
		edges = append(edges, instancename.EdgeBazelInvocations)
	}
	if m.clearedbuilds {
		edges = append(edges, instancename.EdgeBuilds)
	}
	if m.clearedtargets {
		edges = append(edges, instancename.EdgeTargets)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InstanceNameMutation) EdgeCleared(name string) bool {
	switch name {
	case instancename.EdgeBazelInvocations:
		return m.clearedbazel_invocations
	case instancename.EdgeBuilds:
		return m.clearedbuilds
	case instancename.EdgeTargets:
		return m.clearedtargets
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InstanceNameMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown InstanceName unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InstanceNameMutation) ResetEdge(name string) error {
	switch name {
	case instancename.EdgeBazelInvocations:
		m.ResetBazelInvocations()
		return nil
	case instancename.EdgeBuilds:
		m.ResetBuilds()
		return nil
	case instancename.EdgeTargets:
		m.ResetTargets()
		return nil
	}
	return fmt.Errorf("unknown InstanceName edge %s", name)
}

// InvocationFilesMutation represents an operation that mutates the InvocationFiles nodes in the graph.
type InvocationFilesMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int64
	name                    *string
	content                 *string
	digest                  *string
	size_bytes              *int64
	addsize_bytes           *int64
	digest_function         *string
	clearedFields           map[string]struct{}
	bazel_invocation        *int64
	clearedbazel_invocation bool
	done                    bool
	oldValue                func(context.Context) (*InvocationFiles, error)
	predicates              []predicate.InvocationFiles
}

var _ ent.Mutation = (*InvocationFilesMutation)(nil)

// invocationfilesOption allows management of the mutation configuration using functional options.
type invocationfilesOption func(*InvocationFilesMutation)

// newInvocationFilesMutation creates new mutation for the InvocationFiles entity.
func newInvocationFilesMutation(c config, op Op, opts ...invocationfilesOption) *InvocationFilesMutation {
	m := &InvocationFilesMutation{
		config:        c,
		op:            op,
		typ:           TypeInvocationFiles,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInvocationFilesID sets the ID field of the mutation.
func withInvocationFilesID(id int64) invocationfilesOption {
	return func(m *InvocationFilesMutation) {
		var (
			err   error
			once  sync.Once
			value *InvocationFiles
		)
		m.oldValue = func(ctx context.Context) (*InvocationFiles, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InvocationFiles.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInvocationFiles sets the old InvocationFiles of the mutation.
func withInvocationFiles(node *InvocationFiles) invocationfilesOption {
	return func(m *InvocationFilesMutation) {
		m.oldValue = func(context.Context) (*InvocationFiles, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InvocationFilesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InvocationFilesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of InvocationFiles entities.
func (m *InvocationFilesMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InvocationFilesMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InvocationFilesMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InvocationFiles.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *InvocationFilesMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *InvocationFilesMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the InvocationFiles entity.
// If the InvocationFiles object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvocationFilesMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *InvocationFilesMutation) ResetName() {
	m.name = nil
}

// SetContent sets the "content" field.
func (m *InvocationFilesMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *InvocationFilesMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the InvocationFiles entity.
// If the InvocationFiles object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvocationFilesMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *InvocationFilesMutation) ClearContent() {
	m.content = nil
	m.clearedFields[invocationfiles.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *InvocationFilesMutation) ContentCleared() bool {
	_, ok := m.clearedFields[invocationfiles.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *InvocationFilesMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, invocationfiles.FieldContent)
}

// SetDigest sets the "digest" field.
func (m *InvocationFilesMutation) SetDigest(s string) {
	m.digest = &s
}

// Digest returns the value of the "digest" field in the mutation.
func (m *InvocationFilesMutation) Digest() (r string, exists bool) {
	v := m.digest
	if v == nil {
		return
	}
	return *v, true
}

// OldDigest returns the old "digest" field's value of the InvocationFiles entity.
// If the InvocationFiles object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvocationFilesMutation) OldDigest(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDigest is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDigest requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDigest: %w", err)
	}
	return oldValue.Digest, nil
}

// ClearDigest clears the value of the "digest" field.
func (m *InvocationFilesMutation) ClearDigest() {
	m.digest = nil
	m.clearedFields[invocationfiles.FieldDigest] = struct{}{}
}

// DigestCleared returns if the "digest" field was cleared in this mutation.
func (m *InvocationFilesMutation) DigestCleared() bool {
	_, ok := m.clearedFields[invocationfiles.FieldDigest]
	return ok
}

// ResetDigest resets all changes to the "digest" field.
func (m *InvocationFilesMutation) ResetDigest() {
	m.digest = nil
	delete(m.clearedFields, invocationfiles.FieldDigest)
}

// SetSizeBytes sets the "size_bytes" field.
func (m *InvocationFilesMutation) SetSizeBytes(i int64) {
	m.size_bytes = &i
	m.addsize_bytes = nil
}

// SizeBytes returns the value of the "size_bytes" field in the mutation.
func (m *InvocationFilesMutation) SizeBytes() (r int64, exists bool) {
	v := m.size_bytes
	if v == nil {
		return
	}
	return *v, true
}

// OldSizeBytes returns the old "size_bytes" field's value of the InvocationFiles entity.
// If the InvocationFiles object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvocationFilesMutation) OldSizeBytes(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSizeBytes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSizeBytes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSizeBytes: %w", err)
	}
	return oldValue.SizeBytes, nil
}

// AddSizeBytes adds i to the "size_bytes" field.
func (m *InvocationFilesMutation) AddSizeBytes(i int64) {
	if m.addsize_bytes != nil {
		*m.addsize_bytes += i
	} else {
		m.addsize_bytes = &i
	}
}

// AddedSizeBytes returns the value that was added to the "size_bytes" field in this mutation.
func (m *InvocationFilesMutation) AddedSizeBytes() (r int64, exists bool) {
	v := m.addsize_bytes
	if v == nil {
		return
	}
	return *v, true
}

// ClearSizeBytes clears the value of the "size_bytes" field.
func (m *InvocationFilesMutation) ClearSizeBytes() {
	m.size_bytes = nil
	m.addsize_bytes = nil
	m.clearedFields[invocationfiles.FieldSizeBytes] = struct{}{}
}

// SizeBytesCleared returns if the "size_bytes" field was cleared in this mutation.
func (m *InvocationFilesMutation) SizeBytesCleared() bool {
	_, ok := m.clearedFields[invocationfiles.FieldSizeBytes]
	return ok
}

// ResetSizeBytes resets all changes to the "size_bytes" field.
func (m *InvocationFilesMutation) ResetSizeBytes() {
	m.size_bytes = nil
	m.addsize_bytes = nil
	delete(m.clearedFields, invocationfiles.FieldSizeBytes)
}

// SetDigestFunction sets the "digest_function" field.
func (m *InvocationFilesMutation) SetDigestFunction(s string) {
	m.digest_function = &s
}

// DigestFunction returns the value of the "digest_function" field in the mutation.
func (m *InvocationFilesMutation) DigestFunction() (r string, exists bool) {
	v := m.digest_function
	if v == nil {
		return
	}
	return *v, true
}

// OldDigestFunction returns the old "digest_function" field's value of the InvocationFiles entity.
// If the InvocationFiles object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvocationFilesMutation) OldDigestFunction(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDigestFunction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDigestFunction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDigestFunction: %w", err)
	}
	return oldValue.DigestFunction, nil
}

// ClearDigestFunction clears the value of the "digest_function" field.
func (m *InvocationFilesMutation) ClearDigestFunction() {
	m.digest_function = nil
	m.clearedFields[invocationfiles.FieldDigestFunction] = struct{}{}
}

// DigestFunctionCleared returns if the "digest_function" field was cleared in this mutation.
func (m *InvocationFilesMutation) DigestFunctionCleared() bool {
	_, ok := m.clearedFields[invocationfiles.FieldDigestFunction]
	return ok
}

// ResetDigestFunction resets all changes to the "digest_function" field.
func (m *InvocationFilesMutation) ResetDigestFunction() {
	m.digest_function = nil
	delete(m.clearedFields, invocationfiles.FieldDigestFunction)
}

// SetBazelInvocationID sets the "bazel_invocation" edge to the BazelInvocation entity by id.
func (m *InvocationFilesMutation) SetBazelInvocationID(id int64) {
	m.bazel_invocation = &id
}

// ClearBazelInvocation clears the "bazel_invocation" edge to the BazelInvocation entity.
func (m *InvocationFilesMutation) ClearBazelInvocation() {
	m.clearedbazel_invocation = true
}

// BazelInvocationCleared reports if the "bazel_invocation" edge to the BazelInvocation entity was cleared.
func (m *InvocationFilesMutation) BazelInvocationCleared() bool {
	return m.clearedbazel_invocation
}

// BazelInvocationID returns the "bazel_invocation" edge ID in the mutation.
func (m *InvocationFilesMutation) BazelInvocationID() (id int64, exists bool) {
	if m.bazel_invocation != nil {
		return *m.bazel_invocation, true
	}
	return
}

// BazelInvocationIDs returns the "bazel_invocation" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BazelInvocationID instead. It exists only for internal usage by the builders.
func (m *InvocationFilesMutation) BazelInvocationIDs() (ids []int64) {
	if id := m.bazel_invocation; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBazelInvocation resets all changes to the "bazel_invocation" edge.
func (m *InvocationFilesMutation) ResetBazelInvocation() {
	m.bazel_invocation = nil
	m.clearedbazel_invocation = false
}

// Where appends a list predicates to the InvocationFilesMutation builder.
func (m *InvocationFilesMutation) Where(ps ...predicate.InvocationFiles) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InvocationFilesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InvocationFilesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.InvocationFiles, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InvocationFilesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InvocationFilesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (InvocationFiles).
func (m *InvocationFilesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InvocationFilesMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, invocationfiles.FieldName)
	}
	if m.content != nil {
		fields = append(fields, invocationfiles.FieldContent)
	}
	if m.digest != nil {
		fields = append(fields, invocationfiles.FieldDigest)
	}
	if m.size_bytes != nil {
		fields = append(fields, invocationfiles.FieldSizeBytes)
	}
	if m.digest_function != nil {
		fields = append(fields, invocationfiles.FieldDigestFunction)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InvocationFilesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case invocationfiles.FieldName:
		return m.Name()
	case invocationfiles.FieldContent:
		return m.Content()
	case invocationfiles.FieldDigest:
		return m.Digest()
	case invocationfiles.FieldSizeBytes:
		return m.SizeBytes()
	case invocationfiles.FieldDigestFunction:
		return m.DigestFunction()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InvocationFilesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case invocationfiles.FieldName:
		return m.OldName(ctx)
	case invocationfiles.FieldContent:
		return m.OldContent(ctx)
	case invocationfiles.FieldDigest:
		return m.OldDigest(ctx)
	case invocationfiles.FieldSizeBytes:
		return m.OldSizeBytes(ctx)
	case invocationfiles.FieldDigestFunction:
		return m.OldDigestFunction(ctx)
	}
	return nil, fmt.Errorf("unknown InvocationFiles field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvocationFilesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case invocationfiles.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case invocationfiles.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case invocationfiles.FieldDigest:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDigest(v)
		return nil
	case invocationfiles.FieldSizeBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSizeBytes(v)
		return nil
	case invocationfiles.FieldDigestFunction:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDigestFunction(v)
		return nil
	}
	return fmt.Errorf("unknown InvocationFiles field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InvocationFilesMutation) AddedFields() []string {
	var fields []string
	if m.addsize_bytes != nil {
		fields = append(fields, invocationfiles.FieldSizeBytes)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InvocationFilesMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case invocationfiles.FieldSizeBytes:
		return m.AddedSizeBytes()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvocationFilesMutation) AddField(name string, value ent.Value) error {
	switch name {
	case invocationfiles.FieldSizeBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSizeBytes(v)
		return nil
	}
	return fmt.Errorf("unknown InvocationFiles numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InvocationFilesMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(invocationfiles.FieldContent) {
		fields = append(fields, invocationfiles.FieldContent)
	}
	if m.FieldCleared(invocationfiles.FieldDigest) {
		fields = append(fields, invocationfiles.FieldDigest)
	}
	if m.FieldCleared(invocationfiles.FieldSizeBytes) {
		fields = append(fields, invocationfiles.FieldSizeBytes)
	}
	if m.FieldCleared(invocationfiles.FieldDigestFunction) {
		fields = append(fields, invocationfiles.FieldDigestFunction)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InvocationFilesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InvocationFilesMutation) ClearField(name string) error {
	switch name {
	case invocationfiles.FieldContent:
		m.ClearContent()
		return nil
	case invocationfiles.FieldDigest:
		m.ClearDigest()
		return nil
	case invocationfiles.FieldSizeBytes:
		m.ClearSizeBytes()
		return nil
	case invocationfiles.FieldDigestFunction:
		m.ClearDigestFunction()
		return nil
	}
	return fmt.Errorf("unknown InvocationFiles nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InvocationFilesMutation) ResetField(name string) error {
	switch name {
	case invocationfiles.FieldName:
		m.ResetName()
		return nil
	case invocationfiles.FieldContent:
		m.ResetContent()
		return nil
	case invocationfiles.FieldDigest:
		m.ResetDigest()
		return nil
	case invocationfiles.FieldSizeBytes:
		m.ResetSizeBytes()
		return nil
	case invocationfiles.FieldDigestFunction:
		m.ResetDigestFunction()
		return nil
	}
	return fmt.Errorf("unknown InvocationFiles field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InvocationFilesMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.bazel_invocation != nil {
		edges = append(edges, invocationfiles.EdgeBazelInvocation)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InvocationFilesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case invocationfiles.EdgeBazelInvocation:
		if id := m.bazel_invocation; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InvocationFilesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InvocationFilesMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InvocationFilesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbazel_invocation {
		edges = append(edges, invocationfiles.EdgeBazelInvocation)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InvocationFilesMutation) EdgeCleared(name string) bool {
	switch name {
	case invocationfiles.EdgeBazelInvocation:
		return m.clearedbazel_invocation
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InvocationFilesMutation) ClearEdge(name string) error {
	switch name {
	case invocationfiles.EdgeBazelInvocation:
		m.ClearBazelInvocation()
		return nil
	}
	return fmt.Errorf("unknown InvocationFiles unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InvocationFilesMutation) ResetEdge(name string) error {
	switch name {
	case invocationfiles.EdgeBazelInvocation:
		m.ResetBazelInvocation()
		return nil
	}
	return fmt.Errorf("unknown InvocationFiles edge %s", name)
}

// InvocationTargetMutation represents an operation that mutates the InvocationTarget nodes in the graph.
type InvocationTargetMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int64
	success                 *bool
	tags                    *[]string
	appendtags              []string
	start_time_in_ms        *int64
	addstart_time_in_ms     *int64
	end_time_in_ms          *int64
	addend_time_in_ms       *int64
	duration_in_ms          *int64
	addduration_in_ms       *int64
	failure_message         *string
	abort_reason            *invocationtarget.AbortReason
	clearedFields           map[string]struct{}
	bazel_invocation        *int64
	clearedbazel_invocation bool
	target                  *int64
	clearedtarget           bool
	configuration           *int64
	clearedconfiguration    bool
	test_summary            map[int64]struct{}
	removedtest_summary     map[int64]struct{}
	clearedtest_summary     bool
	done                    bool
	oldValue                func(context.Context) (*InvocationTarget, error)
	predicates              []predicate.InvocationTarget
}

var _ ent.Mutation = (*InvocationTargetMutation)(nil)

// invocationtargetOption allows management of the mutation configuration using functional options.
type invocationtargetOption func(*InvocationTargetMutation)

// newInvocationTargetMutation creates new mutation for the InvocationTarget entity.
func newInvocationTargetMutation(c config, op Op, opts ...invocationtargetOption) *InvocationTargetMutation {
	m := &InvocationTargetMutation{
		config:        c,
		op:            op,
		typ:           TypeInvocationTarget,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInvocationTargetID sets the ID field of the mutation.
func withInvocationTargetID(id int64) invocationtargetOption {
	return func(m *InvocationTargetMutation) {
		var (
			err   error
			once  sync.Once
			value *InvocationTarget
		)
		m.oldValue = func(ctx context.Context) (*InvocationTarget, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InvocationTarget.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInvocationTarget sets the old InvocationTarget of the mutation.
func withInvocationTarget(node *InvocationTarget) invocationtargetOption {
	return func(m *InvocationTargetMutation) {
		m.oldValue = func(context.Context) (*InvocationTarget, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InvocationTargetMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InvocationTargetMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of InvocationTarget entities.
func (m *InvocationTargetMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InvocationTargetMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InvocationTargetMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InvocationTarget.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSuccess sets the "success" field.
func (m *InvocationTargetMutation) SetSuccess(b bool) {
	m.success = &b
}

// Success returns the value of the "success" field in the mutation.
func (m *InvocationTargetMutation) Success() (r bool, exists bool) {
	v := m.success
	if v == nil {
		return
	}
	return *v, true
}

// OldSuccess returns the old "success" field's value of the InvocationTarget entity.
// If the InvocationTarget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvocationTargetMutation) OldSuccess(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuccess is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuccess requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuccess: %w", err)
	}
	return oldValue.Success, nil
}

// ResetSuccess resets all changes to the "success" field.
func (m *InvocationTargetMutation) ResetSuccess() {
	m.success = nil
}

// SetTags sets the "tags" field.
func (m *InvocationTargetMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *InvocationTargetMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the InvocationTarget entity.
// If the InvocationTarget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvocationTargetMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *InvocationTargetMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *InvocationTargetMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *InvocationTargetMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[invocationtarget.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *InvocationTargetMutation) TagsCleared() bool {
	_, ok := m.clearedFields[invocationtarget.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *InvocationTargetMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, invocationtarget.FieldTags)
}

// SetStartTimeInMs sets the "start_time_in_ms" field.
func (m *InvocationTargetMutation) SetStartTimeInMs(i int64) {
	m.start_time_in_ms = &i
	m.addstart_time_in_ms = nil
}

// StartTimeInMs returns the value of the "start_time_in_ms" field in the mutation.
func (m *InvocationTargetMutation) StartTimeInMs() (r int64, exists bool) {
	v := m.start_time_in_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTimeInMs returns the old "start_time_in_ms" field's value of the InvocationTarget entity.
// If the InvocationTarget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvocationTargetMutation) OldStartTimeInMs(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTimeInMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTimeInMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTimeInMs: %w", err)
	}
	return oldValue.StartTimeInMs, nil
}

// AddStartTimeInMs adds i to the "start_time_in_ms" field.
func (m *InvocationTargetMutation) AddStartTimeInMs(i int64) {
	if m.addstart_time_in_ms != nil {
		*m.addstart_time_in_ms += i
	} else {
		m.addstart_time_in_ms = &i
	}
}

// AddedStartTimeInMs returns the value that was added to the "start_time_in_ms" field in this mutation.
func (m *InvocationTargetMutation) AddedStartTimeInMs() (r int64, exists bool) {
	v := m.addstart_time_in_ms
	if v == nil {
		return
	}
	return *v, true
}

// ClearStartTimeInMs clears the value of the "start_time_in_ms" field.
func (m *InvocationTargetMutation) ClearStartTimeInMs() {
	m.start_time_in_ms = nil
	m.addstart_time_in_ms = nil
	m.clearedFields[invocationtarget.FieldStartTimeInMs] = struct{}{}
}

// StartTimeInMsCleared returns if the "start_time_in_ms" field was cleared in this mutation.
func (m *InvocationTargetMutation) StartTimeInMsCleared() bool {
	_, ok := m.clearedFields[invocationtarget.FieldStartTimeInMs]
	return ok
}

// ResetStartTimeInMs resets all changes to the "start_time_in_ms" field.
func (m *InvocationTargetMutation) ResetStartTimeInMs() {
	m.start_time_in_ms = nil
	m.addstart_time_in_ms = nil
	delete(m.clearedFields, invocationtarget.FieldStartTimeInMs)
}

// SetEndTimeInMs sets the "end_time_in_ms" field.
func (m *InvocationTargetMutation) SetEndTimeInMs(i int64) {
	m.end_time_in_ms = &i
	m.addend_time_in_ms = nil
}

// EndTimeInMs returns the value of the "end_time_in_ms" field in the mutation.
func (m *InvocationTargetMutation) EndTimeInMs() (r int64, exists bool) {
	v := m.end_time_in_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTimeInMs returns the old "end_time_in_ms" field's value of the InvocationTarget entity.
// If the InvocationTarget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvocationTargetMutation) OldEndTimeInMs(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTimeInMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTimeInMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTimeInMs: %w", err)
	}
	return oldValue.EndTimeInMs, nil
}

// AddEndTimeInMs adds i to the "end_time_in_ms" field.
func (m *InvocationTargetMutation) AddEndTimeInMs(i int64) {
	if m.addend_time_in_ms != nil {
		*m.addend_time_in_ms += i
	} else {
		m.addend_time_in_ms = &i
	}
}

// AddedEndTimeInMs returns the value that was added to the "end_time_in_ms" field in this mutation.
func (m *InvocationTargetMutation) AddedEndTimeInMs() (r int64, exists bool) {
	v := m.addend_time_in_ms
	if v == nil {
		return
	}
	return *v, true
}

// ClearEndTimeInMs clears the value of the "end_time_in_ms" field.
func (m *InvocationTargetMutation) ClearEndTimeInMs() {
	m.end_time_in_ms = nil
	m.addend_time_in_ms = nil
	m.clearedFields[invocationtarget.FieldEndTimeInMs] = struct{}{}
}

// EndTimeInMsCleared returns if the "end_time_in_ms" field was cleared in this mutation.
func (m *InvocationTargetMutation) EndTimeInMsCleared() bool {
	_, ok := m.clearedFields[invocationtarget.FieldEndTimeInMs]
	return ok
}

// ResetEndTimeInMs resets all changes to the "end_time_in_ms" field.
func (m *InvocationTargetMutation) ResetEndTimeInMs() {
	m.end_time_in_ms = nil
	m.addend_time_in_ms = nil
	delete(m.clearedFields, invocationtarget.FieldEndTimeInMs)
}

// SetDurationInMs sets the "duration_in_ms" field.
func (m *InvocationTargetMutation) SetDurationInMs(i int64) {
	m.duration_in_ms = &i
	m.addduration_in_ms = nil
}

// DurationInMs returns the value of the "duration_in_ms" field in the mutation.
func (m *InvocationTargetMutation) DurationInMs() (r int64, exists bool) {
	v := m.duration_in_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldDurationInMs returns the old "duration_in_ms" field's value of the InvocationTarget entity.
// If the InvocationTarget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvocationTargetMutation) OldDurationInMs(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDurationInMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDurationInMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDurationInMs: %w", err)
	}
	return oldValue.DurationInMs, nil
}

// AddDurationInMs adds i to the "duration_in_ms" field.
func (m *InvocationTargetMutation) AddDurationInMs(i int64) {
	if m.addduration_in_ms != nil {
		*m.addduration_in_ms += i
	} else {
		m.addduration_in_ms = &i
	}
}

// AddedDurationInMs returns the value that was added to the "duration_in_ms" field in this mutation.
func (m *InvocationTargetMutation) AddedDurationInMs() (r int64, exists bool) {
	v := m.addduration_in_ms
	if v == nil {
		return
	}
	return *v, true
}

// ClearDurationInMs clears the value of the "duration_in_ms" field.
func (m *InvocationTargetMutation) ClearDurationInMs() {
	m.duration_in_ms = nil
	m.addduration_in_ms = nil
	m.clearedFields[invocationtarget.FieldDurationInMs] = struct{}{}
}

// DurationInMsCleared returns if the "duration_in_ms" field was cleared in this mutation.
func (m *InvocationTargetMutation) DurationInMsCleared() bool {
	_, ok := m.clearedFields[invocationtarget.FieldDurationInMs]
	return ok
}

// ResetDurationInMs resets all changes to the "duration_in_ms" field.
func (m *InvocationTargetMutation) ResetDurationInMs() {
	m.duration_in_ms = nil
	m.addduration_in_ms = nil
	delete(m.clearedFields, invocationtarget.FieldDurationInMs)
}

// SetFailureMessage sets the "failure_message" field.
func (m *InvocationTargetMutation) SetFailureMessage(s string) {
	m.failure_message = &s
}

// FailureMessage returns the value of the "failure_message" field in the mutation.
func (m *InvocationTargetMutation) FailureMessage() (r string, exists bool) {
	v := m.failure_message
	if v == nil {
		return
	}
	return *v, true
}

// OldFailureMessage returns the old "failure_message" field's value of the InvocationTarget entity.
// If the InvocationTarget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvocationTargetMutation) OldFailureMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFailureMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFailureMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFailureMessage: %w", err)
	}
	return oldValue.FailureMessage, nil
}

// ClearFailureMessage clears the value of the "failure_message" field.
func (m *InvocationTargetMutation) ClearFailureMessage() {
	m.failure_message = nil
	m.clearedFields[invocationtarget.FieldFailureMessage] = struct{}{}
}

// FailureMessageCleared returns if the "failure_message" field was cleared in this mutation.
func (m *InvocationTargetMutation) FailureMessageCleared() bool {
	_, ok := m.clearedFields[invocationtarget.FieldFailureMessage]
	return ok
}

// ResetFailureMessage resets all changes to the "failure_message" field.
func (m *InvocationTargetMutation) ResetFailureMessage() {
	m.failure_message = nil
	delete(m.clearedFields, invocationtarget.FieldFailureMessage)
}

// SetAbortReason sets the "abort_reason" field.
func (m *InvocationTargetMutation) SetAbortReason(ir invocationtarget.AbortReason) {
	m.abort_reason = &ir
}

// AbortReason returns the value of the "abort_reason" field in the mutation.
func (m *InvocationTargetMutation) AbortReason() (r invocationtarget.AbortReason, exists bool) {
	v := m.abort_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldAbortReason returns the old "abort_reason" field's value of the InvocationTarget entity.
// If the InvocationTarget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvocationTargetMutation) OldAbortReason(ctx context.Context) (v invocationtarget.AbortReason, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbortReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbortReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbortReason: %w", err)
	}
	return oldValue.AbortReason, nil
}

// ResetAbortReason resets all changes to the "abort_reason" field.
func (m *InvocationTargetMutation) ResetAbortReason() {
	m.abort_reason = nil
}

// SetBazelInvocationID sets the "bazel_invocation" edge to the BazelInvocation entity by id.
func (m *InvocationTargetMutation) SetBazelInvocationID(id int64) {
	m.bazel_invocation = &id
}

// ClearBazelInvocation clears the "bazel_invocation" edge to the BazelInvocation entity.
func (m *InvocationTargetMutation) ClearBazelInvocation() {
	m.clearedbazel_invocation = true
}

// BazelInvocationCleared reports if the "bazel_invocation" edge to the BazelInvocation entity was cleared.
func (m *InvocationTargetMutation) BazelInvocationCleared() bool {
	return m.clearedbazel_invocation
}

// BazelInvocationID returns the "bazel_invocation" edge ID in the mutation.
func (m *InvocationTargetMutation) BazelInvocationID() (id int64, exists bool) {
	if m.bazel_invocation != nil {
		return *m.bazel_invocation, true
	}
	return
}

// BazelInvocationIDs returns the "bazel_invocation" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BazelInvocationID instead. It exists only for internal usage by the builders.
func (m *InvocationTargetMutation) BazelInvocationIDs() (ids []int64) {
	if id := m.bazel_invocation; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBazelInvocation resets all changes to the "bazel_invocation" edge.
func (m *InvocationTargetMutation) ResetBazelInvocation() {
	m.bazel_invocation = nil
	m.clearedbazel_invocation = false
}

// SetTargetID sets the "target" edge to the Target entity by id.
func (m *InvocationTargetMutation) SetTargetID(id int64) {
	m.target = &id
}

// ClearTarget clears the "target" edge to the Target entity.
func (m *InvocationTargetMutation) ClearTarget() {
	m.clearedtarget = true
}

// TargetCleared reports if the "target" edge to the Target entity was cleared.
func (m *InvocationTargetMutation) TargetCleared() bool {
	return m.clearedtarget
}

// TargetID returns the "target" edge ID in the mutation.
func (m *InvocationTargetMutation) TargetID() (id int64, exists bool) {
	if m.target != nil {
		return *m.target, true
	}
	return
}

// TargetIDs returns the "target" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TargetID instead. It exists only for internal usage by the builders.
func (m *InvocationTargetMutation) TargetIDs() (ids []int64) {
	if id := m.target; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTarget resets all changes to the "target" edge.
func (m *InvocationTargetMutation) ResetTarget() {
	m.target = nil
	m.clearedtarget = false
}

// SetConfigurationID sets the "configuration" edge to the Configuration entity by id.
func (m *InvocationTargetMutation) SetConfigurationID(id int64) {
	m.configuration = &id
}

// ClearConfiguration clears the "configuration" edge to the Configuration entity.
func (m *InvocationTargetMutation) ClearConfiguration() {
	m.clearedconfiguration = true
}

// ConfigurationCleared reports if the "configuration" edge to the Configuration entity was cleared.
func (m *InvocationTargetMutation) ConfigurationCleared() bool {
	return m.clearedconfiguration
}

// ConfigurationID returns the "configuration" edge ID in the mutation.
func (m *InvocationTargetMutation) ConfigurationID() (id int64, exists bool) {
	if m.configuration != nil {
		return *m.configuration, true
	}
	return
}

// ConfigurationIDs returns the "configuration" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ConfigurationID instead. It exists only for internal usage by the builders.
func (m *InvocationTargetMutation) ConfigurationIDs() (ids []int64) {
	if id := m.configuration; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConfiguration resets all changes to the "configuration" edge.
func (m *InvocationTargetMutation) ResetConfiguration() {
	m.configuration = nil
	m.clearedconfiguration = false
}

// AddTestSummaryIDs adds the "test_summary" edge to the TestSummary entity by ids.
func (m *InvocationTargetMutation) AddTestSummaryIDs(ids ...int64) {
	if m.test_summary == nil {
		m.test_summary = make(map[int64]struct{})
	}
	for i := range ids {
		m.test_summary[ids[i]] = struct{}{}
	}
}

// ClearTestSummary clears the "test_summary" edge to the TestSummary entity.
func (m *InvocationTargetMutation) ClearTestSummary() {
	m.clearedtest_summary = true
}

// TestSummaryCleared reports if the "test_summary" edge to the TestSummary entity was cleared.
func (m *InvocationTargetMutation) TestSummaryCleared() bool {
	return m.clearedtest_summary
}

// RemoveTestSummaryIDs removes the "test_summary" edge to the TestSummary entity by IDs.
func (m *InvocationTargetMutation) RemoveTestSummaryIDs(ids ...int64) {
	if m.removedtest_summary == nil {
		m.removedtest_summary = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.test_summary, ids[i])
		m.removedtest_summary[ids[i]] = struct{}{}
	}
}

// RemovedTestSummary returns the removed IDs of the "test_summary" edge to the TestSummary entity.
func (m *InvocationTargetMutation) RemovedTestSummaryIDs() (ids []int64) {
	for id := range m.removedtest_summary {
		ids = append(ids, id)
	}
	return
}

// TestSummaryIDs returns the "test_summary" edge IDs in the mutation.
func (m *InvocationTargetMutation) TestSummaryIDs() (ids []int64) {
	for id := range m.test_summary {
		ids = append(ids, id)
	}
	return
}

// ResetTestSummary resets all changes to the "test_summary" edge.
func (m *InvocationTargetMutation) ResetTestSummary() {
	m.test_summary = nil
	m.clearedtest_summary = false
	m.removedtest_summary = nil
}

// Where appends a list predicates to the InvocationTargetMutation builder.
func (m *InvocationTargetMutation) Where(ps ...predicate.InvocationTarget) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InvocationTargetMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InvocationTargetMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.InvocationTarget, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InvocationTargetMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InvocationTargetMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (InvocationTarget).
func (m *InvocationTargetMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InvocationTargetMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.success != nil {
		fields = append(fields, invocationtarget.FieldSuccess)
	}
	if m.tags != nil {
		fields = append(fields, invocationtarget.FieldTags)
	}
	if m.start_time_in_ms != nil {
		fields = append(fields, invocationtarget.FieldStartTimeInMs)
	}
	if m.end_time_in_ms != nil {
		fields = append(fields, invocationtarget.FieldEndTimeInMs)
	}
	if m.duration_in_ms != nil {
		fields = append(fields, invocationtarget.FieldDurationInMs)
	}
	if m.failure_message != nil {
		fields = append(fields, invocationtarget.FieldFailureMessage)
	}
	if m.abort_reason != nil {
		fields = append(fields, invocationtarget.FieldAbortReason)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InvocationTargetMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case invocationtarget.FieldSuccess:
		return m.Success()
	case invocationtarget.FieldTags:
		return m.Tags()
	case invocationtarget.FieldStartTimeInMs:
		return m.StartTimeInMs()
	case invocationtarget.FieldEndTimeInMs:
		return m.EndTimeInMs()
	case invocationtarget.FieldDurationInMs:
		return m.DurationInMs()
	case invocationtarget.FieldFailureMessage:
		return m.FailureMessage()
	case invocationtarget.FieldAbortReason:
		return m.AbortReason()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InvocationTargetMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case invocationtarget.FieldSuccess:
		return m.OldSuccess(ctx)
	case invocationtarget.FieldTags:
		return m.OldTags(ctx)
	case invocationtarget.FieldStartTimeInMs:
		return m.OldStartTimeInMs(ctx)
	case invocationtarget.FieldEndTimeInMs:
		return m.OldEndTimeInMs(ctx)
	case invocationtarget.FieldDurationInMs:
		return m.OldDurationInMs(ctx)
	case invocationtarget.FieldFailureMessage:
		return m.OldFailureMessage(ctx)
	case invocationtarget.FieldAbortReason:
		return m.OldAbortReason(ctx)
	}
	return nil, fmt.Errorf("unknown InvocationTarget field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvocationTargetMutation) SetField(name string, value ent.Value) error {
	switch name {
	case invocationtarget.FieldSuccess:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuccess(v)
		return nil
	case invocationtarget.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case invocationtarget.FieldStartTimeInMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTimeInMs(v)
		return nil
	case invocationtarget.FieldEndTimeInMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTimeInMs(v)
		return nil
	case invocationtarget.FieldDurationInMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDurationInMs(v)
		return nil
	case invocationtarget.FieldFailureMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFailureMessage(v)
		return nil
	case invocationtarget.FieldAbortReason:
		v, ok := value.(invocationtarget.AbortReason)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbortReason(v)
		return nil
	}
	return fmt.Errorf("unknown InvocationTarget field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InvocationTargetMutation) AddedFields() []string {
	var fields []string
	if m.addstart_time_in_ms != nil {
		fields = append(fields, invocationtarget.FieldStartTimeInMs)
	}
	if m.addend_time_in_ms != nil {
		fields = append(fields, invocationtarget.FieldEndTimeInMs)
	}
	if m.addduration_in_ms != nil {
		fields = append(fields, invocationtarget.FieldDurationInMs)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InvocationTargetMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case invocationtarget.FieldStartTimeInMs:
		return m.AddedStartTimeInMs()
	case invocationtarget.FieldEndTimeInMs:
		return m.AddedEndTimeInMs()
	case invocationtarget.FieldDurationInMs:
		return m.AddedDurationInMs()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvocationTargetMutation) AddField(name string, value ent.Value) error {
	switch name {
	case invocationtarget.FieldStartTimeInMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartTimeInMs(v)
		return nil
	case invocationtarget.FieldEndTimeInMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEndTimeInMs(v)
		return nil
	case invocationtarget.FieldDurationInMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDurationInMs(v)
		return nil
	}
	return fmt.Errorf("unknown InvocationTarget numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InvocationTargetMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(invocationtarget.FieldTags) {
		fields = append(fields, invocationtarget.FieldTags)
	}
	if m.FieldCleared(invocationtarget.FieldStartTimeInMs) {
		fields = append(fields, invocationtarget.FieldStartTimeInMs)
	}
	if m.FieldCleared(invocationtarget.FieldEndTimeInMs) {
		fields = append(fields, invocationtarget.FieldEndTimeInMs)
	}
	if m.FieldCleared(invocationtarget.FieldDurationInMs) {
		fields = append(fields, invocationtarget.FieldDurationInMs)
	}
	if m.FieldCleared(invocationtarget.FieldFailureMessage) {
		fields = append(fields, invocationtarget.FieldFailureMessage)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InvocationTargetMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InvocationTargetMutation) ClearField(name string) error {
	switch name {
	case invocationtarget.FieldTags:
		m.ClearTags()
		return nil
	case invocationtarget.FieldStartTimeInMs:
		m.ClearStartTimeInMs()
		return nil
	case invocationtarget.FieldEndTimeInMs:
		m.ClearEndTimeInMs()
		return nil
	case invocationtarget.FieldDurationInMs:
		m.ClearDurationInMs()
		return nil
	case invocationtarget.FieldFailureMessage:
		m.ClearFailureMessage()
		return nil
	}
	return fmt.Errorf("unknown InvocationTarget nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InvocationTargetMutation) ResetField(name string) error {
	switch name {
	case invocationtarget.FieldSuccess:
		m.ResetSuccess()
		return nil
	case invocationtarget.FieldTags:
		m.ResetTags()
		return nil
	case invocationtarget.FieldStartTimeInMs:
		m.ResetStartTimeInMs()
		return nil
	case invocationtarget.FieldEndTimeInMs:
		m.ResetEndTimeInMs()
		return nil
	case invocationtarget.FieldDurationInMs:
		m.ResetDurationInMs()
		return nil
	case invocationtarget.FieldFailureMessage:
		m.ResetFailureMessage()
		return nil
	case invocationtarget.FieldAbortReason:
		m.ResetAbortReason()
		return nil
	}
	return fmt.Errorf("unknown InvocationTarget field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InvocationTargetMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.bazel_invocation != nil {
		edges = append(edges, invocationtarget.EdgeBazelInvocation)
	}
	if m.target != nil {
		edges = append(edges, invocationtarget.EdgeTarget)
	}
	if m.configuration != nil {
		edges = append(edges, invocationtarget.EdgeConfiguration)
	}
	if m.test_summary != nil {
		edges = append(edges, invocationtarget.EdgeTestSummary)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InvocationTargetMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case invocationtarget.EdgeBazelInvocation:
		if id := m.bazel_invocation; id != nil {
			return []ent.Value{*id}
		}
	case invocationtarget.EdgeTarget:
		if id := m.target; id != nil {
			return []ent.Value{*id}
		}
	case invocationtarget.EdgeConfiguration:
		if id := m.configuration; id != nil {
			return []ent.Value{*id}
		}
	case invocationtarget.EdgeTestSummary:
		ids := make([]ent.Value, 0, len(m.test_summary))
		for id := range m.test_summary {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InvocationTargetMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedtest_summary != nil {
		edges = append(edges, invocationtarget.EdgeTestSummary)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InvocationTargetMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case invocationtarget.EdgeTestSummary:
		ids := make([]ent.Value, 0, len(m.removedtest_summary))
		for id := range m.removedtest_summary {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InvocationTargetMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedbazel_invocation {
		edges = append(edges, invocationtarget.EdgeBazelInvocation)
	}
	if m.clearedtarget {
		edges = append(edges, invocationtarget.EdgeTarget)
	}
	if m.clearedconfiguration {
		edges = append(edges, invocationtarget.EdgeConfiguration)
	}
	if m.clearedtest_summary {
		edges = append(edges, invocationtarget.EdgeTestSummary)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InvocationTargetMutation) EdgeCleared(name string) bool {
	switch name {
	case invocationtarget.EdgeBazelInvocation:
		return m.clearedbazel_invocation
	case invocationtarget.EdgeTarget:
		return m.clearedtarget
	case invocationtarget.EdgeConfiguration:
		return m.clearedconfiguration
	case invocationtarget.EdgeTestSummary:
		return m.clearedtest_summary
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InvocationTargetMutation) ClearEdge(name string) error {
	switch name {
	case invocationtarget.EdgeBazelInvocation:
		m.ClearBazelInvocation()
		return nil
	case invocationtarget.EdgeTarget:
		m.ClearTarget()
		return nil
	case invocationtarget.EdgeConfiguration:
		m.ClearConfiguration()
		return nil
	}
	return fmt.Errorf("unknown InvocationTarget unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InvocationTargetMutation) ResetEdge(name string) error {
	switch name {
	case invocationtarget.EdgeBazelInvocation:
		m.ResetBazelInvocation()
		return nil
	case invocationtarget.EdgeTarget:
		m.ResetTarget()
		return nil
	case invocationtarget.EdgeConfiguration:
		m.ResetConfiguration()
		return nil
	case invocationtarget.EdgeTestSummary:
		m.ResetTestSummary()
		return nil
	}
	return fmt.Errorf("unknown InvocationTarget edge %s", name)
}

// MemoryMetricsMutation represents an operation that mutates the MemoryMetrics nodes in the graph.
type MemoryMetricsMutation struct {
	config
	op                                      Op
	typ                                     string
	id                                      *int64
	peak_post_gc_heap_size                  *int64
	addpeak_post_gc_heap_size               *int64
	used_heap_size_post_build               *int64
	addused_heap_size_post_build            *int64
	peak_post_gc_tenured_space_heap_size    *int64
	addpeak_post_gc_tenured_space_heap_size *int64
	clearedFields                           map[string]struct{}
	metrics                                 *int64
	clearedmetrics                          bool
	garbage_metrics                         map[int64]struct{}
	removedgarbage_metrics                  map[int64]struct{}
	clearedgarbage_metrics                  bool
	done                                    bool
	oldValue                                func(context.Context) (*MemoryMetrics, error)
	predicates                              []predicate.MemoryMetrics
}

var _ ent.Mutation = (*MemoryMetricsMutation)(nil)

// memorymetricsOption allows management of the mutation configuration using functional options.
type memorymetricsOption func(*MemoryMetricsMutation)

// newMemoryMetricsMutation creates new mutation for the MemoryMetrics entity.
func newMemoryMetricsMutation(c config, op Op, opts ...memorymetricsOption) *MemoryMetricsMutation {
	m := &MemoryMetricsMutation{
		config:        c,
		op:            op,
		typ:           TypeMemoryMetrics,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMemoryMetricsID sets the ID field of the mutation.
func withMemoryMetricsID(id int64) memorymetricsOption {
	return func(m *MemoryMetricsMutation) {
		var (
			err   error
			once  sync.Once
			value *MemoryMetrics
		)
		m.oldValue = func(ctx context.Context) (*MemoryMetrics, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MemoryMetrics.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMemoryMetrics sets the old MemoryMetrics of the mutation.
func withMemoryMetrics(node *MemoryMetrics) memorymetricsOption {
	return func(m *MemoryMetricsMutation) {
		m.oldValue = func(context.Context) (*MemoryMetrics, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MemoryMetricsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MemoryMetricsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MemoryMetrics entities.
func (m *MemoryMetricsMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MemoryMetricsMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MemoryMetricsMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MemoryMetrics.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPeakPostGcHeapSize sets the "peak_post_gc_heap_size" field.
func (m *MemoryMetricsMutation) SetPeakPostGcHeapSize(i int64) {
	m.peak_post_gc_heap_size = &i
	m.addpeak_post_gc_heap_size = nil
}

// PeakPostGcHeapSize returns the value of the "peak_post_gc_heap_size" field in the mutation.
func (m *MemoryMetricsMutation) PeakPostGcHeapSize() (r int64, exists bool) {
	v := m.peak_post_gc_heap_size
	if v == nil {
		return
	}
	return *v, true
}

// OldPeakPostGcHeapSize returns the old "peak_post_gc_heap_size" field's value of the MemoryMetrics entity.
// If the MemoryMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemoryMetricsMutation) OldPeakPostGcHeapSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPeakPostGcHeapSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPeakPostGcHeapSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPeakPostGcHeapSize: %w", err)
	}
	return oldValue.PeakPostGcHeapSize, nil
}

// AddPeakPostGcHeapSize adds i to the "peak_post_gc_heap_size" field.
func (m *MemoryMetricsMutation) AddPeakPostGcHeapSize(i int64) {
	if m.addpeak_post_gc_heap_size != nil {
		*m.addpeak_post_gc_heap_size += i
	} else {
		m.addpeak_post_gc_heap_size = &i
	}
}

// AddedPeakPostGcHeapSize returns the value that was added to the "peak_post_gc_heap_size" field in this mutation.
func (m *MemoryMetricsMutation) AddedPeakPostGcHeapSize() (r int64, exists bool) {
	v := m.addpeak_post_gc_heap_size
	if v == nil {
		return
	}
	return *v, true
}

// ClearPeakPostGcHeapSize clears the value of the "peak_post_gc_heap_size" field.
func (m *MemoryMetricsMutation) ClearPeakPostGcHeapSize() {
	m.peak_post_gc_heap_size = nil
	m.addpeak_post_gc_heap_size = nil
	m.clearedFields[memorymetrics.FieldPeakPostGcHeapSize] = struct{}{}
}

// PeakPostGcHeapSizeCleared returns if the "peak_post_gc_heap_size" field was cleared in this mutation.
func (m *MemoryMetricsMutation) PeakPostGcHeapSizeCleared() bool {
	_, ok := m.clearedFields[memorymetrics.FieldPeakPostGcHeapSize]
	return ok
}

// ResetPeakPostGcHeapSize resets all changes to the "peak_post_gc_heap_size" field.
func (m *MemoryMetricsMutation) ResetPeakPostGcHeapSize() {
	m.peak_post_gc_heap_size = nil
	m.addpeak_post_gc_heap_size = nil
	delete(m.clearedFields, memorymetrics.FieldPeakPostGcHeapSize)
}

// SetUsedHeapSizePostBuild sets the "used_heap_size_post_build" field.
func (m *MemoryMetricsMutation) SetUsedHeapSizePostBuild(i int64) {
	m.used_heap_size_post_build = &i
	m.addused_heap_size_post_build = nil
}

// UsedHeapSizePostBuild returns the value of the "used_heap_size_post_build" field in the mutation.
func (m *MemoryMetricsMutation) UsedHeapSizePostBuild() (r int64, exists bool) {
	v := m.used_heap_size_post_build
	if v == nil {
		return
	}
	return *v, true
}

// OldUsedHeapSizePostBuild returns the old "used_heap_size_post_build" field's value of the MemoryMetrics entity.
// If the MemoryMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemoryMetricsMutation) OldUsedHeapSizePostBuild(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsedHeapSizePostBuild is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsedHeapSizePostBuild requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsedHeapSizePostBuild: %w", err)
	}
	return oldValue.UsedHeapSizePostBuild, nil
}

// AddUsedHeapSizePostBuild adds i to the "used_heap_size_post_build" field.
func (m *MemoryMetricsMutation) AddUsedHeapSizePostBuild(i int64) {
	if m.addused_heap_size_post_build != nil {
		*m.addused_heap_size_post_build += i
	} else {
		m.addused_heap_size_post_build = &i
	}
}

// AddedUsedHeapSizePostBuild returns the value that was added to the "used_heap_size_post_build" field in this mutation.
func (m *MemoryMetricsMutation) AddedUsedHeapSizePostBuild() (r int64, exists bool) {
	v := m.addused_heap_size_post_build
	if v == nil {
		return
	}
	return *v, true
}

// ClearUsedHeapSizePostBuild clears the value of the "used_heap_size_post_build" field.
func (m *MemoryMetricsMutation) ClearUsedHeapSizePostBuild() {
	m.used_heap_size_post_build = nil
	m.addused_heap_size_post_build = nil
	m.clearedFields[memorymetrics.FieldUsedHeapSizePostBuild] = struct{}{}
}

// UsedHeapSizePostBuildCleared returns if the "used_heap_size_post_build" field was cleared in this mutation.
func (m *MemoryMetricsMutation) UsedHeapSizePostBuildCleared() bool {
	_, ok := m.clearedFields[memorymetrics.FieldUsedHeapSizePostBuild]
	return ok
}

// ResetUsedHeapSizePostBuild resets all changes to the "used_heap_size_post_build" field.
func (m *MemoryMetricsMutation) ResetUsedHeapSizePostBuild() {
	m.used_heap_size_post_build = nil
	m.addused_heap_size_post_build = nil
	delete(m.clearedFields, memorymetrics.FieldUsedHeapSizePostBuild)
}

// SetPeakPostGcTenuredSpaceHeapSize sets the "peak_post_gc_tenured_space_heap_size" field.
func (m *MemoryMetricsMutation) SetPeakPostGcTenuredSpaceHeapSize(i int64) {
	m.peak_post_gc_tenured_space_heap_size = &i
	m.addpeak_post_gc_tenured_space_heap_size = nil
}

// PeakPostGcTenuredSpaceHeapSize returns the value of the "peak_post_gc_tenured_space_heap_size" field in the mutation.
func (m *MemoryMetricsMutation) PeakPostGcTenuredSpaceHeapSize() (r int64, exists bool) {
	v := m.peak_post_gc_tenured_space_heap_size
	if v == nil {
		return
	}
	return *v, true
}

// OldPeakPostGcTenuredSpaceHeapSize returns the old "peak_post_gc_tenured_space_heap_size" field's value of the MemoryMetrics entity.
// If the MemoryMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemoryMetricsMutation) OldPeakPostGcTenuredSpaceHeapSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPeakPostGcTenuredSpaceHeapSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPeakPostGcTenuredSpaceHeapSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPeakPostGcTenuredSpaceHeapSize: %w", err)
	}
	return oldValue.PeakPostGcTenuredSpaceHeapSize, nil
}

// AddPeakPostGcTenuredSpaceHeapSize adds i to the "peak_post_gc_tenured_space_heap_size" field.
func (m *MemoryMetricsMutation) AddPeakPostGcTenuredSpaceHeapSize(i int64) {
	if m.addpeak_post_gc_tenured_space_heap_size != nil {
		*m.addpeak_post_gc_tenured_space_heap_size += i
	} else {
		m.addpeak_post_gc_tenured_space_heap_size = &i
	}
}

// AddedPeakPostGcTenuredSpaceHeapSize returns the value that was added to the "peak_post_gc_tenured_space_heap_size" field in this mutation.
func (m *MemoryMetricsMutation) AddedPeakPostGcTenuredSpaceHeapSize() (r int64, exists bool) {
	v := m.addpeak_post_gc_tenured_space_heap_size
	if v == nil {
		return
	}
	return *v, true
}

// ClearPeakPostGcTenuredSpaceHeapSize clears the value of the "peak_post_gc_tenured_space_heap_size" field.
func (m *MemoryMetricsMutation) ClearPeakPostGcTenuredSpaceHeapSize() {
	m.peak_post_gc_tenured_space_heap_size = nil
	m.addpeak_post_gc_tenured_space_heap_size = nil
	m.clearedFields[memorymetrics.FieldPeakPostGcTenuredSpaceHeapSize] = struct{}{}
}

// PeakPostGcTenuredSpaceHeapSizeCleared returns if the "peak_post_gc_tenured_space_heap_size" field was cleared in this mutation.
func (m *MemoryMetricsMutation) PeakPostGcTenuredSpaceHeapSizeCleared() bool {
	_, ok := m.clearedFields[memorymetrics.FieldPeakPostGcTenuredSpaceHeapSize]
	return ok
}

// ResetPeakPostGcTenuredSpaceHeapSize resets all changes to the "peak_post_gc_tenured_space_heap_size" field.
func (m *MemoryMetricsMutation) ResetPeakPostGcTenuredSpaceHeapSize() {
	m.peak_post_gc_tenured_space_heap_size = nil
	m.addpeak_post_gc_tenured_space_heap_size = nil
	delete(m.clearedFields, memorymetrics.FieldPeakPostGcTenuredSpaceHeapSize)
}

// SetMetricsID sets the "metrics" edge to the Metrics entity by id.
func (m *MemoryMetricsMutation) SetMetricsID(id int64) {
	m.metrics = &id
}

// ClearMetrics clears the "metrics" edge to the Metrics entity.
func (m *MemoryMetricsMutation) ClearMetrics() {
	m.clearedmetrics = true
}

// MetricsCleared reports if the "metrics" edge to the Metrics entity was cleared.
func (m *MemoryMetricsMutation) MetricsCleared() bool {
	return m.clearedmetrics
}

// MetricsID returns the "metrics" edge ID in the mutation.
func (m *MemoryMetricsMutation) MetricsID() (id int64, exists bool) {
	if m.metrics != nil {
		return *m.metrics, true
	}
	return
}

// MetricsIDs returns the "metrics" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MetricsID instead. It exists only for internal usage by the builders.
func (m *MemoryMetricsMutation) MetricsIDs() (ids []int64) {
	if id := m.metrics; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMetrics resets all changes to the "metrics" edge.
func (m *MemoryMetricsMutation) ResetMetrics() {
	m.metrics = nil
	m.clearedmetrics = false
}

// AddGarbageMetricIDs adds the "garbage_metrics" edge to the GarbageMetrics entity by ids.
func (m *MemoryMetricsMutation) AddGarbageMetricIDs(ids ...int64) {
	if m.garbage_metrics == nil {
		m.garbage_metrics = make(map[int64]struct{})
	}
	for i := range ids {
		m.garbage_metrics[ids[i]] = struct{}{}
	}
}

// ClearGarbageMetrics clears the "garbage_metrics" edge to the GarbageMetrics entity.
func (m *MemoryMetricsMutation) ClearGarbageMetrics() {
	m.clearedgarbage_metrics = true
}

// GarbageMetricsCleared reports if the "garbage_metrics" edge to the GarbageMetrics entity was cleared.
func (m *MemoryMetricsMutation) GarbageMetricsCleared() bool {
	return m.clearedgarbage_metrics
}

// RemoveGarbageMetricIDs removes the "garbage_metrics" edge to the GarbageMetrics entity by IDs.
func (m *MemoryMetricsMutation) RemoveGarbageMetricIDs(ids ...int64) {
	if m.removedgarbage_metrics == nil {
		m.removedgarbage_metrics = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.garbage_metrics, ids[i])
		m.removedgarbage_metrics[ids[i]] = struct{}{}
	}
}

// RemovedGarbageMetrics returns the removed IDs of the "garbage_metrics" edge to the GarbageMetrics entity.
func (m *MemoryMetricsMutation) RemovedGarbageMetricsIDs() (ids []int64) {
	for id := range m.removedgarbage_metrics {
		ids = append(ids, id)
	}
	return
}

// GarbageMetricsIDs returns the "garbage_metrics" edge IDs in the mutation.
func (m *MemoryMetricsMutation) GarbageMetricsIDs() (ids []int64) {
	for id := range m.garbage_metrics {
		ids = append(ids, id)
	}
	return
}

// ResetGarbageMetrics resets all changes to the "garbage_metrics" edge.
func (m *MemoryMetricsMutation) ResetGarbageMetrics() {
	m.garbage_metrics = nil
	m.clearedgarbage_metrics = false
	m.removedgarbage_metrics = nil
}

// Where appends a list predicates to the MemoryMetricsMutation builder.
func (m *MemoryMetricsMutation) Where(ps ...predicate.MemoryMetrics) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MemoryMetricsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MemoryMetricsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MemoryMetrics, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MemoryMetricsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MemoryMetricsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MemoryMetrics).
func (m *MemoryMetricsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MemoryMetricsMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.peak_post_gc_heap_size != nil {
		fields = append(fields, memorymetrics.FieldPeakPostGcHeapSize)
	}
	if m.used_heap_size_post_build != nil {
		fields = append(fields, memorymetrics.FieldUsedHeapSizePostBuild)
	}
	if m.peak_post_gc_tenured_space_heap_size != nil {
		fields = append(fields, memorymetrics.FieldPeakPostGcTenuredSpaceHeapSize)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MemoryMetricsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case memorymetrics.FieldPeakPostGcHeapSize:
		return m.PeakPostGcHeapSize()
	case memorymetrics.FieldUsedHeapSizePostBuild:
		return m.UsedHeapSizePostBuild()
	case memorymetrics.FieldPeakPostGcTenuredSpaceHeapSize:
		return m.PeakPostGcTenuredSpaceHeapSize()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MemoryMetricsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case memorymetrics.FieldPeakPostGcHeapSize:
		return m.OldPeakPostGcHeapSize(ctx)
	case memorymetrics.FieldUsedHeapSizePostBuild:
		return m.OldUsedHeapSizePostBuild(ctx)
	case memorymetrics.FieldPeakPostGcTenuredSpaceHeapSize:
		return m.OldPeakPostGcTenuredSpaceHeapSize(ctx)
	}
	return nil, fmt.Errorf("unknown MemoryMetrics field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemoryMetricsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case memorymetrics.FieldPeakPostGcHeapSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPeakPostGcHeapSize(v)
		return nil
	case memorymetrics.FieldUsedHeapSizePostBuild:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsedHeapSizePostBuild(v)
		return nil
	case memorymetrics.FieldPeakPostGcTenuredSpaceHeapSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPeakPostGcTenuredSpaceHeapSize(v)
		return nil
	}
	return fmt.Errorf("unknown MemoryMetrics field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MemoryMetricsMutation) AddedFields() []string {
	var fields []string
	if m.addpeak_post_gc_heap_size != nil {
		fields = append(fields, memorymetrics.FieldPeakPostGcHeapSize)
	}
	if m.addused_heap_size_post_build != nil {
		fields = append(fields, memorymetrics.FieldUsedHeapSizePostBuild)
	}
	if m.addpeak_post_gc_tenured_space_heap_size != nil {
		fields = append(fields, memorymetrics.FieldPeakPostGcTenuredSpaceHeapSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MemoryMetricsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case memorymetrics.FieldPeakPostGcHeapSize:
		return m.AddedPeakPostGcHeapSize()
	case memorymetrics.FieldUsedHeapSizePostBuild:
		return m.AddedUsedHeapSizePostBuild()
	case memorymetrics.FieldPeakPostGcTenuredSpaceHeapSize:
		return m.AddedPeakPostGcTenuredSpaceHeapSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemoryMetricsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case memorymetrics.FieldPeakPostGcHeapSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPeakPostGcHeapSize(v)
		return nil
	case memorymetrics.FieldUsedHeapSizePostBuild:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUsedHeapSizePostBuild(v)
		return nil
	case memorymetrics.FieldPeakPostGcTenuredSpaceHeapSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPeakPostGcTenuredSpaceHeapSize(v)
		return nil
	}
	return fmt.Errorf("unknown MemoryMetrics numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MemoryMetricsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(memorymetrics.FieldPeakPostGcHeapSize) {
		fields = append(fields, memorymetrics.FieldPeakPostGcHeapSize)
	}
	if m.FieldCleared(memorymetrics.FieldUsedHeapSizePostBuild) {
		fields = append(fields, memorymetrics.FieldUsedHeapSizePostBuild)
	}
	if m.FieldCleared(memorymetrics.FieldPeakPostGcTenuredSpaceHeapSize) {
		fields = append(fields, memorymetrics.FieldPeakPostGcTenuredSpaceHeapSize)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MemoryMetricsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MemoryMetricsMutation) ClearField(name string) error {
	switch name {
	case memorymetrics.FieldPeakPostGcHeapSize:
		m.ClearPeakPostGcHeapSize()
		return nil
	case memorymetrics.FieldUsedHeapSizePostBuild:
		m.ClearUsedHeapSizePostBuild()
		return nil
	case memorymetrics.FieldPeakPostGcTenuredSpaceHeapSize:
		m.ClearPeakPostGcTenuredSpaceHeapSize()
		return nil
	}
	return fmt.Errorf("unknown MemoryMetrics nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MemoryMetricsMutation) ResetField(name string) error {
	switch name {
	case memorymetrics.FieldPeakPostGcHeapSize:
		m.ResetPeakPostGcHeapSize()
		return nil
	case memorymetrics.FieldUsedHeapSizePostBuild:
		m.ResetUsedHeapSizePostBuild()
		return nil
	case memorymetrics.FieldPeakPostGcTenuredSpaceHeapSize:
		m.ResetPeakPostGcTenuredSpaceHeapSize()
		return nil
	}
	return fmt.Errorf("unknown MemoryMetrics field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MemoryMetricsMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.metrics != nil {
		edges = append(edges, memorymetrics.EdgeMetrics)
	}
	if m.garbage_metrics != nil {
		edges = append(edges, memorymetrics.EdgeGarbageMetrics)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MemoryMetricsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case memorymetrics.EdgeMetrics:
		if id := m.metrics; id != nil {
			return []ent.Value{*id}
		}
	case memorymetrics.EdgeGarbageMetrics:
		ids := make([]ent.Value, 0, len(m.garbage_metrics))
		for id := range m.garbage_metrics {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MemoryMetricsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedgarbage_metrics != nil {
		edges = append(edges, memorymetrics.EdgeGarbageMetrics)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MemoryMetricsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case memorymetrics.EdgeGarbageMetrics:
		ids := make([]ent.Value, 0, len(m.removedgarbage_metrics))
		for id := range m.removedgarbage_metrics {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MemoryMetricsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmetrics {
		edges = append(edges, memorymetrics.EdgeMetrics)
	}
	if m.clearedgarbage_metrics {
		edges = append(edges, memorymetrics.EdgeGarbageMetrics)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MemoryMetricsMutation) EdgeCleared(name string) bool {
	switch name {
	case memorymetrics.EdgeMetrics:
		return m.clearedmetrics
	case memorymetrics.EdgeGarbageMetrics:
		return m.clearedgarbage_metrics
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MemoryMetricsMutation) ClearEdge(name string) error {
	switch name {
	case memorymetrics.EdgeMetrics:
		m.ClearMetrics()
		return nil
	}
	return fmt.Errorf("unknown MemoryMetrics unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MemoryMetricsMutation) ResetEdge(name string) error {
	switch name {
	case memorymetrics.EdgeMetrics:
		m.ResetMetrics()
		return nil
	case memorymetrics.EdgeGarbageMetrics:
		m.ResetGarbageMetrics()
		return nil
	}
	return fmt.Errorf("unknown MemoryMetrics edge %s", name)
}

// MetricsMutation represents an operation that mutates the Metrics nodes in the graph.
type MetricsMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int64
	clearedFields              map[string]struct{}
	bazel_invocation           *int64
	clearedbazel_invocation    bool
	action_summary             *int64
	clearedaction_summary      bool
	memory_metrics             *int64
	clearedmemory_metrics      bool
	target_metrics             *int64
	clearedtarget_metrics      bool
	package_metrics            *int64
	clearedpackage_metrics     bool
	timing_metrics             *int64
	clearedtiming_metrics      bool
	cumulative_metrics         *int64
	clearedcumulative_metrics  bool
	artifact_metrics           *int64
	clearedartifact_metrics    bool
	network_metrics            *int64
	clearednetwork_metrics     bool
	build_graph_metrics        *int64
	clearedbuild_graph_metrics bool
	done                       bool
	oldValue                   func(context.Context) (*Metrics, error)
	predicates                 []predicate.Metrics
}

var _ ent.Mutation = (*MetricsMutation)(nil)

// metricsOption allows management of the mutation configuration using functional options.
type metricsOption func(*MetricsMutation)

// newMetricsMutation creates new mutation for the Metrics entity.
func newMetricsMutation(c config, op Op, opts ...metricsOption) *MetricsMutation {
	m := &MetricsMutation{
		config:        c,
		op:            op,
		typ:           TypeMetrics,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMetricsID sets the ID field of the mutation.
func withMetricsID(id int64) metricsOption {
	return func(m *MetricsMutation) {
		var (
			err   error
			once  sync.Once
			value *Metrics
		)
		m.oldValue = func(ctx context.Context) (*Metrics, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Metrics.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMetrics sets the old Metrics of the mutation.
func withMetrics(node *Metrics) metricsOption {
	return func(m *MetricsMutation) {
		m.oldValue = func(context.Context) (*Metrics, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MetricsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MetricsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Metrics entities.
func (m *MetricsMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MetricsMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MetricsMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Metrics.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBazelInvocationID sets the "bazel_invocation" edge to the BazelInvocation entity by id.
func (m *MetricsMutation) SetBazelInvocationID(id int64) {
	m.bazel_invocation = &id
}

// ClearBazelInvocation clears the "bazel_invocation" edge to the BazelInvocation entity.
func (m *MetricsMutation) ClearBazelInvocation() {
	m.clearedbazel_invocation = true
}

// BazelInvocationCleared reports if the "bazel_invocation" edge to the BazelInvocation entity was cleared.
func (m *MetricsMutation) BazelInvocationCleared() bool {
	return m.clearedbazel_invocation
}

// BazelInvocationID returns the "bazel_invocation" edge ID in the mutation.
func (m *MetricsMutation) BazelInvocationID() (id int64, exists bool) {
	if m.bazel_invocation != nil {
		return *m.bazel_invocation, true
	}
	return
}

// BazelInvocationIDs returns the "bazel_invocation" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BazelInvocationID instead. It exists only for internal usage by the builders.
func (m *MetricsMutation) BazelInvocationIDs() (ids []int64) {
	if id := m.bazel_invocation; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBazelInvocation resets all changes to the "bazel_invocation" edge.
func (m *MetricsMutation) ResetBazelInvocation() {
	m.bazel_invocation = nil
	m.clearedbazel_invocation = false
}

// SetActionSummaryID sets the "action_summary" edge to the ActionSummary entity by id.
func (m *MetricsMutation) SetActionSummaryID(id int64) {
	m.action_summary = &id
}

// ClearActionSummary clears the "action_summary" edge to the ActionSummary entity.
func (m *MetricsMutation) ClearActionSummary() {
	m.clearedaction_summary = true
}

// ActionSummaryCleared reports if the "action_summary" edge to the ActionSummary entity was cleared.
func (m *MetricsMutation) ActionSummaryCleared() bool {
	return m.clearedaction_summary
}

// ActionSummaryID returns the "action_summary" edge ID in the mutation.
func (m *MetricsMutation) ActionSummaryID() (id int64, exists bool) {
	if m.action_summary != nil {
		return *m.action_summary, true
	}
	return
}

// ActionSummaryIDs returns the "action_summary" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ActionSummaryID instead. It exists only for internal usage by the builders.
func (m *MetricsMutation) ActionSummaryIDs() (ids []int64) {
	if id := m.action_summary; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetActionSummary resets all changes to the "action_summary" edge.
func (m *MetricsMutation) ResetActionSummary() {
	m.action_summary = nil
	m.clearedaction_summary = false
}

// SetMemoryMetricsID sets the "memory_metrics" edge to the MemoryMetrics entity by id.
func (m *MetricsMutation) SetMemoryMetricsID(id int64) {
	m.memory_metrics = &id
}

// ClearMemoryMetrics clears the "memory_metrics" edge to the MemoryMetrics entity.
func (m *MetricsMutation) ClearMemoryMetrics() {
	m.clearedmemory_metrics = true
}

// MemoryMetricsCleared reports if the "memory_metrics" edge to the MemoryMetrics entity was cleared.
func (m *MetricsMutation) MemoryMetricsCleared() bool {
	return m.clearedmemory_metrics
}

// MemoryMetricsID returns the "memory_metrics" edge ID in the mutation.
func (m *MetricsMutation) MemoryMetricsID() (id int64, exists bool) {
	if m.memory_metrics != nil {
		return *m.memory_metrics, true
	}
	return
}

// MemoryMetricsIDs returns the "memory_metrics" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MemoryMetricsID instead. It exists only for internal usage by the builders.
func (m *MetricsMutation) MemoryMetricsIDs() (ids []int64) {
	if id := m.memory_metrics; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMemoryMetrics resets all changes to the "memory_metrics" edge.
func (m *MetricsMutation) ResetMemoryMetrics() {
	m.memory_metrics = nil
	m.clearedmemory_metrics = false
}

// SetTargetMetricsID sets the "target_metrics" edge to the TargetMetrics entity by id.
func (m *MetricsMutation) SetTargetMetricsID(id int64) {
	m.target_metrics = &id
}

// ClearTargetMetrics clears the "target_metrics" edge to the TargetMetrics entity.
func (m *MetricsMutation) ClearTargetMetrics() {
	m.clearedtarget_metrics = true
}

// TargetMetricsCleared reports if the "target_metrics" edge to the TargetMetrics entity was cleared.
func (m *MetricsMutation) TargetMetricsCleared() bool {
	return m.clearedtarget_metrics
}

// TargetMetricsID returns the "target_metrics" edge ID in the mutation.
func (m *MetricsMutation) TargetMetricsID() (id int64, exists bool) {
	if m.target_metrics != nil {
		return *m.target_metrics, true
	}
	return
}

// TargetMetricsIDs returns the "target_metrics" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TargetMetricsID instead. It exists only for internal usage by the builders.
func (m *MetricsMutation) TargetMetricsIDs() (ids []int64) {
	if id := m.target_metrics; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTargetMetrics resets all changes to the "target_metrics" edge.
func (m *MetricsMutation) ResetTargetMetrics() {
	m.target_metrics = nil
	m.clearedtarget_metrics = false
}

// SetPackageMetricsID sets the "package_metrics" edge to the PackageMetrics entity by id.
func (m *MetricsMutation) SetPackageMetricsID(id int64) {
	m.package_metrics = &id
}

// ClearPackageMetrics clears the "package_metrics" edge to the PackageMetrics entity.
func (m *MetricsMutation) ClearPackageMetrics() {
	m.clearedpackage_metrics = true
}

// PackageMetricsCleared reports if the "package_metrics" edge to the PackageMetrics entity was cleared.
func (m *MetricsMutation) PackageMetricsCleared() bool {
	return m.clearedpackage_metrics
}

// PackageMetricsID returns the "package_metrics" edge ID in the mutation.
func (m *MetricsMutation) PackageMetricsID() (id int64, exists bool) {
	if m.package_metrics != nil {
		return *m.package_metrics, true
	}
	return
}

// PackageMetricsIDs returns the "package_metrics" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PackageMetricsID instead. It exists only for internal usage by the builders.
func (m *MetricsMutation) PackageMetricsIDs() (ids []int64) {
	if id := m.package_metrics; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPackageMetrics resets all changes to the "package_metrics" edge.
func (m *MetricsMutation) ResetPackageMetrics() {
	m.package_metrics = nil
	m.clearedpackage_metrics = false
}

// SetTimingMetricsID sets the "timing_metrics" edge to the TimingMetrics entity by id.
func (m *MetricsMutation) SetTimingMetricsID(id int64) {
	m.timing_metrics = &id
}

// ClearTimingMetrics clears the "timing_metrics" edge to the TimingMetrics entity.
func (m *MetricsMutation) ClearTimingMetrics() {
	m.clearedtiming_metrics = true
}

// TimingMetricsCleared reports if the "timing_metrics" edge to the TimingMetrics entity was cleared.
func (m *MetricsMutation) TimingMetricsCleared() bool {
	return m.clearedtiming_metrics
}

// TimingMetricsID returns the "timing_metrics" edge ID in the mutation.
func (m *MetricsMutation) TimingMetricsID() (id int64, exists bool) {
	if m.timing_metrics != nil {
		return *m.timing_metrics, true
	}
	return
}

// TimingMetricsIDs returns the "timing_metrics" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TimingMetricsID instead. It exists only for internal usage by the builders.
func (m *MetricsMutation) TimingMetricsIDs() (ids []int64) {
	if id := m.timing_metrics; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTimingMetrics resets all changes to the "timing_metrics" edge.
func (m *MetricsMutation) ResetTimingMetrics() {
	m.timing_metrics = nil
	m.clearedtiming_metrics = false
}

// SetCumulativeMetricsID sets the "cumulative_metrics" edge to the CumulativeMetrics entity by id.
func (m *MetricsMutation) SetCumulativeMetricsID(id int64) {
	m.cumulative_metrics = &id
}

// ClearCumulativeMetrics clears the "cumulative_metrics" edge to the CumulativeMetrics entity.
func (m *MetricsMutation) ClearCumulativeMetrics() {
	m.clearedcumulative_metrics = true
}

// CumulativeMetricsCleared reports if the "cumulative_metrics" edge to the CumulativeMetrics entity was cleared.
func (m *MetricsMutation) CumulativeMetricsCleared() bool {
	return m.clearedcumulative_metrics
}

// CumulativeMetricsID returns the "cumulative_metrics" edge ID in the mutation.
func (m *MetricsMutation) CumulativeMetricsID() (id int64, exists bool) {
	if m.cumulative_metrics != nil {
		return *m.cumulative_metrics, true
	}
	return
}

// CumulativeMetricsIDs returns the "cumulative_metrics" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CumulativeMetricsID instead. It exists only for internal usage by the builders.
func (m *MetricsMutation) CumulativeMetricsIDs() (ids []int64) {
	if id := m.cumulative_metrics; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCumulativeMetrics resets all changes to the "cumulative_metrics" edge.
func (m *MetricsMutation) ResetCumulativeMetrics() {
	m.cumulative_metrics = nil
	m.clearedcumulative_metrics = false
}

// SetArtifactMetricsID sets the "artifact_metrics" edge to the ArtifactMetrics entity by id.
func (m *MetricsMutation) SetArtifactMetricsID(id int64) {
	m.artifact_metrics = &id
}

// ClearArtifactMetrics clears the "artifact_metrics" edge to the ArtifactMetrics entity.
func (m *MetricsMutation) ClearArtifactMetrics() {
	m.clearedartifact_metrics = true
}

// ArtifactMetricsCleared reports if the "artifact_metrics" edge to the ArtifactMetrics entity was cleared.
func (m *MetricsMutation) ArtifactMetricsCleared() bool {
	return m.clearedartifact_metrics
}

// ArtifactMetricsID returns the "artifact_metrics" edge ID in the mutation.
func (m *MetricsMutation) ArtifactMetricsID() (id int64, exists bool) {
	if m.artifact_metrics != nil {
		return *m.artifact_metrics, true
	}
	return
}

// ArtifactMetricsIDs returns the "artifact_metrics" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ArtifactMetricsID instead. It exists only for internal usage by the builders.
func (m *MetricsMutation) ArtifactMetricsIDs() (ids []int64) {
	if id := m.artifact_metrics; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetArtifactMetrics resets all changes to the "artifact_metrics" edge.
func (m *MetricsMutation) ResetArtifactMetrics() {
	m.artifact_metrics = nil
	m.clearedartifact_metrics = false
}

// SetNetworkMetricsID sets the "network_metrics" edge to the NetworkMetrics entity by id.
func (m *MetricsMutation) SetNetworkMetricsID(id int64) {
	m.network_metrics = &id
}

// ClearNetworkMetrics clears the "network_metrics" edge to the NetworkMetrics entity.
func (m *MetricsMutation) ClearNetworkMetrics() {
	m.clearednetwork_metrics = true
}

// NetworkMetricsCleared reports if the "network_metrics" edge to the NetworkMetrics entity was cleared.
func (m *MetricsMutation) NetworkMetricsCleared() bool {
	return m.clearednetwork_metrics
}

// NetworkMetricsID returns the "network_metrics" edge ID in the mutation.
func (m *MetricsMutation) NetworkMetricsID() (id int64, exists bool) {
	if m.network_metrics != nil {
		return *m.network_metrics, true
	}
	return
}

// NetworkMetricsIDs returns the "network_metrics" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NetworkMetricsID instead. It exists only for internal usage by the builders.
func (m *MetricsMutation) NetworkMetricsIDs() (ids []int64) {
	if id := m.network_metrics; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNetworkMetrics resets all changes to the "network_metrics" edge.
func (m *MetricsMutation) ResetNetworkMetrics() {
	m.network_metrics = nil
	m.clearednetwork_metrics = false
}

// SetBuildGraphMetricsID sets the "build_graph_metrics" edge to the BuildGraphMetrics entity by id.
func (m *MetricsMutation) SetBuildGraphMetricsID(id int64) {
	m.build_graph_metrics = &id
}

// ClearBuildGraphMetrics clears the "build_graph_metrics" edge to the BuildGraphMetrics entity.
func (m *MetricsMutation) ClearBuildGraphMetrics() {
	m.clearedbuild_graph_metrics = true
}

// BuildGraphMetricsCleared reports if the "build_graph_metrics" edge to the BuildGraphMetrics entity was cleared.
func (m *MetricsMutation) BuildGraphMetricsCleared() bool {
	return m.clearedbuild_graph_metrics
}

// BuildGraphMetricsID returns the "build_graph_metrics" edge ID in the mutation.
func (m *MetricsMutation) BuildGraphMetricsID() (id int64, exists bool) {
	if m.build_graph_metrics != nil {
		return *m.build_graph_metrics, true
	}
	return
}

// BuildGraphMetricsIDs returns the "build_graph_metrics" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BuildGraphMetricsID instead. It exists only for internal usage by the builders.
func (m *MetricsMutation) BuildGraphMetricsIDs() (ids []int64) {
	if id := m.build_graph_metrics; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBuildGraphMetrics resets all changes to the "build_graph_metrics" edge.
func (m *MetricsMutation) ResetBuildGraphMetrics() {
	m.build_graph_metrics = nil
	m.clearedbuild_graph_metrics = false
}

// Where appends a list predicates to the MetricsMutation builder.
func (m *MetricsMutation) Where(ps ...predicate.Metrics) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MetricsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MetricsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Metrics, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MetricsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MetricsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Metrics).
func (m *MetricsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MetricsMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MetricsMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MetricsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Metrics field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MetricsMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Metrics field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MetricsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MetricsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MetricsMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Metrics numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MetricsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MetricsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MetricsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Metrics nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MetricsMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Metrics field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MetricsMutation) AddedEdges() []string {
	edges := make([]string, 0, 10)
	if m.bazel_invocation != nil {
		edges = append(edges, metrics.EdgeBazelInvocation)
	}
	if m.action_summary != nil {
		edges = append(edges, metrics.EdgeActionSummary)
	}
	if m.memory_metrics != nil {
		edges = append(edges, metrics.EdgeMemoryMetrics)
	}
	if m.target_metrics != nil {
		edges = append(edges, metrics.EdgeTargetMetrics)
	}
	if m.package_metrics != nil {
		edges = append(edges, metrics.EdgePackageMetrics)
	}
	if m.timing_metrics != nil {
		edges = append(edges, metrics.EdgeTimingMetrics)
	}
	if m.cumulative_metrics != nil {
		edges = append(edges, metrics.EdgeCumulativeMetrics)
	}
	if m.artifact_metrics != nil {
		edges = append(edges, metrics.EdgeArtifactMetrics)
	}
	if m.network_metrics != nil {
		edges = append(edges, metrics.EdgeNetworkMetrics)
	}
	if m.build_graph_metrics != nil {
		edges = append(edges, metrics.EdgeBuildGraphMetrics)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MetricsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case metrics.EdgeBazelInvocation:
		if id := m.bazel_invocation; id != nil {
			return []ent.Value{*id}
		}
	case metrics.EdgeActionSummary:
		if id := m.action_summary; id != nil {
			return []ent.Value{*id}
		}
	case metrics.EdgeMemoryMetrics:
		if id := m.memory_metrics; id != nil {
			return []ent.Value{*id}
		}
	case metrics.EdgeTargetMetrics:
		if id := m.target_metrics; id != nil {
			return []ent.Value{*id}
		}
	case metrics.EdgePackageMetrics:
		if id := m.package_metrics; id != nil {
			return []ent.Value{*id}
		}
	case metrics.EdgeTimingMetrics:
		if id := m.timing_metrics; id != nil {
			return []ent.Value{*id}
		}
	case metrics.EdgeCumulativeMetrics:
		if id := m.cumulative_metrics; id != nil {
			return []ent.Value{*id}
		}
	case metrics.EdgeArtifactMetrics:
		if id := m.artifact_metrics; id != nil {
			return []ent.Value{*id}
		}
	case metrics.EdgeNetworkMetrics:
		if id := m.network_metrics; id != nil {
			return []ent.Value{*id}
		}
	case metrics.EdgeBuildGraphMetrics:
		if id := m.build_graph_metrics; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MetricsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 10)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MetricsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MetricsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 10)
	if m.clearedbazel_invocation {
		edges = append(edges, metrics.EdgeBazelInvocation)
	}
	if m.clearedaction_summary {
		edges = append(edges, metrics.EdgeActionSummary)
	}
	if m.clearedmemory_metrics {
		edges = append(edges, metrics.EdgeMemoryMetrics)
	}
	if m.clearedtarget_metrics {
		edges = append(edges, metrics.EdgeTargetMetrics)
	}
	if m.clearedpackage_metrics {
		edges = append(edges, metrics.EdgePackageMetrics)
	}
	if m.clearedtiming_metrics {
		edges = append(edges, metrics.EdgeTimingMetrics)
	}
	if m.clearedcumulative_metrics {
		edges = append(edges, metrics.EdgeCumulativeMetrics)
	}
	if m.clearedartifact_metrics {
		edges = append(edges, metrics.EdgeArtifactMetrics)
	}
	if m.clearednetwork_metrics {
		edges = append(edges, metrics.EdgeNetworkMetrics)
	}
	if m.clearedbuild_graph_metrics {
		edges = append(edges, metrics.EdgeBuildGraphMetrics)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MetricsMutation) EdgeCleared(name string) bool {
	switch name {
	case metrics.EdgeBazelInvocation:
		return m.clearedbazel_invocation
	case metrics.EdgeActionSummary:
		return m.clearedaction_summary
	case metrics.EdgeMemoryMetrics:
		return m.clearedmemory_metrics
	case metrics.EdgeTargetMetrics:
		return m.clearedtarget_metrics
	case metrics.EdgePackageMetrics:
		return m.clearedpackage_metrics
	case metrics.EdgeTimingMetrics:
		return m.clearedtiming_metrics
	case metrics.EdgeCumulativeMetrics:
		return m.clearedcumulative_metrics
	case metrics.EdgeArtifactMetrics:
		return m.clearedartifact_metrics
	case metrics.EdgeNetworkMetrics:
		return m.clearednetwork_metrics
	case metrics.EdgeBuildGraphMetrics:
		return m.clearedbuild_graph_metrics
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MetricsMutation) ClearEdge(name string) error {
	switch name {
	case metrics.EdgeBazelInvocation:
		m.ClearBazelInvocation()
		return nil
	case metrics.EdgeActionSummary:
		m.ClearActionSummary()
		return nil
	case metrics.EdgeMemoryMetrics:
		m.ClearMemoryMetrics()
		return nil
	case metrics.EdgeTargetMetrics:
		m.ClearTargetMetrics()
		return nil
	case metrics.EdgePackageMetrics:
		m.ClearPackageMetrics()
		return nil
	case metrics.EdgeTimingMetrics:
		m.ClearTimingMetrics()
		return nil
	case metrics.EdgeCumulativeMetrics:
		m.ClearCumulativeMetrics()
		return nil
	case metrics.EdgeArtifactMetrics:
		m.ClearArtifactMetrics()
		return nil
	case metrics.EdgeNetworkMetrics:
		m.ClearNetworkMetrics()
		return nil
	case metrics.EdgeBuildGraphMetrics:
		m.ClearBuildGraphMetrics()
		return nil
	}
	return fmt.Errorf("unknown Metrics unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MetricsMutation) ResetEdge(name string) error {
	switch name {
	case metrics.EdgeBazelInvocation:
		m.ResetBazelInvocation()
		return nil
	case metrics.EdgeActionSummary:
		m.ResetActionSummary()
		return nil
	case metrics.EdgeMemoryMetrics:
		m.ResetMemoryMetrics()
		return nil
	case metrics.EdgeTargetMetrics:
		m.ResetTargetMetrics()
		return nil
	case metrics.EdgePackageMetrics:
		m.ResetPackageMetrics()
		return nil
	case metrics.EdgeTimingMetrics:
		m.ResetTimingMetrics()
		return nil
	case metrics.EdgeCumulativeMetrics:
		m.ResetCumulativeMetrics()
		return nil
	case metrics.EdgeArtifactMetrics:
		m.ResetArtifactMetrics()
		return nil
	case metrics.EdgeNetworkMetrics:
		m.ResetNetworkMetrics()
		return nil
	case metrics.EdgeBuildGraphMetrics:
		m.ResetBuildGraphMetrics()
		return nil
	}
	return fmt.Errorf("unknown Metrics edge %s", name)
}

// MissDetailMutation represents an operation that mutates the MissDetail nodes in the graph.
type MissDetailMutation struct {
	config
	op                             Op
	typ                            string
	id                             *int64
	reason                         *string
	count                          *int32
	addcount                       *int32
	clearedFields                  map[string]struct{}
	action_cache_statistics        *int64
	clearedaction_cache_statistics bool
	done                           bool
	oldValue                       func(context.Context) (*MissDetail, error)
	predicates                     []predicate.MissDetail
}

var _ ent.Mutation = (*MissDetailMutation)(nil)

// missdetailOption allows management of the mutation configuration using functional options.
type missdetailOption func(*MissDetailMutation)

// newMissDetailMutation creates new mutation for the MissDetail entity.
func newMissDetailMutation(c config, op Op, opts ...missdetailOption) *MissDetailMutation {
	m := &MissDetailMutation{
		config:        c,
		op:            op,
		typ:           TypeMissDetail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMissDetailID sets the ID field of the mutation.
func withMissDetailID(id int64) missdetailOption {
	return func(m *MissDetailMutation) {
		var (
			err   error
			once  sync.Once
			value *MissDetail
		)
		m.oldValue = func(ctx context.Context) (*MissDetail, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MissDetail.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMissDetail sets the old MissDetail of the mutation.
func withMissDetail(node *MissDetail) missdetailOption {
	return func(m *MissDetailMutation) {
		m.oldValue = func(context.Context) (*MissDetail, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MissDetailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MissDetailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MissDetail entities.
func (m *MissDetailMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MissDetailMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MissDetailMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MissDetail.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetReason sets the "reason" field.
func (m *MissDetailMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *MissDetailMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the MissDetail entity.
// If the MissDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissDetailMutation) OldReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ResetReason resets all changes to the "reason" field.
func (m *MissDetailMutation) ResetReason() {
	m.reason = nil
}

// SetCount sets the "count" field.
func (m *MissDetailMutation) SetCount(i int32) {
	m.count = &i
	m.addcount = nil
}

// Count returns the value of the "count" field in the mutation.
func (m *MissDetailMutation) Count() (r int32, exists bool) {
	v := m.count
	if v == nil {
		return
	}
	return *v, true
}

// OldCount returns the old "count" field's value of the MissDetail entity.
// If the MissDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MissDetailMutation) OldCount(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCount: %w", err)
	}
	return oldValue.Count, nil
}

// AddCount adds i to the "count" field.
func (m *MissDetailMutation) AddCount(i int32) {
	if m.addcount != nil {
		*m.addcount += i
	} else {
		m.addcount = &i
	}
}

// AddedCount returns the value that was added to the "count" field in this mutation.
func (m *MissDetailMutation) AddedCount() (r int32, exists bool) {
	v := m.addcount
	if v == nil {
		return
	}
	return *v, true
}

// ClearCount clears the value of the "count" field.
func (m *MissDetailMutation) ClearCount() {
	m.count = nil
	m.addcount = nil
	m.clearedFields[missdetail.FieldCount] = struct{}{}
}

// CountCleared returns if the "count" field was cleared in this mutation.
func (m *MissDetailMutation) CountCleared() bool {
	_, ok := m.clearedFields[missdetail.FieldCount]
	return ok
}

// ResetCount resets all changes to the "count" field.
func (m *MissDetailMutation) ResetCount() {
	m.count = nil
	m.addcount = nil
	delete(m.clearedFields, missdetail.FieldCount)
}

// SetActionCacheStatisticsID sets the "action_cache_statistics" edge to the ActionCacheStatistics entity by id.
func (m *MissDetailMutation) SetActionCacheStatisticsID(id int64) {
	m.action_cache_statistics = &id
}

// ClearActionCacheStatistics clears the "action_cache_statistics" edge to the ActionCacheStatistics entity.
func (m *MissDetailMutation) ClearActionCacheStatistics() {
	m.clearedaction_cache_statistics = true
}

// ActionCacheStatisticsCleared reports if the "action_cache_statistics" edge to the ActionCacheStatistics entity was cleared.
func (m *MissDetailMutation) ActionCacheStatisticsCleared() bool {
	return m.clearedaction_cache_statistics
}

// ActionCacheStatisticsID returns the "action_cache_statistics" edge ID in the mutation.
func (m *MissDetailMutation) ActionCacheStatisticsID() (id int64, exists bool) {
	if m.action_cache_statistics != nil {
		return *m.action_cache_statistics, true
	}
	return
}

// ActionCacheStatisticsIDs returns the "action_cache_statistics" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ActionCacheStatisticsID instead. It exists only for internal usage by the builders.
func (m *MissDetailMutation) ActionCacheStatisticsIDs() (ids []int64) {
	if id := m.action_cache_statistics; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetActionCacheStatistics resets all changes to the "action_cache_statistics" edge.
func (m *MissDetailMutation) ResetActionCacheStatistics() {
	m.action_cache_statistics = nil
	m.clearedaction_cache_statistics = false
}

// Where appends a list predicates to the MissDetailMutation builder.
func (m *MissDetailMutation) Where(ps ...predicate.MissDetail) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MissDetailMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MissDetailMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MissDetail, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MissDetailMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MissDetailMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MissDetail).
func (m *MissDetailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MissDetailMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.reason != nil {
		fields = append(fields, missdetail.FieldReason)
	}
	if m.count != nil {
		fields = append(fields, missdetail.FieldCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MissDetailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case missdetail.FieldReason:
		return m.Reason()
	case missdetail.FieldCount:
		return m.Count()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MissDetailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case missdetail.FieldReason:
		return m.OldReason(ctx)
	case missdetail.FieldCount:
		return m.OldCount(ctx)
	}
	return nil, fmt.Errorf("unknown MissDetail field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MissDetailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case missdetail.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	case missdetail.FieldCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCount(v)
		return nil
	}
	return fmt.Errorf("unknown MissDetail field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MissDetailMutation) AddedFields() []string {
	var fields []string
	if m.addcount != nil {
		fields = append(fields, missdetail.FieldCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MissDetailMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case missdetail.FieldCount:
		return m.AddedCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MissDetailMutation) AddField(name string, value ent.Value) error {
	switch name {
	case missdetail.FieldCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCount(v)
		return nil
	}
	return fmt.Errorf("unknown MissDetail numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MissDetailMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(missdetail.FieldCount) {
		fields = append(fields, missdetail.FieldCount)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MissDetailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MissDetailMutation) ClearField(name string) error {
	switch name {
	case missdetail.FieldCount:
		m.ClearCount()
		return nil
	}
	return fmt.Errorf("unknown MissDetail nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MissDetailMutation) ResetField(name string) error {
	switch name {
	case missdetail.FieldReason:
		m.ResetReason()
		return nil
	case missdetail.FieldCount:
		m.ResetCount()
		return nil
	}
	return fmt.Errorf("unknown MissDetail field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MissDetailMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.action_cache_statistics != nil {
		edges = append(edges, missdetail.EdgeActionCacheStatistics)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MissDetailMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case missdetail.EdgeActionCacheStatistics:
		if id := m.action_cache_statistics; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MissDetailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MissDetailMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MissDetailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedaction_cache_statistics {
		edges = append(edges, missdetail.EdgeActionCacheStatistics)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MissDetailMutation) EdgeCleared(name string) bool {
	switch name {
	case missdetail.EdgeActionCacheStatistics:
		return m.clearedaction_cache_statistics
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MissDetailMutation) ClearEdge(name string) error {
	switch name {
	case missdetail.EdgeActionCacheStatistics:
		m.ClearActionCacheStatistics()
		return nil
	}
	return fmt.Errorf("unknown MissDetail unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MissDetailMutation) ResetEdge(name string) error {
	switch name {
	case missdetail.EdgeActionCacheStatistics:
		m.ResetActionCacheStatistics()
		return nil
	}
	return fmt.Errorf("unknown MissDetail edge %s", name)
}

// NetworkMetricsMutation represents an operation that mutates the NetworkMetrics nodes in the graph.
type NetworkMetricsMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int64
	clearedFields               map[string]struct{}
	metrics                     *int64
	clearedmetrics              bool
	system_network_stats        *int64
	clearedsystem_network_stats bool
	done                        bool
	oldValue                    func(context.Context) (*NetworkMetrics, error)
	predicates                  []predicate.NetworkMetrics
}

var _ ent.Mutation = (*NetworkMetricsMutation)(nil)

// networkmetricsOption allows management of the mutation configuration using functional options.
type networkmetricsOption func(*NetworkMetricsMutation)

// newNetworkMetricsMutation creates new mutation for the NetworkMetrics entity.
func newNetworkMetricsMutation(c config, op Op, opts ...networkmetricsOption) *NetworkMetricsMutation {
	m := &NetworkMetricsMutation{
		config:        c,
		op:            op,
		typ:           TypeNetworkMetrics,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNetworkMetricsID sets the ID field of the mutation.
func withNetworkMetricsID(id int64) networkmetricsOption {
	return func(m *NetworkMetricsMutation) {
		var (
			err   error
			once  sync.Once
			value *NetworkMetrics
		)
		m.oldValue = func(ctx context.Context) (*NetworkMetrics, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NetworkMetrics.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNetworkMetrics sets the old NetworkMetrics of the mutation.
func withNetworkMetrics(node *NetworkMetrics) networkmetricsOption {
	return func(m *NetworkMetricsMutation) {
		m.oldValue = func(context.Context) (*NetworkMetrics, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NetworkMetricsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NetworkMetricsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of NetworkMetrics entities.
func (m *NetworkMetricsMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NetworkMetricsMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NetworkMetricsMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NetworkMetrics.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetMetricsID sets the "metrics" edge to the Metrics entity by id.
func (m *NetworkMetricsMutation) SetMetricsID(id int64) {
	m.metrics = &id
}

// ClearMetrics clears the "metrics" edge to the Metrics entity.
func (m *NetworkMetricsMutation) ClearMetrics() {
	m.clearedmetrics = true
}

// MetricsCleared reports if the "metrics" edge to the Metrics entity was cleared.
func (m *NetworkMetricsMutation) MetricsCleared() bool {
	return m.clearedmetrics
}

// MetricsID returns the "metrics" edge ID in the mutation.
func (m *NetworkMetricsMutation) MetricsID() (id int64, exists bool) {
	if m.metrics != nil {
		return *m.metrics, true
	}
	return
}

// MetricsIDs returns the "metrics" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MetricsID instead. It exists only for internal usage by the builders.
func (m *NetworkMetricsMutation) MetricsIDs() (ids []int64) {
	if id := m.metrics; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMetrics resets all changes to the "metrics" edge.
func (m *NetworkMetricsMutation) ResetMetrics() {
	m.metrics = nil
	m.clearedmetrics = false
}

// SetSystemNetworkStatsID sets the "system_network_stats" edge to the SystemNetworkStats entity by id.
func (m *NetworkMetricsMutation) SetSystemNetworkStatsID(id int64) {
	m.system_network_stats = &id
}

// ClearSystemNetworkStats clears the "system_network_stats" edge to the SystemNetworkStats entity.
func (m *NetworkMetricsMutation) ClearSystemNetworkStats() {
	m.clearedsystem_network_stats = true
}

// SystemNetworkStatsCleared reports if the "system_network_stats" edge to the SystemNetworkStats entity was cleared.
func (m *NetworkMetricsMutation) SystemNetworkStatsCleared() bool {
	return m.clearedsystem_network_stats
}

// SystemNetworkStatsID returns the "system_network_stats" edge ID in the mutation.
func (m *NetworkMetricsMutation) SystemNetworkStatsID() (id int64, exists bool) {
	if m.system_network_stats != nil {
		return *m.system_network_stats, true
	}
	return
}

// SystemNetworkStatsIDs returns the "system_network_stats" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SystemNetworkStatsID instead. It exists only for internal usage by the builders.
func (m *NetworkMetricsMutation) SystemNetworkStatsIDs() (ids []int64) {
	if id := m.system_network_stats; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSystemNetworkStats resets all changes to the "system_network_stats" edge.
func (m *NetworkMetricsMutation) ResetSystemNetworkStats() {
	m.system_network_stats = nil
	m.clearedsystem_network_stats = false
}

// Where appends a list predicates to the NetworkMetricsMutation builder.
func (m *NetworkMetricsMutation) Where(ps ...predicate.NetworkMetrics) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NetworkMetricsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NetworkMetricsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NetworkMetrics, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NetworkMetricsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NetworkMetricsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NetworkMetrics).
func (m *NetworkMetricsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NetworkMetricsMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NetworkMetricsMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NetworkMetricsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown NetworkMetrics field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NetworkMetricsMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NetworkMetrics field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NetworkMetricsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NetworkMetricsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NetworkMetricsMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown NetworkMetrics numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NetworkMetricsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NetworkMetricsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NetworkMetricsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown NetworkMetrics nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NetworkMetricsMutation) ResetField(name string) error {
	return fmt.Errorf("unknown NetworkMetrics field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NetworkMetricsMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.metrics != nil {
		edges = append(edges, networkmetrics.EdgeMetrics)
	}
	if m.system_network_stats != nil {
		edges = append(edges, networkmetrics.EdgeSystemNetworkStats)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NetworkMetricsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case networkmetrics.EdgeMetrics:
		if id := m.metrics; id != nil {
			return []ent.Value{*id}
		}
	case networkmetrics.EdgeSystemNetworkStats:
		if id := m.system_network_stats; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NetworkMetricsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NetworkMetricsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NetworkMetricsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmetrics {
		edges = append(edges, networkmetrics.EdgeMetrics)
	}
	if m.clearedsystem_network_stats {
		edges = append(edges, networkmetrics.EdgeSystemNetworkStats)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NetworkMetricsMutation) EdgeCleared(name string) bool {
	switch name {
	case networkmetrics.EdgeMetrics:
		return m.clearedmetrics
	case networkmetrics.EdgeSystemNetworkStats:
		return m.clearedsystem_network_stats
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NetworkMetricsMutation) ClearEdge(name string) error {
	switch name {
	case networkmetrics.EdgeMetrics:
		m.ClearMetrics()
		return nil
	case networkmetrics.EdgeSystemNetworkStats:
		m.ClearSystemNetworkStats()
		return nil
	}
	return fmt.Errorf("unknown NetworkMetrics unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NetworkMetricsMutation) ResetEdge(name string) error {
	switch name {
	case networkmetrics.EdgeMetrics:
		m.ResetMetrics()
		return nil
	case networkmetrics.EdgeSystemNetworkStats:
		m.ResetSystemNetworkStats()
		return nil
	}
	return fmt.Errorf("unknown NetworkMetrics edge %s", name)
}

// PackageLoadMetricsMutation represents an operation that mutates the PackageLoadMetrics nodes in the graph.
type PackageLoadMetricsMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int64
	name                    *string
	load_duration           *int64
	addload_duration        *int64
	num_targets             *uint64
	addnum_targets          *int64
	computation_steps       *uint64
	addcomputation_steps    *int64
	num_transitive_loads    *uint64
	addnum_transitive_loads *int64
	package_overhead        *uint64
	addpackage_overhead     *int64
	clearedFields           map[string]struct{}
	package_metrics         *int64
	clearedpackage_metrics  bool
	done                    bool
	oldValue                func(context.Context) (*PackageLoadMetrics, error)
	predicates              []predicate.PackageLoadMetrics
}

var _ ent.Mutation = (*PackageLoadMetricsMutation)(nil)

// packageloadmetricsOption allows management of the mutation configuration using functional options.
type packageloadmetricsOption func(*PackageLoadMetricsMutation)

// newPackageLoadMetricsMutation creates new mutation for the PackageLoadMetrics entity.
func newPackageLoadMetricsMutation(c config, op Op, opts ...packageloadmetricsOption) *PackageLoadMetricsMutation {
	m := &PackageLoadMetricsMutation{
		config:        c,
		op:            op,
		typ:           TypePackageLoadMetrics,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPackageLoadMetricsID sets the ID field of the mutation.
func withPackageLoadMetricsID(id int64) packageloadmetricsOption {
	return func(m *PackageLoadMetricsMutation) {
		var (
			err   error
			once  sync.Once
			value *PackageLoadMetrics
		)
		m.oldValue = func(ctx context.Context) (*PackageLoadMetrics, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PackageLoadMetrics.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPackageLoadMetrics sets the old PackageLoadMetrics of the mutation.
func withPackageLoadMetrics(node *PackageLoadMetrics) packageloadmetricsOption {
	return func(m *PackageLoadMetricsMutation) {
		m.oldValue = func(context.Context) (*PackageLoadMetrics, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PackageLoadMetricsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PackageLoadMetricsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PackageLoadMetrics entities.
func (m *PackageLoadMetricsMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PackageLoadMetricsMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PackageLoadMetricsMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PackageLoadMetrics.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *PackageLoadMetricsMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PackageLoadMetricsMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PackageLoadMetrics entity.
// If the PackageLoadMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackageLoadMetricsMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *PackageLoadMetricsMutation) ClearName() {
	m.name = nil
	m.clearedFields[packageloadmetrics.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *PackageLoadMetricsMutation) NameCleared() bool {
	_, ok := m.clearedFields[packageloadmetrics.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *PackageLoadMetricsMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, packageloadmetrics.FieldName)
}

// SetLoadDuration sets the "load_duration" field.
func (m *PackageLoadMetricsMutation) SetLoadDuration(i int64) {
	m.load_duration = &i
	m.addload_duration = nil
}

// LoadDuration returns the value of the "load_duration" field in the mutation.
func (m *PackageLoadMetricsMutation) LoadDuration() (r int64, exists bool) {
	v := m.load_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldLoadDuration returns the old "load_duration" field's value of the PackageLoadMetrics entity.
// If the PackageLoadMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackageLoadMetricsMutation) OldLoadDuration(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLoadDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLoadDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLoadDuration: %w", err)
	}
	return oldValue.LoadDuration, nil
}

// AddLoadDuration adds i to the "load_duration" field.
func (m *PackageLoadMetricsMutation) AddLoadDuration(i int64) {
	if m.addload_duration != nil {
		*m.addload_duration += i
	} else {
		m.addload_duration = &i
	}
}

// AddedLoadDuration returns the value that was added to the "load_duration" field in this mutation.
func (m *PackageLoadMetricsMutation) AddedLoadDuration() (r int64, exists bool) {
	v := m.addload_duration
	if v == nil {
		return
	}
	return *v, true
}

// ClearLoadDuration clears the value of the "load_duration" field.
func (m *PackageLoadMetricsMutation) ClearLoadDuration() {
	m.load_duration = nil
	m.addload_duration = nil
	m.clearedFields[packageloadmetrics.FieldLoadDuration] = struct{}{}
}

// LoadDurationCleared returns if the "load_duration" field was cleared in this mutation.
func (m *PackageLoadMetricsMutation) LoadDurationCleared() bool {
	_, ok := m.clearedFields[packageloadmetrics.FieldLoadDuration]
	return ok
}

// ResetLoadDuration resets all changes to the "load_duration" field.
func (m *PackageLoadMetricsMutation) ResetLoadDuration() {
	m.load_duration = nil
	m.addload_duration = nil
	delete(m.clearedFields, packageloadmetrics.FieldLoadDuration)
}

// SetNumTargets sets the "num_targets" field.
func (m *PackageLoadMetricsMutation) SetNumTargets(u uint64) {
	m.num_targets = &u
	m.addnum_targets = nil
}

// NumTargets returns the value of the "num_targets" field in the mutation.
func (m *PackageLoadMetricsMutation) NumTargets() (r uint64, exists bool) {
	v := m.num_targets
	if v == nil {
		return
	}
	return *v, true
}

// OldNumTargets returns the old "num_targets" field's value of the PackageLoadMetrics entity.
// If the PackageLoadMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackageLoadMetricsMutation) OldNumTargets(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumTargets is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumTargets requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumTargets: %w", err)
	}
	return oldValue.NumTargets, nil
}

// AddNumTargets adds u to the "num_targets" field.
func (m *PackageLoadMetricsMutation) AddNumTargets(u int64) {
	if m.addnum_targets != nil {
		*m.addnum_targets += u
	} else {
		m.addnum_targets = &u
	}
}

// AddedNumTargets returns the value that was added to the "num_targets" field in this mutation.
func (m *PackageLoadMetricsMutation) AddedNumTargets() (r int64, exists bool) {
	v := m.addnum_targets
	if v == nil {
		return
	}
	return *v, true
}

// ClearNumTargets clears the value of the "num_targets" field.
func (m *PackageLoadMetricsMutation) ClearNumTargets() {
	m.num_targets = nil
	m.addnum_targets = nil
	m.clearedFields[packageloadmetrics.FieldNumTargets] = struct{}{}
}

// NumTargetsCleared returns if the "num_targets" field was cleared in this mutation.
func (m *PackageLoadMetricsMutation) NumTargetsCleared() bool {
	_, ok := m.clearedFields[packageloadmetrics.FieldNumTargets]
	return ok
}

// ResetNumTargets resets all changes to the "num_targets" field.
func (m *PackageLoadMetricsMutation) ResetNumTargets() {
	m.num_targets = nil
	m.addnum_targets = nil
	delete(m.clearedFields, packageloadmetrics.FieldNumTargets)
}

// SetComputationSteps sets the "computation_steps" field.
func (m *PackageLoadMetricsMutation) SetComputationSteps(u uint64) {
	m.computation_steps = &u
	m.addcomputation_steps = nil
}

// ComputationSteps returns the value of the "computation_steps" field in the mutation.
func (m *PackageLoadMetricsMutation) ComputationSteps() (r uint64, exists bool) {
	v := m.computation_steps
	if v == nil {
		return
	}
	return *v, true
}

// OldComputationSteps returns the old "computation_steps" field's value of the PackageLoadMetrics entity.
// If the PackageLoadMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackageLoadMetricsMutation) OldComputationSteps(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComputationSteps is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComputationSteps requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComputationSteps: %w", err)
	}
	return oldValue.ComputationSteps, nil
}

// AddComputationSteps adds u to the "computation_steps" field.
func (m *PackageLoadMetricsMutation) AddComputationSteps(u int64) {
	if m.addcomputation_steps != nil {
		*m.addcomputation_steps += u
	} else {
		m.addcomputation_steps = &u
	}
}

// AddedComputationSteps returns the value that was added to the "computation_steps" field in this mutation.
func (m *PackageLoadMetricsMutation) AddedComputationSteps() (r int64, exists bool) {
	v := m.addcomputation_steps
	if v == nil {
		return
	}
	return *v, true
}

// ClearComputationSteps clears the value of the "computation_steps" field.
func (m *PackageLoadMetricsMutation) ClearComputationSteps() {
	m.computation_steps = nil
	m.addcomputation_steps = nil
	m.clearedFields[packageloadmetrics.FieldComputationSteps] = struct{}{}
}

// ComputationStepsCleared returns if the "computation_steps" field was cleared in this mutation.
func (m *PackageLoadMetricsMutation) ComputationStepsCleared() bool {
	_, ok := m.clearedFields[packageloadmetrics.FieldComputationSteps]
	return ok
}

// ResetComputationSteps resets all changes to the "computation_steps" field.
func (m *PackageLoadMetricsMutation) ResetComputationSteps() {
	m.computation_steps = nil
	m.addcomputation_steps = nil
	delete(m.clearedFields, packageloadmetrics.FieldComputationSteps)
}

// SetNumTransitiveLoads sets the "num_transitive_loads" field.
func (m *PackageLoadMetricsMutation) SetNumTransitiveLoads(u uint64) {
	m.num_transitive_loads = &u
	m.addnum_transitive_loads = nil
}

// NumTransitiveLoads returns the value of the "num_transitive_loads" field in the mutation.
func (m *PackageLoadMetricsMutation) NumTransitiveLoads() (r uint64, exists bool) {
	v := m.num_transitive_loads
	if v == nil {
		return
	}
	return *v, true
}

// OldNumTransitiveLoads returns the old "num_transitive_loads" field's value of the PackageLoadMetrics entity.
// If the PackageLoadMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackageLoadMetricsMutation) OldNumTransitiveLoads(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumTransitiveLoads is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumTransitiveLoads requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumTransitiveLoads: %w", err)
	}
	return oldValue.NumTransitiveLoads, nil
}

// AddNumTransitiveLoads adds u to the "num_transitive_loads" field.
func (m *PackageLoadMetricsMutation) AddNumTransitiveLoads(u int64) {
	if m.addnum_transitive_loads != nil {
		*m.addnum_transitive_loads += u
	} else {
		m.addnum_transitive_loads = &u
	}
}

// AddedNumTransitiveLoads returns the value that was added to the "num_transitive_loads" field in this mutation.
func (m *PackageLoadMetricsMutation) AddedNumTransitiveLoads() (r int64, exists bool) {
	v := m.addnum_transitive_loads
	if v == nil {
		return
	}
	return *v, true
}

// ClearNumTransitiveLoads clears the value of the "num_transitive_loads" field.
func (m *PackageLoadMetricsMutation) ClearNumTransitiveLoads() {
	m.num_transitive_loads = nil
	m.addnum_transitive_loads = nil
	m.clearedFields[packageloadmetrics.FieldNumTransitiveLoads] = struct{}{}
}

// NumTransitiveLoadsCleared returns if the "num_transitive_loads" field was cleared in this mutation.
func (m *PackageLoadMetricsMutation) NumTransitiveLoadsCleared() bool {
	_, ok := m.clearedFields[packageloadmetrics.FieldNumTransitiveLoads]
	return ok
}

// ResetNumTransitiveLoads resets all changes to the "num_transitive_loads" field.
func (m *PackageLoadMetricsMutation) ResetNumTransitiveLoads() {
	m.num_transitive_loads = nil
	m.addnum_transitive_loads = nil
	delete(m.clearedFields, packageloadmetrics.FieldNumTransitiveLoads)
}

// SetPackageOverhead sets the "package_overhead" field.
func (m *PackageLoadMetricsMutation) SetPackageOverhead(u uint64) {
	m.package_overhead = &u
	m.addpackage_overhead = nil
}

// PackageOverhead returns the value of the "package_overhead" field in the mutation.
func (m *PackageLoadMetricsMutation) PackageOverhead() (r uint64, exists bool) {
	v := m.package_overhead
	if v == nil {
		return
	}
	return *v, true
}

// OldPackageOverhead returns the old "package_overhead" field's value of the PackageLoadMetrics entity.
// If the PackageLoadMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackageLoadMetricsMutation) OldPackageOverhead(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackageOverhead is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackageOverhead requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackageOverhead: %w", err)
	}
	return oldValue.PackageOverhead, nil
}

// AddPackageOverhead adds u to the "package_overhead" field.
func (m *PackageLoadMetricsMutation) AddPackageOverhead(u int64) {
	if m.addpackage_overhead != nil {
		*m.addpackage_overhead += u
	} else {
		m.addpackage_overhead = &u
	}
}

// AddedPackageOverhead returns the value that was added to the "package_overhead" field in this mutation.
func (m *PackageLoadMetricsMutation) AddedPackageOverhead() (r int64, exists bool) {
	v := m.addpackage_overhead
	if v == nil {
		return
	}
	return *v, true
}

// ClearPackageOverhead clears the value of the "package_overhead" field.
func (m *PackageLoadMetricsMutation) ClearPackageOverhead() {
	m.package_overhead = nil
	m.addpackage_overhead = nil
	m.clearedFields[packageloadmetrics.FieldPackageOverhead] = struct{}{}
}

// PackageOverheadCleared returns if the "package_overhead" field was cleared in this mutation.
func (m *PackageLoadMetricsMutation) PackageOverheadCleared() bool {
	_, ok := m.clearedFields[packageloadmetrics.FieldPackageOverhead]
	return ok
}

// ResetPackageOverhead resets all changes to the "package_overhead" field.
func (m *PackageLoadMetricsMutation) ResetPackageOverhead() {
	m.package_overhead = nil
	m.addpackage_overhead = nil
	delete(m.clearedFields, packageloadmetrics.FieldPackageOverhead)
}

// SetPackageMetricsID sets the "package_metrics" edge to the PackageMetrics entity by id.
func (m *PackageLoadMetricsMutation) SetPackageMetricsID(id int64) {
	m.package_metrics = &id
}

// ClearPackageMetrics clears the "package_metrics" edge to the PackageMetrics entity.
func (m *PackageLoadMetricsMutation) ClearPackageMetrics() {
	m.clearedpackage_metrics = true
}

// PackageMetricsCleared reports if the "package_metrics" edge to the PackageMetrics entity was cleared.
func (m *PackageLoadMetricsMutation) PackageMetricsCleared() bool {
	return m.clearedpackage_metrics
}

// PackageMetricsID returns the "package_metrics" edge ID in the mutation.
func (m *PackageLoadMetricsMutation) PackageMetricsID() (id int64, exists bool) {
	if m.package_metrics != nil {
		return *m.package_metrics, true
	}
	return
}

// PackageMetricsIDs returns the "package_metrics" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PackageMetricsID instead. It exists only for internal usage by the builders.
func (m *PackageLoadMetricsMutation) PackageMetricsIDs() (ids []int64) {
	if id := m.package_metrics; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPackageMetrics resets all changes to the "package_metrics" edge.
func (m *PackageLoadMetricsMutation) ResetPackageMetrics() {
	m.package_metrics = nil
	m.clearedpackage_metrics = false
}

// Where appends a list predicates to the PackageLoadMetricsMutation builder.
func (m *PackageLoadMetricsMutation) Where(ps ...predicate.PackageLoadMetrics) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PackageLoadMetricsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PackageLoadMetricsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PackageLoadMetrics, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PackageLoadMetricsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PackageLoadMetricsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PackageLoadMetrics).
func (m *PackageLoadMetricsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PackageLoadMetricsMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, packageloadmetrics.FieldName)
	}
	if m.load_duration != nil {
		fields = append(fields, packageloadmetrics.FieldLoadDuration)
	}
	if m.num_targets != nil {
		fields = append(fields, packageloadmetrics.FieldNumTargets)
	}
	if m.computation_steps != nil {
		fields = append(fields, packageloadmetrics.FieldComputationSteps)
	}
	if m.num_transitive_loads != nil {
		fields = append(fields, packageloadmetrics.FieldNumTransitiveLoads)
	}
	if m.package_overhead != nil {
		fields = append(fields, packageloadmetrics.FieldPackageOverhead)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PackageLoadMetricsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case packageloadmetrics.FieldName:
		return m.Name()
	case packageloadmetrics.FieldLoadDuration:
		return m.LoadDuration()
	case packageloadmetrics.FieldNumTargets:
		return m.NumTargets()
	case packageloadmetrics.FieldComputationSteps:
		return m.ComputationSteps()
	case packageloadmetrics.FieldNumTransitiveLoads:
		return m.NumTransitiveLoads()
	case packageloadmetrics.FieldPackageOverhead:
		return m.PackageOverhead()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PackageLoadMetricsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case packageloadmetrics.FieldName:
		return m.OldName(ctx)
	case packageloadmetrics.FieldLoadDuration:
		return m.OldLoadDuration(ctx)
	case packageloadmetrics.FieldNumTargets:
		return m.OldNumTargets(ctx)
	case packageloadmetrics.FieldComputationSteps:
		return m.OldComputationSteps(ctx)
	case packageloadmetrics.FieldNumTransitiveLoads:
		return m.OldNumTransitiveLoads(ctx)
	case packageloadmetrics.FieldPackageOverhead:
		return m.OldPackageOverhead(ctx)
	}
	return nil, fmt.Errorf("unknown PackageLoadMetrics field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PackageLoadMetricsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case packageloadmetrics.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case packageloadmetrics.FieldLoadDuration:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLoadDuration(v)
		return nil
	case packageloadmetrics.FieldNumTargets:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumTargets(v)
		return nil
	case packageloadmetrics.FieldComputationSteps:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComputationSteps(v)
		return nil
	case packageloadmetrics.FieldNumTransitiveLoads:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumTransitiveLoads(v)
		return nil
	case packageloadmetrics.FieldPackageOverhead:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackageOverhead(v)
		return nil
	}
	return fmt.Errorf("unknown PackageLoadMetrics field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PackageLoadMetricsMutation) AddedFields() []string {
	var fields []string
	if m.addload_duration != nil {
		fields = append(fields, packageloadmetrics.FieldLoadDuration)
	}
	if m.addnum_targets != nil {
		fields = append(fields, packageloadmetrics.FieldNumTargets)
	}
	if m.addcomputation_steps != nil {
		fields = append(fields, packageloadmetrics.FieldComputationSteps)
	}
	if m.addnum_transitive_loads != nil {
		fields = append(fields, packageloadmetrics.FieldNumTransitiveLoads)
	}
	if m.addpackage_overhead != nil {
		fields = append(fields, packageloadmetrics.FieldPackageOverhead)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PackageLoadMetricsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case packageloadmetrics.FieldLoadDuration:
		return m.AddedLoadDuration()
	case packageloadmetrics.FieldNumTargets:
		return m.AddedNumTargets()
	case packageloadmetrics.FieldComputationSteps:
		return m.AddedComputationSteps()
	case packageloadmetrics.FieldNumTransitiveLoads:
		return m.AddedNumTransitiveLoads()
	case packageloadmetrics.FieldPackageOverhead:
		return m.AddedPackageOverhead()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PackageLoadMetricsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case packageloadmetrics.FieldLoadDuration:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLoadDuration(v)
		return nil
	case packageloadmetrics.FieldNumTargets:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumTargets(v)
		return nil
	case packageloadmetrics.FieldComputationSteps:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddComputationSteps(v)
		return nil
	case packageloadmetrics.FieldNumTransitiveLoads:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumTransitiveLoads(v)
		return nil
	case packageloadmetrics.FieldPackageOverhead:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPackageOverhead(v)
		return nil
	}
	return fmt.Errorf("unknown PackageLoadMetrics numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PackageLoadMetricsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(packageloadmetrics.FieldName) {
		fields = append(fields, packageloadmetrics.FieldName)
	}
	if m.FieldCleared(packageloadmetrics.FieldLoadDuration) {
		fields = append(fields, packageloadmetrics.FieldLoadDuration)
	}
	if m.FieldCleared(packageloadmetrics.FieldNumTargets) {
		fields = append(fields, packageloadmetrics.FieldNumTargets)
	}
	if m.FieldCleared(packageloadmetrics.FieldComputationSteps) {
		fields = append(fields, packageloadmetrics.FieldComputationSteps)
	}
	if m.FieldCleared(packageloadmetrics.FieldNumTransitiveLoads) {
		fields = append(fields, packageloadmetrics.FieldNumTransitiveLoads)
	}
	if m.FieldCleared(packageloadmetrics.FieldPackageOverhead) {
		fields = append(fields, packageloadmetrics.FieldPackageOverhead)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PackageLoadMetricsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PackageLoadMetricsMutation) ClearField(name string) error {
	switch name {
	case packageloadmetrics.FieldName:
		m.ClearName()
		return nil
	case packageloadmetrics.FieldLoadDuration:
		m.ClearLoadDuration()
		return nil
	case packageloadmetrics.FieldNumTargets:
		m.ClearNumTargets()
		return nil
	case packageloadmetrics.FieldComputationSteps:
		m.ClearComputationSteps()
		return nil
	case packageloadmetrics.FieldNumTransitiveLoads:
		m.ClearNumTransitiveLoads()
		return nil
	case packageloadmetrics.FieldPackageOverhead:
		m.ClearPackageOverhead()
		return nil
	}
	return fmt.Errorf("unknown PackageLoadMetrics nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PackageLoadMetricsMutation) ResetField(name string) error {
	switch name {
	case packageloadmetrics.FieldName:
		m.ResetName()
		return nil
	case packageloadmetrics.FieldLoadDuration:
		m.ResetLoadDuration()
		return nil
	case packageloadmetrics.FieldNumTargets:
		m.ResetNumTargets()
		return nil
	case packageloadmetrics.FieldComputationSteps:
		m.ResetComputationSteps()
		return nil
	case packageloadmetrics.FieldNumTransitiveLoads:
		m.ResetNumTransitiveLoads()
		return nil
	case packageloadmetrics.FieldPackageOverhead:
		m.ResetPackageOverhead()
		return nil
	}
	return fmt.Errorf("unknown PackageLoadMetrics field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PackageLoadMetricsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.package_metrics != nil {
		edges = append(edges, packageloadmetrics.EdgePackageMetrics)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PackageLoadMetricsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case packageloadmetrics.EdgePackageMetrics:
		if id := m.package_metrics; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PackageLoadMetricsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PackageLoadMetricsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PackageLoadMetricsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpackage_metrics {
		edges = append(edges, packageloadmetrics.EdgePackageMetrics)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PackageLoadMetricsMutation) EdgeCleared(name string) bool {
	switch name {
	case packageloadmetrics.EdgePackageMetrics:
		return m.clearedpackage_metrics
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PackageLoadMetricsMutation) ClearEdge(name string) error {
	switch name {
	case packageloadmetrics.EdgePackageMetrics:
		m.ClearPackageMetrics()
		return nil
	}
	return fmt.Errorf("unknown PackageLoadMetrics unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PackageLoadMetricsMutation) ResetEdge(name string) error {
	switch name {
	case packageloadmetrics.EdgePackageMetrics:
		m.ResetPackageMetrics()
		return nil
	}
	return fmt.Errorf("unknown PackageLoadMetrics edge %s", name)
}

// PackageMetricsMutation represents an operation that mutates the PackageMetrics nodes in the graph.
type PackageMetricsMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int64
	packages_loaded             *int64
	addpackages_loaded          *int64
	clearedFields               map[string]struct{}
	metrics                     *int64
	clearedmetrics              bool
	package_load_metrics        map[int64]struct{}
	removedpackage_load_metrics map[int64]struct{}
	clearedpackage_load_metrics bool
	done                        bool
	oldValue                    func(context.Context) (*PackageMetrics, error)
	predicates                  []predicate.PackageMetrics
}

var _ ent.Mutation = (*PackageMetricsMutation)(nil)

// packagemetricsOption allows management of the mutation configuration using functional options.
type packagemetricsOption func(*PackageMetricsMutation)

// newPackageMetricsMutation creates new mutation for the PackageMetrics entity.
func newPackageMetricsMutation(c config, op Op, opts ...packagemetricsOption) *PackageMetricsMutation {
	m := &PackageMetricsMutation{
		config:        c,
		op:            op,
		typ:           TypePackageMetrics,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPackageMetricsID sets the ID field of the mutation.
func withPackageMetricsID(id int64) packagemetricsOption {
	return func(m *PackageMetricsMutation) {
		var (
			err   error
			once  sync.Once
			value *PackageMetrics
		)
		m.oldValue = func(ctx context.Context) (*PackageMetrics, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PackageMetrics.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPackageMetrics sets the old PackageMetrics of the mutation.
func withPackageMetrics(node *PackageMetrics) packagemetricsOption {
	return func(m *PackageMetricsMutation) {
		m.oldValue = func(context.Context) (*PackageMetrics, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PackageMetricsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PackageMetricsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PackageMetrics entities.
func (m *PackageMetricsMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PackageMetricsMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PackageMetricsMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PackageMetrics.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPackagesLoaded sets the "packages_loaded" field.
func (m *PackageMetricsMutation) SetPackagesLoaded(i int64) {
	m.packages_loaded = &i
	m.addpackages_loaded = nil
}

// PackagesLoaded returns the value of the "packages_loaded" field in the mutation.
func (m *PackageMetricsMutation) PackagesLoaded() (r int64, exists bool) {
	v := m.packages_loaded
	if v == nil {
		return
	}
	return *v, true
}

// OldPackagesLoaded returns the old "packages_loaded" field's value of the PackageMetrics entity.
// If the PackageMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackageMetricsMutation) OldPackagesLoaded(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackagesLoaded is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackagesLoaded requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackagesLoaded: %w", err)
	}
	return oldValue.PackagesLoaded, nil
}

// AddPackagesLoaded adds i to the "packages_loaded" field.
func (m *PackageMetricsMutation) AddPackagesLoaded(i int64) {
	if m.addpackages_loaded != nil {
		*m.addpackages_loaded += i
	} else {
		m.addpackages_loaded = &i
	}
}

// AddedPackagesLoaded returns the value that was added to the "packages_loaded" field in this mutation.
func (m *PackageMetricsMutation) AddedPackagesLoaded() (r int64, exists bool) {
	v := m.addpackages_loaded
	if v == nil {
		return
	}
	return *v, true
}

// ClearPackagesLoaded clears the value of the "packages_loaded" field.
func (m *PackageMetricsMutation) ClearPackagesLoaded() {
	m.packages_loaded = nil
	m.addpackages_loaded = nil
	m.clearedFields[packagemetrics.FieldPackagesLoaded] = struct{}{}
}

// PackagesLoadedCleared returns if the "packages_loaded" field was cleared in this mutation.
func (m *PackageMetricsMutation) PackagesLoadedCleared() bool {
	_, ok := m.clearedFields[packagemetrics.FieldPackagesLoaded]
	return ok
}

// ResetPackagesLoaded resets all changes to the "packages_loaded" field.
func (m *PackageMetricsMutation) ResetPackagesLoaded() {
	m.packages_loaded = nil
	m.addpackages_loaded = nil
	delete(m.clearedFields, packagemetrics.FieldPackagesLoaded)
}

// SetMetricsID sets the "metrics" edge to the Metrics entity by id.
func (m *PackageMetricsMutation) SetMetricsID(id int64) {
	m.metrics = &id
}

// ClearMetrics clears the "metrics" edge to the Metrics entity.
func (m *PackageMetricsMutation) ClearMetrics() {
	m.clearedmetrics = true
}

// MetricsCleared reports if the "metrics" edge to the Metrics entity was cleared.
func (m *PackageMetricsMutation) MetricsCleared() bool {
	return m.clearedmetrics
}

// MetricsID returns the "metrics" edge ID in the mutation.
func (m *PackageMetricsMutation) MetricsID() (id int64, exists bool) {
	if m.metrics != nil {
		return *m.metrics, true
	}
	return
}

// MetricsIDs returns the "metrics" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MetricsID instead. It exists only for internal usage by the builders.
func (m *PackageMetricsMutation) MetricsIDs() (ids []int64) {
	if id := m.metrics; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMetrics resets all changes to the "metrics" edge.
func (m *PackageMetricsMutation) ResetMetrics() {
	m.metrics = nil
	m.clearedmetrics = false
}

// AddPackageLoadMetricIDs adds the "package_load_metrics" edge to the PackageLoadMetrics entity by ids.
func (m *PackageMetricsMutation) AddPackageLoadMetricIDs(ids ...int64) {
	if m.package_load_metrics == nil {
		m.package_load_metrics = make(map[int64]struct{})
	}
	for i := range ids {
		m.package_load_metrics[ids[i]] = struct{}{}
	}
}

// ClearPackageLoadMetrics clears the "package_load_metrics" edge to the PackageLoadMetrics entity.
func (m *PackageMetricsMutation) ClearPackageLoadMetrics() {
	m.clearedpackage_load_metrics = true
}

// PackageLoadMetricsCleared reports if the "package_load_metrics" edge to the PackageLoadMetrics entity was cleared.
func (m *PackageMetricsMutation) PackageLoadMetricsCleared() bool {
	return m.clearedpackage_load_metrics
}

// RemovePackageLoadMetricIDs removes the "package_load_metrics" edge to the PackageLoadMetrics entity by IDs.
func (m *PackageMetricsMutation) RemovePackageLoadMetricIDs(ids ...int64) {
	if m.removedpackage_load_metrics == nil {
		m.removedpackage_load_metrics = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.package_load_metrics, ids[i])
		m.removedpackage_load_metrics[ids[i]] = struct{}{}
	}
}

// RemovedPackageLoadMetrics returns the removed IDs of the "package_load_metrics" edge to the PackageLoadMetrics entity.
func (m *PackageMetricsMutation) RemovedPackageLoadMetricsIDs() (ids []int64) {
	for id := range m.removedpackage_load_metrics {
		ids = append(ids, id)
	}
	return
}

// PackageLoadMetricsIDs returns the "package_load_metrics" edge IDs in the mutation.
func (m *PackageMetricsMutation) PackageLoadMetricsIDs() (ids []int64) {
	for id := range m.package_load_metrics {
		ids = append(ids, id)
	}
	return
}

// ResetPackageLoadMetrics resets all changes to the "package_load_metrics" edge.
func (m *PackageMetricsMutation) ResetPackageLoadMetrics() {
	m.package_load_metrics = nil
	m.clearedpackage_load_metrics = false
	m.removedpackage_load_metrics = nil
}

// Where appends a list predicates to the PackageMetricsMutation builder.
func (m *PackageMetricsMutation) Where(ps ...predicate.PackageMetrics) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PackageMetricsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PackageMetricsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PackageMetrics, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PackageMetricsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PackageMetricsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PackageMetrics).
func (m *PackageMetricsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PackageMetricsMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.packages_loaded != nil {
		fields = append(fields, packagemetrics.FieldPackagesLoaded)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PackageMetricsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case packagemetrics.FieldPackagesLoaded:
		return m.PackagesLoaded()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PackageMetricsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case packagemetrics.FieldPackagesLoaded:
		return m.OldPackagesLoaded(ctx)
	}
	return nil, fmt.Errorf("unknown PackageMetrics field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PackageMetricsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case packagemetrics.FieldPackagesLoaded:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackagesLoaded(v)
		return nil
	}
	return fmt.Errorf("unknown PackageMetrics field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PackageMetricsMutation) AddedFields() []string {
	var fields []string
	if m.addpackages_loaded != nil {
		fields = append(fields, packagemetrics.FieldPackagesLoaded)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PackageMetricsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case packagemetrics.FieldPackagesLoaded:
		return m.AddedPackagesLoaded()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PackageMetricsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case packagemetrics.FieldPackagesLoaded:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPackagesLoaded(v)
		return nil
	}
	return fmt.Errorf("unknown PackageMetrics numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PackageMetricsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(packagemetrics.FieldPackagesLoaded) {
		fields = append(fields, packagemetrics.FieldPackagesLoaded)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PackageMetricsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PackageMetricsMutation) ClearField(name string) error {
	switch name {
	case packagemetrics.FieldPackagesLoaded:
		m.ClearPackagesLoaded()
		return nil
	}
	return fmt.Errorf("unknown PackageMetrics nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PackageMetricsMutation) ResetField(name string) error {
	switch name {
	case packagemetrics.FieldPackagesLoaded:
		m.ResetPackagesLoaded()
		return nil
	}
	return fmt.Errorf("unknown PackageMetrics field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PackageMetricsMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.metrics != nil {
		edges = append(edges, packagemetrics.EdgeMetrics)
	}
	if m.package_load_metrics != nil {
		edges = append(edges, packagemetrics.EdgePackageLoadMetrics)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PackageMetricsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case packagemetrics.EdgeMetrics:
		if id := m.metrics; id != nil {
			return []ent.Value{*id}
		}
	case packagemetrics.EdgePackageLoadMetrics:
		ids := make([]ent.Value, 0, len(m.package_load_metrics))
		for id := range m.package_load_metrics {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PackageMetricsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedpackage_load_metrics != nil {
		edges = append(edges, packagemetrics.EdgePackageLoadMetrics)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PackageMetricsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case packagemetrics.EdgePackageLoadMetrics:
		ids := make([]ent.Value, 0, len(m.removedpackage_load_metrics))
		for id := range m.removedpackage_load_metrics {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PackageMetricsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmetrics {
		edges = append(edges, packagemetrics.EdgeMetrics)
	}
	if m.clearedpackage_load_metrics {
		edges = append(edges, packagemetrics.EdgePackageLoadMetrics)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PackageMetricsMutation) EdgeCleared(name string) bool {
	switch name {
	case packagemetrics.EdgeMetrics:
		return m.clearedmetrics
	case packagemetrics.EdgePackageLoadMetrics:
		return m.clearedpackage_load_metrics
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PackageMetricsMutation) ClearEdge(name string) error {
	switch name {
	case packagemetrics.EdgeMetrics:
		m.ClearMetrics()
		return nil
	}
	return fmt.Errorf("unknown PackageMetrics unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PackageMetricsMutation) ResetEdge(name string) error {
	switch name {
	case packagemetrics.EdgeMetrics:
		m.ResetMetrics()
		return nil
	case packagemetrics.EdgePackageLoadMetrics:
		m.ResetPackageLoadMetrics()
		return nil
	}
	return fmt.Errorf("unknown PackageMetrics edge %s", name)
}

// RunnerCountMutation represents an operation that mutates the RunnerCount nodes in the graph.
type RunnerCountMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int64
	name                  *string
	exec_kind             *string
	actions_executed      *int64
	addactions_executed   *int64
	clearedFields         map[string]struct{}
	action_summary        *int64
	clearedaction_summary bool
	done                  bool
	oldValue              func(context.Context) (*RunnerCount, error)
	predicates            []predicate.RunnerCount
}

var _ ent.Mutation = (*RunnerCountMutation)(nil)

// runnercountOption allows management of the mutation configuration using functional options.
type runnercountOption func(*RunnerCountMutation)

// newRunnerCountMutation creates new mutation for the RunnerCount entity.
func newRunnerCountMutation(c config, op Op, opts ...runnercountOption) *RunnerCountMutation {
	m := &RunnerCountMutation{
		config:        c,
		op:            op,
		typ:           TypeRunnerCount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRunnerCountID sets the ID field of the mutation.
func withRunnerCountID(id int64) runnercountOption {
	return func(m *RunnerCountMutation) {
		var (
			err   error
			once  sync.Once
			value *RunnerCount
		)
		m.oldValue = func(ctx context.Context) (*RunnerCount, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RunnerCount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRunnerCount sets the old RunnerCount of the mutation.
func withRunnerCount(node *RunnerCount) runnercountOption {
	return func(m *RunnerCountMutation) {
		m.oldValue = func(context.Context) (*RunnerCount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RunnerCountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RunnerCountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RunnerCount entities.
func (m *RunnerCountMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RunnerCountMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RunnerCountMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RunnerCount.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *RunnerCountMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RunnerCountMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the RunnerCount entity.
// If the RunnerCount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RunnerCountMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *RunnerCountMutation) ClearName() {
	m.name = nil
	m.clearedFields[runnercount.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *RunnerCountMutation) NameCleared() bool {
	_, ok := m.clearedFields[runnercount.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *RunnerCountMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, runnercount.FieldName)
}

// SetExecKind sets the "exec_kind" field.
func (m *RunnerCountMutation) SetExecKind(s string) {
	m.exec_kind = &s
}

// ExecKind returns the value of the "exec_kind" field in the mutation.
func (m *RunnerCountMutation) ExecKind() (r string, exists bool) {
	v := m.exec_kind
	if v == nil {
		return
	}
	return *v, true
}

// OldExecKind returns the old "exec_kind" field's value of the RunnerCount entity.
// If the RunnerCount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RunnerCountMutation) OldExecKind(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExecKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExecKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExecKind: %w", err)
	}
	return oldValue.ExecKind, nil
}

// ClearExecKind clears the value of the "exec_kind" field.
func (m *RunnerCountMutation) ClearExecKind() {
	m.exec_kind = nil
	m.clearedFields[runnercount.FieldExecKind] = struct{}{}
}

// ExecKindCleared returns if the "exec_kind" field was cleared in this mutation.
func (m *RunnerCountMutation) ExecKindCleared() bool {
	_, ok := m.clearedFields[runnercount.FieldExecKind]
	return ok
}

// ResetExecKind resets all changes to the "exec_kind" field.
func (m *RunnerCountMutation) ResetExecKind() {
	m.exec_kind = nil
	delete(m.clearedFields, runnercount.FieldExecKind)
}

// SetActionsExecuted sets the "actions_executed" field.
func (m *RunnerCountMutation) SetActionsExecuted(i int64) {
	m.actions_executed = &i
	m.addactions_executed = nil
}

// ActionsExecuted returns the value of the "actions_executed" field in the mutation.
func (m *RunnerCountMutation) ActionsExecuted() (r int64, exists bool) {
	v := m.actions_executed
	if v == nil {
		return
	}
	return *v, true
}

// OldActionsExecuted returns the old "actions_executed" field's value of the RunnerCount entity.
// If the RunnerCount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RunnerCountMutation) OldActionsExecuted(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActionsExecuted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActionsExecuted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActionsExecuted: %w", err)
	}
	return oldValue.ActionsExecuted, nil
}

// AddActionsExecuted adds i to the "actions_executed" field.
func (m *RunnerCountMutation) AddActionsExecuted(i int64) {
	if m.addactions_executed != nil {
		*m.addactions_executed += i
	} else {
		m.addactions_executed = &i
	}
}

// AddedActionsExecuted returns the value that was added to the "actions_executed" field in this mutation.
func (m *RunnerCountMutation) AddedActionsExecuted() (r int64, exists bool) {
	v := m.addactions_executed
	if v == nil {
		return
	}
	return *v, true
}

// ClearActionsExecuted clears the value of the "actions_executed" field.
func (m *RunnerCountMutation) ClearActionsExecuted() {
	m.actions_executed = nil
	m.addactions_executed = nil
	m.clearedFields[runnercount.FieldActionsExecuted] = struct{}{}
}

// ActionsExecutedCleared returns if the "actions_executed" field was cleared in this mutation.
func (m *RunnerCountMutation) ActionsExecutedCleared() bool {
	_, ok := m.clearedFields[runnercount.FieldActionsExecuted]
	return ok
}

// ResetActionsExecuted resets all changes to the "actions_executed" field.
func (m *RunnerCountMutation) ResetActionsExecuted() {
	m.actions_executed = nil
	m.addactions_executed = nil
	delete(m.clearedFields, runnercount.FieldActionsExecuted)
}

// SetActionSummaryID sets the "action_summary" edge to the ActionSummary entity by id.
func (m *RunnerCountMutation) SetActionSummaryID(id int64) {
	m.action_summary = &id
}

// ClearActionSummary clears the "action_summary" edge to the ActionSummary entity.
func (m *RunnerCountMutation) ClearActionSummary() {
	m.clearedaction_summary = true
}

// ActionSummaryCleared reports if the "action_summary" edge to the ActionSummary entity was cleared.
func (m *RunnerCountMutation) ActionSummaryCleared() bool {
	return m.clearedaction_summary
}

// ActionSummaryID returns the "action_summary" edge ID in the mutation.
func (m *RunnerCountMutation) ActionSummaryID() (id int64, exists bool) {
	if m.action_summary != nil {
		return *m.action_summary, true
	}
	return
}

// ActionSummaryIDs returns the "action_summary" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ActionSummaryID instead. It exists only for internal usage by the builders.
func (m *RunnerCountMutation) ActionSummaryIDs() (ids []int64) {
	if id := m.action_summary; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetActionSummary resets all changes to the "action_summary" edge.
func (m *RunnerCountMutation) ResetActionSummary() {
	m.action_summary = nil
	m.clearedaction_summary = false
}

// Where appends a list predicates to the RunnerCountMutation builder.
func (m *RunnerCountMutation) Where(ps ...predicate.RunnerCount) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RunnerCountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RunnerCountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RunnerCount, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RunnerCountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RunnerCountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RunnerCount).
func (m *RunnerCountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RunnerCountMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, runnercount.FieldName)
	}
	if m.exec_kind != nil {
		fields = append(fields, runnercount.FieldExecKind)
	}
	if m.actions_executed != nil {
		fields = append(fields, runnercount.FieldActionsExecuted)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RunnerCountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case runnercount.FieldName:
		return m.Name()
	case runnercount.FieldExecKind:
		return m.ExecKind()
	case runnercount.FieldActionsExecuted:
		return m.ActionsExecuted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RunnerCountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case runnercount.FieldName:
		return m.OldName(ctx)
	case runnercount.FieldExecKind:
		return m.OldExecKind(ctx)
	case runnercount.FieldActionsExecuted:
		return m.OldActionsExecuted(ctx)
	}
	return nil, fmt.Errorf("unknown RunnerCount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RunnerCountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case runnercount.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case runnercount.FieldExecKind:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExecKind(v)
		return nil
	case runnercount.FieldActionsExecuted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActionsExecuted(v)
		return nil
	}
	return fmt.Errorf("unknown RunnerCount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RunnerCountMutation) AddedFields() []string {
	var fields []string
	if m.addactions_executed != nil {
		fields = append(fields, runnercount.FieldActionsExecuted)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RunnerCountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case runnercount.FieldActionsExecuted:
		return m.AddedActionsExecuted()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RunnerCountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case runnercount.FieldActionsExecuted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddActionsExecuted(v)
		return nil
	}
	return fmt.Errorf("unknown RunnerCount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RunnerCountMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(runnercount.FieldName) {
		fields = append(fields, runnercount.FieldName)
	}
	if m.FieldCleared(runnercount.FieldExecKind) {
		fields = append(fields, runnercount.FieldExecKind)
	}
	if m.FieldCleared(runnercount.FieldActionsExecuted) {
		fields = append(fields, runnercount.FieldActionsExecuted)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RunnerCountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RunnerCountMutation) ClearField(name string) error {
	switch name {
	case runnercount.FieldName:
		m.ClearName()
		return nil
	case runnercount.FieldExecKind:
		m.ClearExecKind()
		return nil
	case runnercount.FieldActionsExecuted:
		m.ClearActionsExecuted()
		return nil
	}
	return fmt.Errorf("unknown RunnerCount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RunnerCountMutation) ResetField(name string) error {
	switch name {
	case runnercount.FieldName:
		m.ResetName()
		return nil
	case runnercount.FieldExecKind:
		m.ResetExecKind()
		return nil
	case runnercount.FieldActionsExecuted:
		m.ResetActionsExecuted()
		return nil
	}
	return fmt.Errorf("unknown RunnerCount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RunnerCountMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.action_summary != nil {
		edges = append(edges, runnercount.EdgeActionSummary)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RunnerCountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case runnercount.EdgeActionSummary:
		if id := m.action_summary; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RunnerCountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RunnerCountMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RunnerCountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedaction_summary {
		edges = append(edges, runnercount.EdgeActionSummary)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RunnerCountMutation) EdgeCleared(name string) bool {
	switch name {
	case runnercount.EdgeActionSummary:
		return m.clearedaction_summary
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RunnerCountMutation) ClearEdge(name string) error {
	switch name {
	case runnercount.EdgeActionSummary:
		m.ClearActionSummary()
		return nil
	}
	return fmt.Errorf("unknown RunnerCount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RunnerCountMutation) ResetEdge(name string) error {
	switch name {
	case runnercount.EdgeActionSummary:
		m.ResetActionSummary()
		return nil
	}
	return fmt.Errorf("unknown RunnerCount edge %s", name)
}

// SourceControlMutation represents an operation that mutates the SourceControl nodes in the graph.
type SourceControlMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int64
	provider                *sourcecontrol.Provider
	instance_url            *string
	repo                    *string
	refs                    *string
	commit_sha              *string
	actor                   *string
	event_name              *string
	workflow                *string
	run_id                  *string
	run_number              *string
	job                     *string
	action                  *string
	runner_name             *string
	runner_arch             *string
	runner_os               *string
	workspace               *string
	clearedFields           map[string]struct{}
	bazel_invocation        *int64
	clearedbazel_invocation bool
	done                    bool
	oldValue                func(context.Context) (*SourceControl, error)
	predicates              []predicate.SourceControl
}

var _ ent.Mutation = (*SourceControlMutation)(nil)

// sourcecontrolOption allows management of the mutation configuration using functional options.
type sourcecontrolOption func(*SourceControlMutation)

// newSourceControlMutation creates new mutation for the SourceControl entity.
func newSourceControlMutation(c config, op Op, opts ...sourcecontrolOption) *SourceControlMutation {
	m := &SourceControlMutation{
		config:        c,
		op:            op,
		typ:           TypeSourceControl,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSourceControlID sets the ID field of the mutation.
func withSourceControlID(id int64) sourcecontrolOption {
	return func(m *SourceControlMutation) {
		var (
			err   error
			once  sync.Once
			value *SourceControl
		)
		m.oldValue = func(ctx context.Context) (*SourceControl, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SourceControl.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSourceControl sets the old SourceControl of the mutation.
func withSourceControl(node *SourceControl) sourcecontrolOption {
	return func(m *SourceControlMutation) {
		m.oldValue = func(context.Context) (*SourceControl, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SourceControlMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SourceControlMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SourceControl entities.
func (m *SourceControlMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SourceControlMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SourceControlMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SourceControl.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProvider sets the "provider" field.
func (m *SourceControlMutation) SetProvider(s sourcecontrol.Provider) {
	m.provider = &s
}

// Provider returns the value of the "provider" field in the mutation.
func (m *SourceControlMutation) Provider() (r sourcecontrol.Provider, exists bool) {
	v := m.provider
	if v == nil {
		return
	}
	return *v, true
}

// OldProvider returns the old "provider" field's value of the SourceControl entity.
// If the SourceControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceControlMutation) OldProvider(ctx context.Context) (v sourcecontrol.Provider, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvider is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvider requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvider: %w", err)
	}
	return oldValue.Provider, nil
}

// ClearProvider clears the value of the "provider" field.
func (m *SourceControlMutation) ClearProvider() {
	m.provider = nil
	m.clearedFields[sourcecontrol.FieldProvider] = struct{}{}
}

// ProviderCleared returns if the "provider" field was cleared in this mutation.
func (m *SourceControlMutation) ProviderCleared() bool {
	_, ok := m.clearedFields[sourcecontrol.FieldProvider]
	return ok
}

// ResetProvider resets all changes to the "provider" field.
func (m *SourceControlMutation) ResetProvider() {
	m.provider = nil
	delete(m.clearedFields, sourcecontrol.FieldProvider)
}

// SetInstanceURL sets the "instance_url" field.
func (m *SourceControlMutation) SetInstanceURL(s string) {
	m.instance_url = &s
}

// InstanceURL returns the value of the "instance_url" field in the mutation.
func (m *SourceControlMutation) InstanceURL() (r string, exists bool) {
	v := m.instance_url
	if v == nil {
		return
	}
	return *v, true
}

// OldInstanceURL returns the old "instance_url" field's value of the SourceControl entity.
// If the SourceControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceControlMutation) OldInstanceURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstanceURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstanceURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstanceURL: %w", err)
	}
	return oldValue.InstanceURL, nil
}

// ClearInstanceURL clears the value of the "instance_url" field.
func (m *SourceControlMutation) ClearInstanceURL() {
	m.instance_url = nil
	m.clearedFields[sourcecontrol.FieldInstanceURL] = struct{}{}
}

// InstanceURLCleared returns if the "instance_url" field was cleared in this mutation.
func (m *SourceControlMutation) InstanceURLCleared() bool {
	_, ok := m.clearedFields[sourcecontrol.FieldInstanceURL]
	return ok
}

// ResetInstanceURL resets all changes to the "instance_url" field.
func (m *SourceControlMutation) ResetInstanceURL() {
	m.instance_url = nil
	delete(m.clearedFields, sourcecontrol.FieldInstanceURL)
}

// SetRepo sets the "repo" field.
func (m *SourceControlMutation) SetRepo(s string) {
	m.repo = &s
}

// Repo returns the value of the "repo" field in the mutation.
func (m *SourceControlMutation) Repo() (r string, exists bool) {
	v := m.repo
	if v == nil {
		return
	}
	return *v, true
}

// OldRepo returns the old "repo" field's value of the SourceControl entity.
// If the SourceControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceControlMutation) OldRepo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRepo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRepo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRepo: %w", err)
	}
	return oldValue.Repo, nil
}

// ClearRepo clears the value of the "repo" field.
func (m *SourceControlMutation) ClearRepo() {
	m.repo = nil
	m.clearedFields[sourcecontrol.FieldRepo] = struct{}{}
}

// RepoCleared returns if the "repo" field was cleared in this mutation.
func (m *SourceControlMutation) RepoCleared() bool {
	_, ok := m.clearedFields[sourcecontrol.FieldRepo]
	return ok
}

// ResetRepo resets all changes to the "repo" field.
func (m *SourceControlMutation) ResetRepo() {
	m.repo = nil
	delete(m.clearedFields, sourcecontrol.FieldRepo)
}

// SetRefs sets the "refs" field.
func (m *SourceControlMutation) SetRefs(s string) {
	m.refs = &s
}

// Refs returns the value of the "refs" field in the mutation.
func (m *SourceControlMutation) Refs() (r string, exists bool) {
	v := m.refs
	if v == nil {
		return
	}
	return *v, true
}

// OldRefs returns the old "refs" field's value of the SourceControl entity.
// If the SourceControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceControlMutation) OldRefs(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefs: %w", err)
	}
	return oldValue.Refs, nil
}

// ClearRefs clears the value of the "refs" field.
func (m *SourceControlMutation) ClearRefs() {
	m.refs = nil
	m.clearedFields[sourcecontrol.FieldRefs] = struct{}{}
}

// RefsCleared returns if the "refs" field was cleared in this mutation.
func (m *SourceControlMutation) RefsCleared() bool {
	_, ok := m.clearedFields[sourcecontrol.FieldRefs]
	return ok
}

// ResetRefs resets all changes to the "refs" field.
func (m *SourceControlMutation) ResetRefs() {
	m.refs = nil
	delete(m.clearedFields, sourcecontrol.FieldRefs)
}

// SetCommitSha sets the "commit_sha" field.
func (m *SourceControlMutation) SetCommitSha(s string) {
	m.commit_sha = &s
}

// CommitSha returns the value of the "commit_sha" field in the mutation.
func (m *SourceControlMutation) CommitSha() (r string, exists bool) {
	v := m.commit_sha
	if v == nil {
		return
	}
	return *v, true
}

// OldCommitSha returns the old "commit_sha" field's value of the SourceControl entity.
// If the SourceControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceControlMutation) OldCommitSha(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommitSha is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommitSha requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommitSha: %w", err)
	}
	return oldValue.CommitSha, nil
}

// ClearCommitSha clears the value of the "commit_sha" field.
func (m *SourceControlMutation) ClearCommitSha() {
	m.commit_sha = nil
	m.clearedFields[sourcecontrol.FieldCommitSha] = struct{}{}
}

// CommitShaCleared returns if the "commit_sha" field was cleared in this mutation.
func (m *SourceControlMutation) CommitShaCleared() bool {
	_, ok := m.clearedFields[sourcecontrol.FieldCommitSha]
	return ok
}

// ResetCommitSha resets all changes to the "commit_sha" field.
func (m *SourceControlMutation) ResetCommitSha() {
	m.commit_sha = nil
	delete(m.clearedFields, sourcecontrol.FieldCommitSha)
}

// SetActor sets the "actor" field.
func (m *SourceControlMutation) SetActor(s string) {
	m.actor = &s
}

// Actor returns the value of the "actor" field in the mutation.
func (m *SourceControlMutation) Actor() (r string, exists bool) {
	v := m.actor
	if v == nil {
		return
	}
	return *v, true
}

// OldActor returns the old "actor" field's value of the SourceControl entity.
// If the SourceControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceControlMutation) OldActor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActor: %w", err)
	}
	return oldValue.Actor, nil
}

// ClearActor clears the value of the "actor" field.
func (m *SourceControlMutation) ClearActor() {
	m.actor = nil
	m.clearedFields[sourcecontrol.FieldActor] = struct{}{}
}

// ActorCleared returns if the "actor" field was cleared in this mutation.
func (m *SourceControlMutation) ActorCleared() bool {
	_, ok := m.clearedFields[sourcecontrol.FieldActor]
	return ok
}

// ResetActor resets all changes to the "actor" field.
func (m *SourceControlMutation) ResetActor() {
	m.actor = nil
	delete(m.clearedFields, sourcecontrol.FieldActor)
}

// SetEventName sets the "event_name" field.
func (m *SourceControlMutation) SetEventName(s string) {
	m.event_name = &s
}

// EventName returns the value of the "event_name" field in the mutation.
func (m *SourceControlMutation) EventName() (r string, exists bool) {
	v := m.event_name
	if v == nil {
		return
	}
	return *v, true
}

// OldEventName returns the old "event_name" field's value of the SourceControl entity.
// If the SourceControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceControlMutation) OldEventName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventName: %w", err)
	}
	return oldValue.EventName, nil
}

// ClearEventName clears the value of the "event_name" field.
func (m *SourceControlMutation) ClearEventName() {
	m.event_name = nil
	m.clearedFields[sourcecontrol.FieldEventName] = struct{}{}
}

// EventNameCleared returns if the "event_name" field was cleared in this mutation.
func (m *SourceControlMutation) EventNameCleared() bool {
	_, ok := m.clearedFields[sourcecontrol.FieldEventName]
	return ok
}

// ResetEventName resets all changes to the "event_name" field.
func (m *SourceControlMutation) ResetEventName() {
	m.event_name = nil
	delete(m.clearedFields, sourcecontrol.FieldEventName)
}

// SetWorkflow sets the "workflow" field.
func (m *SourceControlMutation) SetWorkflow(s string) {
	m.workflow = &s
}

// Workflow returns the value of the "workflow" field in the mutation.
func (m *SourceControlMutation) Workflow() (r string, exists bool) {
	v := m.workflow
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkflow returns the old "workflow" field's value of the SourceControl entity.
// If the SourceControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceControlMutation) OldWorkflow(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkflow is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkflow requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkflow: %w", err)
	}
	return oldValue.Workflow, nil
}

// ClearWorkflow clears the value of the "workflow" field.
func (m *SourceControlMutation) ClearWorkflow() {
	m.workflow = nil
	m.clearedFields[sourcecontrol.FieldWorkflow] = struct{}{}
}

// WorkflowCleared returns if the "workflow" field was cleared in this mutation.
func (m *SourceControlMutation) WorkflowCleared() bool {
	_, ok := m.clearedFields[sourcecontrol.FieldWorkflow]
	return ok
}

// ResetWorkflow resets all changes to the "workflow" field.
func (m *SourceControlMutation) ResetWorkflow() {
	m.workflow = nil
	delete(m.clearedFields, sourcecontrol.FieldWorkflow)
}

// SetRunID sets the "run_id" field.
func (m *SourceControlMutation) SetRunID(s string) {
	m.run_id = &s
}

// RunID returns the value of the "run_id" field in the mutation.
func (m *SourceControlMutation) RunID() (r string, exists bool) {
	v := m.run_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRunID returns the old "run_id" field's value of the SourceControl entity.
// If the SourceControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceControlMutation) OldRunID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRunID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRunID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRunID: %w", err)
	}
	return oldValue.RunID, nil
}

// ClearRunID clears the value of the "run_id" field.
func (m *SourceControlMutation) ClearRunID() {
	m.run_id = nil
	m.clearedFields[sourcecontrol.FieldRunID] = struct{}{}
}

// RunIDCleared returns if the "run_id" field was cleared in this mutation.
func (m *SourceControlMutation) RunIDCleared() bool {
	_, ok := m.clearedFields[sourcecontrol.FieldRunID]
	return ok
}

// ResetRunID resets all changes to the "run_id" field.
func (m *SourceControlMutation) ResetRunID() {
	m.run_id = nil
	delete(m.clearedFields, sourcecontrol.FieldRunID)
}

// SetRunNumber sets the "run_number" field.
func (m *SourceControlMutation) SetRunNumber(s string) {
	m.run_number = &s
}

// RunNumber returns the value of the "run_number" field in the mutation.
func (m *SourceControlMutation) RunNumber() (r string, exists bool) {
	v := m.run_number
	if v == nil {
		return
	}
	return *v, true
}

// OldRunNumber returns the old "run_number" field's value of the SourceControl entity.
// If the SourceControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceControlMutation) OldRunNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRunNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRunNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRunNumber: %w", err)
	}
	return oldValue.RunNumber, nil
}

// ClearRunNumber clears the value of the "run_number" field.
func (m *SourceControlMutation) ClearRunNumber() {
	m.run_number = nil
	m.clearedFields[sourcecontrol.FieldRunNumber] = struct{}{}
}

// RunNumberCleared returns if the "run_number" field was cleared in this mutation.
func (m *SourceControlMutation) RunNumberCleared() bool {
	_, ok := m.clearedFields[sourcecontrol.FieldRunNumber]
	return ok
}

// ResetRunNumber resets all changes to the "run_number" field.
func (m *SourceControlMutation) ResetRunNumber() {
	m.run_number = nil
	delete(m.clearedFields, sourcecontrol.FieldRunNumber)
}

// SetJob sets the "job" field.
func (m *SourceControlMutation) SetJob(s string) {
	m.job = &s
}

// Job returns the value of the "job" field in the mutation.
func (m *SourceControlMutation) Job() (r string, exists bool) {
	v := m.job
	if v == nil {
		return
	}
	return *v, true
}

// OldJob returns the old "job" field's value of the SourceControl entity.
// If the SourceControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceControlMutation) OldJob(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJob is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJob requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJob: %w", err)
	}
	return oldValue.Job, nil
}

// ClearJob clears the value of the "job" field.
func (m *SourceControlMutation) ClearJob() {
	m.job = nil
	m.clearedFields[sourcecontrol.FieldJob] = struct{}{}
}

// JobCleared returns if the "job" field was cleared in this mutation.
func (m *SourceControlMutation) JobCleared() bool {
	_, ok := m.clearedFields[sourcecontrol.FieldJob]
	return ok
}

// ResetJob resets all changes to the "job" field.
func (m *SourceControlMutation) ResetJob() {
	m.job = nil
	delete(m.clearedFields, sourcecontrol.FieldJob)
}

// SetAction sets the "action" field.
func (m *SourceControlMutation) SetAction(s string) {
	m.action = &s
}

// Action returns the value of the "action" field in the mutation.
func (m *SourceControlMutation) Action() (r string, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old "action" field's value of the SourceControl entity.
// If the SourceControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceControlMutation) OldAction(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// ClearAction clears the value of the "action" field.
func (m *SourceControlMutation) ClearAction() {
	m.action = nil
	m.clearedFields[sourcecontrol.FieldAction] = struct{}{}
}

// ActionCleared returns if the "action" field was cleared in this mutation.
func (m *SourceControlMutation) ActionCleared() bool {
	_, ok := m.clearedFields[sourcecontrol.FieldAction]
	return ok
}

// ResetAction resets all changes to the "action" field.
func (m *SourceControlMutation) ResetAction() {
	m.action = nil
	delete(m.clearedFields, sourcecontrol.FieldAction)
}

// SetRunnerName sets the "runner_name" field.
func (m *SourceControlMutation) SetRunnerName(s string) {
	m.runner_name = &s
}

// RunnerName returns the value of the "runner_name" field in the mutation.
func (m *SourceControlMutation) RunnerName() (r string, exists bool) {
	v := m.runner_name
	if v == nil {
		return
	}
	return *v, true
}

// OldRunnerName returns the old "runner_name" field's value of the SourceControl entity.
// If the SourceControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceControlMutation) OldRunnerName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRunnerName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRunnerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRunnerName: %w", err)
	}
	return oldValue.RunnerName, nil
}

// ClearRunnerName clears the value of the "runner_name" field.
func (m *SourceControlMutation) ClearRunnerName() {
	m.runner_name = nil
	m.clearedFields[sourcecontrol.FieldRunnerName] = struct{}{}
}

// RunnerNameCleared returns if the "runner_name" field was cleared in this mutation.
func (m *SourceControlMutation) RunnerNameCleared() bool {
	_, ok := m.clearedFields[sourcecontrol.FieldRunnerName]
	return ok
}

// ResetRunnerName resets all changes to the "runner_name" field.
func (m *SourceControlMutation) ResetRunnerName() {
	m.runner_name = nil
	delete(m.clearedFields, sourcecontrol.FieldRunnerName)
}

// SetRunnerArch sets the "runner_arch" field.
func (m *SourceControlMutation) SetRunnerArch(s string) {
	m.runner_arch = &s
}

// RunnerArch returns the value of the "runner_arch" field in the mutation.
func (m *SourceControlMutation) RunnerArch() (r string, exists bool) {
	v := m.runner_arch
	if v == nil {
		return
	}
	return *v, true
}

// OldRunnerArch returns the old "runner_arch" field's value of the SourceControl entity.
// If the SourceControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceControlMutation) OldRunnerArch(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRunnerArch is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRunnerArch requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRunnerArch: %w", err)
	}
	return oldValue.RunnerArch, nil
}

// ClearRunnerArch clears the value of the "runner_arch" field.
func (m *SourceControlMutation) ClearRunnerArch() {
	m.runner_arch = nil
	m.clearedFields[sourcecontrol.FieldRunnerArch] = struct{}{}
}

// RunnerArchCleared returns if the "runner_arch" field was cleared in this mutation.
func (m *SourceControlMutation) RunnerArchCleared() bool {
	_, ok := m.clearedFields[sourcecontrol.FieldRunnerArch]
	return ok
}

// ResetRunnerArch resets all changes to the "runner_arch" field.
func (m *SourceControlMutation) ResetRunnerArch() {
	m.runner_arch = nil
	delete(m.clearedFields, sourcecontrol.FieldRunnerArch)
}

// SetRunnerOs sets the "runner_os" field.
func (m *SourceControlMutation) SetRunnerOs(s string) {
	m.runner_os = &s
}

// RunnerOs returns the value of the "runner_os" field in the mutation.
func (m *SourceControlMutation) RunnerOs() (r string, exists bool) {
	v := m.runner_os
	if v == nil {
		return
	}
	return *v, true
}

// OldRunnerOs returns the old "runner_os" field's value of the SourceControl entity.
// If the SourceControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceControlMutation) OldRunnerOs(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRunnerOs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRunnerOs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRunnerOs: %w", err)
	}
	return oldValue.RunnerOs, nil
}

// ClearRunnerOs clears the value of the "runner_os" field.
func (m *SourceControlMutation) ClearRunnerOs() {
	m.runner_os = nil
	m.clearedFields[sourcecontrol.FieldRunnerOs] = struct{}{}
}

// RunnerOsCleared returns if the "runner_os" field was cleared in this mutation.
func (m *SourceControlMutation) RunnerOsCleared() bool {
	_, ok := m.clearedFields[sourcecontrol.FieldRunnerOs]
	return ok
}

// ResetRunnerOs resets all changes to the "runner_os" field.
func (m *SourceControlMutation) ResetRunnerOs() {
	m.runner_os = nil
	delete(m.clearedFields, sourcecontrol.FieldRunnerOs)
}

// SetWorkspace sets the "workspace" field.
func (m *SourceControlMutation) SetWorkspace(s string) {
	m.workspace = &s
}

// Workspace returns the value of the "workspace" field in the mutation.
func (m *SourceControlMutation) Workspace() (r string, exists bool) {
	v := m.workspace
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkspace returns the old "workspace" field's value of the SourceControl entity.
// If the SourceControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceControlMutation) OldWorkspace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkspace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkspace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkspace: %w", err)
	}
	return oldValue.Workspace, nil
}

// ClearWorkspace clears the value of the "workspace" field.
func (m *SourceControlMutation) ClearWorkspace() {
	m.workspace = nil
	m.clearedFields[sourcecontrol.FieldWorkspace] = struct{}{}
}

// WorkspaceCleared returns if the "workspace" field was cleared in this mutation.
func (m *SourceControlMutation) WorkspaceCleared() bool {
	_, ok := m.clearedFields[sourcecontrol.FieldWorkspace]
	return ok
}

// ResetWorkspace resets all changes to the "workspace" field.
func (m *SourceControlMutation) ResetWorkspace() {
	m.workspace = nil
	delete(m.clearedFields, sourcecontrol.FieldWorkspace)
}

// SetBazelInvocationID sets the "bazel_invocation" edge to the BazelInvocation entity by id.
func (m *SourceControlMutation) SetBazelInvocationID(id int64) {
	m.bazel_invocation = &id
}

// ClearBazelInvocation clears the "bazel_invocation" edge to the BazelInvocation entity.
func (m *SourceControlMutation) ClearBazelInvocation() {
	m.clearedbazel_invocation = true
}

// BazelInvocationCleared reports if the "bazel_invocation" edge to the BazelInvocation entity was cleared.
func (m *SourceControlMutation) BazelInvocationCleared() bool {
	return m.clearedbazel_invocation
}

// BazelInvocationID returns the "bazel_invocation" edge ID in the mutation.
func (m *SourceControlMutation) BazelInvocationID() (id int64, exists bool) {
	if m.bazel_invocation != nil {
		return *m.bazel_invocation, true
	}
	return
}

// BazelInvocationIDs returns the "bazel_invocation" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BazelInvocationID instead. It exists only for internal usage by the builders.
func (m *SourceControlMutation) BazelInvocationIDs() (ids []int64) {
	if id := m.bazel_invocation; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBazelInvocation resets all changes to the "bazel_invocation" edge.
func (m *SourceControlMutation) ResetBazelInvocation() {
	m.bazel_invocation = nil
	m.clearedbazel_invocation = false
}

// Where appends a list predicates to the SourceControlMutation builder.
func (m *SourceControlMutation) Where(ps ...predicate.SourceControl) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SourceControlMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SourceControlMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SourceControl, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SourceControlMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SourceControlMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SourceControl).
func (m *SourceControlMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SourceControlMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.provider != nil {
		fields = append(fields, sourcecontrol.FieldProvider)
	}
	if m.instance_url != nil {
		fields = append(fields, sourcecontrol.FieldInstanceURL)
	}
	if m.repo != nil {
		fields = append(fields, sourcecontrol.FieldRepo)
	}
	if m.refs != nil {
		fields = append(fields, sourcecontrol.FieldRefs)
	}
	if m.commit_sha != nil {
		fields = append(fields, sourcecontrol.FieldCommitSha)
	}
	if m.actor != nil {
		fields = append(fields, sourcecontrol.FieldActor)
	}
	if m.event_name != nil {
		fields = append(fields, sourcecontrol.FieldEventName)
	}
	if m.workflow != nil {
		fields = append(fields, sourcecontrol.FieldWorkflow)
	}
	if m.run_id != nil {
		fields = append(fields, sourcecontrol.FieldRunID)
	}
	if m.run_number != nil {
		fields = append(fields, sourcecontrol.FieldRunNumber)
	}
	if m.job != nil {
		fields = append(fields, sourcecontrol.FieldJob)
	}
	if m.action != nil {
		fields = append(fields, sourcecontrol.FieldAction)
	}
	if m.runner_name != nil {
		fields = append(fields, sourcecontrol.FieldRunnerName)
	}
	if m.runner_arch != nil {
		fields = append(fields, sourcecontrol.FieldRunnerArch)
	}
	if m.runner_os != nil {
		fields = append(fields, sourcecontrol.FieldRunnerOs)
	}
	if m.workspace != nil {
		fields = append(fields, sourcecontrol.FieldWorkspace)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SourceControlMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sourcecontrol.FieldProvider:
		return m.Provider()
	case sourcecontrol.FieldInstanceURL:
		return m.InstanceURL()
	case sourcecontrol.FieldRepo:
		return m.Repo()
	case sourcecontrol.FieldRefs:
		return m.Refs()
	case sourcecontrol.FieldCommitSha:
		return m.CommitSha()
	case sourcecontrol.FieldActor:
		return m.Actor()
	case sourcecontrol.FieldEventName:
		return m.EventName()
	case sourcecontrol.FieldWorkflow:
		return m.Workflow()
	case sourcecontrol.FieldRunID:
		return m.RunID()
	case sourcecontrol.FieldRunNumber:
		return m.RunNumber()
	case sourcecontrol.FieldJob:
		return m.Job()
	case sourcecontrol.FieldAction:
		return m.Action()
	case sourcecontrol.FieldRunnerName:
		return m.RunnerName()
	case sourcecontrol.FieldRunnerArch:
		return m.RunnerArch()
	case sourcecontrol.FieldRunnerOs:
		return m.RunnerOs()
	case sourcecontrol.FieldWorkspace:
		return m.Workspace()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SourceControlMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sourcecontrol.FieldProvider:
		return m.OldProvider(ctx)
	case sourcecontrol.FieldInstanceURL:
		return m.OldInstanceURL(ctx)
	case sourcecontrol.FieldRepo:
		return m.OldRepo(ctx)
	case sourcecontrol.FieldRefs:
		return m.OldRefs(ctx)
	case sourcecontrol.FieldCommitSha:
		return m.OldCommitSha(ctx)
	case sourcecontrol.FieldActor:
		return m.OldActor(ctx)
	case sourcecontrol.FieldEventName:
		return m.OldEventName(ctx)
	case sourcecontrol.FieldWorkflow:
		return m.OldWorkflow(ctx)
	case sourcecontrol.FieldRunID:
		return m.OldRunID(ctx)
	case sourcecontrol.FieldRunNumber:
		return m.OldRunNumber(ctx)
	case sourcecontrol.FieldJob:
		return m.OldJob(ctx)
	case sourcecontrol.FieldAction:
		return m.OldAction(ctx)
	case sourcecontrol.FieldRunnerName:
		return m.OldRunnerName(ctx)
	case sourcecontrol.FieldRunnerArch:
		return m.OldRunnerArch(ctx)
	case sourcecontrol.FieldRunnerOs:
		return m.OldRunnerOs(ctx)
	case sourcecontrol.FieldWorkspace:
		return m.OldWorkspace(ctx)
	}
	return nil, fmt.Errorf("unknown SourceControl field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SourceControlMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sourcecontrol.FieldProvider:
		v, ok := value.(sourcecontrol.Provider)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvider(v)
		return nil
	case sourcecontrol.FieldInstanceURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstanceURL(v)
		return nil
	case sourcecontrol.FieldRepo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRepo(v)
		return nil
	case sourcecontrol.FieldRefs:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefs(v)
		return nil
	case sourcecontrol.FieldCommitSha:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommitSha(v)
		return nil
	case sourcecontrol.FieldActor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActor(v)
		return nil
	case sourcecontrol.FieldEventName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventName(v)
		return nil
	case sourcecontrol.FieldWorkflow:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkflow(v)
		return nil
	case sourcecontrol.FieldRunID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRunID(v)
		return nil
	case sourcecontrol.FieldRunNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRunNumber(v)
		return nil
	case sourcecontrol.FieldJob:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJob(v)
		return nil
	case sourcecontrol.FieldAction:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case sourcecontrol.FieldRunnerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRunnerName(v)
		return nil
	case sourcecontrol.FieldRunnerArch:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRunnerArch(v)
		return nil
	case sourcecontrol.FieldRunnerOs:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRunnerOs(v)
		return nil
	case sourcecontrol.FieldWorkspace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkspace(v)
		return nil
	}
	return fmt.Errorf("unknown SourceControl field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SourceControlMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SourceControlMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SourceControlMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SourceControl numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SourceControlMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sourcecontrol.FieldProvider) {
		fields = append(fields, sourcecontrol.FieldProvider)
	}
	if m.FieldCleared(sourcecontrol.FieldInstanceURL) {
		fields = append(fields, sourcecontrol.FieldInstanceURL)
	}
	if m.FieldCleared(sourcecontrol.FieldRepo) {
		fields = append(fields, sourcecontrol.FieldRepo)
	}
	if m.FieldCleared(sourcecontrol.FieldRefs) {
		fields = append(fields, sourcecontrol.FieldRefs)
	}
	if m.FieldCleared(sourcecontrol.FieldCommitSha) {
		fields = append(fields, sourcecontrol.FieldCommitSha)
	}
	if m.FieldCleared(sourcecontrol.FieldActor) {
		fields = append(fields, sourcecontrol.FieldActor)
	}
	if m.FieldCleared(sourcecontrol.FieldEventName) {
		fields = append(fields, sourcecontrol.FieldEventName)
	}
	if m.FieldCleared(sourcecontrol.FieldWorkflow) {
		fields = append(fields, sourcecontrol.FieldWorkflow)
	}
	if m.FieldCleared(sourcecontrol.FieldRunID) {
		fields = append(fields, sourcecontrol.FieldRunID)
	}
	if m.FieldCleared(sourcecontrol.FieldRunNumber) {
		fields = append(fields, sourcecontrol.FieldRunNumber)
	}
	if m.FieldCleared(sourcecontrol.FieldJob) {
		fields = append(fields, sourcecontrol.FieldJob)
	}
	if m.FieldCleared(sourcecontrol.FieldAction) {
		fields = append(fields, sourcecontrol.FieldAction)
	}
	if m.FieldCleared(sourcecontrol.FieldRunnerName) {
		fields = append(fields, sourcecontrol.FieldRunnerName)
	}
	if m.FieldCleared(sourcecontrol.FieldRunnerArch) {
		fields = append(fields, sourcecontrol.FieldRunnerArch)
	}
	if m.FieldCleared(sourcecontrol.FieldRunnerOs) {
		fields = append(fields, sourcecontrol.FieldRunnerOs)
	}
	if m.FieldCleared(sourcecontrol.FieldWorkspace) {
		fields = append(fields, sourcecontrol.FieldWorkspace)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SourceControlMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SourceControlMutation) ClearField(name string) error {
	switch name {
	case sourcecontrol.FieldProvider:
		m.ClearProvider()
		return nil
	case sourcecontrol.FieldInstanceURL:
		m.ClearInstanceURL()
		return nil
	case sourcecontrol.FieldRepo:
		m.ClearRepo()
		return nil
	case sourcecontrol.FieldRefs:
		m.ClearRefs()
		return nil
	case sourcecontrol.FieldCommitSha:
		m.ClearCommitSha()
		return nil
	case sourcecontrol.FieldActor:
		m.ClearActor()
		return nil
	case sourcecontrol.FieldEventName:
		m.ClearEventName()
		return nil
	case sourcecontrol.FieldWorkflow:
		m.ClearWorkflow()
		return nil
	case sourcecontrol.FieldRunID:
		m.ClearRunID()
		return nil
	case sourcecontrol.FieldRunNumber:
		m.ClearRunNumber()
		return nil
	case sourcecontrol.FieldJob:
		m.ClearJob()
		return nil
	case sourcecontrol.FieldAction:
		m.ClearAction()
		return nil
	case sourcecontrol.FieldRunnerName:
		m.ClearRunnerName()
		return nil
	case sourcecontrol.FieldRunnerArch:
		m.ClearRunnerArch()
		return nil
	case sourcecontrol.FieldRunnerOs:
		m.ClearRunnerOs()
		return nil
	case sourcecontrol.FieldWorkspace:
		m.ClearWorkspace()
		return nil
	}
	return fmt.Errorf("unknown SourceControl nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SourceControlMutation) ResetField(name string) error {
	switch name {
	case sourcecontrol.FieldProvider:
		m.ResetProvider()
		return nil
	case sourcecontrol.FieldInstanceURL:
		m.ResetInstanceURL()
		return nil
	case sourcecontrol.FieldRepo:
		m.ResetRepo()
		return nil
	case sourcecontrol.FieldRefs:
		m.ResetRefs()
		return nil
	case sourcecontrol.FieldCommitSha:
		m.ResetCommitSha()
		return nil
	case sourcecontrol.FieldActor:
		m.ResetActor()
		return nil
	case sourcecontrol.FieldEventName:
		m.ResetEventName()
		return nil
	case sourcecontrol.FieldWorkflow:
		m.ResetWorkflow()
		return nil
	case sourcecontrol.FieldRunID:
		m.ResetRunID()
		return nil
	case sourcecontrol.FieldRunNumber:
		m.ResetRunNumber()
		return nil
	case sourcecontrol.FieldJob:
		m.ResetJob()
		return nil
	case sourcecontrol.FieldAction:
		m.ResetAction()
		return nil
	case sourcecontrol.FieldRunnerName:
		m.ResetRunnerName()
		return nil
	case sourcecontrol.FieldRunnerArch:
		m.ResetRunnerArch()
		return nil
	case sourcecontrol.FieldRunnerOs:
		m.ResetRunnerOs()
		return nil
	case sourcecontrol.FieldWorkspace:
		m.ResetWorkspace()
		return nil
	}
	return fmt.Errorf("unknown SourceControl field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SourceControlMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.bazel_invocation != nil {
		edges = append(edges, sourcecontrol.EdgeBazelInvocation)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SourceControlMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sourcecontrol.EdgeBazelInvocation:
		if id := m.bazel_invocation; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SourceControlMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SourceControlMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SourceControlMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbazel_invocation {
		edges = append(edges, sourcecontrol.EdgeBazelInvocation)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SourceControlMutation) EdgeCleared(name string) bool {
	switch name {
	case sourcecontrol.EdgeBazelInvocation:
		return m.clearedbazel_invocation
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SourceControlMutation) ClearEdge(name string) error {
	switch name {
	case sourcecontrol.EdgeBazelInvocation:
		m.ClearBazelInvocation()
		return nil
	}
	return fmt.Errorf("unknown SourceControl unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SourceControlMutation) ResetEdge(name string) error {
	switch name {
	case sourcecontrol.EdgeBazelInvocation:
		m.ResetBazelInvocation()
		return nil
	}
	return fmt.Errorf("unknown SourceControl edge %s", name)
}

// SystemNetworkStatsMutation represents an operation that mutates the SystemNetworkStats nodes in the graph.
type SystemNetworkStatsMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int64
	bytes_sent                   *uint64
	addbytes_sent                *int64
	bytes_recv                   *uint64
	addbytes_recv                *int64
	packets_sent                 *uint64
	addpackets_sent              *int64
	packets_recv                 *uint64
	addpackets_recv              *int64
	peak_bytes_sent_per_sec      *uint64
	addpeak_bytes_sent_per_sec   *int64
	peak_bytes_recv_per_sec      *uint64
	addpeak_bytes_recv_per_sec   *int64
	peak_packets_sent_per_sec    *uint64
	addpeak_packets_sent_per_sec *int64
	peak_packets_recv_per_sec    *uint64
	addpeak_packets_recv_per_sec *int64
	clearedFields                map[string]struct{}
	network_metrics              *int64
	clearednetwork_metrics       bool
	done                         bool
	oldValue                     func(context.Context) (*SystemNetworkStats, error)
	predicates                   []predicate.SystemNetworkStats
}

var _ ent.Mutation = (*SystemNetworkStatsMutation)(nil)

// systemnetworkstatsOption allows management of the mutation configuration using functional options.
type systemnetworkstatsOption func(*SystemNetworkStatsMutation)

// newSystemNetworkStatsMutation creates new mutation for the SystemNetworkStats entity.
func newSystemNetworkStatsMutation(c config, op Op, opts ...systemnetworkstatsOption) *SystemNetworkStatsMutation {
	m := &SystemNetworkStatsMutation{
		config:        c,
		op:            op,
		typ:           TypeSystemNetworkStats,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSystemNetworkStatsID sets the ID field of the mutation.
func withSystemNetworkStatsID(id int64) systemnetworkstatsOption {
	return func(m *SystemNetworkStatsMutation) {
		var (
			err   error
			once  sync.Once
			value *SystemNetworkStats
		)
		m.oldValue = func(ctx context.Context) (*SystemNetworkStats, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SystemNetworkStats.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSystemNetworkStats sets the old SystemNetworkStats of the mutation.
func withSystemNetworkStats(node *SystemNetworkStats) systemnetworkstatsOption {
	return func(m *SystemNetworkStatsMutation) {
		m.oldValue = func(context.Context) (*SystemNetworkStats, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SystemNetworkStatsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SystemNetworkStatsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SystemNetworkStats entities.
func (m *SystemNetworkStatsMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SystemNetworkStatsMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SystemNetworkStatsMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SystemNetworkStats.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBytesSent sets the "bytes_sent" field.
func (m *SystemNetworkStatsMutation) SetBytesSent(u uint64) {
	m.bytes_sent = &u
	m.addbytes_sent = nil
}

// BytesSent returns the value of the "bytes_sent" field in the mutation.
func (m *SystemNetworkStatsMutation) BytesSent() (r uint64, exists bool) {
	v := m.bytes_sent
	if v == nil {
		return
	}
	return *v, true
}

// OldBytesSent returns the old "bytes_sent" field's value of the SystemNetworkStats entity.
// If the SystemNetworkStats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemNetworkStatsMutation) OldBytesSent(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBytesSent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBytesSent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBytesSent: %w", err)
	}
	return oldValue.BytesSent, nil
}

// AddBytesSent adds u to the "bytes_sent" field.
func (m *SystemNetworkStatsMutation) AddBytesSent(u int64) {
	if m.addbytes_sent != nil {
		*m.addbytes_sent += u
	} else {
		m.addbytes_sent = &u
	}
}

// AddedBytesSent returns the value that was added to the "bytes_sent" field in this mutation.
func (m *SystemNetworkStatsMutation) AddedBytesSent() (r int64, exists bool) {
	v := m.addbytes_sent
	if v == nil {
		return
	}
	return *v, true
}

// ClearBytesSent clears the value of the "bytes_sent" field.
func (m *SystemNetworkStatsMutation) ClearBytesSent() {
	m.bytes_sent = nil
	m.addbytes_sent = nil
	m.clearedFields[systemnetworkstats.FieldBytesSent] = struct{}{}
}

// BytesSentCleared returns if the "bytes_sent" field was cleared in this mutation.
func (m *SystemNetworkStatsMutation) BytesSentCleared() bool {
	_, ok := m.clearedFields[systemnetworkstats.FieldBytesSent]
	return ok
}

// ResetBytesSent resets all changes to the "bytes_sent" field.
func (m *SystemNetworkStatsMutation) ResetBytesSent() {
	m.bytes_sent = nil
	m.addbytes_sent = nil
	delete(m.clearedFields, systemnetworkstats.FieldBytesSent)
}

// SetBytesRecv sets the "bytes_recv" field.
func (m *SystemNetworkStatsMutation) SetBytesRecv(u uint64) {
	m.bytes_recv = &u
	m.addbytes_recv = nil
}

// BytesRecv returns the value of the "bytes_recv" field in the mutation.
func (m *SystemNetworkStatsMutation) BytesRecv() (r uint64, exists bool) {
	v := m.bytes_recv
	if v == nil {
		return
	}
	return *v, true
}

// OldBytesRecv returns the old "bytes_recv" field's value of the SystemNetworkStats entity.
// If the SystemNetworkStats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemNetworkStatsMutation) OldBytesRecv(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBytesRecv is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBytesRecv requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBytesRecv: %w", err)
	}
	return oldValue.BytesRecv, nil
}

// AddBytesRecv adds u to the "bytes_recv" field.
func (m *SystemNetworkStatsMutation) AddBytesRecv(u int64) {
	if m.addbytes_recv != nil {
		*m.addbytes_recv += u
	} else {
		m.addbytes_recv = &u
	}
}

// AddedBytesRecv returns the value that was added to the "bytes_recv" field in this mutation.
func (m *SystemNetworkStatsMutation) AddedBytesRecv() (r int64, exists bool) {
	v := m.addbytes_recv
	if v == nil {
		return
	}
	return *v, true
}

// ClearBytesRecv clears the value of the "bytes_recv" field.
func (m *SystemNetworkStatsMutation) ClearBytesRecv() {
	m.bytes_recv = nil
	m.addbytes_recv = nil
	m.clearedFields[systemnetworkstats.FieldBytesRecv] = struct{}{}
}

// BytesRecvCleared returns if the "bytes_recv" field was cleared in this mutation.
func (m *SystemNetworkStatsMutation) BytesRecvCleared() bool {
	_, ok := m.clearedFields[systemnetworkstats.FieldBytesRecv]
	return ok
}

// ResetBytesRecv resets all changes to the "bytes_recv" field.
func (m *SystemNetworkStatsMutation) ResetBytesRecv() {
	m.bytes_recv = nil
	m.addbytes_recv = nil
	delete(m.clearedFields, systemnetworkstats.FieldBytesRecv)
}

// SetPacketsSent sets the "packets_sent" field.
func (m *SystemNetworkStatsMutation) SetPacketsSent(u uint64) {
	m.packets_sent = &u
	m.addpackets_sent = nil
}

// PacketsSent returns the value of the "packets_sent" field in the mutation.
func (m *SystemNetworkStatsMutation) PacketsSent() (r uint64, exists bool) {
	v := m.packets_sent
	if v == nil {
		return
	}
	return *v, true
}

// OldPacketsSent returns the old "packets_sent" field's value of the SystemNetworkStats entity.
// If the SystemNetworkStats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemNetworkStatsMutation) OldPacketsSent(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPacketsSent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPacketsSent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPacketsSent: %w", err)
	}
	return oldValue.PacketsSent, nil
}

// AddPacketsSent adds u to the "packets_sent" field.
func (m *SystemNetworkStatsMutation) AddPacketsSent(u int64) {
	if m.addpackets_sent != nil {
		*m.addpackets_sent += u
	} else {
		m.addpackets_sent = &u
	}
}

// AddedPacketsSent returns the value that was added to the "packets_sent" field in this mutation.
func (m *SystemNetworkStatsMutation) AddedPacketsSent() (r int64, exists bool) {
	v := m.addpackets_sent
	if v == nil {
		return
	}
	return *v, true
}

// ClearPacketsSent clears the value of the "packets_sent" field.
func (m *SystemNetworkStatsMutation) ClearPacketsSent() {
	m.packets_sent = nil
	m.addpackets_sent = nil
	m.clearedFields[systemnetworkstats.FieldPacketsSent] = struct{}{}
}

// PacketsSentCleared returns if the "packets_sent" field was cleared in this mutation.
func (m *SystemNetworkStatsMutation) PacketsSentCleared() bool {
	_, ok := m.clearedFields[systemnetworkstats.FieldPacketsSent]
	return ok
}

// ResetPacketsSent resets all changes to the "packets_sent" field.
func (m *SystemNetworkStatsMutation) ResetPacketsSent() {
	m.packets_sent = nil
	m.addpackets_sent = nil
	delete(m.clearedFields, systemnetworkstats.FieldPacketsSent)
}

// SetPacketsRecv sets the "packets_recv" field.
func (m *SystemNetworkStatsMutation) SetPacketsRecv(u uint64) {
	m.packets_recv = &u
	m.addpackets_recv = nil
}

// PacketsRecv returns the value of the "packets_recv" field in the mutation.
func (m *SystemNetworkStatsMutation) PacketsRecv() (r uint64, exists bool) {
	v := m.packets_recv
	if v == nil {
		return
	}
	return *v, true
}

// OldPacketsRecv returns the old "packets_recv" field's value of the SystemNetworkStats entity.
// If the SystemNetworkStats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemNetworkStatsMutation) OldPacketsRecv(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPacketsRecv is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPacketsRecv requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPacketsRecv: %w", err)
	}
	return oldValue.PacketsRecv, nil
}

// AddPacketsRecv adds u to the "packets_recv" field.
func (m *SystemNetworkStatsMutation) AddPacketsRecv(u int64) {
	if m.addpackets_recv != nil {
		*m.addpackets_recv += u
	} else {
		m.addpackets_recv = &u
	}
}

// AddedPacketsRecv returns the value that was added to the "packets_recv" field in this mutation.
func (m *SystemNetworkStatsMutation) AddedPacketsRecv() (r int64, exists bool) {
	v := m.addpackets_recv
	if v == nil {
		return
	}
	return *v, true
}

// ClearPacketsRecv clears the value of the "packets_recv" field.
func (m *SystemNetworkStatsMutation) ClearPacketsRecv() {
	m.packets_recv = nil
	m.addpackets_recv = nil
	m.clearedFields[systemnetworkstats.FieldPacketsRecv] = struct{}{}
}

// PacketsRecvCleared returns if the "packets_recv" field was cleared in this mutation.
func (m *SystemNetworkStatsMutation) PacketsRecvCleared() bool {
	_, ok := m.clearedFields[systemnetworkstats.FieldPacketsRecv]
	return ok
}

// ResetPacketsRecv resets all changes to the "packets_recv" field.
func (m *SystemNetworkStatsMutation) ResetPacketsRecv() {
	m.packets_recv = nil
	m.addpackets_recv = nil
	delete(m.clearedFields, systemnetworkstats.FieldPacketsRecv)
}

// SetPeakBytesSentPerSec sets the "peak_bytes_sent_per_sec" field.
func (m *SystemNetworkStatsMutation) SetPeakBytesSentPerSec(u uint64) {
	m.peak_bytes_sent_per_sec = &u
	m.addpeak_bytes_sent_per_sec = nil
}

// PeakBytesSentPerSec returns the value of the "peak_bytes_sent_per_sec" field in the mutation.
func (m *SystemNetworkStatsMutation) PeakBytesSentPerSec() (r uint64, exists bool) {
	v := m.peak_bytes_sent_per_sec
	if v == nil {
		return
	}
	return *v, true
}

// OldPeakBytesSentPerSec returns the old "peak_bytes_sent_per_sec" field's value of the SystemNetworkStats entity.
// If the SystemNetworkStats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemNetworkStatsMutation) OldPeakBytesSentPerSec(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPeakBytesSentPerSec is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPeakBytesSentPerSec requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPeakBytesSentPerSec: %w", err)
	}
	return oldValue.PeakBytesSentPerSec, nil
}

// AddPeakBytesSentPerSec adds u to the "peak_bytes_sent_per_sec" field.
func (m *SystemNetworkStatsMutation) AddPeakBytesSentPerSec(u int64) {
	if m.addpeak_bytes_sent_per_sec != nil {
		*m.addpeak_bytes_sent_per_sec += u
	} else {
		m.addpeak_bytes_sent_per_sec = &u
	}
}

// AddedPeakBytesSentPerSec returns the value that was added to the "peak_bytes_sent_per_sec" field in this mutation.
func (m *SystemNetworkStatsMutation) AddedPeakBytesSentPerSec() (r int64, exists bool) {
	v := m.addpeak_bytes_sent_per_sec
	if v == nil {
		return
	}
	return *v, true
}

// ClearPeakBytesSentPerSec clears the value of the "peak_bytes_sent_per_sec" field.
func (m *SystemNetworkStatsMutation) ClearPeakBytesSentPerSec() {
	m.peak_bytes_sent_per_sec = nil
	m.addpeak_bytes_sent_per_sec = nil
	m.clearedFields[systemnetworkstats.FieldPeakBytesSentPerSec] = struct{}{}
}

// PeakBytesSentPerSecCleared returns if the "peak_bytes_sent_per_sec" field was cleared in this mutation.
func (m *SystemNetworkStatsMutation) PeakBytesSentPerSecCleared() bool {
	_, ok := m.clearedFields[systemnetworkstats.FieldPeakBytesSentPerSec]
	return ok
}

// ResetPeakBytesSentPerSec resets all changes to the "peak_bytes_sent_per_sec" field.
func (m *SystemNetworkStatsMutation) ResetPeakBytesSentPerSec() {
	m.peak_bytes_sent_per_sec = nil
	m.addpeak_bytes_sent_per_sec = nil
	delete(m.clearedFields, systemnetworkstats.FieldPeakBytesSentPerSec)
}

// SetPeakBytesRecvPerSec sets the "peak_bytes_recv_per_sec" field.
func (m *SystemNetworkStatsMutation) SetPeakBytesRecvPerSec(u uint64) {
	m.peak_bytes_recv_per_sec = &u
	m.addpeak_bytes_recv_per_sec = nil
}

// PeakBytesRecvPerSec returns the value of the "peak_bytes_recv_per_sec" field in the mutation.
func (m *SystemNetworkStatsMutation) PeakBytesRecvPerSec() (r uint64, exists bool) {
	v := m.peak_bytes_recv_per_sec
	if v == nil {
		return
	}
	return *v, true
}

// OldPeakBytesRecvPerSec returns the old "peak_bytes_recv_per_sec" field's value of the SystemNetworkStats entity.
// If the SystemNetworkStats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemNetworkStatsMutation) OldPeakBytesRecvPerSec(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPeakBytesRecvPerSec is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPeakBytesRecvPerSec requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPeakBytesRecvPerSec: %w", err)
	}
	return oldValue.PeakBytesRecvPerSec, nil
}

// AddPeakBytesRecvPerSec adds u to the "peak_bytes_recv_per_sec" field.
func (m *SystemNetworkStatsMutation) AddPeakBytesRecvPerSec(u int64) {
	if m.addpeak_bytes_recv_per_sec != nil {
		*m.addpeak_bytes_recv_per_sec += u
	} else {
		m.addpeak_bytes_recv_per_sec = &u
	}
}

// AddedPeakBytesRecvPerSec returns the value that was added to the "peak_bytes_recv_per_sec" field in this mutation.
func (m *SystemNetworkStatsMutation) AddedPeakBytesRecvPerSec() (r int64, exists bool) {
	v := m.addpeak_bytes_recv_per_sec
	if v == nil {
		return
	}
	return *v, true
}

// ClearPeakBytesRecvPerSec clears the value of the "peak_bytes_recv_per_sec" field.
func (m *SystemNetworkStatsMutation) ClearPeakBytesRecvPerSec() {
	m.peak_bytes_recv_per_sec = nil
	m.addpeak_bytes_recv_per_sec = nil
	m.clearedFields[systemnetworkstats.FieldPeakBytesRecvPerSec] = struct{}{}
}

// PeakBytesRecvPerSecCleared returns if the "peak_bytes_recv_per_sec" field was cleared in this mutation.
func (m *SystemNetworkStatsMutation) PeakBytesRecvPerSecCleared() bool {
	_, ok := m.clearedFields[systemnetworkstats.FieldPeakBytesRecvPerSec]
	return ok
}

// ResetPeakBytesRecvPerSec resets all changes to the "peak_bytes_recv_per_sec" field.
func (m *SystemNetworkStatsMutation) ResetPeakBytesRecvPerSec() {
	m.peak_bytes_recv_per_sec = nil
	m.addpeak_bytes_recv_per_sec = nil
	delete(m.clearedFields, systemnetworkstats.FieldPeakBytesRecvPerSec)
}

// SetPeakPacketsSentPerSec sets the "peak_packets_sent_per_sec" field.
func (m *SystemNetworkStatsMutation) SetPeakPacketsSentPerSec(u uint64) {
	m.peak_packets_sent_per_sec = &u
	m.addpeak_packets_sent_per_sec = nil
}

// PeakPacketsSentPerSec returns the value of the "peak_packets_sent_per_sec" field in the mutation.
func (m *SystemNetworkStatsMutation) PeakPacketsSentPerSec() (r uint64, exists bool) {
	v := m.peak_packets_sent_per_sec
	if v == nil {
		return
	}
	return *v, true
}

// OldPeakPacketsSentPerSec returns the old "peak_packets_sent_per_sec" field's value of the SystemNetworkStats entity.
// If the SystemNetworkStats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemNetworkStatsMutation) OldPeakPacketsSentPerSec(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPeakPacketsSentPerSec is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPeakPacketsSentPerSec requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPeakPacketsSentPerSec: %w", err)
	}
	return oldValue.PeakPacketsSentPerSec, nil
}

// AddPeakPacketsSentPerSec adds u to the "peak_packets_sent_per_sec" field.
func (m *SystemNetworkStatsMutation) AddPeakPacketsSentPerSec(u int64) {
	if m.addpeak_packets_sent_per_sec != nil {
		*m.addpeak_packets_sent_per_sec += u
	} else {
		m.addpeak_packets_sent_per_sec = &u
	}
}

// AddedPeakPacketsSentPerSec returns the value that was added to the "peak_packets_sent_per_sec" field in this mutation.
func (m *SystemNetworkStatsMutation) AddedPeakPacketsSentPerSec() (r int64, exists bool) {
	v := m.addpeak_packets_sent_per_sec
	if v == nil {
		return
	}
	return *v, true
}

// ClearPeakPacketsSentPerSec clears the value of the "peak_packets_sent_per_sec" field.
func (m *SystemNetworkStatsMutation) ClearPeakPacketsSentPerSec() {
	m.peak_packets_sent_per_sec = nil
	m.addpeak_packets_sent_per_sec = nil
	m.clearedFields[systemnetworkstats.FieldPeakPacketsSentPerSec] = struct{}{}
}

// PeakPacketsSentPerSecCleared returns if the "peak_packets_sent_per_sec" field was cleared in this mutation.
func (m *SystemNetworkStatsMutation) PeakPacketsSentPerSecCleared() bool {
	_, ok := m.clearedFields[systemnetworkstats.FieldPeakPacketsSentPerSec]
	return ok
}

// ResetPeakPacketsSentPerSec resets all changes to the "peak_packets_sent_per_sec" field.
func (m *SystemNetworkStatsMutation) ResetPeakPacketsSentPerSec() {
	m.peak_packets_sent_per_sec = nil
	m.addpeak_packets_sent_per_sec = nil
	delete(m.clearedFields, systemnetworkstats.FieldPeakPacketsSentPerSec)
}

// SetPeakPacketsRecvPerSec sets the "peak_packets_recv_per_sec" field.
func (m *SystemNetworkStatsMutation) SetPeakPacketsRecvPerSec(u uint64) {
	m.peak_packets_recv_per_sec = &u
	m.addpeak_packets_recv_per_sec = nil
}

// PeakPacketsRecvPerSec returns the value of the "peak_packets_recv_per_sec" field in the mutation.
func (m *SystemNetworkStatsMutation) PeakPacketsRecvPerSec() (r uint64, exists bool) {
	v := m.peak_packets_recv_per_sec
	if v == nil {
		return
	}
	return *v, true
}

// OldPeakPacketsRecvPerSec returns the old "peak_packets_recv_per_sec" field's value of the SystemNetworkStats entity.
// If the SystemNetworkStats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemNetworkStatsMutation) OldPeakPacketsRecvPerSec(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPeakPacketsRecvPerSec is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPeakPacketsRecvPerSec requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPeakPacketsRecvPerSec: %w", err)
	}
	return oldValue.PeakPacketsRecvPerSec, nil
}

// AddPeakPacketsRecvPerSec adds u to the "peak_packets_recv_per_sec" field.
func (m *SystemNetworkStatsMutation) AddPeakPacketsRecvPerSec(u int64) {
	if m.addpeak_packets_recv_per_sec != nil {
		*m.addpeak_packets_recv_per_sec += u
	} else {
		m.addpeak_packets_recv_per_sec = &u
	}
}

// AddedPeakPacketsRecvPerSec returns the value that was added to the "peak_packets_recv_per_sec" field in this mutation.
func (m *SystemNetworkStatsMutation) AddedPeakPacketsRecvPerSec() (r int64, exists bool) {
	v := m.addpeak_packets_recv_per_sec
	if v == nil {
		return
	}
	return *v, true
}

// ClearPeakPacketsRecvPerSec clears the value of the "peak_packets_recv_per_sec" field.
func (m *SystemNetworkStatsMutation) ClearPeakPacketsRecvPerSec() {
	m.peak_packets_recv_per_sec = nil
	m.addpeak_packets_recv_per_sec = nil
	m.clearedFields[systemnetworkstats.FieldPeakPacketsRecvPerSec] = struct{}{}
}

// PeakPacketsRecvPerSecCleared returns if the "peak_packets_recv_per_sec" field was cleared in this mutation.
func (m *SystemNetworkStatsMutation) PeakPacketsRecvPerSecCleared() bool {
	_, ok := m.clearedFields[systemnetworkstats.FieldPeakPacketsRecvPerSec]
	return ok
}

// ResetPeakPacketsRecvPerSec resets all changes to the "peak_packets_recv_per_sec" field.
func (m *SystemNetworkStatsMutation) ResetPeakPacketsRecvPerSec() {
	m.peak_packets_recv_per_sec = nil
	m.addpeak_packets_recv_per_sec = nil
	delete(m.clearedFields, systemnetworkstats.FieldPeakPacketsRecvPerSec)
}

// SetNetworkMetricsID sets the "network_metrics" edge to the NetworkMetrics entity by id.
func (m *SystemNetworkStatsMutation) SetNetworkMetricsID(id int64) {
	m.network_metrics = &id
}

// ClearNetworkMetrics clears the "network_metrics" edge to the NetworkMetrics entity.
func (m *SystemNetworkStatsMutation) ClearNetworkMetrics() {
	m.clearednetwork_metrics = true
}

// NetworkMetricsCleared reports if the "network_metrics" edge to the NetworkMetrics entity was cleared.
func (m *SystemNetworkStatsMutation) NetworkMetricsCleared() bool {
	return m.clearednetwork_metrics
}

// NetworkMetricsID returns the "network_metrics" edge ID in the mutation.
func (m *SystemNetworkStatsMutation) NetworkMetricsID() (id int64, exists bool) {
	if m.network_metrics != nil {
		return *m.network_metrics, true
	}
	return
}

// NetworkMetricsIDs returns the "network_metrics" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NetworkMetricsID instead. It exists only for internal usage by the builders.
func (m *SystemNetworkStatsMutation) NetworkMetricsIDs() (ids []int64) {
	if id := m.network_metrics; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNetworkMetrics resets all changes to the "network_metrics" edge.
func (m *SystemNetworkStatsMutation) ResetNetworkMetrics() {
	m.network_metrics = nil
	m.clearednetwork_metrics = false
}

// Where appends a list predicates to the SystemNetworkStatsMutation builder.
func (m *SystemNetworkStatsMutation) Where(ps ...predicate.SystemNetworkStats) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SystemNetworkStatsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SystemNetworkStatsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SystemNetworkStats, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SystemNetworkStatsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SystemNetworkStatsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SystemNetworkStats).
func (m *SystemNetworkStatsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SystemNetworkStatsMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.bytes_sent != nil {
		fields = append(fields, systemnetworkstats.FieldBytesSent)
	}
	if m.bytes_recv != nil {
		fields = append(fields, systemnetworkstats.FieldBytesRecv)
	}
	if m.packets_sent != nil {
		fields = append(fields, systemnetworkstats.FieldPacketsSent)
	}
	if m.packets_recv != nil {
		fields = append(fields, systemnetworkstats.FieldPacketsRecv)
	}
	if m.peak_bytes_sent_per_sec != nil {
		fields = append(fields, systemnetworkstats.FieldPeakBytesSentPerSec)
	}
	if m.peak_bytes_recv_per_sec != nil {
		fields = append(fields, systemnetworkstats.FieldPeakBytesRecvPerSec)
	}
	if m.peak_packets_sent_per_sec != nil {
		fields = append(fields, systemnetworkstats.FieldPeakPacketsSentPerSec)
	}
	if m.peak_packets_recv_per_sec != nil {
		fields = append(fields, systemnetworkstats.FieldPeakPacketsRecvPerSec)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SystemNetworkStatsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case systemnetworkstats.FieldBytesSent:
		return m.BytesSent()
	case systemnetworkstats.FieldBytesRecv:
		return m.BytesRecv()
	case systemnetworkstats.FieldPacketsSent:
		return m.PacketsSent()
	case systemnetworkstats.FieldPacketsRecv:
		return m.PacketsRecv()
	case systemnetworkstats.FieldPeakBytesSentPerSec:
		return m.PeakBytesSentPerSec()
	case systemnetworkstats.FieldPeakBytesRecvPerSec:
		return m.PeakBytesRecvPerSec()
	case systemnetworkstats.FieldPeakPacketsSentPerSec:
		return m.PeakPacketsSentPerSec()
	case systemnetworkstats.FieldPeakPacketsRecvPerSec:
		return m.PeakPacketsRecvPerSec()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SystemNetworkStatsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case systemnetworkstats.FieldBytesSent:
		return m.OldBytesSent(ctx)
	case systemnetworkstats.FieldBytesRecv:
		return m.OldBytesRecv(ctx)
	case systemnetworkstats.FieldPacketsSent:
		return m.OldPacketsSent(ctx)
	case systemnetworkstats.FieldPacketsRecv:
		return m.OldPacketsRecv(ctx)
	case systemnetworkstats.FieldPeakBytesSentPerSec:
		return m.OldPeakBytesSentPerSec(ctx)
	case systemnetworkstats.FieldPeakBytesRecvPerSec:
		return m.OldPeakBytesRecvPerSec(ctx)
	case systemnetworkstats.FieldPeakPacketsSentPerSec:
		return m.OldPeakPacketsSentPerSec(ctx)
	case systemnetworkstats.FieldPeakPacketsRecvPerSec:
		return m.OldPeakPacketsRecvPerSec(ctx)
	}
	return nil, fmt.Errorf("unknown SystemNetworkStats field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemNetworkStatsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case systemnetworkstats.FieldBytesSent:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBytesSent(v)
		return nil
	case systemnetworkstats.FieldBytesRecv:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBytesRecv(v)
		return nil
	case systemnetworkstats.FieldPacketsSent:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPacketsSent(v)
		return nil
	case systemnetworkstats.FieldPacketsRecv:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPacketsRecv(v)
		return nil
	case systemnetworkstats.FieldPeakBytesSentPerSec:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPeakBytesSentPerSec(v)
		return nil
	case systemnetworkstats.FieldPeakBytesRecvPerSec:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPeakBytesRecvPerSec(v)
		return nil
	case systemnetworkstats.FieldPeakPacketsSentPerSec:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPeakPacketsSentPerSec(v)
		return nil
	case systemnetworkstats.FieldPeakPacketsRecvPerSec:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPeakPacketsRecvPerSec(v)
		return nil
	}
	return fmt.Errorf("unknown SystemNetworkStats field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SystemNetworkStatsMutation) AddedFields() []string {
	var fields []string
	if m.addbytes_sent != nil {
		fields = append(fields, systemnetworkstats.FieldBytesSent)
	}
	if m.addbytes_recv != nil {
		fields = append(fields, systemnetworkstats.FieldBytesRecv)
	}
	if m.addpackets_sent != nil {
		fields = append(fields, systemnetworkstats.FieldPacketsSent)
	}
	if m.addpackets_recv != nil {
		fields = append(fields, systemnetworkstats.FieldPacketsRecv)
	}
	if m.addpeak_bytes_sent_per_sec != nil {
		fields = append(fields, systemnetworkstats.FieldPeakBytesSentPerSec)
	}
	if m.addpeak_bytes_recv_per_sec != nil {
		fields = append(fields, systemnetworkstats.FieldPeakBytesRecvPerSec)
	}
	if m.addpeak_packets_sent_per_sec != nil {
		fields = append(fields, systemnetworkstats.FieldPeakPacketsSentPerSec)
	}
	if m.addpeak_packets_recv_per_sec != nil {
		fields = append(fields, systemnetworkstats.FieldPeakPacketsRecvPerSec)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SystemNetworkStatsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case systemnetworkstats.FieldBytesSent:
		return m.AddedBytesSent()
	case systemnetworkstats.FieldBytesRecv:
		return m.AddedBytesRecv()
	case systemnetworkstats.FieldPacketsSent:
		return m.AddedPacketsSent()
	case systemnetworkstats.FieldPacketsRecv:
		return m.AddedPacketsRecv()
	case systemnetworkstats.FieldPeakBytesSentPerSec:
		return m.AddedPeakBytesSentPerSec()
	case systemnetworkstats.FieldPeakBytesRecvPerSec:
		return m.AddedPeakBytesRecvPerSec()
	case systemnetworkstats.FieldPeakPacketsSentPerSec:
		return m.AddedPeakPacketsSentPerSec()
	case systemnetworkstats.FieldPeakPacketsRecvPerSec:
		return m.AddedPeakPacketsRecvPerSec()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemNetworkStatsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case systemnetworkstats.FieldBytesSent:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBytesSent(v)
		return nil
	case systemnetworkstats.FieldBytesRecv:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBytesRecv(v)
		return nil
	case systemnetworkstats.FieldPacketsSent:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPacketsSent(v)
		return nil
	case systemnetworkstats.FieldPacketsRecv:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPacketsRecv(v)
		return nil
	case systemnetworkstats.FieldPeakBytesSentPerSec:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPeakBytesSentPerSec(v)
		return nil
	case systemnetworkstats.FieldPeakBytesRecvPerSec:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPeakBytesRecvPerSec(v)
		return nil
	case systemnetworkstats.FieldPeakPacketsSentPerSec:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPeakPacketsSentPerSec(v)
		return nil
	case systemnetworkstats.FieldPeakPacketsRecvPerSec:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPeakPacketsRecvPerSec(v)
		return nil
	}
	return fmt.Errorf("unknown SystemNetworkStats numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SystemNetworkStatsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(systemnetworkstats.FieldBytesSent) {
		fields = append(fields, systemnetworkstats.FieldBytesSent)
	}
	if m.FieldCleared(systemnetworkstats.FieldBytesRecv) {
		fields = append(fields, systemnetworkstats.FieldBytesRecv)
	}
	if m.FieldCleared(systemnetworkstats.FieldPacketsSent) {
		fields = append(fields, systemnetworkstats.FieldPacketsSent)
	}
	if m.FieldCleared(systemnetworkstats.FieldPacketsRecv) {
		fields = append(fields, systemnetworkstats.FieldPacketsRecv)
	}
	if m.FieldCleared(systemnetworkstats.FieldPeakBytesSentPerSec) {
		fields = append(fields, systemnetworkstats.FieldPeakBytesSentPerSec)
	}
	if m.FieldCleared(systemnetworkstats.FieldPeakBytesRecvPerSec) {
		fields = append(fields, systemnetworkstats.FieldPeakBytesRecvPerSec)
	}
	if m.FieldCleared(systemnetworkstats.FieldPeakPacketsSentPerSec) {
		fields = append(fields, systemnetworkstats.FieldPeakPacketsSentPerSec)
	}
	if m.FieldCleared(systemnetworkstats.FieldPeakPacketsRecvPerSec) {
		fields = append(fields, systemnetworkstats.FieldPeakPacketsRecvPerSec)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SystemNetworkStatsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SystemNetworkStatsMutation) ClearField(name string) error {
	switch name {
	case systemnetworkstats.FieldBytesSent:
		m.ClearBytesSent()
		return nil
	case systemnetworkstats.FieldBytesRecv:
		m.ClearBytesRecv()
		return nil
	case systemnetworkstats.FieldPacketsSent:
		m.ClearPacketsSent()
		return nil
	case systemnetworkstats.FieldPacketsRecv:
		m.ClearPacketsRecv()
		return nil
	case systemnetworkstats.FieldPeakBytesSentPerSec:
		m.ClearPeakBytesSentPerSec()
		return nil
	case systemnetworkstats.FieldPeakBytesRecvPerSec:
		m.ClearPeakBytesRecvPerSec()
		return nil
	case systemnetworkstats.FieldPeakPacketsSentPerSec:
		m.ClearPeakPacketsSentPerSec()
		return nil
	case systemnetworkstats.FieldPeakPacketsRecvPerSec:
		m.ClearPeakPacketsRecvPerSec()
		return nil
	}
	return fmt.Errorf("unknown SystemNetworkStats nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SystemNetworkStatsMutation) ResetField(name string) error {
	switch name {
	case systemnetworkstats.FieldBytesSent:
		m.ResetBytesSent()
		return nil
	case systemnetworkstats.FieldBytesRecv:
		m.ResetBytesRecv()
		return nil
	case systemnetworkstats.FieldPacketsSent:
		m.ResetPacketsSent()
		return nil
	case systemnetworkstats.FieldPacketsRecv:
		m.ResetPacketsRecv()
		return nil
	case systemnetworkstats.FieldPeakBytesSentPerSec:
		m.ResetPeakBytesSentPerSec()
		return nil
	case systemnetworkstats.FieldPeakBytesRecvPerSec:
		m.ResetPeakBytesRecvPerSec()
		return nil
	case systemnetworkstats.FieldPeakPacketsSentPerSec:
		m.ResetPeakPacketsSentPerSec()
		return nil
	case systemnetworkstats.FieldPeakPacketsRecvPerSec:
		m.ResetPeakPacketsRecvPerSec()
		return nil
	}
	return fmt.Errorf("unknown SystemNetworkStats field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SystemNetworkStatsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.network_metrics != nil {
		edges = append(edges, systemnetworkstats.EdgeNetworkMetrics)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SystemNetworkStatsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case systemnetworkstats.EdgeNetworkMetrics:
		if id := m.network_metrics; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SystemNetworkStatsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SystemNetworkStatsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SystemNetworkStatsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearednetwork_metrics {
		edges = append(edges, systemnetworkstats.EdgeNetworkMetrics)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SystemNetworkStatsMutation) EdgeCleared(name string) bool {
	switch name {
	case systemnetworkstats.EdgeNetworkMetrics:
		return m.clearednetwork_metrics
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SystemNetworkStatsMutation) ClearEdge(name string) error {
	switch name {
	case systemnetworkstats.EdgeNetworkMetrics:
		m.ClearNetworkMetrics()
		return nil
	}
	return fmt.Errorf("unknown SystemNetworkStats unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SystemNetworkStatsMutation) ResetEdge(name string) error {
	switch name {
	case systemnetworkstats.EdgeNetworkMetrics:
		m.ResetNetworkMetrics()
		return nil
	}
	return fmt.Errorf("unknown SystemNetworkStats edge %s", name)
}

// TargetMutation represents an operation that mutates the Target nodes in the graph.
type TargetMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int64
	label                       *string
	aspect                      *string
	target_kind                 *string
	clearedFields               map[string]struct{}
	instance_name               *int64
	clearedinstance_name        bool
	invocation_targets          map[int64]struct{}
	removedinvocation_targets   map[int64]struct{}
	clearedinvocation_targets   bool
	target_kind_mappings        map[int64]struct{}
	removedtarget_kind_mappings map[int64]struct{}
	clearedtarget_kind_mappings bool
	done                        bool
	oldValue                    func(context.Context) (*Target, error)
	predicates                  []predicate.Target
}

var _ ent.Mutation = (*TargetMutation)(nil)

// targetOption allows management of the mutation configuration using functional options.
type targetOption func(*TargetMutation)

// newTargetMutation creates new mutation for the Target entity.
func newTargetMutation(c config, op Op, opts ...targetOption) *TargetMutation {
	m := &TargetMutation{
		config:        c,
		op:            op,
		typ:           TypeTarget,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTargetID sets the ID field of the mutation.
func withTargetID(id int64) targetOption {
	return func(m *TargetMutation) {
		var (
			err   error
			once  sync.Once
			value *Target
		)
		m.oldValue = func(ctx context.Context) (*Target, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Target.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTarget sets the old Target of the mutation.
func withTarget(node *Target) targetOption {
	return func(m *TargetMutation) {
		m.oldValue = func(context.Context) (*Target, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TargetMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TargetMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Target entities.
func (m *TargetMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TargetMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TargetMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Target.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLabel sets the "label" field.
func (m *TargetMutation) SetLabel(s string) {
	m.label = &s
}

// Label returns the value of the "label" field in the mutation.
func (m *TargetMutation) Label() (r string, exists bool) {
	v := m.label
	if v == nil {
		return
	}
	return *v, true
}

// OldLabel returns the old "label" field's value of the Target entity.
// If the Target object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TargetMutation) OldLabel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabel: %w", err)
	}
	return oldValue.Label, nil
}

// ResetLabel resets all changes to the "label" field.
func (m *TargetMutation) ResetLabel() {
	m.label = nil
}

// SetAspect sets the "aspect" field.
func (m *TargetMutation) SetAspect(s string) {
	m.aspect = &s
}

// Aspect returns the value of the "aspect" field in the mutation.
func (m *TargetMutation) Aspect() (r string, exists bool) {
	v := m.aspect
	if v == nil {
		return
	}
	return *v, true
}

// OldAspect returns the old "aspect" field's value of the Target entity.
// If the Target object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TargetMutation) OldAspect(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAspect is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAspect requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAspect: %w", err)
	}
	return oldValue.Aspect, nil
}

// ResetAspect resets all changes to the "aspect" field.
func (m *TargetMutation) ResetAspect() {
	m.aspect = nil
}

// SetTargetKind sets the "target_kind" field.
func (m *TargetMutation) SetTargetKind(s string) {
	m.target_kind = &s
}

// TargetKind returns the value of the "target_kind" field in the mutation.
func (m *TargetMutation) TargetKind() (r string, exists bool) {
	v := m.target_kind
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetKind returns the old "target_kind" field's value of the Target entity.
// If the Target object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TargetMutation) OldTargetKind(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetKind: %w", err)
	}
	return oldValue.TargetKind, nil
}

// ResetTargetKind resets all changes to the "target_kind" field.
func (m *TargetMutation) ResetTargetKind() {
	m.target_kind = nil
}

// SetInstanceNameID sets the "instance_name" edge to the InstanceName entity by id.
func (m *TargetMutation) SetInstanceNameID(id int64) {
	m.instance_name = &id
}

// ClearInstanceName clears the "instance_name" edge to the InstanceName entity.
func (m *TargetMutation) ClearInstanceName() {
	m.clearedinstance_name = true
}

// InstanceNameCleared reports if the "instance_name" edge to the InstanceName entity was cleared.
func (m *TargetMutation) InstanceNameCleared() bool {
	return m.clearedinstance_name
}

// InstanceNameID returns the "instance_name" edge ID in the mutation.
func (m *TargetMutation) InstanceNameID() (id int64, exists bool) {
	if m.instance_name != nil {
		return *m.instance_name, true
	}
	return
}

// InstanceNameIDs returns the "instance_name" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InstanceNameID instead. It exists only for internal usage by the builders.
func (m *TargetMutation) InstanceNameIDs() (ids []int64) {
	if id := m.instance_name; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInstanceName resets all changes to the "instance_name" edge.
func (m *TargetMutation) ResetInstanceName() {
	m.instance_name = nil
	m.clearedinstance_name = false
}

// AddInvocationTargetIDs adds the "invocation_targets" edge to the InvocationTarget entity by ids.
func (m *TargetMutation) AddInvocationTargetIDs(ids ...int64) {
	if m.invocation_targets == nil {
		m.invocation_targets = make(map[int64]struct{})
	}
	for i := range ids {
		m.invocation_targets[ids[i]] = struct{}{}
	}
}

// ClearInvocationTargets clears the "invocation_targets" edge to the InvocationTarget entity.
func (m *TargetMutation) ClearInvocationTargets() {
	m.clearedinvocation_targets = true
}

// InvocationTargetsCleared reports if the "invocation_targets" edge to the InvocationTarget entity was cleared.
func (m *TargetMutation) InvocationTargetsCleared() bool {
	return m.clearedinvocation_targets
}

// RemoveInvocationTargetIDs removes the "invocation_targets" edge to the InvocationTarget entity by IDs.
func (m *TargetMutation) RemoveInvocationTargetIDs(ids ...int64) {
	if m.removedinvocation_targets == nil {
		m.removedinvocation_targets = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.invocation_targets, ids[i])
		m.removedinvocation_targets[ids[i]] = struct{}{}
	}
}

// RemovedInvocationTargets returns the removed IDs of the "invocation_targets" edge to the InvocationTarget entity.
func (m *TargetMutation) RemovedInvocationTargetsIDs() (ids []int64) {
	for id := range m.removedinvocation_targets {
		ids = append(ids, id)
	}
	return
}

// InvocationTargetsIDs returns the "invocation_targets" edge IDs in the mutation.
func (m *TargetMutation) InvocationTargetsIDs() (ids []int64) {
	for id := range m.invocation_targets {
		ids = append(ids, id)
	}
	return
}

// ResetInvocationTargets resets all changes to the "invocation_targets" edge.
func (m *TargetMutation) ResetInvocationTargets() {
	m.invocation_targets = nil
	m.clearedinvocation_targets = false
	m.removedinvocation_targets = nil
}

// AddTargetKindMappingIDs adds the "target_kind_mappings" edge to the TargetKindMapping entity by ids.
func (m *TargetMutation) AddTargetKindMappingIDs(ids ...int64) {
	if m.target_kind_mappings == nil {
		m.target_kind_mappings = make(map[int64]struct{})
	}
	for i := range ids {
		m.target_kind_mappings[ids[i]] = struct{}{}
	}
}

// ClearTargetKindMappings clears the "target_kind_mappings" edge to the TargetKindMapping entity.
func (m *TargetMutation) ClearTargetKindMappings() {
	m.clearedtarget_kind_mappings = true
}

// TargetKindMappingsCleared reports if the "target_kind_mappings" edge to the TargetKindMapping entity was cleared.
func (m *TargetMutation) TargetKindMappingsCleared() bool {
	return m.clearedtarget_kind_mappings
}

// RemoveTargetKindMappingIDs removes the "target_kind_mappings" edge to the TargetKindMapping entity by IDs.
func (m *TargetMutation) RemoveTargetKindMappingIDs(ids ...int64) {
	if m.removedtarget_kind_mappings == nil {
		m.removedtarget_kind_mappings = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.target_kind_mappings, ids[i])
		m.removedtarget_kind_mappings[ids[i]] = struct{}{}
	}
}

// RemovedTargetKindMappings returns the removed IDs of the "target_kind_mappings" edge to the TargetKindMapping entity.
func (m *TargetMutation) RemovedTargetKindMappingsIDs() (ids []int64) {
	for id := range m.removedtarget_kind_mappings {
		ids = append(ids, id)
	}
	return
}

// TargetKindMappingsIDs returns the "target_kind_mappings" edge IDs in the mutation.
func (m *TargetMutation) TargetKindMappingsIDs() (ids []int64) {
	for id := range m.target_kind_mappings {
		ids = append(ids, id)
	}
	return
}

// ResetTargetKindMappings resets all changes to the "target_kind_mappings" edge.
func (m *TargetMutation) ResetTargetKindMappings() {
	m.target_kind_mappings = nil
	m.clearedtarget_kind_mappings = false
	m.removedtarget_kind_mappings = nil
}

// Where appends a list predicates to the TargetMutation builder.
func (m *TargetMutation) Where(ps ...predicate.Target) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TargetMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TargetMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Target, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TargetMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TargetMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Target).
func (m *TargetMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TargetMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.label != nil {
		fields = append(fields, target.FieldLabel)
	}
	if m.aspect != nil {
		fields = append(fields, target.FieldAspect)
	}
	if m.target_kind != nil {
		fields = append(fields, target.FieldTargetKind)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TargetMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case target.FieldLabel:
		return m.Label()
	case target.FieldAspect:
		return m.Aspect()
	case target.FieldTargetKind:
		return m.TargetKind()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TargetMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case target.FieldLabel:
		return m.OldLabel(ctx)
	case target.FieldAspect:
		return m.OldAspect(ctx)
	case target.FieldTargetKind:
		return m.OldTargetKind(ctx)
	}
	return nil, fmt.Errorf("unknown Target field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TargetMutation) SetField(name string, value ent.Value) error {
	switch name {
	case target.FieldLabel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabel(v)
		return nil
	case target.FieldAspect:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAspect(v)
		return nil
	case target.FieldTargetKind:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetKind(v)
		return nil
	}
	return fmt.Errorf("unknown Target field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TargetMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TargetMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TargetMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Target numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TargetMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TargetMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TargetMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Target nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TargetMutation) ResetField(name string) error {
	switch name {
	case target.FieldLabel:
		m.ResetLabel()
		return nil
	case target.FieldAspect:
		m.ResetAspect()
		return nil
	case target.FieldTargetKind:
		m.ResetTargetKind()
		return nil
	}
	return fmt.Errorf("unknown Target field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TargetMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.instance_name != nil {
		edges = append(edges, target.EdgeInstanceName)
	}
	if m.invocation_targets != nil {
		edges = append(edges, target.EdgeInvocationTargets)
	}
	if m.target_kind_mappings != nil {
		edges = append(edges, target.EdgeTargetKindMappings)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TargetMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case target.EdgeInstanceName:
		if id := m.instance_name; id != nil {
			return []ent.Value{*id}
		}
	case target.EdgeInvocationTargets:
		ids := make([]ent.Value, 0, len(m.invocation_targets))
		for id := range m.invocation_targets {
			ids = append(ids, id)
		}
		return ids
	case target.EdgeTargetKindMappings:
		ids := make([]ent.Value, 0, len(m.target_kind_mappings))
		for id := range m.target_kind_mappings {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TargetMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedinvocation_targets != nil {
		edges = append(edges, target.EdgeInvocationTargets)
	}
	if m.removedtarget_kind_mappings != nil {
		edges = append(edges, target.EdgeTargetKindMappings)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TargetMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case target.EdgeInvocationTargets:
		ids := make([]ent.Value, 0, len(m.removedinvocation_targets))
		for id := range m.removedinvocation_targets {
			ids = append(ids, id)
		}
		return ids
	case target.EdgeTargetKindMappings:
		ids := make([]ent.Value, 0, len(m.removedtarget_kind_mappings))
		for id := range m.removedtarget_kind_mappings {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TargetMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedinstance_name {
		edges = append(edges, target.EdgeInstanceName)
	}
	if m.clearedinvocation_targets {
		edges = append(edges, target.EdgeInvocationTargets)
	}
	if m.clearedtarget_kind_mappings {
		edges = append(edges, target.EdgeTargetKindMappings)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TargetMutation) EdgeCleared(name string) bool {
	switch name {
	case target.EdgeInstanceName:
		return m.clearedinstance_name
	case target.EdgeInvocationTargets:
		return m.clearedinvocation_targets
	case target.EdgeTargetKindMappings:
		return m.clearedtarget_kind_mappings
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TargetMutation) ClearEdge(name string) error {
	switch name {
	case target.EdgeInstanceName:
		m.ClearInstanceName()
		return nil
	}
	return fmt.Errorf("unknown Target unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TargetMutation) ResetEdge(name string) error {
	switch name {
	case target.EdgeInstanceName:
		m.ResetInstanceName()
		return nil
	case target.EdgeInvocationTargets:
		m.ResetInvocationTargets()
		return nil
	case target.EdgeTargetKindMappings:
		m.ResetTargetKindMappings()
		return nil
	}
	return fmt.Errorf("unknown Target edge %s", name)
}

// TargetKindMappingMutation represents an operation that mutates the TargetKindMapping nodes in the graph.
type TargetKindMappingMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int64
	start_time_in_ms        *int64
	addstart_time_in_ms     *int64
	clearedFields           map[string]struct{}
	bazel_invocation        *int64
	clearedbazel_invocation bool
	target                  *int64
	clearedtarget           bool
	done                    bool
	oldValue                func(context.Context) (*TargetKindMapping, error)
	predicates              []predicate.TargetKindMapping
}

var _ ent.Mutation = (*TargetKindMappingMutation)(nil)

// targetkindmappingOption allows management of the mutation configuration using functional options.
type targetkindmappingOption func(*TargetKindMappingMutation)

// newTargetKindMappingMutation creates new mutation for the TargetKindMapping entity.
func newTargetKindMappingMutation(c config, op Op, opts ...targetkindmappingOption) *TargetKindMappingMutation {
	m := &TargetKindMappingMutation{
		config:        c,
		op:            op,
		typ:           TypeTargetKindMapping,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTargetKindMappingID sets the ID field of the mutation.
func withTargetKindMappingID(id int64) targetkindmappingOption {
	return func(m *TargetKindMappingMutation) {
		var (
			err   error
			once  sync.Once
			value *TargetKindMapping
		)
		m.oldValue = func(ctx context.Context) (*TargetKindMapping, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TargetKindMapping.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTargetKindMapping sets the old TargetKindMapping of the mutation.
func withTargetKindMapping(node *TargetKindMapping) targetkindmappingOption {
	return func(m *TargetKindMappingMutation) {
		m.oldValue = func(context.Context) (*TargetKindMapping, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TargetKindMappingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TargetKindMappingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TargetKindMapping entities.
func (m *TargetKindMappingMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TargetKindMappingMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TargetKindMappingMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TargetKindMapping.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBazelInvocationID sets the "bazel_invocation_id" field.
func (m *TargetKindMappingMutation) SetBazelInvocationID(i int64) {
	m.bazel_invocation = &i
}

// BazelInvocationID returns the value of the "bazel_invocation_id" field in the mutation.
func (m *TargetKindMappingMutation) BazelInvocationID() (r int64, exists bool) {
	v := m.bazel_invocation
	if v == nil {
		return
	}
	return *v, true
}

// OldBazelInvocationID returns the old "bazel_invocation_id" field's value of the TargetKindMapping entity.
// If the TargetKindMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TargetKindMappingMutation) OldBazelInvocationID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBazelInvocationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBazelInvocationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBazelInvocationID: %w", err)
	}
	return oldValue.BazelInvocationID, nil
}

// ResetBazelInvocationID resets all changes to the "bazel_invocation_id" field.
func (m *TargetKindMappingMutation) ResetBazelInvocationID() {
	m.bazel_invocation = nil
}

// SetTargetID sets the "target_id" field.
func (m *TargetKindMappingMutation) SetTargetID(i int64) {
	m.target = &i
}

// TargetID returns the value of the "target_id" field in the mutation.
func (m *TargetKindMappingMutation) TargetID() (r int64, exists bool) {
	v := m.target
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetID returns the old "target_id" field's value of the TargetKindMapping entity.
// If the TargetKindMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TargetKindMappingMutation) OldTargetID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetID: %w", err)
	}
	return oldValue.TargetID, nil
}

// ResetTargetID resets all changes to the "target_id" field.
func (m *TargetKindMappingMutation) ResetTargetID() {
	m.target = nil
}

// SetStartTimeInMs sets the "start_time_in_ms" field.
func (m *TargetKindMappingMutation) SetStartTimeInMs(i int64) {
	m.start_time_in_ms = &i
	m.addstart_time_in_ms = nil
}

// StartTimeInMs returns the value of the "start_time_in_ms" field in the mutation.
func (m *TargetKindMappingMutation) StartTimeInMs() (r int64, exists bool) {
	v := m.start_time_in_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTimeInMs returns the old "start_time_in_ms" field's value of the TargetKindMapping entity.
// If the TargetKindMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TargetKindMappingMutation) OldStartTimeInMs(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTimeInMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTimeInMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTimeInMs: %w", err)
	}
	return oldValue.StartTimeInMs, nil
}

// AddStartTimeInMs adds i to the "start_time_in_ms" field.
func (m *TargetKindMappingMutation) AddStartTimeInMs(i int64) {
	if m.addstart_time_in_ms != nil {
		*m.addstart_time_in_ms += i
	} else {
		m.addstart_time_in_ms = &i
	}
}

// AddedStartTimeInMs returns the value that was added to the "start_time_in_ms" field in this mutation.
func (m *TargetKindMappingMutation) AddedStartTimeInMs() (r int64, exists bool) {
	v := m.addstart_time_in_ms
	if v == nil {
		return
	}
	return *v, true
}

// ClearStartTimeInMs clears the value of the "start_time_in_ms" field.
func (m *TargetKindMappingMutation) ClearStartTimeInMs() {
	m.start_time_in_ms = nil
	m.addstart_time_in_ms = nil
	m.clearedFields[targetkindmapping.FieldStartTimeInMs] = struct{}{}
}

// StartTimeInMsCleared returns if the "start_time_in_ms" field was cleared in this mutation.
func (m *TargetKindMappingMutation) StartTimeInMsCleared() bool {
	_, ok := m.clearedFields[targetkindmapping.FieldStartTimeInMs]
	return ok
}

// ResetStartTimeInMs resets all changes to the "start_time_in_ms" field.
func (m *TargetKindMappingMutation) ResetStartTimeInMs() {
	m.start_time_in_ms = nil
	m.addstart_time_in_ms = nil
	delete(m.clearedFields, targetkindmapping.FieldStartTimeInMs)
}

// ClearBazelInvocation clears the "bazel_invocation" edge to the BazelInvocation entity.
func (m *TargetKindMappingMutation) ClearBazelInvocation() {
	m.clearedbazel_invocation = true
	m.clearedFields[targetkindmapping.FieldBazelInvocationID] = struct{}{}
}

// BazelInvocationCleared reports if the "bazel_invocation" edge to the BazelInvocation entity was cleared.
func (m *TargetKindMappingMutation) BazelInvocationCleared() bool {
	return m.clearedbazel_invocation
}

// BazelInvocationIDs returns the "bazel_invocation" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BazelInvocationID instead. It exists only for internal usage by the builders.
func (m *TargetKindMappingMutation) BazelInvocationIDs() (ids []int64) {
	if id := m.bazel_invocation; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBazelInvocation resets all changes to the "bazel_invocation" edge.
func (m *TargetKindMappingMutation) ResetBazelInvocation() {
	m.bazel_invocation = nil
	m.clearedbazel_invocation = false
}

// ClearTarget clears the "target" edge to the Target entity.
func (m *TargetKindMappingMutation) ClearTarget() {
	m.clearedtarget = true
	m.clearedFields[targetkindmapping.FieldTargetID] = struct{}{}
}

// TargetCleared reports if the "target" edge to the Target entity was cleared.
func (m *TargetKindMappingMutation) TargetCleared() bool {
	return m.clearedtarget
}

// TargetIDs returns the "target" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TargetID instead. It exists only for internal usage by the builders.
func (m *TargetKindMappingMutation) TargetIDs() (ids []int64) {
	if id := m.target; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTarget resets all changes to the "target" edge.
func (m *TargetKindMappingMutation) ResetTarget() {
	m.target = nil
	m.clearedtarget = false
}

// Where appends a list predicates to the TargetKindMappingMutation builder.
func (m *TargetKindMappingMutation) Where(ps ...predicate.TargetKindMapping) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TargetKindMappingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TargetKindMappingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TargetKindMapping, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TargetKindMappingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TargetKindMappingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TargetKindMapping).
func (m *TargetKindMappingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TargetKindMappingMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.bazel_invocation != nil {
		fields = append(fields, targetkindmapping.FieldBazelInvocationID)
	}
	if m.target != nil {
		fields = append(fields, targetkindmapping.FieldTargetID)
	}
	if m.start_time_in_ms != nil {
		fields = append(fields, targetkindmapping.FieldStartTimeInMs)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TargetKindMappingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case targetkindmapping.FieldBazelInvocationID:
		return m.BazelInvocationID()
	case targetkindmapping.FieldTargetID:
		return m.TargetID()
	case targetkindmapping.FieldStartTimeInMs:
		return m.StartTimeInMs()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TargetKindMappingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case targetkindmapping.FieldBazelInvocationID:
		return m.OldBazelInvocationID(ctx)
	case targetkindmapping.FieldTargetID:
		return m.OldTargetID(ctx)
	case targetkindmapping.FieldStartTimeInMs:
		return m.OldStartTimeInMs(ctx)
	}
	return nil, fmt.Errorf("unknown TargetKindMapping field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TargetKindMappingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case targetkindmapping.FieldBazelInvocationID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBazelInvocationID(v)
		return nil
	case targetkindmapping.FieldTargetID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetID(v)
		return nil
	case targetkindmapping.FieldStartTimeInMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTimeInMs(v)
		return nil
	}
	return fmt.Errorf("unknown TargetKindMapping field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TargetKindMappingMutation) AddedFields() []string {
	var fields []string
	if m.addstart_time_in_ms != nil {
		fields = append(fields, targetkindmapping.FieldStartTimeInMs)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TargetKindMappingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case targetkindmapping.FieldStartTimeInMs:
		return m.AddedStartTimeInMs()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TargetKindMappingMutation) AddField(name string, value ent.Value) error {
	switch name {
	case targetkindmapping.FieldStartTimeInMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartTimeInMs(v)
		return nil
	}
	return fmt.Errorf("unknown TargetKindMapping numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TargetKindMappingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(targetkindmapping.FieldStartTimeInMs) {
		fields = append(fields, targetkindmapping.FieldStartTimeInMs)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TargetKindMappingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TargetKindMappingMutation) ClearField(name string) error {
	switch name {
	case targetkindmapping.FieldStartTimeInMs:
		m.ClearStartTimeInMs()
		return nil
	}
	return fmt.Errorf("unknown TargetKindMapping nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TargetKindMappingMutation) ResetField(name string) error {
	switch name {
	case targetkindmapping.FieldBazelInvocationID:
		m.ResetBazelInvocationID()
		return nil
	case targetkindmapping.FieldTargetID:
		m.ResetTargetID()
		return nil
	case targetkindmapping.FieldStartTimeInMs:
		m.ResetStartTimeInMs()
		return nil
	}
	return fmt.Errorf("unknown TargetKindMapping field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TargetKindMappingMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.bazel_invocation != nil {
		edges = append(edges, targetkindmapping.EdgeBazelInvocation)
	}
	if m.target != nil {
		edges = append(edges, targetkindmapping.EdgeTarget)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TargetKindMappingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case targetkindmapping.EdgeBazelInvocation:
		if id := m.bazel_invocation; id != nil {
			return []ent.Value{*id}
		}
	case targetkindmapping.EdgeTarget:
		if id := m.target; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TargetKindMappingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TargetKindMappingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TargetKindMappingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbazel_invocation {
		edges = append(edges, targetkindmapping.EdgeBazelInvocation)
	}
	if m.clearedtarget {
		edges = append(edges, targetkindmapping.EdgeTarget)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TargetKindMappingMutation) EdgeCleared(name string) bool {
	switch name {
	case targetkindmapping.EdgeBazelInvocation:
		return m.clearedbazel_invocation
	case targetkindmapping.EdgeTarget:
		return m.clearedtarget
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TargetKindMappingMutation) ClearEdge(name string) error {
	switch name {
	case targetkindmapping.EdgeBazelInvocation:
		m.ClearBazelInvocation()
		return nil
	case targetkindmapping.EdgeTarget:
		m.ClearTarget()
		return nil
	}
	return fmt.Errorf("unknown TargetKindMapping unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TargetKindMappingMutation) ResetEdge(name string) error {
	switch name {
	case targetkindmapping.EdgeBazelInvocation:
		m.ResetBazelInvocation()
		return nil
	case targetkindmapping.EdgeTarget:
		m.ResetTarget()
		return nil
	}
	return fmt.Errorf("unknown TargetKindMapping edge %s", name)
}

// TargetMetricsMutation represents an operation that mutates the TargetMetrics nodes in the graph.
type TargetMetricsMutation struct {
	config
	op                                          Op
	typ                                         string
	id                                          *int64
	targets_loaded                              *int64
	addtargets_loaded                           *int64
	targets_configured                          *int64
	addtargets_configured                       *int64
	targets_configured_not_including_aspects    *int64
	addtargets_configured_not_including_aspects *int64
	clearedFields                               map[string]struct{}
	metrics                                     *int64
	clearedmetrics                              bool
	done                                        bool
	oldValue                                    func(context.Context) (*TargetMetrics, error)
	predicates                                  []predicate.TargetMetrics
}

var _ ent.Mutation = (*TargetMetricsMutation)(nil)

// targetmetricsOption allows management of the mutation configuration using functional options.
type targetmetricsOption func(*TargetMetricsMutation)

// newTargetMetricsMutation creates new mutation for the TargetMetrics entity.
func newTargetMetricsMutation(c config, op Op, opts ...targetmetricsOption) *TargetMetricsMutation {
	m := &TargetMetricsMutation{
		config:        c,
		op:            op,
		typ:           TypeTargetMetrics,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTargetMetricsID sets the ID field of the mutation.
func withTargetMetricsID(id int64) targetmetricsOption {
	return func(m *TargetMetricsMutation) {
		var (
			err   error
			once  sync.Once
			value *TargetMetrics
		)
		m.oldValue = func(ctx context.Context) (*TargetMetrics, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TargetMetrics.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTargetMetrics sets the old TargetMetrics of the mutation.
func withTargetMetrics(node *TargetMetrics) targetmetricsOption {
	return func(m *TargetMetricsMutation) {
		m.oldValue = func(context.Context) (*TargetMetrics, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TargetMetricsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TargetMetricsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TargetMetrics entities.
func (m *TargetMetricsMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TargetMetricsMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TargetMetricsMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TargetMetrics.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTargetsLoaded sets the "targets_loaded" field.
func (m *TargetMetricsMutation) SetTargetsLoaded(i int64) {
	m.targets_loaded = &i
	m.addtargets_loaded = nil
}

// TargetsLoaded returns the value of the "targets_loaded" field in the mutation.
func (m *TargetMetricsMutation) TargetsLoaded() (r int64, exists bool) {
	v := m.targets_loaded
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetsLoaded returns the old "targets_loaded" field's value of the TargetMetrics entity.
// If the TargetMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TargetMetricsMutation) OldTargetsLoaded(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetsLoaded is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetsLoaded requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetsLoaded: %w", err)
	}
	return oldValue.TargetsLoaded, nil
}

// AddTargetsLoaded adds i to the "targets_loaded" field.
func (m *TargetMetricsMutation) AddTargetsLoaded(i int64) {
	if m.addtargets_loaded != nil {
		*m.addtargets_loaded += i
	} else {
		m.addtargets_loaded = &i
	}
}

// AddedTargetsLoaded returns the value that was added to the "targets_loaded" field in this mutation.
func (m *TargetMetricsMutation) AddedTargetsLoaded() (r int64, exists bool) {
	v := m.addtargets_loaded
	if v == nil {
		return
	}
	return *v, true
}

// ClearTargetsLoaded clears the value of the "targets_loaded" field.
func (m *TargetMetricsMutation) ClearTargetsLoaded() {
	m.targets_loaded = nil
	m.addtargets_loaded = nil
	m.clearedFields[targetmetrics.FieldTargetsLoaded] = struct{}{}
}

// TargetsLoadedCleared returns if the "targets_loaded" field was cleared in this mutation.
func (m *TargetMetricsMutation) TargetsLoadedCleared() bool {
	_, ok := m.clearedFields[targetmetrics.FieldTargetsLoaded]
	return ok
}

// ResetTargetsLoaded resets all changes to the "targets_loaded" field.
func (m *TargetMetricsMutation) ResetTargetsLoaded() {
	m.targets_loaded = nil
	m.addtargets_loaded = nil
	delete(m.clearedFields, targetmetrics.FieldTargetsLoaded)
}

// SetTargetsConfigured sets the "targets_configured" field.
func (m *TargetMetricsMutation) SetTargetsConfigured(i int64) {
	m.targets_configured = &i
	m.addtargets_configured = nil
}

// TargetsConfigured returns the value of the "targets_configured" field in the mutation.
func (m *TargetMetricsMutation) TargetsConfigured() (r int64, exists bool) {
	v := m.targets_configured
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetsConfigured returns the old "targets_configured" field's value of the TargetMetrics entity.
// If the TargetMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TargetMetricsMutation) OldTargetsConfigured(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetsConfigured is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetsConfigured requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetsConfigured: %w", err)
	}
	return oldValue.TargetsConfigured, nil
}

// AddTargetsConfigured adds i to the "targets_configured" field.
func (m *TargetMetricsMutation) AddTargetsConfigured(i int64) {
	if m.addtargets_configured != nil {
		*m.addtargets_configured += i
	} else {
		m.addtargets_configured = &i
	}
}

// AddedTargetsConfigured returns the value that was added to the "targets_configured" field in this mutation.
func (m *TargetMetricsMutation) AddedTargetsConfigured() (r int64, exists bool) {
	v := m.addtargets_configured
	if v == nil {
		return
	}
	return *v, true
}

// ClearTargetsConfigured clears the value of the "targets_configured" field.
func (m *TargetMetricsMutation) ClearTargetsConfigured() {
	m.targets_configured = nil
	m.addtargets_configured = nil
	m.clearedFields[targetmetrics.FieldTargetsConfigured] = struct{}{}
}

// TargetsConfiguredCleared returns if the "targets_configured" field was cleared in this mutation.
func (m *TargetMetricsMutation) TargetsConfiguredCleared() bool {
	_, ok := m.clearedFields[targetmetrics.FieldTargetsConfigured]
	return ok
}

// ResetTargetsConfigured resets all changes to the "targets_configured" field.
func (m *TargetMetricsMutation) ResetTargetsConfigured() {
	m.targets_configured = nil
	m.addtargets_configured = nil
	delete(m.clearedFields, targetmetrics.FieldTargetsConfigured)
}

// SetTargetsConfiguredNotIncludingAspects sets the "targets_configured_not_including_aspects" field.
func (m *TargetMetricsMutation) SetTargetsConfiguredNotIncludingAspects(i int64) {
	m.targets_configured_not_including_aspects = &i
	m.addtargets_configured_not_including_aspects = nil
}

// TargetsConfiguredNotIncludingAspects returns the value of the "targets_configured_not_including_aspects" field in the mutation.
func (m *TargetMetricsMutation) TargetsConfiguredNotIncludingAspects() (r int64, exists bool) {
	v := m.targets_configured_not_including_aspects
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetsConfiguredNotIncludingAspects returns the old "targets_configured_not_including_aspects" field's value of the TargetMetrics entity.
// If the TargetMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TargetMetricsMutation) OldTargetsConfiguredNotIncludingAspects(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetsConfiguredNotIncludingAspects is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetsConfiguredNotIncludingAspects requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetsConfiguredNotIncludingAspects: %w", err)
	}
	return oldValue.TargetsConfiguredNotIncludingAspects, nil
}

// AddTargetsConfiguredNotIncludingAspects adds i to the "targets_configured_not_including_aspects" field.
func (m *TargetMetricsMutation) AddTargetsConfiguredNotIncludingAspects(i int64) {
	if m.addtargets_configured_not_including_aspects != nil {
		*m.addtargets_configured_not_including_aspects += i
	} else {
		m.addtargets_configured_not_including_aspects = &i
	}
}

// AddedTargetsConfiguredNotIncludingAspects returns the value that was added to the "targets_configured_not_including_aspects" field in this mutation.
func (m *TargetMetricsMutation) AddedTargetsConfiguredNotIncludingAspects() (r int64, exists bool) {
	v := m.addtargets_configured_not_including_aspects
	if v == nil {
		return
	}
	return *v, true
}

// ClearTargetsConfiguredNotIncludingAspects clears the value of the "targets_configured_not_including_aspects" field.
func (m *TargetMetricsMutation) ClearTargetsConfiguredNotIncludingAspects() {
	m.targets_configured_not_including_aspects = nil
	m.addtargets_configured_not_including_aspects = nil
	m.clearedFields[targetmetrics.FieldTargetsConfiguredNotIncludingAspects] = struct{}{}
}

// TargetsConfiguredNotIncludingAspectsCleared returns if the "targets_configured_not_including_aspects" field was cleared in this mutation.
func (m *TargetMetricsMutation) TargetsConfiguredNotIncludingAspectsCleared() bool {
	_, ok := m.clearedFields[targetmetrics.FieldTargetsConfiguredNotIncludingAspects]
	return ok
}

// ResetTargetsConfiguredNotIncludingAspects resets all changes to the "targets_configured_not_including_aspects" field.
func (m *TargetMetricsMutation) ResetTargetsConfiguredNotIncludingAspects() {
	m.targets_configured_not_including_aspects = nil
	m.addtargets_configured_not_including_aspects = nil
	delete(m.clearedFields, targetmetrics.FieldTargetsConfiguredNotIncludingAspects)
}

// SetMetricsID sets the "metrics" edge to the Metrics entity by id.
func (m *TargetMetricsMutation) SetMetricsID(id int64) {
	m.metrics = &id
}

// ClearMetrics clears the "metrics" edge to the Metrics entity.
func (m *TargetMetricsMutation) ClearMetrics() {
	m.clearedmetrics = true
}

// MetricsCleared reports if the "metrics" edge to the Metrics entity was cleared.
func (m *TargetMetricsMutation) MetricsCleared() bool {
	return m.clearedmetrics
}

// MetricsID returns the "metrics" edge ID in the mutation.
func (m *TargetMetricsMutation) MetricsID() (id int64, exists bool) {
	if m.metrics != nil {
		return *m.metrics, true
	}
	return
}

// MetricsIDs returns the "metrics" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MetricsID instead. It exists only for internal usage by the builders.
func (m *TargetMetricsMutation) MetricsIDs() (ids []int64) {
	if id := m.metrics; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMetrics resets all changes to the "metrics" edge.
func (m *TargetMetricsMutation) ResetMetrics() {
	m.metrics = nil
	m.clearedmetrics = false
}

// Where appends a list predicates to the TargetMetricsMutation builder.
func (m *TargetMetricsMutation) Where(ps ...predicate.TargetMetrics) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TargetMetricsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TargetMetricsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TargetMetrics, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TargetMetricsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TargetMetricsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TargetMetrics).
func (m *TargetMetricsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TargetMetricsMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.targets_loaded != nil {
		fields = append(fields, targetmetrics.FieldTargetsLoaded)
	}
	if m.targets_configured != nil {
		fields = append(fields, targetmetrics.FieldTargetsConfigured)
	}
	if m.targets_configured_not_including_aspects != nil {
		fields = append(fields, targetmetrics.FieldTargetsConfiguredNotIncludingAspects)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TargetMetricsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case targetmetrics.FieldTargetsLoaded:
		return m.TargetsLoaded()
	case targetmetrics.FieldTargetsConfigured:
		return m.TargetsConfigured()
	case targetmetrics.FieldTargetsConfiguredNotIncludingAspects:
		return m.TargetsConfiguredNotIncludingAspects()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TargetMetricsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case targetmetrics.FieldTargetsLoaded:
		return m.OldTargetsLoaded(ctx)
	case targetmetrics.FieldTargetsConfigured:
		return m.OldTargetsConfigured(ctx)
	case targetmetrics.FieldTargetsConfiguredNotIncludingAspects:
		return m.OldTargetsConfiguredNotIncludingAspects(ctx)
	}
	return nil, fmt.Errorf("unknown TargetMetrics field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TargetMetricsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case targetmetrics.FieldTargetsLoaded:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetsLoaded(v)
		return nil
	case targetmetrics.FieldTargetsConfigured:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetsConfigured(v)
		return nil
	case targetmetrics.FieldTargetsConfiguredNotIncludingAspects:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetsConfiguredNotIncludingAspects(v)
		return nil
	}
	return fmt.Errorf("unknown TargetMetrics field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TargetMetricsMutation) AddedFields() []string {
	var fields []string
	if m.addtargets_loaded != nil {
		fields = append(fields, targetmetrics.FieldTargetsLoaded)
	}
	if m.addtargets_configured != nil {
		fields = append(fields, targetmetrics.FieldTargetsConfigured)
	}
	if m.addtargets_configured_not_including_aspects != nil {
		fields = append(fields, targetmetrics.FieldTargetsConfiguredNotIncludingAspects)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TargetMetricsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case targetmetrics.FieldTargetsLoaded:
		return m.AddedTargetsLoaded()
	case targetmetrics.FieldTargetsConfigured:
		return m.AddedTargetsConfigured()
	case targetmetrics.FieldTargetsConfiguredNotIncludingAspects:
		return m.AddedTargetsConfiguredNotIncludingAspects()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TargetMetricsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case targetmetrics.FieldTargetsLoaded:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTargetsLoaded(v)
		return nil
	case targetmetrics.FieldTargetsConfigured:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTargetsConfigured(v)
		return nil
	case targetmetrics.FieldTargetsConfiguredNotIncludingAspects:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTargetsConfiguredNotIncludingAspects(v)
		return nil
	}
	return fmt.Errorf("unknown TargetMetrics numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TargetMetricsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(targetmetrics.FieldTargetsLoaded) {
		fields = append(fields, targetmetrics.FieldTargetsLoaded)
	}
	if m.FieldCleared(targetmetrics.FieldTargetsConfigured) {
		fields = append(fields, targetmetrics.FieldTargetsConfigured)
	}
	if m.FieldCleared(targetmetrics.FieldTargetsConfiguredNotIncludingAspects) {
		fields = append(fields, targetmetrics.FieldTargetsConfiguredNotIncludingAspects)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TargetMetricsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TargetMetricsMutation) ClearField(name string) error {
	switch name {
	case targetmetrics.FieldTargetsLoaded:
		m.ClearTargetsLoaded()
		return nil
	case targetmetrics.FieldTargetsConfigured:
		m.ClearTargetsConfigured()
		return nil
	case targetmetrics.FieldTargetsConfiguredNotIncludingAspects:
		m.ClearTargetsConfiguredNotIncludingAspects()
		return nil
	}
	return fmt.Errorf("unknown TargetMetrics nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TargetMetricsMutation) ResetField(name string) error {
	switch name {
	case targetmetrics.FieldTargetsLoaded:
		m.ResetTargetsLoaded()
		return nil
	case targetmetrics.FieldTargetsConfigured:
		m.ResetTargetsConfigured()
		return nil
	case targetmetrics.FieldTargetsConfiguredNotIncludingAspects:
		m.ResetTargetsConfiguredNotIncludingAspects()
		return nil
	}
	return fmt.Errorf("unknown TargetMetrics field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TargetMetricsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.metrics != nil {
		edges = append(edges, targetmetrics.EdgeMetrics)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TargetMetricsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case targetmetrics.EdgeMetrics:
		if id := m.metrics; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TargetMetricsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TargetMetricsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TargetMetricsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmetrics {
		edges = append(edges, targetmetrics.EdgeMetrics)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TargetMetricsMutation) EdgeCleared(name string) bool {
	switch name {
	case targetmetrics.EdgeMetrics:
		return m.clearedmetrics
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TargetMetricsMutation) ClearEdge(name string) error {
	switch name {
	case targetmetrics.EdgeMetrics:
		m.ClearMetrics()
		return nil
	}
	return fmt.Errorf("unknown TargetMetrics unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TargetMetricsMutation) ResetEdge(name string) error {
	switch name {
	case targetmetrics.EdgeMetrics:
		m.ResetMetrics()
		return nil
	}
	return fmt.Errorf("unknown TargetMetrics edge %s", name)
}

// TestResultMutation represents an operation that mutates the TestResult nodes in the graph.
type TestResultMutation struct {
	config
	op                             Op
	typ                            string
	id                             *int64
	run                            *int32
	addrun                         *int32
	shard                          *int32
	addshard                       *int32
	attempt                        *int32
	addattempt                     *int32
	status                         *string
	status_details                 *string
	cached_locally                 *bool
	test_attempt_start             *time.Time
	test_attempt_duration_in_ms    *int64
	addtest_attempt_duration_in_ms *int64
	warning                        *[]string
	appendwarning                  []string
	strategy                       *string
	cached_remotely                *bool
	exit_code                      *int32
	addexit_code                   *int32
	hostname                       *string
	timing_breakdown               *map[string]interface{}
	clearedFields                  map[string]struct{}
	test_summary                   *int64
	clearedtest_summary            bool
	done                           bool
	oldValue                       func(context.Context) (*TestResult, error)
	predicates                     []predicate.TestResult
}

var _ ent.Mutation = (*TestResultMutation)(nil)

// testresultOption allows management of the mutation configuration using functional options.
type testresultOption func(*TestResultMutation)

// newTestResultMutation creates new mutation for the TestResult entity.
func newTestResultMutation(c config, op Op, opts ...testresultOption) *TestResultMutation {
	m := &TestResultMutation{
		config:        c,
		op:            op,
		typ:           TypeTestResult,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTestResultID sets the ID field of the mutation.
func withTestResultID(id int64) testresultOption {
	return func(m *TestResultMutation) {
		var (
			err   error
			once  sync.Once
			value *TestResult
		)
		m.oldValue = func(ctx context.Context) (*TestResult, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TestResult.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTestResult sets the old TestResult of the mutation.
func withTestResult(node *TestResult) testresultOption {
	return func(m *TestResultMutation) {
		m.oldValue = func(context.Context) (*TestResult, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TestResultMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TestResultMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TestResult entities.
func (m *TestResultMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TestResultMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TestResultMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TestResult.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRun sets the "run" field.
func (m *TestResultMutation) SetRun(i int32) {
	m.run = &i
	m.addrun = nil
}

// Run returns the value of the "run" field in the mutation.
func (m *TestResultMutation) Run() (r int32, exists bool) {
	v := m.run
	if v == nil {
		return
	}
	return *v, true
}

// OldRun returns the old "run" field's value of the TestResult entity.
// If the TestResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestResultMutation) OldRun(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRun is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRun requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRun: %w", err)
	}
	return oldValue.Run, nil
}

// AddRun adds i to the "run" field.
func (m *TestResultMutation) AddRun(i int32) {
	if m.addrun != nil {
		*m.addrun += i
	} else {
		m.addrun = &i
	}
}

// AddedRun returns the value that was added to the "run" field in this mutation.
func (m *TestResultMutation) AddedRun() (r int32, exists bool) {
	v := m.addrun
	if v == nil {
		return
	}
	return *v, true
}

// ResetRun resets all changes to the "run" field.
func (m *TestResultMutation) ResetRun() {
	m.run = nil
	m.addrun = nil
}

// SetShard sets the "shard" field.
func (m *TestResultMutation) SetShard(i int32) {
	m.shard = &i
	m.addshard = nil
}

// Shard returns the value of the "shard" field in the mutation.
func (m *TestResultMutation) Shard() (r int32, exists bool) {
	v := m.shard
	if v == nil {
		return
	}
	return *v, true
}

// OldShard returns the old "shard" field's value of the TestResult entity.
// If the TestResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestResultMutation) OldShard(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShard is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShard requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShard: %w", err)
	}
	return oldValue.Shard, nil
}

// AddShard adds i to the "shard" field.
func (m *TestResultMutation) AddShard(i int32) {
	if m.addshard != nil {
		*m.addshard += i
	} else {
		m.addshard = &i
	}
}

// AddedShard returns the value that was added to the "shard" field in this mutation.
func (m *TestResultMutation) AddedShard() (r int32, exists bool) {
	v := m.addshard
	if v == nil {
		return
	}
	return *v, true
}

// ResetShard resets all changes to the "shard" field.
func (m *TestResultMutation) ResetShard() {
	m.shard = nil
	m.addshard = nil
}

// SetAttempt sets the "attempt" field.
func (m *TestResultMutation) SetAttempt(i int32) {
	m.attempt = &i
	m.addattempt = nil
}

// Attempt returns the value of the "attempt" field in the mutation.
func (m *TestResultMutation) Attempt() (r int32, exists bool) {
	v := m.attempt
	if v == nil {
		return
	}
	return *v, true
}

// OldAttempt returns the old "attempt" field's value of the TestResult entity.
// If the TestResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestResultMutation) OldAttempt(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttempt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttempt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttempt: %w", err)
	}
	return oldValue.Attempt, nil
}

// AddAttempt adds i to the "attempt" field.
func (m *TestResultMutation) AddAttempt(i int32) {
	if m.addattempt != nil {
		*m.addattempt += i
	} else {
		m.addattempt = &i
	}
}

// AddedAttempt returns the value that was added to the "attempt" field in this mutation.
func (m *TestResultMutation) AddedAttempt() (r int32, exists bool) {
	v := m.addattempt
	if v == nil {
		return
	}
	return *v, true
}

// ResetAttempt resets all changes to the "attempt" field.
func (m *TestResultMutation) ResetAttempt() {
	m.attempt = nil
	m.addattempt = nil
}

// SetStatus sets the "status" field.
func (m *TestResultMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *TestResultMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the TestResult entity.
// If the TestResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestResultMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *TestResultMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[testresult.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *TestResultMutation) StatusCleared() bool {
	_, ok := m.clearedFields[testresult.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *TestResultMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, testresult.FieldStatus)
}

// SetStatusDetails sets the "status_details" field.
func (m *TestResultMutation) SetStatusDetails(s string) {
	m.status_details = &s
}

// StatusDetails returns the value of the "status_details" field in the mutation.
func (m *TestResultMutation) StatusDetails() (r string, exists bool) {
	v := m.status_details
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusDetails returns the old "status_details" field's value of the TestResult entity.
// If the TestResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestResultMutation) OldStatusDetails(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatusDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatusDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusDetails: %w", err)
	}
	return oldValue.StatusDetails, nil
}

// ClearStatusDetails clears the value of the "status_details" field.
func (m *TestResultMutation) ClearStatusDetails() {
	m.status_details = nil
	m.clearedFields[testresult.FieldStatusDetails] = struct{}{}
}

// StatusDetailsCleared returns if the "status_details" field was cleared in this mutation.
func (m *TestResultMutation) StatusDetailsCleared() bool {
	_, ok := m.clearedFields[testresult.FieldStatusDetails]
	return ok
}

// ResetStatusDetails resets all changes to the "status_details" field.
func (m *TestResultMutation) ResetStatusDetails() {
	m.status_details = nil
	delete(m.clearedFields, testresult.FieldStatusDetails)
}

// SetCachedLocally sets the "cached_locally" field.
func (m *TestResultMutation) SetCachedLocally(b bool) {
	m.cached_locally = &b
}

// CachedLocally returns the value of the "cached_locally" field in the mutation.
func (m *TestResultMutation) CachedLocally() (r bool, exists bool) {
	v := m.cached_locally
	if v == nil {
		return
	}
	return *v, true
}

// OldCachedLocally returns the old "cached_locally" field's value of the TestResult entity.
// If the TestResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestResultMutation) OldCachedLocally(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCachedLocally is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCachedLocally requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCachedLocally: %w", err)
	}
	return oldValue.CachedLocally, nil
}

// ClearCachedLocally clears the value of the "cached_locally" field.
func (m *TestResultMutation) ClearCachedLocally() {
	m.cached_locally = nil
	m.clearedFields[testresult.FieldCachedLocally] = struct{}{}
}

// CachedLocallyCleared returns if the "cached_locally" field was cleared in this mutation.
func (m *TestResultMutation) CachedLocallyCleared() bool {
	_, ok := m.clearedFields[testresult.FieldCachedLocally]
	return ok
}

// ResetCachedLocally resets all changes to the "cached_locally" field.
func (m *TestResultMutation) ResetCachedLocally() {
	m.cached_locally = nil
	delete(m.clearedFields, testresult.FieldCachedLocally)
}

// SetTestAttemptStart sets the "test_attempt_start" field.
func (m *TestResultMutation) SetTestAttemptStart(t time.Time) {
	m.test_attempt_start = &t
}

// TestAttemptStart returns the value of the "test_attempt_start" field in the mutation.
func (m *TestResultMutation) TestAttemptStart() (r time.Time, exists bool) {
	v := m.test_attempt_start
	if v == nil {
		return
	}
	return *v, true
}

// OldTestAttemptStart returns the old "test_attempt_start" field's value of the TestResult entity.
// If the TestResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestResultMutation) OldTestAttemptStart(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTestAttemptStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTestAttemptStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTestAttemptStart: %w", err)
	}
	return oldValue.TestAttemptStart, nil
}

// ClearTestAttemptStart clears the value of the "test_attempt_start" field.
func (m *TestResultMutation) ClearTestAttemptStart() {
	m.test_attempt_start = nil
	m.clearedFields[testresult.FieldTestAttemptStart] = struct{}{}
}

// TestAttemptStartCleared returns if the "test_attempt_start" field was cleared in this mutation.
func (m *TestResultMutation) TestAttemptStartCleared() bool {
	_, ok := m.clearedFields[testresult.FieldTestAttemptStart]
	return ok
}

// ResetTestAttemptStart resets all changes to the "test_attempt_start" field.
func (m *TestResultMutation) ResetTestAttemptStart() {
	m.test_attempt_start = nil
	delete(m.clearedFields, testresult.FieldTestAttemptStart)
}

// SetTestAttemptDurationInMs sets the "test_attempt_duration_in_ms" field.
func (m *TestResultMutation) SetTestAttemptDurationInMs(i int64) {
	m.test_attempt_duration_in_ms = &i
	m.addtest_attempt_duration_in_ms = nil
}

// TestAttemptDurationInMs returns the value of the "test_attempt_duration_in_ms" field in the mutation.
func (m *TestResultMutation) TestAttemptDurationInMs() (r int64, exists bool) {
	v := m.test_attempt_duration_in_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldTestAttemptDurationInMs returns the old "test_attempt_duration_in_ms" field's value of the TestResult entity.
// If the TestResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestResultMutation) OldTestAttemptDurationInMs(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTestAttemptDurationInMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTestAttemptDurationInMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTestAttemptDurationInMs: %w", err)
	}
	return oldValue.TestAttemptDurationInMs, nil
}

// AddTestAttemptDurationInMs adds i to the "test_attempt_duration_in_ms" field.
func (m *TestResultMutation) AddTestAttemptDurationInMs(i int64) {
	if m.addtest_attempt_duration_in_ms != nil {
		*m.addtest_attempt_duration_in_ms += i
	} else {
		m.addtest_attempt_duration_in_ms = &i
	}
}

// AddedTestAttemptDurationInMs returns the value that was added to the "test_attempt_duration_in_ms" field in this mutation.
func (m *TestResultMutation) AddedTestAttemptDurationInMs() (r int64, exists bool) {
	v := m.addtest_attempt_duration_in_ms
	if v == nil {
		return
	}
	return *v, true
}

// ClearTestAttemptDurationInMs clears the value of the "test_attempt_duration_in_ms" field.
func (m *TestResultMutation) ClearTestAttemptDurationInMs() {
	m.test_attempt_duration_in_ms = nil
	m.addtest_attempt_duration_in_ms = nil
	m.clearedFields[testresult.FieldTestAttemptDurationInMs] = struct{}{}
}

// TestAttemptDurationInMsCleared returns if the "test_attempt_duration_in_ms" field was cleared in this mutation.
func (m *TestResultMutation) TestAttemptDurationInMsCleared() bool {
	_, ok := m.clearedFields[testresult.FieldTestAttemptDurationInMs]
	return ok
}

// ResetTestAttemptDurationInMs resets all changes to the "test_attempt_duration_in_ms" field.
func (m *TestResultMutation) ResetTestAttemptDurationInMs() {
	m.test_attempt_duration_in_ms = nil
	m.addtest_attempt_duration_in_ms = nil
	delete(m.clearedFields, testresult.FieldTestAttemptDurationInMs)
}

// SetWarning sets the "warning" field.
func (m *TestResultMutation) SetWarning(s []string) {
	m.warning = &s
	m.appendwarning = nil
}

// Warning returns the value of the "warning" field in the mutation.
func (m *TestResultMutation) Warning() (r []string, exists bool) {
	v := m.warning
	if v == nil {
		return
	}
	return *v, true
}

// OldWarning returns the old "warning" field's value of the TestResult entity.
// If the TestResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestResultMutation) OldWarning(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWarning is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWarning requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWarning: %w", err)
	}
	return oldValue.Warning, nil
}

// AppendWarning adds s to the "warning" field.
func (m *TestResultMutation) AppendWarning(s []string) {
	m.appendwarning = append(m.appendwarning, s...)
}

// AppendedWarning returns the list of values that were appended to the "warning" field in this mutation.
func (m *TestResultMutation) AppendedWarning() ([]string, bool) {
	if len(m.appendwarning) == 0 {
		return nil, false
	}
	return m.appendwarning, true
}

// ClearWarning clears the value of the "warning" field.
func (m *TestResultMutation) ClearWarning() {
	m.warning = nil
	m.appendwarning = nil
	m.clearedFields[testresult.FieldWarning] = struct{}{}
}

// WarningCleared returns if the "warning" field was cleared in this mutation.
func (m *TestResultMutation) WarningCleared() bool {
	_, ok := m.clearedFields[testresult.FieldWarning]
	return ok
}

// ResetWarning resets all changes to the "warning" field.
func (m *TestResultMutation) ResetWarning() {
	m.warning = nil
	m.appendwarning = nil
	delete(m.clearedFields, testresult.FieldWarning)
}

// SetStrategy sets the "strategy" field.
func (m *TestResultMutation) SetStrategy(s string) {
	m.strategy = &s
}

// Strategy returns the value of the "strategy" field in the mutation.
func (m *TestResultMutation) Strategy() (r string, exists bool) {
	v := m.strategy
	if v == nil {
		return
	}
	return *v, true
}

// OldStrategy returns the old "strategy" field's value of the TestResult entity.
// If the TestResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestResultMutation) OldStrategy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStrategy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStrategy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStrategy: %w", err)
	}
	return oldValue.Strategy, nil
}

// ClearStrategy clears the value of the "strategy" field.
func (m *TestResultMutation) ClearStrategy() {
	m.strategy = nil
	m.clearedFields[testresult.FieldStrategy] = struct{}{}
}

// StrategyCleared returns if the "strategy" field was cleared in this mutation.
func (m *TestResultMutation) StrategyCleared() bool {
	_, ok := m.clearedFields[testresult.FieldStrategy]
	return ok
}

// ResetStrategy resets all changes to the "strategy" field.
func (m *TestResultMutation) ResetStrategy() {
	m.strategy = nil
	delete(m.clearedFields, testresult.FieldStrategy)
}

// SetCachedRemotely sets the "cached_remotely" field.
func (m *TestResultMutation) SetCachedRemotely(b bool) {
	m.cached_remotely = &b
}

// CachedRemotely returns the value of the "cached_remotely" field in the mutation.
func (m *TestResultMutation) CachedRemotely() (r bool, exists bool) {
	v := m.cached_remotely
	if v == nil {
		return
	}
	return *v, true
}

// OldCachedRemotely returns the old "cached_remotely" field's value of the TestResult entity.
// If the TestResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestResultMutation) OldCachedRemotely(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCachedRemotely is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCachedRemotely requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCachedRemotely: %w", err)
	}
	return oldValue.CachedRemotely, nil
}

// ClearCachedRemotely clears the value of the "cached_remotely" field.
func (m *TestResultMutation) ClearCachedRemotely() {
	m.cached_remotely = nil
	m.clearedFields[testresult.FieldCachedRemotely] = struct{}{}
}

// CachedRemotelyCleared returns if the "cached_remotely" field was cleared in this mutation.
func (m *TestResultMutation) CachedRemotelyCleared() bool {
	_, ok := m.clearedFields[testresult.FieldCachedRemotely]
	return ok
}

// ResetCachedRemotely resets all changes to the "cached_remotely" field.
func (m *TestResultMutation) ResetCachedRemotely() {
	m.cached_remotely = nil
	delete(m.clearedFields, testresult.FieldCachedRemotely)
}

// SetExitCode sets the "exit_code" field.
func (m *TestResultMutation) SetExitCode(i int32) {
	m.exit_code = &i
	m.addexit_code = nil
}

// ExitCode returns the value of the "exit_code" field in the mutation.
func (m *TestResultMutation) ExitCode() (r int32, exists bool) {
	v := m.exit_code
	if v == nil {
		return
	}
	return *v, true
}

// OldExitCode returns the old "exit_code" field's value of the TestResult entity.
// If the TestResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestResultMutation) OldExitCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExitCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExitCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExitCode: %w", err)
	}
	return oldValue.ExitCode, nil
}

// AddExitCode adds i to the "exit_code" field.
func (m *TestResultMutation) AddExitCode(i int32) {
	if m.addexit_code != nil {
		*m.addexit_code += i
	} else {
		m.addexit_code = &i
	}
}

// AddedExitCode returns the value that was added to the "exit_code" field in this mutation.
func (m *TestResultMutation) AddedExitCode() (r int32, exists bool) {
	v := m.addexit_code
	if v == nil {
		return
	}
	return *v, true
}

// ClearExitCode clears the value of the "exit_code" field.
func (m *TestResultMutation) ClearExitCode() {
	m.exit_code = nil
	m.addexit_code = nil
	m.clearedFields[testresult.FieldExitCode] = struct{}{}
}

// ExitCodeCleared returns if the "exit_code" field was cleared in this mutation.
func (m *TestResultMutation) ExitCodeCleared() bool {
	_, ok := m.clearedFields[testresult.FieldExitCode]
	return ok
}

// ResetExitCode resets all changes to the "exit_code" field.
func (m *TestResultMutation) ResetExitCode() {
	m.exit_code = nil
	m.addexit_code = nil
	delete(m.clearedFields, testresult.FieldExitCode)
}

// SetHostname sets the "hostname" field.
func (m *TestResultMutation) SetHostname(s string) {
	m.hostname = &s
}

// Hostname returns the value of the "hostname" field in the mutation.
func (m *TestResultMutation) Hostname() (r string, exists bool) {
	v := m.hostname
	if v == nil {
		return
	}
	return *v, true
}

// OldHostname returns the old "hostname" field's value of the TestResult entity.
// If the TestResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestResultMutation) OldHostname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHostname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHostname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHostname: %w", err)
	}
	return oldValue.Hostname, nil
}

// ClearHostname clears the value of the "hostname" field.
func (m *TestResultMutation) ClearHostname() {
	m.hostname = nil
	m.clearedFields[testresult.FieldHostname] = struct{}{}
}

// HostnameCleared returns if the "hostname" field was cleared in this mutation.
func (m *TestResultMutation) HostnameCleared() bool {
	_, ok := m.clearedFields[testresult.FieldHostname]
	return ok
}

// ResetHostname resets all changes to the "hostname" field.
func (m *TestResultMutation) ResetHostname() {
	m.hostname = nil
	delete(m.clearedFields, testresult.FieldHostname)
}

// SetTimingBreakdown sets the "timing_breakdown" field.
func (m *TestResultMutation) SetTimingBreakdown(value map[string]interface{}) {
	m.timing_breakdown = &value
}

// TimingBreakdown returns the value of the "timing_breakdown" field in the mutation.
func (m *TestResultMutation) TimingBreakdown() (r map[string]interface{}, exists bool) {
	v := m.timing_breakdown
	if v == nil {
		return
	}
	return *v, true
}

// OldTimingBreakdown returns the old "timing_breakdown" field's value of the TestResult entity.
// If the TestResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestResultMutation) OldTimingBreakdown(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimingBreakdown is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimingBreakdown requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimingBreakdown: %w", err)
	}
	return oldValue.TimingBreakdown, nil
}

// ClearTimingBreakdown clears the value of the "timing_breakdown" field.
func (m *TestResultMutation) ClearTimingBreakdown() {
	m.timing_breakdown = nil
	m.clearedFields[testresult.FieldTimingBreakdown] = struct{}{}
}

// TimingBreakdownCleared returns if the "timing_breakdown" field was cleared in this mutation.
func (m *TestResultMutation) TimingBreakdownCleared() bool {
	_, ok := m.clearedFields[testresult.FieldTimingBreakdown]
	return ok
}

// ResetTimingBreakdown resets all changes to the "timing_breakdown" field.
func (m *TestResultMutation) ResetTimingBreakdown() {
	m.timing_breakdown = nil
	delete(m.clearedFields, testresult.FieldTimingBreakdown)
}

// SetTestSummaryID sets the "test_summary" edge to the TestSummary entity by id.
func (m *TestResultMutation) SetTestSummaryID(id int64) {
	m.test_summary = &id
}

// ClearTestSummary clears the "test_summary" edge to the TestSummary entity.
func (m *TestResultMutation) ClearTestSummary() {
	m.clearedtest_summary = true
}

// TestSummaryCleared reports if the "test_summary" edge to the TestSummary entity was cleared.
func (m *TestResultMutation) TestSummaryCleared() bool {
	return m.clearedtest_summary
}

// TestSummaryID returns the "test_summary" edge ID in the mutation.
func (m *TestResultMutation) TestSummaryID() (id int64, exists bool) {
	if m.test_summary != nil {
		return *m.test_summary, true
	}
	return
}

// TestSummaryIDs returns the "test_summary" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TestSummaryID instead. It exists only for internal usage by the builders.
func (m *TestResultMutation) TestSummaryIDs() (ids []int64) {
	if id := m.test_summary; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTestSummary resets all changes to the "test_summary" edge.
func (m *TestResultMutation) ResetTestSummary() {
	m.test_summary = nil
	m.clearedtest_summary = false
}

// Where appends a list predicates to the TestResultMutation builder.
func (m *TestResultMutation) Where(ps ...predicate.TestResult) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TestResultMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TestResultMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TestResult, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TestResultMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TestResultMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TestResult).
func (m *TestResultMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TestResultMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.run != nil {
		fields = append(fields, testresult.FieldRun)
	}
	if m.shard != nil {
		fields = append(fields, testresult.FieldShard)
	}
	if m.attempt != nil {
		fields = append(fields, testresult.FieldAttempt)
	}
	if m.status != nil {
		fields = append(fields, testresult.FieldStatus)
	}
	if m.status_details != nil {
		fields = append(fields, testresult.FieldStatusDetails)
	}
	if m.cached_locally != nil {
		fields = append(fields, testresult.FieldCachedLocally)
	}
	if m.test_attempt_start != nil {
		fields = append(fields, testresult.FieldTestAttemptStart)
	}
	if m.test_attempt_duration_in_ms != nil {
		fields = append(fields, testresult.FieldTestAttemptDurationInMs)
	}
	if m.warning != nil {
		fields = append(fields, testresult.FieldWarning)
	}
	if m.strategy != nil {
		fields = append(fields, testresult.FieldStrategy)
	}
	if m.cached_remotely != nil {
		fields = append(fields, testresult.FieldCachedRemotely)
	}
	if m.exit_code != nil {
		fields = append(fields, testresult.FieldExitCode)
	}
	if m.hostname != nil {
		fields = append(fields, testresult.FieldHostname)
	}
	if m.timing_breakdown != nil {
		fields = append(fields, testresult.FieldTimingBreakdown)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TestResultMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case testresult.FieldRun:
		return m.Run()
	case testresult.FieldShard:
		return m.Shard()
	case testresult.FieldAttempt:
		return m.Attempt()
	case testresult.FieldStatus:
		return m.Status()
	case testresult.FieldStatusDetails:
		return m.StatusDetails()
	case testresult.FieldCachedLocally:
		return m.CachedLocally()
	case testresult.FieldTestAttemptStart:
		return m.TestAttemptStart()
	case testresult.FieldTestAttemptDurationInMs:
		return m.TestAttemptDurationInMs()
	case testresult.FieldWarning:
		return m.Warning()
	case testresult.FieldStrategy:
		return m.Strategy()
	case testresult.FieldCachedRemotely:
		return m.CachedRemotely()
	case testresult.FieldExitCode:
		return m.ExitCode()
	case testresult.FieldHostname:
		return m.Hostname()
	case testresult.FieldTimingBreakdown:
		return m.TimingBreakdown()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TestResultMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case testresult.FieldRun:
		return m.OldRun(ctx)
	case testresult.FieldShard:
		return m.OldShard(ctx)
	case testresult.FieldAttempt:
		return m.OldAttempt(ctx)
	case testresult.FieldStatus:
		return m.OldStatus(ctx)
	case testresult.FieldStatusDetails:
		return m.OldStatusDetails(ctx)
	case testresult.FieldCachedLocally:
		return m.OldCachedLocally(ctx)
	case testresult.FieldTestAttemptStart:
		return m.OldTestAttemptStart(ctx)
	case testresult.FieldTestAttemptDurationInMs:
		return m.OldTestAttemptDurationInMs(ctx)
	case testresult.FieldWarning:
		return m.OldWarning(ctx)
	case testresult.FieldStrategy:
		return m.OldStrategy(ctx)
	case testresult.FieldCachedRemotely:
		return m.OldCachedRemotely(ctx)
	case testresult.FieldExitCode:
		return m.OldExitCode(ctx)
	case testresult.FieldHostname:
		return m.OldHostname(ctx)
	case testresult.FieldTimingBreakdown:
		return m.OldTimingBreakdown(ctx)
	}
	return nil, fmt.Errorf("unknown TestResult field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestResultMutation) SetField(name string, value ent.Value) error {
	switch name {
	case testresult.FieldRun:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRun(v)
		return nil
	case testresult.FieldShard:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShard(v)
		return nil
	case testresult.FieldAttempt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttempt(v)
		return nil
	case testresult.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case testresult.FieldStatusDetails:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusDetails(v)
		return nil
	case testresult.FieldCachedLocally:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCachedLocally(v)
		return nil
	case testresult.FieldTestAttemptStart:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTestAttemptStart(v)
		return nil
	case testresult.FieldTestAttemptDurationInMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTestAttemptDurationInMs(v)
		return nil
	case testresult.FieldWarning:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWarning(v)
		return nil
	case testresult.FieldStrategy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStrategy(v)
		return nil
	case testresult.FieldCachedRemotely:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCachedRemotely(v)
		return nil
	case testresult.FieldExitCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExitCode(v)
		return nil
	case testresult.FieldHostname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHostname(v)
		return nil
	case testresult.FieldTimingBreakdown:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimingBreakdown(v)
		return nil
	}
	return fmt.Errorf("unknown TestResult field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TestResultMutation) AddedFields() []string {
	var fields []string
	if m.addrun != nil {
		fields = append(fields, testresult.FieldRun)
	}
	if m.addshard != nil {
		fields = append(fields, testresult.FieldShard)
	}
	if m.addattempt != nil {
		fields = append(fields, testresult.FieldAttempt)
	}
	if m.addtest_attempt_duration_in_ms != nil {
		fields = append(fields, testresult.FieldTestAttemptDurationInMs)
	}
	if m.addexit_code != nil {
		fields = append(fields, testresult.FieldExitCode)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TestResultMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case testresult.FieldRun:
		return m.AddedRun()
	case testresult.FieldShard:
		return m.AddedShard()
	case testresult.FieldAttempt:
		return m.AddedAttempt()
	case testresult.FieldTestAttemptDurationInMs:
		return m.AddedTestAttemptDurationInMs()
	case testresult.FieldExitCode:
		return m.AddedExitCode()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestResultMutation) AddField(name string, value ent.Value) error {
	switch name {
	case testresult.FieldRun:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRun(v)
		return nil
	case testresult.FieldShard:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShard(v)
		return nil
	case testresult.FieldAttempt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAttempt(v)
		return nil
	case testresult.FieldTestAttemptDurationInMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTestAttemptDurationInMs(v)
		return nil
	case testresult.FieldExitCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExitCode(v)
		return nil
	}
	return fmt.Errorf("unknown TestResult numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TestResultMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(testresult.FieldStatus) {
		fields = append(fields, testresult.FieldStatus)
	}
	if m.FieldCleared(testresult.FieldStatusDetails) {
		fields = append(fields, testresult.FieldStatusDetails)
	}
	if m.FieldCleared(testresult.FieldCachedLocally) {
		fields = append(fields, testresult.FieldCachedLocally)
	}
	if m.FieldCleared(testresult.FieldTestAttemptStart) {
		fields = append(fields, testresult.FieldTestAttemptStart)
	}
	if m.FieldCleared(testresult.FieldTestAttemptDurationInMs) {
		fields = append(fields, testresult.FieldTestAttemptDurationInMs)
	}
	if m.FieldCleared(testresult.FieldWarning) {
		fields = append(fields, testresult.FieldWarning)
	}
	if m.FieldCleared(testresult.FieldStrategy) {
		fields = append(fields, testresult.FieldStrategy)
	}
	if m.FieldCleared(testresult.FieldCachedRemotely) {
		fields = append(fields, testresult.FieldCachedRemotely)
	}
	if m.FieldCleared(testresult.FieldExitCode) {
		fields = append(fields, testresult.FieldExitCode)
	}
	if m.FieldCleared(testresult.FieldHostname) {
		fields = append(fields, testresult.FieldHostname)
	}
	if m.FieldCleared(testresult.FieldTimingBreakdown) {
		fields = append(fields, testresult.FieldTimingBreakdown)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TestResultMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TestResultMutation) ClearField(name string) error {
	switch name {
	case testresult.FieldStatus:
		m.ClearStatus()
		return nil
	case testresult.FieldStatusDetails:
		m.ClearStatusDetails()
		return nil
	case testresult.FieldCachedLocally:
		m.ClearCachedLocally()
		return nil
	case testresult.FieldTestAttemptStart:
		m.ClearTestAttemptStart()
		return nil
	case testresult.FieldTestAttemptDurationInMs:
		m.ClearTestAttemptDurationInMs()
		return nil
	case testresult.FieldWarning:
		m.ClearWarning()
		return nil
	case testresult.FieldStrategy:
		m.ClearStrategy()
		return nil
	case testresult.FieldCachedRemotely:
		m.ClearCachedRemotely()
		return nil
	case testresult.FieldExitCode:
		m.ClearExitCode()
		return nil
	case testresult.FieldHostname:
		m.ClearHostname()
		return nil
	case testresult.FieldTimingBreakdown:
		m.ClearTimingBreakdown()
		return nil
	}
	return fmt.Errorf("unknown TestResult nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TestResultMutation) ResetField(name string) error {
	switch name {
	case testresult.FieldRun:
		m.ResetRun()
		return nil
	case testresult.FieldShard:
		m.ResetShard()
		return nil
	case testresult.FieldAttempt:
		m.ResetAttempt()
		return nil
	case testresult.FieldStatus:
		m.ResetStatus()
		return nil
	case testresult.FieldStatusDetails:
		m.ResetStatusDetails()
		return nil
	case testresult.FieldCachedLocally:
		m.ResetCachedLocally()
		return nil
	case testresult.FieldTestAttemptStart:
		m.ResetTestAttemptStart()
		return nil
	case testresult.FieldTestAttemptDurationInMs:
		m.ResetTestAttemptDurationInMs()
		return nil
	case testresult.FieldWarning:
		m.ResetWarning()
		return nil
	case testresult.FieldStrategy:
		m.ResetStrategy()
		return nil
	case testresult.FieldCachedRemotely:
		m.ResetCachedRemotely()
		return nil
	case testresult.FieldExitCode:
		m.ResetExitCode()
		return nil
	case testresult.FieldHostname:
		m.ResetHostname()
		return nil
	case testresult.FieldTimingBreakdown:
		m.ResetTimingBreakdown()
		return nil
	}
	return fmt.Errorf("unknown TestResult field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TestResultMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.test_summary != nil {
		edges = append(edges, testresult.EdgeTestSummary)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TestResultMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case testresult.EdgeTestSummary:
		if id := m.test_summary; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TestResultMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TestResultMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TestResultMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtest_summary {
		edges = append(edges, testresult.EdgeTestSummary)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TestResultMutation) EdgeCleared(name string) bool {
	switch name {
	case testresult.EdgeTestSummary:
		return m.clearedtest_summary
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TestResultMutation) ClearEdge(name string) error {
	switch name {
	case testresult.EdgeTestSummary:
		m.ClearTestSummary()
		return nil
	}
	return fmt.Errorf("unknown TestResult unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TestResultMutation) ResetEdge(name string) error {
	switch name {
	case testresult.EdgeTestSummary:
		m.ResetTestSummary()
		return nil
	}
	return fmt.Errorf("unknown TestResult edge %s", name)
}

// TestSummaryMutation represents an operation that mutates the TestSummary nodes in the graph.
type TestSummaryMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int64
	overall_status              *string
	total_run_count             *int32
	addtotal_run_count          *int32
	run_count                   *int32
	addrun_count                *int32
	attempt_count               *int32
	addattempt_count            *int32
	shard_count                 *int32
	addshard_count              *int32
	total_num_cached            *int32
	addtotal_num_cached         *int32
	first_start_time            *time.Time
	last_stop_time              *time.Time
	total_run_duration_in_ms    *int64
	addtotal_run_duration_in_ms *int64
	clearedFields               map[string]struct{}
	invocation_target           *int64
	clearedinvocation_target    bool
	test_results                map[int64]struct{}
	removedtest_results         map[int64]struct{}
	clearedtest_results         bool
	done                        bool
	oldValue                    func(context.Context) (*TestSummary, error)
	predicates                  []predicate.TestSummary
}

var _ ent.Mutation = (*TestSummaryMutation)(nil)

// testsummaryOption allows management of the mutation configuration using functional options.
type testsummaryOption func(*TestSummaryMutation)

// newTestSummaryMutation creates new mutation for the TestSummary entity.
func newTestSummaryMutation(c config, op Op, opts ...testsummaryOption) *TestSummaryMutation {
	m := &TestSummaryMutation{
		config:        c,
		op:            op,
		typ:           TypeTestSummary,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTestSummaryID sets the ID field of the mutation.
func withTestSummaryID(id int64) testsummaryOption {
	return func(m *TestSummaryMutation) {
		var (
			err   error
			once  sync.Once
			value *TestSummary
		)
		m.oldValue = func(ctx context.Context) (*TestSummary, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TestSummary.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTestSummary sets the old TestSummary of the mutation.
func withTestSummary(node *TestSummary) testsummaryOption {
	return func(m *TestSummaryMutation) {
		m.oldValue = func(context.Context) (*TestSummary, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TestSummaryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TestSummaryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TestSummary entities.
func (m *TestSummaryMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TestSummaryMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TestSummaryMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TestSummary.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOverallStatus sets the "overall_status" field.
func (m *TestSummaryMutation) SetOverallStatus(s string) {
	m.overall_status = &s
}

// OverallStatus returns the value of the "overall_status" field in the mutation.
func (m *TestSummaryMutation) OverallStatus() (r string, exists bool) {
	v := m.overall_status
	if v == nil {
		return
	}
	return *v, true
}

// OldOverallStatus returns the old "overall_status" field's value of the TestSummary entity.
// If the TestSummary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestSummaryMutation) OldOverallStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOverallStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOverallStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOverallStatus: %w", err)
	}
	return oldValue.OverallStatus, nil
}

// ClearOverallStatus clears the value of the "overall_status" field.
func (m *TestSummaryMutation) ClearOverallStatus() {
	m.overall_status = nil
	m.clearedFields[testsummary.FieldOverallStatus] = struct{}{}
}

// OverallStatusCleared returns if the "overall_status" field was cleared in this mutation.
func (m *TestSummaryMutation) OverallStatusCleared() bool {
	_, ok := m.clearedFields[testsummary.FieldOverallStatus]
	return ok
}

// ResetOverallStatus resets all changes to the "overall_status" field.
func (m *TestSummaryMutation) ResetOverallStatus() {
	m.overall_status = nil
	delete(m.clearedFields, testsummary.FieldOverallStatus)
}

// SetTotalRunCount sets the "total_run_count" field.
func (m *TestSummaryMutation) SetTotalRunCount(i int32) {
	m.total_run_count = &i
	m.addtotal_run_count = nil
}

// TotalRunCount returns the value of the "total_run_count" field in the mutation.
func (m *TestSummaryMutation) TotalRunCount() (r int32, exists bool) {
	v := m.total_run_count
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalRunCount returns the old "total_run_count" field's value of the TestSummary entity.
// If the TestSummary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestSummaryMutation) OldTotalRunCount(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalRunCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalRunCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalRunCount: %w", err)
	}
	return oldValue.TotalRunCount, nil
}

// AddTotalRunCount adds i to the "total_run_count" field.
func (m *TestSummaryMutation) AddTotalRunCount(i int32) {
	if m.addtotal_run_count != nil {
		*m.addtotal_run_count += i
	} else {
		m.addtotal_run_count = &i
	}
}

// AddedTotalRunCount returns the value that was added to the "total_run_count" field in this mutation.
func (m *TestSummaryMutation) AddedTotalRunCount() (r int32, exists bool) {
	v := m.addtotal_run_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearTotalRunCount clears the value of the "total_run_count" field.
func (m *TestSummaryMutation) ClearTotalRunCount() {
	m.total_run_count = nil
	m.addtotal_run_count = nil
	m.clearedFields[testsummary.FieldTotalRunCount] = struct{}{}
}

// TotalRunCountCleared returns if the "total_run_count" field was cleared in this mutation.
func (m *TestSummaryMutation) TotalRunCountCleared() bool {
	_, ok := m.clearedFields[testsummary.FieldTotalRunCount]
	return ok
}

// ResetTotalRunCount resets all changes to the "total_run_count" field.
func (m *TestSummaryMutation) ResetTotalRunCount() {
	m.total_run_count = nil
	m.addtotal_run_count = nil
	delete(m.clearedFields, testsummary.FieldTotalRunCount)
}

// SetRunCount sets the "run_count" field.
func (m *TestSummaryMutation) SetRunCount(i int32) {
	m.run_count = &i
	m.addrun_count = nil
}

// RunCount returns the value of the "run_count" field in the mutation.
func (m *TestSummaryMutation) RunCount() (r int32, exists bool) {
	v := m.run_count
	if v == nil {
		return
	}
	return *v, true
}

// OldRunCount returns the old "run_count" field's value of the TestSummary entity.
// If the TestSummary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestSummaryMutation) OldRunCount(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRunCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRunCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRunCount: %w", err)
	}
	return oldValue.RunCount, nil
}

// AddRunCount adds i to the "run_count" field.
func (m *TestSummaryMutation) AddRunCount(i int32) {
	if m.addrun_count != nil {
		*m.addrun_count += i
	} else {
		m.addrun_count = &i
	}
}

// AddedRunCount returns the value that was added to the "run_count" field in this mutation.
func (m *TestSummaryMutation) AddedRunCount() (r int32, exists bool) {
	v := m.addrun_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearRunCount clears the value of the "run_count" field.
func (m *TestSummaryMutation) ClearRunCount() {
	m.run_count = nil
	m.addrun_count = nil
	m.clearedFields[testsummary.FieldRunCount] = struct{}{}
}

// RunCountCleared returns if the "run_count" field was cleared in this mutation.
func (m *TestSummaryMutation) RunCountCleared() bool {
	_, ok := m.clearedFields[testsummary.FieldRunCount]
	return ok
}

// ResetRunCount resets all changes to the "run_count" field.
func (m *TestSummaryMutation) ResetRunCount() {
	m.run_count = nil
	m.addrun_count = nil
	delete(m.clearedFields, testsummary.FieldRunCount)
}

// SetAttemptCount sets the "attempt_count" field.
func (m *TestSummaryMutation) SetAttemptCount(i int32) {
	m.attempt_count = &i
	m.addattempt_count = nil
}

// AttemptCount returns the value of the "attempt_count" field in the mutation.
func (m *TestSummaryMutation) AttemptCount() (r int32, exists bool) {
	v := m.attempt_count
	if v == nil {
		return
	}
	return *v, true
}

// OldAttemptCount returns the old "attempt_count" field's value of the TestSummary entity.
// If the TestSummary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestSummaryMutation) OldAttemptCount(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttemptCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttemptCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttemptCount: %w", err)
	}
	return oldValue.AttemptCount, nil
}

// AddAttemptCount adds i to the "attempt_count" field.
func (m *TestSummaryMutation) AddAttemptCount(i int32) {
	if m.addattempt_count != nil {
		*m.addattempt_count += i
	} else {
		m.addattempt_count = &i
	}
}

// AddedAttemptCount returns the value that was added to the "attempt_count" field in this mutation.
func (m *TestSummaryMutation) AddedAttemptCount() (r int32, exists bool) {
	v := m.addattempt_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearAttemptCount clears the value of the "attempt_count" field.
func (m *TestSummaryMutation) ClearAttemptCount() {
	m.attempt_count = nil
	m.addattempt_count = nil
	m.clearedFields[testsummary.FieldAttemptCount] = struct{}{}
}

// AttemptCountCleared returns if the "attempt_count" field was cleared in this mutation.
func (m *TestSummaryMutation) AttemptCountCleared() bool {
	_, ok := m.clearedFields[testsummary.FieldAttemptCount]
	return ok
}

// ResetAttemptCount resets all changes to the "attempt_count" field.
func (m *TestSummaryMutation) ResetAttemptCount() {
	m.attempt_count = nil
	m.addattempt_count = nil
	delete(m.clearedFields, testsummary.FieldAttemptCount)
}

// SetShardCount sets the "shard_count" field.
func (m *TestSummaryMutation) SetShardCount(i int32) {
	m.shard_count = &i
	m.addshard_count = nil
}

// ShardCount returns the value of the "shard_count" field in the mutation.
func (m *TestSummaryMutation) ShardCount() (r int32, exists bool) {
	v := m.shard_count
	if v == nil {
		return
	}
	return *v, true
}

// OldShardCount returns the old "shard_count" field's value of the TestSummary entity.
// If the TestSummary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestSummaryMutation) OldShardCount(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShardCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShardCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShardCount: %w", err)
	}
	return oldValue.ShardCount, nil
}

// AddShardCount adds i to the "shard_count" field.
func (m *TestSummaryMutation) AddShardCount(i int32) {
	if m.addshard_count != nil {
		*m.addshard_count += i
	} else {
		m.addshard_count = &i
	}
}

// AddedShardCount returns the value that was added to the "shard_count" field in this mutation.
func (m *TestSummaryMutation) AddedShardCount() (r int32, exists bool) {
	v := m.addshard_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearShardCount clears the value of the "shard_count" field.
func (m *TestSummaryMutation) ClearShardCount() {
	m.shard_count = nil
	m.addshard_count = nil
	m.clearedFields[testsummary.FieldShardCount] = struct{}{}
}

// ShardCountCleared returns if the "shard_count" field was cleared in this mutation.
func (m *TestSummaryMutation) ShardCountCleared() bool {
	_, ok := m.clearedFields[testsummary.FieldShardCount]
	return ok
}

// ResetShardCount resets all changes to the "shard_count" field.
func (m *TestSummaryMutation) ResetShardCount() {
	m.shard_count = nil
	m.addshard_count = nil
	delete(m.clearedFields, testsummary.FieldShardCount)
}

// SetTotalNumCached sets the "total_num_cached" field.
func (m *TestSummaryMutation) SetTotalNumCached(i int32) {
	m.total_num_cached = &i
	m.addtotal_num_cached = nil
}

// TotalNumCached returns the value of the "total_num_cached" field in the mutation.
func (m *TestSummaryMutation) TotalNumCached() (r int32, exists bool) {
	v := m.total_num_cached
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalNumCached returns the old "total_num_cached" field's value of the TestSummary entity.
// If the TestSummary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestSummaryMutation) OldTotalNumCached(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalNumCached is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalNumCached requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalNumCached: %w", err)
	}
	return oldValue.TotalNumCached, nil
}

// AddTotalNumCached adds i to the "total_num_cached" field.
func (m *TestSummaryMutation) AddTotalNumCached(i int32) {
	if m.addtotal_num_cached != nil {
		*m.addtotal_num_cached += i
	} else {
		m.addtotal_num_cached = &i
	}
}

// AddedTotalNumCached returns the value that was added to the "total_num_cached" field in this mutation.
func (m *TestSummaryMutation) AddedTotalNumCached() (r int32, exists bool) {
	v := m.addtotal_num_cached
	if v == nil {
		return
	}
	return *v, true
}

// ClearTotalNumCached clears the value of the "total_num_cached" field.
func (m *TestSummaryMutation) ClearTotalNumCached() {
	m.total_num_cached = nil
	m.addtotal_num_cached = nil
	m.clearedFields[testsummary.FieldTotalNumCached] = struct{}{}
}

// TotalNumCachedCleared returns if the "total_num_cached" field was cleared in this mutation.
func (m *TestSummaryMutation) TotalNumCachedCleared() bool {
	_, ok := m.clearedFields[testsummary.FieldTotalNumCached]
	return ok
}

// ResetTotalNumCached resets all changes to the "total_num_cached" field.
func (m *TestSummaryMutation) ResetTotalNumCached() {
	m.total_num_cached = nil
	m.addtotal_num_cached = nil
	delete(m.clearedFields, testsummary.FieldTotalNumCached)
}

// SetFirstStartTime sets the "first_start_time" field.
func (m *TestSummaryMutation) SetFirstStartTime(t time.Time) {
	m.first_start_time = &t
}

// FirstStartTime returns the value of the "first_start_time" field in the mutation.
func (m *TestSummaryMutation) FirstStartTime() (r time.Time, exists bool) {
	v := m.first_start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstStartTime returns the old "first_start_time" field's value of the TestSummary entity.
// If the TestSummary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestSummaryMutation) OldFirstStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstStartTime: %w", err)
	}
	return oldValue.FirstStartTime, nil
}

// ClearFirstStartTime clears the value of the "first_start_time" field.
func (m *TestSummaryMutation) ClearFirstStartTime() {
	m.first_start_time = nil
	m.clearedFields[testsummary.FieldFirstStartTime] = struct{}{}
}

// FirstStartTimeCleared returns if the "first_start_time" field was cleared in this mutation.
func (m *TestSummaryMutation) FirstStartTimeCleared() bool {
	_, ok := m.clearedFields[testsummary.FieldFirstStartTime]
	return ok
}

// ResetFirstStartTime resets all changes to the "first_start_time" field.
func (m *TestSummaryMutation) ResetFirstStartTime() {
	m.first_start_time = nil
	delete(m.clearedFields, testsummary.FieldFirstStartTime)
}

// SetLastStopTime sets the "last_stop_time" field.
func (m *TestSummaryMutation) SetLastStopTime(t time.Time) {
	m.last_stop_time = &t
}

// LastStopTime returns the value of the "last_stop_time" field in the mutation.
func (m *TestSummaryMutation) LastStopTime() (r time.Time, exists bool) {
	v := m.last_stop_time
	if v == nil {
		return
	}
	return *v, true
}

// OldLastStopTime returns the old "last_stop_time" field's value of the TestSummary entity.
// If the TestSummary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestSummaryMutation) OldLastStopTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastStopTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastStopTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastStopTime: %w", err)
	}
	return oldValue.LastStopTime, nil
}

// ClearLastStopTime clears the value of the "last_stop_time" field.
func (m *TestSummaryMutation) ClearLastStopTime() {
	m.last_stop_time = nil
	m.clearedFields[testsummary.FieldLastStopTime] = struct{}{}
}

// LastStopTimeCleared returns if the "last_stop_time" field was cleared in this mutation.
func (m *TestSummaryMutation) LastStopTimeCleared() bool {
	_, ok := m.clearedFields[testsummary.FieldLastStopTime]
	return ok
}

// ResetLastStopTime resets all changes to the "last_stop_time" field.
func (m *TestSummaryMutation) ResetLastStopTime() {
	m.last_stop_time = nil
	delete(m.clearedFields, testsummary.FieldLastStopTime)
}

// SetTotalRunDurationInMs sets the "total_run_duration_in_ms" field.
func (m *TestSummaryMutation) SetTotalRunDurationInMs(i int64) {
	m.total_run_duration_in_ms = &i
	m.addtotal_run_duration_in_ms = nil
}

// TotalRunDurationInMs returns the value of the "total_run_duration_in_ms" field in the mutation.
func (m *TestSummaryMutation) TotalRunDurationInMs() (r int64, exists bool) {
	v := m.total_run_duration_in_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalRunDurationInMs returns the old "total_run_duration_in_ms" field's value of the TestSummary entity.
// If the TestSummary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestSummaryMutation) OldTotalRunDurationInMs(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalRunDurationInMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalRunDurationInMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalRunDurationInMs: %w", err)
	}
	return oldValue.TotalRunDurationInMs, nil
}

// AddTotalRunDurationInMs adds i to the "total_run_duration_in_ms" field.
func (m *TestSummaryMutation) AddTotalRunDurationInMs(i int64) {
	if m.addtotal_run_duration_in_ms != nil {
		*m.addtotal_run_duration_in_ms += i
	} else {
		m.addtotal_run_duration_in_ms = &i
	}
}

// AddedTotalRunDurationInMs returns the value that was added to the "total_run_duration_in_ms" field in this mutation.
func (m *TestSummaryMutation) AddedTotalRunDurationInMs() (r int64, exists bool) {
	v := m.addtotal_run_duration_in_ms
	if v == nil {
		return
	}
	return *v, true
}

// ClearTotalRunDurationInMs clears the value of the "total_run_duration_in_ms" field.
func (m *TestSummaryMutation) ClearTotalRunDurationInMs() {
	m.total_run_duration_in_ms = nil
	m.addtotal_run_duration_in_ms = nil
	m.clearedFields[testsummary.FieldTotalRunDurationInMs] = struct{}{}
}

// TotalRunDurationInMsCleared returns if the "total_run_duration_in_ms" field was cleared in this mutation.
func (m *TestSummaryMutation) TotalRunDurationInMsCleared() bool {
	_, ok := m.clearedFields[testsummary.FieldTotalRunDurationInMs]
	return ok
}

// ResetTotalRunDurationInMs resets all changes to the "total_run_duration_in_ms" field.
func (m *TestSummaryMutation) ResetTotalRunDurationInMs() {
	m.total_run_duration_in_ms = nil
	m.addtotal_run_duration_in_ms = nil
	delete(m.clearedFields, testsummary.FieldTotalRunDurationInMs)
}

// SetInvocationTargetID sets the "invocation_target" edge to the InvocationTarget entity by id.
func (m *TestSummaryMutation) SetInvocationTargetID(id int64) {
	m.invocation_target = &id
}

// ClearInvocationTarget clears the "invocation_target" edge to the InvocationTarget entity.
func (m *TestSummaryMutation) ClearInvocationTarget() {
	m.clearedinvocation_target = true
}

// InvocationTargetCleared reports if the "invocation_target" edge to the InvocationTarget entity was cleared.
func (m *TestSummaryMutation) InvocationTargetCleared() bool {
	return m.clearedinvocation_target
}

// InvocationTargetID returns the "invocation_target" edge ID in the mutation.
func (m *TestSummaryMutation) InvocationTargetID() (id int64, exists bool) {
	if m.invocation_target != nil {
		return *m.invocation_target, true
	}
	return
}

// InvocationTargetIDs returns the "invocation_target" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InvocationTargetID instead. It exists only for internal usage by the builders.
func (m *TestSummaryMutation) InvocationTargetIDs() (ids []int64) {
	if id := m.invocation_target; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInvocationTarget resets all changes to the "invocation_target" edge.
func (m *TestSummaryMutation) ResetInvocationTarget() {
	m.invocation_target = nil
	m.clearedinvocation_target = false
}

// AddTestResultIDs adds the "test_results" edge to the TestResult entity by ids.
func (m *TestSummaryMutation) AddTestResultIDs(ids ...int64) {
	if m.test_results == nil {
		m.test_results = make(map[int64]struct{})
	}
	for i := range ids {
		m.test_results[ids[i]] = struct{}{}
	}
}

// ClearTestResults clears the "test_results" edge to the TestResult entity.
func (m *TestSummaryMutation) ClearTestResults() {
	m.clearedtest_results = true
}

// TestResultsCleared reports if the "test_results" edge to the TestResult entity was cleared.
func (m *TestSummaryMutation) TestResultsCleared() bool {
	return m.clearedtest_results
}

// RemoveTestResultIDs removes the "test_results" edge to the TestResult entity by IDs.
func (m *TestSummaryMutation) RemoveTestResultIDs(ids ...int64) {
	if m.removedtest_results == nil {
		m.removedtest_results = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.test_results, ids[i])
		m.removedtest_results[ids[i]] = struct{}{}
	}
}

// RemovedTestResults returns the removed IDs of the "test_results" edge to the TestResult entity.
func (m *TestSummaryMutation) RemovedTestResultsIDs() (ids []int64) {
	for id := range m.removedtest_results {
		ids = append(ids, id)
	}
	return
}

// TestResultsIDs returns the "test_results" edge IDs in the mutation.
func (m *TestSummaryMutation) TestResultsIDs() (ids []int64) {
	for id := range m.test_results {
		ids = append(ids, id)
	}
	return
}

// ResetTestResults resets all changes to the "test_results" edge.
func (m *TestSummaryMutation) ResetTestResults() {
	m.test_results = nil
	m.clearedtest_results = false
	m.removedtest_results = nil
}

// Where appends a list predicates to the TestSummaryMutation builder.
func (m *TestSummaryMutation) Where(ps ...predicate.TestSummary) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TestSummaryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TestSummaryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TestSummary, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TestSummaryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TestSummaryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TestSummary).
func (m *TestSummaryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TestSummaryMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.overall_status != nil {
		fields = append(fields, testsummary.FieldOverallStatus)
	}
	if m.total_run_count != nil {
		fields = append(fields, testsummary.FieldTotalRunCount)
	}
	if m.run_count != nil {
		fields = append(fields, testsummary.FieldRunCount)
	}
	if m.attempt_count != nil {
		fields = append(fields, testsummary.FieldAttemptCount)
	}
	if m.shard_count != nil {
		fields = append(fields, testsummary.FieldShardCount)
	}
	if m.total_num_cached != nil {
		fields = append(fields, testsummary.FieldTotalNumCached)
	}
	if m.first_start_time != nil {
		fields = append(fields, testsummary.FieldFirstStartTime)
	}
	if m.last_stop_time != nil {
		fields = append(fields, testsummary.FieldLastStopTime)
	}
	if m.total_run_duration_in_ms != nil {
		fields = append(fields, testsummary.FieldTotalRunDurationInMs)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TestSummaryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case testsummary.FieldOverallStatus:
		return m.OverallStatus()
	case testsummary.FieldTotalRunCount:
		return m.TotalRunCount()
	case testsummary.FieldRunCount:
		return m.RunCount()
	case testsummary.FieldAttemptCount:
		return m.AttemptCount()
	case testsummary.FieldShardCount:
		return m.ShardCount()
	case testsummary.FieldTotalNumCached:
		return m.TotalNumCached()
	case testsummary.FieldFirstStartTime:
		return m.FirstStartTime()
	case testsummary.FieldLastStopTime:
		return m.LastStopTime()
	case testsummary.FieldTotalRunDurationInMs:
		return m.TotalRunDurationInMs()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TestSummaryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case testsummary.FieldOverallStatus:
		return m.OldOverallStatus(ctx)
	case testsummary.FieldTotalRunCount:
		return m.OldTotalRunCount(ctx)
	case testsummary.FieldRunCount:
		return m.OldRunCount(ctx)
	case testsummary.FieldAttemptCount:
		return m.OldAttemptCount(ctx)
	case testsummary.FieldShardCount:
		return m.OldShardCount(ctx)
	case testsummary.FieldTotalNumCached:
		return m.OldTotalNumCached(ctx)
	case testsummary.FieldFirstStartTime:
		return m.OldFirstStartTime(ctx)
	case testsummary.FieldLastStopTime:
		return m.OldLastStopTime(ctx)
	case testsummary.FieldTotalRunDurationInMs:
		return m.OldTotalRunDurationInMs(ctx)
	}
	return nil, fmt.Errorf("unknown TestSummary field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestSummaryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case testsummary.FieldOverallStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOverallStatus(v)
		return nil
	case testsummary.FieldTotalRunCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalRunCount(v)
		return nil
	case testsummary.FieldRunCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRunCount(v)
		return nil
	case testsummary.FieldAttemptCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttemptCount(v)
		return nil
	case testsummary.FieldShardCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShardCount(v)
		return nil
	case testsummary.FieldTotalNumCached:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalNumCached(v)
		return nil
	case testsummary.FieldFirstStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstStartTime(v)
		return nil
	case testsummary.FieldLastStopTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastStopTime(v)
		return nil
	case testsummary.FieldTotalRunDurationInMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalRunDurationInMs(v)
		return nil
	}
	return fmt.Errorf("unknown TestSummary field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TestSummaryMutation) AddedFields() []string {
	var fields []string
	if m.addtotal_run_count != nil {
		fields = append(fields, testsummary.FieldTotalRunCount)
	}
	if m.addrun_count != nil {
		fields = append(fields, testsummary.FieldRunCount)
	}
	if m.addattempt_count != nil {
		fields = append(fields, testsummary.FieldAttemptCount)
	}
	if m.addshard_count != nil {
		fields = append(fields, testsummary.FieldShardCount)
	}
	if m.addtotal_num_cached != nil {
		fields = append(fields, testsummary.FieldTotalNumCached)
	}
	if m.addtotal_run_duration_in_ms != nil {
		fields = append(fields, testsummary.FieldTotalRunDurationInMs)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TestSummaryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case testsummary.FieldTotalRunCount:
		return m.AddedTotalRunCount()
	case testsummary.FieldRunCount:
		return m.AddedRunCount()
	case testsummary.FieldAttemptCount:
		return m.AddedAttemptCount()
	case testsummary.FieldShardCount:
		return m.AddedShardCount()
	case testsummary.FieldTotalNumCached:
		return m.AddedTotalNumCached()
	case testsummary.FieldTotalRunDurationInMs:
		return m.AddedTotalRunDurationInMs()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestSummaryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case testsummary.FieldTotalRunCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalRunCount(v)
		return nil
	case testsummary.FieldRunCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRunCount(v)
		return nil
	case testsummary.FieldAttemptCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAttemptCount(v)
		return nil
	case testsummary.FieldShardCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShardCount(v)
		return nil
	case testsummary.FieldTotalNumCached:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalNumCached(v)
		return nil
	case testsummary.FieldTotalRunDurationInMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalRunDurationInMs(v)
		return nil
	}
	return fmt.Errorf("unknown TestSummary numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TestSummaryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(testsummary.FieldOverallStatus) {
		fields = append(fields, testsummary.FieldOverallStatus)
	}
	if m.FieldCleared(testsummary.FieldTotalRunCount) {
		fields = append(fields, testsummary.FieldTotalRunCount)
	}
	if m.FieldCleared(testsummary.FieldRunCount) {
		fields = append(fields, testsummary.FieldRunCount)
	}
	if m.FieldCleared(testsummary.FieldAttemptCount) {
		fields = append(fields, testsummary.FieldAttemptCount)
	}
	if m.FieldCleared(testsummary.FieldShardCount) {
		fields = append(fields, testsummary.FieldShardCount)
	}
	if m.FieldCleared(testsummary.FieldTotalNumCached) {
		fields = append(fields, testsummary.FieldTotalNumCached)
	}
	if m.FieldCleared(testsummary.FieldFirstStartTime) {
		fields = append(fields, testsummary.FieldFirstStartTime)
	}
	if m.FieldCleared(testsummary.FieldLastStopTime) {
		fields = append(fields, testsummary.FieldLastStopTime)
	}
	if m.FieldCleared(testsummary.FieldTotalRunDurationInMs) {
		fields = append(fields, testsummary.FieldTotalRunDurationInMs)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TestSummaryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TestSummaryMutation) ClearField(name string) error {
	switch name {
	case testsummary.FieldOverallStatus:
		m.ClearOverallStatus()
		return nil
	case testsummary.FieldTotalRunCount:
		m.ClearTotalRunCount()
		return nil
	case testsummary.FieldRunCount:
		m.ClearRunCount()
		return nil
	case testsummary.FieldAttemptCount:
		m.ClearAttemptCount()
		return nil
	case testsummary.FieldShardCount:
		m.ClearShardCount()
		return nil
	case testsummary.FieldTotalNumCached:
		m.ClearTotalNumCached()
		return nil
	case testsummary.FieldFirstStartTime:
		m.ClearFirstStartTime()
		return nil
	case testsummary.FieldLastStopTime:
		m.ClearLastStopTime()
		return nil
	case testsummary.FieldTotalRunDurationInMs:
		m.ClearTotalRunDurationInMs()
		return nil
	}
	return fmt.Errorf("unknown TestSummary nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TestSummaryMutation) ResetField(name string) error {
	switch name {
	case testsummary.FieldOverallStatus:
		m.ResetOverallStatus()
		return nil
	case testsummary.FieldTotalRunCount:
		m.ResetTotalRunCount()
		return nil
	case testsummary.FieldRunCount:
		m.ResetRunCount()
		return nil
	case testsummary.FieldAttemptCount:
		m.ResetAttemptCount()
		return nil
	case testsummary.FieldShardCount:
		m.ResetShardCount()
		return nil
	case testsummary.FieldTotalNumCached:
		m.ResetTotalNumCached()
		return nil
	case testsummary.FieldFirstStartTime:
		m.ResetFirstStartTime()
		return nil
	case testsummary.FieldLastStopTime:
		m.ResetLastStopTime()
		return nil
	case testsummary.FieldTotalRunDurationInMs:
		m.ResetTotalRunDurationInMs()
		return nil
	}
	return fmt.Errorf("unknown TestSummary field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TestSummaryMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.invocation_target != nil {
		edges = append(edges, testsummary.EdgeInvocationTarget)
	}
	if m.test_results != nil {
		edges = append(edges, testsummary.EdgeTestResults)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TestSummaryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case testsummary.EdgeInvocationTarget:
		if id := m.invocation_target; id != nil {
			return []ent.Value{*id}
		}
	case testsummary.EdgeTestResults:
		ids := make([]ent.Value, 0, len(m.test_results))
		for id := range m.test_results {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TestSummaryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtest_results != nil {
		edges = append(edges, testsummary.EdgeTestResults)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TestSummaryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case testsummary.EdgeTestResults:
		ids := make([]ent.Value, 0, len(m.removedtest_results))
		for id := range m.removedtest_results {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TestSummaryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedinvocation_target {
		edges = append(edges, testsummary.EdgeInvocationTarget)
	}
	if m.clearedtest_results {
		edges = append(edges, testsummary.EdgeTestResults)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TestSummaryMutation) EdgeCleared(name string) bool {
	switch name {
	case testsummary.EdgeInvocationTarget:
		return m.clearedinvocation_target
	case testsummary.EdgeTestResults:
		return m.clearedtest_results
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TestSummaryMutation) ClearEdge(name string) error {
	switch name {
	case testsummary.EdgeInvocationTarget:
		m.ClearInvocationTarget()
		return nil
	}
	return fmt.Errorf("unknown TestSummary unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TestSummaryMutation) ResetEdge(name string) error {
	switch name {
	case testsummary.EdgeInvocationTarget:
		m.ResetInvocationTarget()
		return nil
	case testsummary.EdgeTestResults:
		m.ResetTestResults()
		return nil
	}
	return fmt.Errorf("unknown TestSummary edge %s", name)
}

// TimingMetricsMutation represents an operation that mutates the TimingMetrics nodes in the graph.
type TimingMetricsMutation struct {
	config
	op                               Op
	typ                              string
	id                               *int64
	cpu_time_in_ms                   *int64
	addcpu_time_in_ms                *int64
	wall_time_in_ms                  *int64
	addwall_time_in_ms               *int64
	analysis_phase_time_in_ms        *int64
	addanalysis_phase_time_in_ms     *int64
	execution_phase_time_in_ms       *int64
	addexecution_phase_time_in_ms    *int64
	actions_execution_start_in_ms    *int64
	addactions_execution_start_in_ms *int64
	clearedFields                    map[string]struct{}
	metrics                          *int64
	clearedmetrics                   bool
	done                             bool
	oldValue                         func(context.Context) (*TimingMetrics, error)
	predicates                       []predicate.TimingMetrics
}

var _ ent.Mutation = (*TimingMetricsMutation)(nil)

// timingmetricsOption allows management of the mutation configuration using functional options.
type timingmetricsOption func(*TimingMetricsMutation)

// newTimingMetricsMutation creates new mutation for the TimingMetrics entity.
func newTimingMetricsMutation(c config, op Op, opts ...timingmetricsOption) *TimingMetricsMutation {
	m := &TimingMetricsMutation{
		config:        c,
		op:            op,
		typ:           TypeTimingMetrics,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTimingMetricsID sets the ID field of the mutation.
func withTimingMetricsID(id int64) timingmetricsOption {
	return func(m *TimingMetricsMutation) {
		var (
			err   error
			once  sync.Once
			value *TimingMetrics
		)
		m.oldValue = func(ctx context.Context) (*TimingMetrics, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TimingMetrics.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTimingMetrics sets the old TimingMetrics of the mutation.
func withTimingMetrics(node *TimingMetrics) timingmetricsOption {
	return func(m *TimingMetricsMutation) {
		m.oldValue = func(context.Context) (*TimingMetrics, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TimingMetricsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TimingMetricsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TimingMetrics entities.
func (m *TimingMetricsMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TimingMetricsMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TimingMetricsMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TimingMetrics.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCPUTimeInMs sets the "cpu_time_in_ms" field.
func (m *TimingMetricsMutation) SetCPUTimeInMs(i int64) {
	m.cpu_time_in_ms = &i
	m.addcpu_time_in_ms = nil
}

// CPUTimeInMs returns the value of the "cpu_time_in_ms" field in the mutation.
func (m *TimingMetricsMutation) CPUTimeInMs() (r int64, exists bool) {
	v := m.cpu_time_in_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldCPUTimeInMs returns the old "cpu_time_in_ms" field's value of the TimingMetrics entity.
// If the TimingMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimingMetricsMutation) OldCPUTimeInMs(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCPUTimeInMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCPUTimeInMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCPUTimeInMs: %w", err)
	}
	return oldValue.CPUTimeInMs, nil
}

// AddCPUTimeInMs adds i to the "cpu_time_in_ms" field.
func (m *TimingMetricsMutation) AddCPUTimeInMs(i int64) {
	if m.addcpu_time_in_ms != nil {
		*m.addcpu_time_in_ms += i
	} else {
		m.addcpu_time_in_ms = &i
	}
}

// AddedCPUTimeInMs returns the value that was added to the "cpu_time_in_ms" field in this mutation.
func (m *TimingMetricsMutation) AddedCPUTimeInMs() (r int64, exists bool) {
	v := m.addcpu_time_in_ms
	if v == nil {
		return
	}
	return *v, true
}

// ClearCPUTimeInMs clears the value of the "cpu_time_in_ms" field.
func (m *TimingMetricsMutation) ClearCPUTimeInMs() {
	m.cpu_time_in_ms = nil
	m.addcpu_time_in_ms = nil
	m.clearedFields[timingmetrics.FieldCPUTimeInMs] = struct{}{}
}

// CPUTimeInMsCleared returns if the "cpu_time_in_ms" field was cleared in this mutation.
func (m *TimingMetricsMutation) CPUTimeInMsCleared() bool {
	_, ok := m.clearedFields[timingmetrics.FieldCPUTimeInMs]
	return ok
}

// ResetCPUTimeInMs resets all changes to the "cpu_time_in_ms" field.
func (m *TimingMetricsMutation) ResetCPUTimeInMs() {
	m.cpu_time_in_ms = nil
	m.addcpu_time_in_ms = nil
	delete(m.clearedFields, timingmetrics.FieldCPUTimeInMs)
}

// SetWallTimeInMs sets the "wall_time_in_ms" field.
func (m *TimingMetricsMutation) SetWallTimeInMs(i int64) {
	m.wall_time_in_ms = &i
	m.addwall_time_in_ms = nil
}

// WallTimeInMs returns the value of the "wall_time_in_ms" field in the mutation.
func (m *TimingMetricsMutation) WallTimeInMs() (r int64, exists bool) {
	v := m.wall_time_in_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldWallTimeInMs returns the old "wall_time_in_ms" field's value of the TimingMetrics entity.
// If the TimingMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimingMetricsMutation) OldWallTimeInMs(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWallTimeInMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWallTimeInMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWallTimeInMs: %w", err)
	}
	return oldValue.WallTimeInMs, nil
}

// AddWallTimeInMs adds i to the "wall_time_in_ms" field.
func (m *TimingMetricsMutation) AddWallTimeInMs(i int64) {
	if m.addwall_time_in_ms != nil {
		*m.addwall_time_in_ms += i
	} else {
		m.addwall_time_in_ms = &i
	}
}

// AddedWallTimeInMs returns the value that was added to the "wall_time_in_ms" field in this mutation.
func (m *TimingMetricsMutation) AddedWallTimeInMs() (r int64, exists bool) {
	v := m.addwall_time_in_ms
	if v == nil {
		return
	}
	return *v, true
}

// ClearWallTimeInMs clears the value of the "wall_time_in_ms" field.
func (m *TimingMetricsMutation) ClearWallTimeInMs() {
	m.wall_time_in_ms = nil
	m.addwall_time_in_ms = nil
	m.clearedFields[timingmetrics.FieldWallTimeInMs] = struct{}{}
}

// WallTimeInMsCleared returns if the "wall_time_in_ms" field was cleared in this mutation.
func (m *TimingMetricsMutation) WallTimeInMsCleared() bool {
	_, ok := m.clearedFields[timingmetrics.FieldWallTimeInMs]
	return ok
}

// ResetWallTimeInMs resets all changes to the "wall_time_in_ms" field.
func (m *TimingMetricsMutation) ResetWallTimeInMs() {
	m.wall_time_in_ms = nil
	m.addwall_time_in_ms = nil
	delete(m.clearedFields, timingmetrics.FieldWallTimeInMs)
}

// SetAnalysisPhaseTimeInMs sets the "analysis_phase_time_in_ms" field.
func (m *TimingMetricsMutation) SetAnalysisPhaseTimeInMs(i int64) {
	m.analysis_phase_time_in_ms = &i
	m.addanalysis_phase_time_in_ms = nil
}

// AnalysisPhaseTimeInMs returns the value of the "analysis_phase_time_in_ms" field in the mutation.
func (m *TimingMetricsMutation) AnalysisPhaseTimeInMs() (r int64, exists bool) {
	v := m.analysis_phase_time_in_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldAnalysisPhaseTimeInMs returns the old "analysis_phase_time_in_ms" field's value of the TimingMetrics entity.
// If the TimingMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimingMetricsMutation) OldAnalysisPhaseTimeInMs(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnalysisPhaseTimeInMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnalysisPhaseTimeInMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnalysisPhaseTimeInMs: %w", err)
	}
	return oldValue.AnalysisPhaseTimeInMs, nil
}

// AddAnalysisPhaseTimeInMs adds i to the "analysis_phase_time_in_ms" field.
func (m *TimingMetricsMutation) AddAnalysisPhaseTimeInMs(i int64) {
	if m.addanalysis_phase_time_in_ms != nil {
		*m.addanalysis_phase_time_in_ms += i
	} else {
		m.addanalysis_phase_time_in_ms = &i
	}
}

// AddedAnalysisPhaseTimeInMs returns the value that was added to the "analysis_phase_time_in_ms" field in this mutation.
func (m *TimingMetricsMutation) AddedAnalysisPhaseTimeInMs() (r int64, exists bool) {
	v := m.addanalysis_phase_time_in_ms
	if v == nil {
		return
	}
	return *v, true
}

// ClearAnalysisPhaseTimeInMs clears the value of the "analysis_phase_time_in_ms" field.
func (m *TimingMetricsMutation) ClearAnalysisPhaseTimeInMs() {
	m.analysis_phase_time_in_ms = nil
	m.addanalysis_phase_time_in_ms = nil
	m.clearedFields[timingmetrics.FieldAnalysisPhaseTimeInMs] = struct{}{}
}

// AnalysisPhaseTimeInMsCleared returns if the "analysis_phase_time_in_ms" field was cleared in this mutation.
func (m *TimingMetricsMutation) AnalysisPhaseTimeInMsCleared() bool {
	_, ok := m.clearedFields[timingmetrics.FieldAnalysisPhaseTimeInMs]
	return ok
}

// ResetAnalysisPhaseTimeInMs resets all changes to the "analysis_phase_time_in_ms" field.
func (m *TimingMetricsMutation) ResetAnalysisPhaseTimeInMs() {
	m.analysis_phase_time_in_ms = nil
	m.addanalysis_phase_time_in_ms = nil
	delete(m.clearedFields, timingmetrics.FieldAnalysisPhaseTimeInMs)
}

// SetExecutionPhaseTimeInMs sets the "execution_phase_time_in_ms" field.
func (m *TimingMetricsMutation) SetExecutionPhaseTimeInMs(i int64) {
	m.execution_phase_time_in_ms = &i
	m.addexecution_phase_time_in_ms = nil
}

// ExecutionPhaseTimeInMs returns the value of the "execution_phase_time_in_ms" field in the mutation.
func (m *TimingMetricsMutation) ExecutionPhaseTimeInMs() (r int64, exists bool) {
	v := m.execution_phase_time_in_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldExecutionPhaseTimeInMs returns the old "execution_phase_time_in_ms" field's value of the TimingMetrics entity.
// If the TimingMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimingMetricsMutation) OldExecutionPhaseTimeInMs(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExecutionPhaseTimeInMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExecutionPhaseTimeInMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExecutionPhaseTimeInMs: %w", err)
	}
	return oldValue.ExecutionPhaseTimeInMs, nil
}

// AddExecutionPhaseTimeInMs adds i to the "execution_phase_time_in_ms" field.
func (m *TimingMetricsMutation) AddExecutionPhaseTimeInMs(i int64) {
	if m.addexecution_phase_time_in_ms != nil {
		*m.addexecution_phase_time_in_ms += i
	} else {
		m.addexecution_phase_time_in_ms = &i
	}
}

// AddedExecutionPhaseTimeInMs returns the value that was added to the "execution_phase_time_in_ms" field in this mutation.
func (m *TimingMetricsMutation) AddedExecutionPhaseTimeInMs() (r int64, exists bool) {
	v := m.addexecution_phase_time_in_ms
	if v == nil {
		return
	}
	return *v, true
}

// ClearExecutionPhaseTimeInMs clears the value of the "execution_phase_time_in_ms" field.
func (m *TimingMetricsMutation) ClearExecutionPhaseTimeInMs() {
	m.execution_phase_time_in_ms = nil
	m.addexecution_phase_time_in_ms = nil
	m.clearedFields[timingmetrics.FieldExecutionPhaseTimeInMs] = struct{}{}
}

// ExecutionPhaseTimeInMsCleared returns if the "execution_phase_time_in_ms" field was cleared in this mutation.
func (m *TimingMetricsMutation) ExecutionPhaseTimeInMsCleared() bool {
	_, ok := m.clearedFields[timingmetrics.FieldExecutionPhaseTimeInMs]
	return ok
}

// ResetExecutionPhaseTimeInMs resets all changes to the "execution_phase_time_in_ms" field.
func (m *TimingMetricsMutation) ResetExecutionPhaseTimeInMs() {
	m.execution_phase_time_in_ms = nil
	m.addexecution_phase_time_in_ms = nil
	delete(m.clearedFields, timingmetrics.FieldExecutionPhaseTimeInMs)
}

// SetActionsExecutionStartInMs sets the "actions_execution_start_in_ms" field.
func (m *TimingMetricsMutation) SetActionsExecutionStartInMs(i int64) {
	m.actions_execution_start_in_ms = &i
	m.addactions_execution_start_in_ms = nil
}

// ActionsExecutionStartInMs returns the value of the "actions_execution_start_in_ms" field in the mutation.
func (m *TimingMetricsMutation) ActionsExecutionStartInMs() (r int64, exists bool) {
	v := m.actions_execution_start_in_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldActionsExecutionStartInMs returns the old "actions_execution_start_in_ms" field's value of the TimingMetrics entity.
// If the TimingMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimingMetricsMutation) OldActionsExecutionStartInMs(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActionsExecutionStartInMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActionsExecutionStartInMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActionsExecutionStartInMs: %w", err)
	}
	return oldValue.ActionsExecutionStartInMs, nil
}

// AddActionsExecutionStartInMs adds i to the "actions_execution_start_in_ms" field.
func (m *TimingMetricsMutation) AddActionsExecutionStartInMs(i int64) {
	if m.addactions_execution_start_in_ms != nil {
		*m.addactions_execution_start_in_ms += i
	} else {
		m.addactions_execution_start_in_ms = &i
	}
}

// AddedActionsExecutionStartInMs returns the value that was added to the "actions_execution_start_in_ms" field in this mutation.
func (m *TimingMetricsMutation) AddedActionsExecutionStartInMs() (r int64, exists bool) {
	v := m.addactions_execution_start_in_ms
	if v == nil {
		return
	}
	return *v, true
}

// ClearActionsExecutionStartInMs clears the value of the "actions_execution_start_in_ms" field.
func (m *TimingMetricsMutation) ClearActionsExecutionStartInMs() {
	m.actions_execution_start_in_ms = nil
	m.addactions_execution_start_in_ms = nil
	m.clearedFields[timingmetrics.FieldActionsExecutionStartInMs] = struct{}{}
}

// ActionsExecutionStartInMsCleared returns if the "actions_execution_start_in_ms" field was cleared in this mutation.
func (m *TimingMetricsMutation) ActionsExecutionStartInMsCleared() bool {
	_, ok := m.clearedFields[timingmetrics.FieldActionsExecutionStartInMs]
	return ok
}

// ResetActionsExecutionStartInMs resets all changes to the "actions_execution_start_in_ms" field.
func (m *TimingMetricsMutation) ResetActionsExecutionStartInMs() {
	m.actions_execution_start_in_ms = nil
	m.addactions_execution_start_in_ms = nil
	delete(m.clearedFields, timingmetrics.FieldActionsExecutionStartInMs)
}

// SetMetricsID sets the "metrics" edge to the Metrics entity by id.
func (m *TimingMetricsMutation) SetMetricsID(id int64) {
	m.metrics = &id
}

// ClearMetrics clears the "metrics" edge to the Metrics entity.
func (m *TimingMetricsMutation) ClearMetrics() {
	m.clearedmetrics = true
}

// MetricsCleared reports if the "metrics" edge to the Metrics entity was cleared.
func (m *TimingMetricsMutation) MetricsCleared() bool {
	return m.clearedmetrics
}

// MetricsID returns the "metrics" edge ID in the mutation.
func (m *TimingMetricsMutation) MetricsID() (id int64, exists bool) {
	if m.metrics != nil {
		return *m.metrics, true
	}
	return
}

// MetricsIDs returns the "metrics" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MetricsID instead. It exists only for internal usage by the builders.
func (m *TimingMetricsMutation) MetricsIDs() (ids []int64) {
	if id := m.metrics; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMetrics resets all changes to the "metrics" edge.
func (m *TimingMetricsMutation) ResetMetrics() {
	m.metrics = nil
	m.clearedmetrics = false
}

// Where appends a list predicates to the TimingMetricsMutation builder.
func (m *TimingMetricsMutation) Where(ps ...predicate.TimingMetrics) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TimingMetricsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TimingMetricsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TimingMetrics, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TimingMetricsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TimingMetricsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TimingMetrics).
func (m *TimingMetricsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TimingMetricsMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.cpu_time_in_ms != nil {
		fields = append(fields, timingmetrics.FieldCPUTimeInMs)
	}
	if m.wall_time_in_ms != nil {
		fields = append(fields, timingmetrics.FieldWallTimeInMs)
	}
	if m.analysis_phase_time_in_ms != nil {
		fields = append(fields, timingmetrics.FieldAnalysisPhaseTimeInMs)
	}
	if m.execution_phase_time_in_ms != nil {
		fields = append(fields, timingmetrics.FieldExecutionPhaseTimeInMs)
	}
	if m.actions_execution_start_in_ms != nil {
		fields = append(fields, timingmetrics.FieldActionsExecutionStartInMs)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TimingMetricsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case timingmetrics.FieldCPUTimeInMs:
		return m.CPUTimeInMs()
	case timingmetrics.FieldWallTimeInMs:
		return m.WallTimeInMs()
	case timingmetrics.FieldAnalysisPhaseTimeInMs:
		return m.AnalysisPhaseTimeInMs()
	case timingmetrics.FieldExecutionPhaseTimeInMs:
		return m.ExecutionPhaseTimeInMs()
	case timingmetrics.FieldActionsExecutionStartInMs:
		return m.ActionsExecutionStartInMs()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TimingMetricsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case timingmetrics.FieldCPUTimeInMs:
		return m.OldCPUTimeInMs(ctx)
	case timingmetrics.FieldWallTimeInMs:
		return m.OldWallTimeInMs(ctx)
	case timingmetrics.FieldAnalysisPhaseTimeInMs:
		return m.OldAnalysisPhaseTimeInMs(ctx)
	case timingmetrics.FieldExecutionPhaseTimeInMs:
		return m.OldExecutionPhaseTimeInMs(ctx)
	case timingmetrics.FieldActionsExecutionStartInMs:
		return m.OldActionsExecutionStartInMs(ctx)
	}
	return nil, fmt.Errorf("unknown TimingMetrics field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TimingMetricsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case timingmetrics.FieldCPUTimeInMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCPUTimeInMs(v)
		return nil
	case timingmetrics.FieldWallTimeInMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWallTimeInMs(v)
		return nil
	case timingmetrics.FieldAnalysisPhaseTimeInMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnalysisPhaseTimeInMs(v)
		return nil
	case timingmetrics.FieldExecutionPhaseTimeInMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExecutionPhaseTimeInMs(v)
		return nil
	case timingmetrics.FieldActionsExecutionStartInMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActionsExecutionStartInMs(v)
		return nil
	}
	return fmt.Errorf("unknown TimingMetrics field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TimingMetricsMutation) AddedFields() []string {
	var fields []string
	if m.addcpu_time_in_ms != nil {
		fields = append(fields, timingmetrics.FieldCPUTimeInMs)
	}
	if m.addwall_time_in_ms != nil {
		fields = append(fields, timingmetrics.FieldWallTimeInMs)
	}
	if m.addanalysis_phase_time_in_ms != nil {
		fields = append(fields, timingmetrics.FieldAnalysisPhaseTimeInMs)
	}
	if m.addexecution_phase_time_in_ms != nil {
		fields = append(fields, timingmetrics.FieldExecutionPhaseTimeInMs)
	}
	if m.addactions_execution_start_in_ms != nil {
		fields = append(fields, timingmetrics.FieldActionsExecutionStartInMs)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TimingMetricsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case timingmetrics.FieldCPUTimeInMs:
		return m.AddedCPUTimeInMs()
	case timingmetrics.FieldWallTimeInMs:
		return m.AddedWallTimeInMs()
	case timingmetrics.FieldAnalysisPhaseTimeInMs:
		return m.AddedAnalysisPhaseTimeInMs()
	case timingmetrics.FieldExecutionPhaseTimeInMs:
		return m.AddedExecutionPhaseTimeInMs()
	case timingmetrics.FieldActionsExecutionStartInMs:
		return m.AddedActionsExecutionStartInMs()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TimingMetricsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case timingmetrics.FieldCPUTimeInMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCPUTimeInMs(v)
		return nil
	case timingmetrics.FieldWallTimeInMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWallTimeInMs(v)
		return nil
	case timingmetrics.FieldAnalysisPhaseTimeInMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAnalysisPhaseTimeInMs(v)
		return nil
	case timingmetrics.FieldExecutionPhaseTimeInMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExecutionPhaseTimeInMs(v)
		return nil
	case timingmetrics.FieldActionsExecutionStartInMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddActionsExecutionStartInMs(v)
		return nil
	}
	return fmt.Errorf("unknown TimingMetrics numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TimingMetricsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(timingmetrics.FieldCPUTimeInMs) {
		fields = append(fields, timingmetrics.FieldCPUTimeInMs)
	}
	if m.FieldCleared(timingmetrics.FieldWallTimeInMs) {
		fields = append(fields, timingmetrics.FieldWallTimeInMs)
	}
	if m.FieldCleared(timingmetrics.FieldAnalysisPhaseTimeInMs) {
		fields = append(fields, timingmetrics.FieldAnalysisPhaseTimeInMs)
	}
	if m.FieldCleared(timingmetrics.FieldExecutionPhaseTimeInMs) {
		fields = append(fields, timingmetrics.FieldExecutionPhaseTimeInMs)
	}
	if m.FieldCleared(timingmetrics.FieldActionsExecutionStartInMs) {
		fields = append(fields, timingmetrics.FieldActionsExecutionStartInMs)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TimingMetricsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TimingMetricsMutation) ClearField(name string) error {
	switch name {
	case timingmetrics.FieldCPUTimeInMs:
		m.ClearCPUTimeInMs()
		return nil
	case timingmetrics.FieldWallTimeInMs:
		m.ClearWallTimeInMs()
		return nil
	case timingmetrics.FieldAnalysisPhaseTimeInMs:
		m.ClearAnalysisPhaseTimeInMs()
		return nil
	case timingmetrics.FieldExecutionPhaseTimeInMs:
		m.ClearExecutionPhaseTimeInMs()
		return nil
	case timingmetrics.FieldActionsExecutionStartInMs:
		m.ClearActionsExecutionStartInMs()
		return nil
	}
	return fmt.Errorf("unknown TimingMetrics nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TimingMetricsMutation) ResetField(name string) error {
	switch name {
	case timingmetrics.FieldCPUTimeInMs:
		m.ResetCPUTimeInMs()
		return nil
	case timingmetrics.FieldWallTimeInMs:
		m.ResetWallTimeInMs()
		return nil
	case timingmetrics.FieldAnalysisPhaseTimeInMs:
		m.ResetAnalysisPhaseTimeInMs()
		return nil
	case timingmetrics.FieldExecutionPhaseTimeInMs:
		m.ResetExecutionPhaseTimeInMs()
		return nil
	case timingmetrics.FieldActionsExecutionStartInMs:
		m.ResetActionsExecutionStartInMs()
		return nil
	}
	return fmt.Errorf("unknown TimingMetrics field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TimingMetricsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.metrics != nil {
		edges = append(edges, timingmetrics.EdgeMetrics)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TimingMetricsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case timingmetrics.EdgeMetrics:
		if id := m.metrics; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TimingMetricsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TimingMetricsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TimingMetricsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmetrics {
		edges = append(edges, timingmetrics.EdgeMetrics)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TimingMetricsMutation) EdgeCleared(name string) bool {
	switch name {
	case timingmetrics.EdgeMetrics:
		return m.clearedmetrics
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TimingMetricsMutation) ClearEdge(name string) error {
	switch name {
	case timingmetrics.EdgeMetrics:
		m.ClearMetrics()
		return nil
	}
	return fmt.Errorf("unknown TimingMetrics unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TimingMetricsMutation) ResetEdge(name string) error {
	switch name {
	case timingmetrics.EdgeMetrics:
		m.ResetMetrics()
		return nil
	}
	return fmt.Errorf("unknown TimingMetrics edge %s", name)
}
