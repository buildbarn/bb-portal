// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/buildbarn/bb-portal/ent/gen/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/buildbarn/bb-portal/ent/gen/ent/action"
	"github.com/buildbarn/bb-portal/ent/gen/ent/actioncachestatistics"
	"github.com/buildbarn/bb-portal/ent/gen/ent/actiondata"
	"github.com/buildbarn/bb-portal/ent/gen/ent/actionsummary"
	"github.com/buildbarn/bb-portal/ent/gen/ent/artifactmetrics"
	"github.com/buildbarn/bb-portal/ent/gen/ent/authenticateduser"
	"github.com/buildbarn/bb-portal/ent/gen/ent/bazelinvocation"
	"github.com/buildbarn/bb-portal/ent/gen/ent/bazelinvocationproblem"
	"github.com/buildbarn/bb-portal/ent/gen/ent/blob"
	"github.com/buildbarn/bb-portal/ent/gen/ent/build"
	"github.com/buildbarn/bb-portal/ent/gen/ent/buildgraphmetrics"
	"github.com/buildbarn/bb-portal/ent/gen/ent/buildlogchunk"
	"github.com/buildbarn/bb-portal/ent/gen/ent/configuration"
	"github.com/buildbarn/bb-portal/ent/gen/ent/connectionmetadata"
	"github.com/buildbarn/bb-portal/ent/gen/ent/cumulativemetrics"
	"github.com/buildbarn/bb-portal/ent/gen/ent/evaluationstat"
	"github.com/buildbarn/bb-portal/ent/gen/ent/eventmetadata"
	"github.com/buildbarn/bb-portal/ent/gen/ent/garbagemetrics"
	"github.com/buildbarn/bb-portal/ent/gen/ent/incompletebuildlog"
	"github.com/buildbarn/bb-portal/ent/gen/ent/instancename"
	"github.com/buildbarn/bb-portal/ent/gen/ent/invocationfiles"
	"github.com/buildbarn/bb-portal/ent/gen/ent/invocationtarget"
	"github.com/buildbarn/bb-portal/ent/gen/ent/memorymetrics"
	"github.com/buildbarn/bb-portal/ent/gen/ent/metrics"
	"github.com/buildbarn/bb-portal/ent/gen/ent/missdetail"
	"github.com/buildbarn/bb-portal/ent/gen/ent/networkmetrics"
	"github.com/buildbarn/bb-portal/ent/gen/ent/packageloadmetrics"
	"github.com/buildbarn/bb-portal/ent/gen/ent/packagemetrics"
	"github.com/buildbarn/bb-portal/ent/gen/ent/runnercount"
	"github.com/buildbarn/bb-portal/ent/gen/ent/sourcecontrol"
	"github.com/buildbarn/bb-portal/ent/gen/ent/systemnetworkstats"
	"github.com/buildbarn/bb-portal/ent/gen/ent/target"
	"github.com/buildbarn/bb-portal/ent/gen/ent/targetkindmapping"
	"github.com/buildbarn/bb-portal/ent/gen/ent/targetmetrics"
	"github.com/buildbarn/bb-portal/ent/gen/ent/testresult"
	"github.com/buildbarn/bb-portal/ent/gen/ent/testsummary"
	"github.com/buildbarn/bb-portal/ent/gen/ent/timingmetrics"

	stdsql "database/sql"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Action is the client for interacting with the Action builders.
	Action *ActionClient
	// ActionCacheStatistics is the client for interacting with the ActionCacheStatistics builders.
	ActionCacheStatistics *ActionCacheStatisticsClient
	// ActionData is the client for interacting with the ActionData builders.
	ActionData *ActionDataClient
	// ActionSummary is the client for interacting with the ActionSummary builders.
	ActionSummary *ActionSummaryClient
	// ArtifactMetrics is the client for interacting with the ArtifactMetrics builders.
	ArtifactMetrics *ArtifactMetricsClient
	// AuthenticatedUser is the client for interacting with the AuthenticatedUser builders.
	AuthenticatedUser *AuthenticatedUserClient
	// BazelInvocation is the client for interacting with the BazelInvocation builders.
	BazelInvocation *BazelInvocationClient
	// BazelInvocationProblem is the client for interacting with the BazelInvocationProblem builders.
	BazelInvocationProblem *BazelInvocationProblemClient
	// Blob is the client for interacting with the Blob builders.
	Blob *BlobClient
	// Build is the client for interacting with the Build builders.
	Build *BuildClient
	// BuildGraphMetrics is the client for interacting with the BuildGraphMetrics builders.
	BuildGraphMetrics *BuildGraphMetricsClient
	// BuildLogChunk is the client for interacting with the BuildLogChunk builders.
	BuildLogChunk *BuildLogChunkClient
	// Configuration is the client for interacting with the Configuration builders.
	Configuration *ConfigurationClient
	// ConnectionMetadata is the client for interacting with the ConnectionMetadata builders.
	ConnectionMetadata *ConnectionMetadataClient
	// CumulativeMetrics is the client for interacting with the CumulativeMetrics builders.
	CumulativeMetrics *CumulativeMetricsClient
	// EvaluationStat is the client for interacting with the EvaluationStat builders.
	EvaluationStat *EvaluationStatClient
	// EventMetadata is the client for interacting with the EventMetadata builders.
	EventMetadata *EventMetadataClient
	// GarbageMetrics is the client for interacting with the GarbageMetrics builders.
	GarbageMetrics *GarbageMetricsClient
	// IncompleteBuildLog is the client for interacting with the IncompleteBuildLog builders.
	IncompleteBuildLog *IncompleteBuildLogClient
	// InstanceName is the client for interacting with the InstanceName builders.
	InstanceName *InstanceNameClient
	// InvocationFiles is the client for interacting with the InvocationFiles builders.
	InvocationFiles *InvocationFilesClient
	// InvocationTarget is the client for interacting with the InvocationTarget builders.
	InvocationTarget *InvocationTargetClient
	// MemoryMetrics is the client for interacting with the MemoryMetrics builders.
	MemoryMetrics *MemoryMetricsClient
	// Metrics is the client for interacting with the Metrics builders.
	Metrics *MetricsClient
	// MissDetail is the client for interacting with the MissDetail builders.
	MissDetail *MissDetailClient
	// NetworkMetrics is the client for interacting with the NetworkMetrics builders.
	NetworkMetrics *NetworkMetricsClient
	// PackageLoadMetrics is the client for interacting with the PackageLoadMetrics builders.
	PackageLoadMetrics *PackageLoadMetricsClient
	// PackageMetrics is the client for interacting with the PackageMetrics builders.
	PackageMetrics *PackageMetricsClient
	// RunnerCount is the client for interacting with the RunnerCount builders.
	RunnerCount *RunnerCountClient
	// SourceControl is the client for interacting with the SourceControl builders.
	SourceControl *SourceControlClient
	// SystemNetworkStats is the client for interacting with the SystemNetworkStats builders.
	SystemNetworkStats *SystemNetworkStatsClient
	// Target is the client for interacting with the Target builders.
	Target *TargetClient
	// TargetKindMapping is the client for interacting with the TargetKindMapping builders.
	TargetKindMapping *TargetKindMappingClient
	// TargetMetrics is the client for interacting with the TargetMetrics builders.
	TargetMetrics *TargetMetricsClient
	// TestResult is the client for interacting with the TestResult builders.
	TestResult *TestResultClient
	// TestSummary is the client for interacting with the TestSummary builders.
	TestSummary *TestSummaryClient
	// TimingMetrics is the client for interacting with the TimingMetrics builders.
	TimingMetrics *TimingMetricsClient
	// additional fields for node api
	tables tables
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Action = NewActionClient(c.config)
	c.ActionCacheStatistics = NewActionCacheStatisticsClient(c.config)
	c.ActionData = NewActionDataClient(c.config)
	c.ActionSummary = NewActionSummaryClient(c.config)
	c.ArtifactMetrics = NewArtifactMetricsClient(c.config)
	c.AuthenticatedUser = NewAuthenticatedUserClient(c.config)
	c.BazelInvocation = NewBazelInvocationClient(c.config)
	c.BazelInvocationProblem = NewBazelInvocationProblemClient(c.config)
	c.Blob = NewBlobClient(c.config)
	c.Build = NewBuildClient(c.config)
	c.BuildGraphMetrics = NewBuildGraphMetricsClient(c.config)
	c.BuildLogChunk = NewBuildLogChunkClient(c.config)
	c.Configuration = NewConfigurationClient(c.config)
	c.ConnectionMetadata = NewConnectionMetadataClient(c.config)
	c.CumulativeMetrics = NewCumulativeMetricsClient(c.config)
	c.EvaluationStat = NewEvaluationStatClient(c.config)
	c.EventMetadata = NewEventMetadataClient(c.config)
	c.GarbageMetrics = NewGarbageMetricsClient(c.config)
	c.IncompleteBuildLog = NewIncompleteBuildLogClient(c.config)
	c.InstanceName = NewInstanceNameClient(c.config)
	c.InvocationFiles = NewInvocationFilesClient(c.config)
	c.InvocationTarget = NewInvocationTargetClient(c.config)
	c.MemoryMetrics = NewMemoryMetricsClient(c.config)
	c.Metrics = NewMetricsClient(c.config)
	c.MissDetail = NewMissDetailClient(c.config)
	c.NetworkMetrics = NewNetworkMetricsClient(c.config)
	c.PackageLoadMetrics = NewPackageLoadMetricsClient(c.config)
	c.PackageMetrics = NewPackageMetricsClient(c.config)
	c.RunnerCount = NewRunnerCountClient(c.config)
	c.SourceControl = NewSourceControlClient(c.config)
	c.SystemNetworkStats = NewSystemNetworkStatsClient(c.config)
	c.Target = NewTargetClient(c.config)
	c.TargetKindMapping = NewTargetKindMappingClient(c.config)
	c.TargetMetrics = NewTargetMetricsClient(c.config)
	c.TestResult = NewTestResultClient(c.config)
	c.TestSummary = NewTestSummaryClient(c.config)
	c.TimingMetrics = NewTimingMetricsClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                    ctx,
		config:                 cfg,
		Action:                 NewActionClient(cfg),
		ActionCacheStatistics:  NewActionCacheStatisticsClient(cfg),
		ActionData:             NewActionDataClient(cfg),
		ActionSummary:          NewActionSummaryClient(cfg),
		ArtifactMetrics:        NewArtifactMetricsClient(cfg),
		AuthenticatedUser:      NewAuthenticatedUserClient(cfg),
		BazelInvocation:        NewBazelInvocationClient(cfg),
		BazelInvocationProblem: NewBazelInvocationProblemClient(cfg),
		Blob:                   NewBlobClient(cfg),
		Build:                  NewBuildClient(cfg),
		BuildGraphMetrics:      NewBuildGraphMetricsClient(cfg),
		BuildLogChunk:          NewBuildLogChunkClient(cfg),
		Configuration:          NewConfigurationClient(cfg),
		ConnectionMetadata:     NewConnectionMetadataClient(cfg),
		CumulativeMetrics:      NewCumulativeMetricsClient(cfg),
		EvaluationStat:         NewEvaluationStatClient(cfg),
		EventMetadata:          NewEventMetadataClient(cfg),
		GarbageMetrics:         NewGarbageMetricsClient(cfg),
		IncompleteBuildLog:     NewIncompleteBuildLogClient(cfg),
		InstanceName:           NewInstanceNameClient(cfg),
		InvocationFiles:        NewInvocationFilesClient(cfg),
		InvocationTarget:       NewInvocationTargetClient(cfg),
		MemoryMetrics:          NewMemoryMetricsClient(cfg),
		Metrics:                NewMetricsClient(cfg),
		MissDetail:             NewMissDetailClient(cfg),
		NetworkMetrics:         NewNetworkMetricsClient(cfg),
		PackageLoadMetrics:     NewPackageLoadMetricsClient(cfg),
		PackageMetrics:         NewPackageMetricsClient(cfg),
		RunnerCount:            NewRunnerCountClient(cfg),
		SourceControl:          NewSourceControlClient(cfg),
		SystemNetworkStats:     NewSystemNetworkStatsClient(cfg),
		Target:                 NewTargetClient(cfg),
		TargetKindMapping:      NewTargetKindMappingClient(cfg),
		TargetMetrics:          NewTargetMetricsClient(cfg),
		TestResult:             NewTestResultClient(cfg),
		TestSummary:            NewTestSummaryClient(cfg),
		TimingMetrics:          NewTimingMetricsClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                    ctx,
		config:                 cfg,
		Action:                 NewActionClient(cfg),
		ActionCacheStatistics:  NewActionCacheStatisticsClient(cfg),
		ActionData:             NewActionDataClient(cfg),
		ActionSummary:          NewActionSummaryClient(cfg),
		ArtifactMetrics:        NewArtifactMetricsClient(cfg),
		AuthenticatedUser:      NewAuthenticatedUserClient(cfg),
		BazelInvocation:        NewBazelInvocationClient(cfg),
		BazelInvocationProblem: NewBazelInvocationProblemClient(cfg),
		Blob:                   NewBlobClient(cfg),
		Build:                  NewBuildClient(cfg),
		BuildGraphMetrics:      NewBuildGraphMetricsClient(cfg),
		BuildLogChunk:          NewBuildLogChunkClient(cfg),
		Configuration:          NewConfigurationClient(cfg),
		ConnectionMetadata:     NewConnectionMetadataClient(cfg),
		CumulativeMetrics:      NewCumulativeMetricsClient(cfg),
		EvaluationStat:         NewEvaluationStatClient(cfg),
		EventMetadata:          NewEventMetadataClient(cfg),
		GarbageMetrics:         NewGarbageMetricsClient(cfg),
		IncompleteBuildLog:     NewIncompleteBuildLogClient(cfg),
		InstanceName:           NewInstanceNameClient(cfg),
		InvocationFiles:        NewInvocationFilesClient(cfg),
		InvocationTarget:       NewInvocationTargetClient(cfg),
		MemoryMetrics:          NewMemoryMetricsClient(cfg),
		Metrics:                NewMetricsClient(cfg),
		MissDetail:             NewMissDetailClient(cfg),
		NetworkMetrics:         NewNetworkMetricsClient(cfg),
		PackageLoadMetrics:     NewPackageLoadMetricsClient(cfg),
		PackageMetrics:         NewPackageMetricsClient(cfg),
		RunnerCount:            NewRunnerCountClient(cfg),
		SourceControl:          NewSourceControlClient(cfg),
		SystemNetworkStats:     NewSystemNetworkStatsClient(cfg),
		Target:                 NewTargetClient(cfg),
		TargetKindMapping:      NewTargetKindMappingClient(cfg),
		TargetMetrics:          NewTargetMetricsClient(cfg),
		TestResult:             NewTestResultClient(cfg),
		TestSummary:            NewTestSummaryClient(cfg),
		TimingMetrics:          NewTimingMetricsClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Action.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Action, c.ActionCacheStatistics, c.ActionData, c.ActionSummary,
		c.ArtifactMetrics, c.AuthenticatedUser, c.BazelInvocation,
		c.BazelInvocationProblem, c.Blob, c.Build, c.BuildGraphMetrics,
		c.BuildLogChunk, c.Configuration, c.ConnectionMetadata, c.CumulativeMetrics,
		c.EvaluationStat, c.EventMetadata, c.GarbageMetrics, c.IncompleteBuildLog,
		c.InstanceName, c.InvocationFiles, c.InvocationTarget, c.MemoryMetrics,
		c.Metrics, c.MissDetail, c.NetworkMetrics, c.PackageLoadMetrics,
		c.PackageMetrics, c.RunnerCount, c.SourceControl, c.SystemNetworkStats,
		c.Target, c.TargetKindMapping, c.TargetMetrics, c.TestResult, c.TestSummary,
		c.TimingMetrics,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Action, c.ActionCacheStatistics, c.ActionData, c.ActionSummary,
		c.ArtifactMetrics, c.AuthenticatedUser, c.BazelInvocation,
		c.BazelInvocationProblem, c.Blob, c.Build, c.BuildGraphMetrics,
		c.BuildLogChunk, c.Configuration, c.ConnectionMetadata, c.CumulativeMetrics,
		c.EvaluationStat, c.EventMetadata, c.GarbageMetrics, c.IncompleteBuildLog,
		c.InstanceName, c.InvocationFiles, c.InvocationTarget, c.MemoryMetrics,
		c.Metrics, c.MissDetail, c.NetworkMetrics, c.PackageLoadMetrics,
		c.PackageMetrics, c.RunnerCount, c.SourceControl, c.SystemNetworkStats,
		c.Target, c.TargetKindMapping, c.TargetMetrics, c.TestResult, c.TestSummary,
		c.TimingMetrics,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *ActionMutation:
		return c.Action.mutate(ctx, m)
	case *ActionCacheStatisticsMutation:
		return c.ActionCacheStatistics.mutate(ctx, m)
	case *ActionDataMutation:
		return c.ActionData.mutate(ctx, m)
	case *ActionSummaryMutation:
		return c.ActionSummary.mutate(ctx, m)
	case *ArtifactMetricsMutation:
		return c.ArtifactMetrics.mutate(ctx, m)
	case *AuthenticatedUserMutation:
		return c.AuthenticatedUser.mutate(ctx, m)
	case *BazelInvocationMutation:
		return c.BazelInvocation.mutate(ctx, m)
	case *BazelInvocationProblemMutation:
		return c.BazelInvocationProblem.mutate(ctx, m)
	case *BlobMutation:
		return c.Blob.mutate(ctx, m)
	case *BuildMutation:
		return c.Build.mutate(ctx, m)
	case *BuildGraphMetricsMutation:
		return c.BuildGraphMetrics.mutate(ctx, m)
	case *BuildLogChunkMutation:
		return c.BuildLogChunk.mutate(ctx, m)
	case *ConfigurationMutation:
		return c.Configuration.mutate(ctx, m)
	case *ConnectionMetadataMutation:
		return c.ConnectionMetadata.mutate(ctx, m)
	case *CumulativeMetricsMutation:
		return c.CumulativeMetrics.mutate(ctx, m)
	case *EvaluationStatMutation:
		return c.EvaluationStat.mutate(ctx, m)
	case *EventMetadataMutation:
		return c.EventMetadata.mutate(ctx, m)
	case *GarbageMetricsMutation:
		return c.GarbageMetrics.mutate(ctx, m)
	case *IncompleteBuildLogMutation:
		return c.IncompleteBuildLog.mutate(ctx, m)
	case *InstanceNameMutation:
		return c.InstanceName.mutate(ctx, m)
	case *InvocationFilesMutation:
		return c.InvocationFiles.mutate(ctx, m)
	case *InvocationTargetMutation:
		return c.InvocationTarget.mutate(ctx, m)
	case *MemoryMetricsMutation:
		return c.MemoryMetrics.mutate(ctx, m)
	case *MetricsMutation:
		return c.Metrics.mutate(ctx, m)
	case *MissDetailMutation:
		return c.MissDetail.mutate(ctx, m)
	case *NetworkMetricsMutation:
		return c.NetworkMetrics.mutate(ctx, m)
	case *PackageLoadMetricsMutation:
		return c.PackageLoadMetrics.mutate(ctx, m)
	case *PackageMetricsMutation:
		return c.PackageMetrics.mutate(ctx, m)
	case *RunnerCountMutation:
		return c.RunnerCount.mutate(ctx, m)
	case *SourceControlMutation:
		return c.SourceControl.mutate(ctx, m)
	case *SystemNetworkStatsMutation:
		return c.SystemNetworkStats.mutate(ctx, m)
	case *TargetMutation:
		return c.Target.mutate(ctx, m)
	case *TargetKindMappingMutation:
		return c.TargetKindMapping.mutate(ctx, m)
	case *TargetMetricsMutation:
		return c.TargetMetrics.mutate(ctx, m)
	case *TestResultMutation:
		return c.TestResult.mutate(ctx, m)
	case *TestSummaryMutation:
		return c.TestSummary.mutate(ctx, m)
	case *TimingMetricsMutation:
		return c.TimingMetrics.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// ActionClient is a client for the Action schema.
type ActionClient struct {
	config
}

// NewActionClient returns a client for the Action from the given config.
func NewActionClient(c config) *ActionClient {
	return &ActionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `action.Hooks(f(g(h())))`.
func (c *ActionClient) Use(hooks ...Hook) {
	c.hooks.Action = append(c.hooks.Action, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `action.Intercept(f(g(h())))`.
func (c *ActionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Action = append(c.inters.Action, interceptors...)
}

// Create returns a builder for creating a Action entity.
func (c *ActionClient) Create() *ActionCreate {
	mutation := newActionMutation(c.config, OpCreate)
	return &ActionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Action entities.
func (c *ActionClient) CreateBulk(builders ...*ActionCreate) *ActionCreateBulk {
	return &ActionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ActionClient) MapCreateBulk(slice any, setFunc func(*ActionCreate, int)) *ActionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ActionCreateBulk{err: fmt.Errorf("calling to ActionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ActionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ActionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Action.
func (c *ActionClient) Update() *ActionUpdate {
	mutation := newActionMutation(c.config, OpUpdate)
	return &ActionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ActionClient) UpdateOne(a *Action) *ActionUpdateOne {
	mutation := newActionMutation(c.config, OpUpdateOne, withAction(a))
	return &ActionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ActionClient) UpdateOneID(id int64) *ActionUpdateOne {
	mutation := newActionMutation(c.config, OpUpdateOne, withActionID(id))
	return &ActionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Action.
func (c *ActionClient) Delete() *ActionDelete {
	mutation := newActionMutation(c.config, OpDelete)
	return &ActionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ActionClient) DeleteOne(a *Action) *ActionDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ActionClient) DeleteOneID(id int64) *ActionDeleteOne {
	builder := c.Delete().Where(action.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ActionDeleteOne{builder}
}

// Query returns a query builder for Action.
func (c *ActionClient) Query() *ActionQuery {
	return &ActionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAction},
		inters: c.Interceptors(),
	}
}

// Get returns a Action entity by its id.
func (c *ActionClient) Get(ctx context.Context, id int64) (*Action, error) {
	return c.Query().Where(action.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ActionClient) GetX(ctx context.Context, id int64) *Action {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBazelInvocation queries the bazel_invocation edge of a Action.
func (c *ActionClient) QueryBazelInvocation(a *Action) *BazelInvocationQuery {
	query := (&BazelInvocationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(action.Table, action.FieldID, id),
			sqlgraph.To(bazelinvocation.Table, bazelinvocation.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, action.BazelInvocationTable, action.BazelInvocationColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryConfiguration queries the configuration edge of a Action.
func (c *ActionClient) QueryConfiguration(a *Action) *ConfigurationQuery {
	query := (&ConfigurationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(action.Table, action.FieldID, id),
			sqlgraph.To(configuration.Table, configuration.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, action.ConfigurationTable, action.ConfigurationColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ActionClient) Hooks() []Hook {
	return c.hooks.Action
}

// Interceptors returns the client interceptors.
func (c *ActionClient) Interceptors() []Interceptor {
	return c.inters.Action
}

func (c *ActionClient) mutate(ctx context.Context, m *ActionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ActionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ActionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ActionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ActionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Action mutation op: %q", m.Op())
	}
}

// ActionCacheStatisticsClient is a client for the ActionCacheStatistics schema.
type ActionCacheStatisticsClient struct {
	config
}

// NewActionCacheStatisticsClient returns a client for the ActionCacheStatistics from the given config.
func NewActionCacheStatisticsClient(c config) *ActionCacheStatisticsClient {
	return &ActionCacheStatisticsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `actioncachestatistics.Hooks(f(g(h())))`.
func (c *ActionCacheStatisticsClient) Use(hooks ...Hook) {
	c.hooks.ActionCacheStatistics = append(c.hooks.ActionCacheStatistics, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `actioncachestatistics.Intercept(f(g(h())))`.
func (c *ActionCacheStatisticsClient) Intercept(interceptors ...Interceptor) {
	c.inters.ActionCacheStatistics = append(c.inters.ActionCacheStatistics, interceptors...)
}

// Create returns a builder for creating a ActionCacheStatistics entity.
func (c *ActionCacheStatisticsClient) Create() *ActionCacheStatisticsCreate {
	mutation := newActionCacheStatisticsMutation(c.config, OpCreate)
	return &ActionCacheStatisticsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ActionCacheStatistics entities.
func (c *ActionCacheStatisticsClient) CreateBulk(builders ...*ActionCacheStatisticsCreate) *ActionCacheStatisticsCreateBulk {
	return &ActionCacheStatisticsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ActionCacheStatisticsClient) MapCreateBulk(slice any, setFunc func(*ActionCacheStatisticsCreate, int)) *ActionCacheStatisticsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ActionCacheStatisticsCreateBulk{err: fmt.Errorf("calling to ActionCacheStatisticsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ActionCacheStatisticsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ActionCacheStatisticsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ActionCacheStatistics.
func (c *ActionCacheStatisticsClient) Update() *ActionCacheStatisticsUpdate {
	mutation := newActionCacheStatisticsMutation(c.config, OpUpdate)
	return &ActionCacheStatisticsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ActionCacheStatisticsClient) UpdateOne(acs *ActionCacheStatistics) *ActionCacheStatisticsUpdateOne {
	mutation := newActionCacheStatisticsMutation(c.config, OpUpdateOne, withActionCacheStatistics(acs))
	return &ActionCacheStatisticsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ActionCacheStatisticsClient) UpdateOneID(id int64) *ActionCacheStatisticsUpdateOne {
	mutation := newActionCacheStatisticsMutation(c.config, OpUpdateOne, withActionCacheStatisticsID(id))
	return &ActionCacheStatisticsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ActionCacheStatistics.
func (c *ActionCacheStatisticsClient) Delete() *ActionCacheStatisticsDelete {
	mutation := newActionCacheStatisticsMutation(c.config, OpDelete)
	return &ActionCacheStatisticsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ActionCacheStatisticsClient) DeleteOne(acs *ActionCacheStatistics) *ActionCacheStatisticsDeleteOne {
	return c.DeleteOneID(acs.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ActionCacheStatisticsClient) DeleteOneID(id int64) *ActionCacheStatisticsDeleteOne {
	builder := c.Delete().Where(actioncachestatistics.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ActionCacheStatisticsDeleteOne{builder}
}

// Query returns a query builder for ActionCacheStatistics.
func (c *ActionCacheStatisticsClient) Query() *ActionCacheStatisticsQuery {
	return &ActionCacheStatisticsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeActionCacheStatistics},
		inters: c.Interceptors(),
	}
}

// Get returns a ActionCacheStatistics entity by its id.
func (c *ActionCacheStatisticsClient) Get(ctx context.Context, id int64) (*ActionCacheStatistics, error) {
	return c.Query().Where(actioncachestatistics.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ActionCacheStatisticsClient) GetX(ctx context.Context, id int64) *ActionCacheStatistics {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryActionSummary queries the action_summary edge of a ActionCacheStatistics.
func (c *ActionCacheStatisticsClient) QueryActionSummary(acs *ActionCacheStatistics) *ActionSummaryQuery {
	query := (&ActionSummaryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := acs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(actioncachestatistics.Table, actioncachestatistics.FieldID, id),
			sqlgraph.To(actionsummary.Table, actionsummary.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, actioncachestatistics.ActionSummaryTable, actioncachestatistics.ActionSummaryColumn),
		)
		fromV = sqlgraph.Neighbors(acs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMissDetails queries the miss_details edge of a ActionCacheStatistics.
func (c *ActionCacheStatisticsClient) QueryMissDetails(acs *ActionCacheStatistics) *MissDetailQuery {
	query := (&MissDetailClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := acs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(actioncachestatistics.Table, actioncachestatistics.FieldID, id),
			sqlgraph.To(missdetail.Table, missdetail.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, actioncachestatistics.MissDetailsTable, actioncachestatistics.MissDetailsColumn),
		)
		fromV = sqlgraph.Neighbors(acs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ActionCacheStatisticsClient) Hooks() []Hook {
	return c.hooks.ActionCacheStatistics
}

// Interceptors returns the client interceptors.
func (c *ActionCacheStatisticsClient) Interceptors() []Interceptor {
	return c.inters.ActionCacheStatistics
}

func (c *ActionCacheStatisticsClient) mutate(ctx context.Context, m *ActionCacheStatisticsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ActionCacheStatisticsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ActionCacheStatisticsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ActionCacheStatisticsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ActionCacheStatisticsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ActionCacheStatistics mutation op: %q", m.Op())
	}
}

// ActionDataClient is a client for the ActionData schema.
type ActionDataClient struct {
	config
}

// NewActionDataClient returns a client for the ActionData from the given config.
func NewActionDataClient(c config) *ActionDataClient {
	return &ActionDataClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `actiondata.Hooks(f(g(h())))`.
func (c *ActionDataClient) Use(hooks ...Hook) {
	c.hooks.ActionData = append(c.hooks.ActionData, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `actiondata.Intercept(f(g(h())))`.
func (c *ActionDataClient) Intercept(interceptors ...Interceptor) {
	c.inters.ActionData = append(c.inters.ActionData, interceptors...)
}

// Create returns a builder for creating a ActionData entity.
func (c *ActionDataClient) Create() *ActionDataCreate {
	mutation := newActionDataMutation(c.config, OpCreate)
	return &ActionDataCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ActionData entities.
func (c *ActionDataClient) CreateBulk(builders ...*ActionDataCreate) *ActionDataCreateBulk {
	return &ActionDataCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ActionDataClient) MapCreateBulk(slice any, setFunc func(*ActionDataCreate, int)) *ActionDataCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ActionDataCreateBulk{err: fmt.Errorf("calling to ActionDataClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ActionDataCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ActionDataCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ActionData.
func (c *ActionDataClient) Update() *ActionDataUpdate {
	mutation := newActionDataMutation(c.config, OpUpdate)
	return &ActionDataUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ActionDataClient) UpdateOne(ad *ActionData) *ActionDataUpdateOne {
	mutation := newActionDataMutation(c.config, OpUpdateOne, withActionData(ad))
	return &ActionDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ActionDataClient) UpdateOneID(id int64) *ActionDataUpdateOne {
	mutation := newActionDataMutation(c.config, OpUpdateOne, withActionDataID(id))
	return &ActionDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ActionData.
func (c *ActionDataClient) Delete() *ActionDataDelete {
	mutation := newActionDataMutation(c.config, OpDelete)
	return &ActionDataDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ActionDataClient) DeleteOne(ad *ActionData) *ActionDataDeleteOne {
	return c.DeleteOneID(ad.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ActionDataClient) DeleteOneID(id int64) *ActionDataDeleteOne {
	builder := c.Delete().Where(actiondata.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ActionDataDeleteOne{builder}
}

// Query returns a query builder for ActionData.
func (c *ActionDataClient) Query() *ActionDataQuery {
	return &ActionDataQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeActionData},
		inters: c.Interceptors(),
	}
}

// Get returns a ActionData entity by its id.
func (c *ActionDataClient) Get(ctx context.Context, id int64) (*ActionData, error) {
	return c.Query().Where(actiondata.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ActionDataClient) GetX(ctx context.Context, id int64) *ActionData {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryActionSummary queries the action_summary edge of a ActionData.
func (c *ActionDataClient) QueryActionSummary(ad *ActionData) *ActionSummaryQuery {
	query := (&ActionSummaryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ad.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(actiondata.Table, actiondata.FieldID, id),
			sqlgraph.To(actionsummary.Table, actionsummary.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, actiondata.ActionSummaryTable, actiondata.ActionSummaryColumn),
		)
		fromV = sqlgraph.Neighbors(ad.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ActionDataClient) Hooks() []Hook {
	return c.hooks.ActionData
}

// Interceptors returns the client interceptors.
func (c *ActionDataClient) Interceptors() []Interceptor {
	return c.inters.ActionData
}

func (c *ActionDataClient) mutate(ctx context.Context, m *ActionDataMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ActionDataCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ActionDataUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ActionDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ActionDataDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ActionData mutation op: %q", m.Op())
	}
}

// ActionSummaryClient is a client for the ActionSummary schema.
type ActionSummaryClient struct {
	config
}

// NewActionSummaryClient returns a client for the ActionSummary from the given config.
func NewActionSummaryClient(c config) *ActionSummaryClient {
	return &ActionSummaryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `actionsummary.Hooks(f(g(h())))`.
func (c *ActionSummaryClient) Use(hooks ...Hook) {
	c.hooks.ActionSummary = append(c.hooks.ActionSummary, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `actionsummary.Intercept(f(g(h())))`.
func (c *ActionSummaryClient) Intercept(interceptors ...Interceptor) {
	c.inters.ActionSummary = append(c.inters.ActionSummary, interceptors...)
}

// Create returns a builder for creating a ActionSummary entity.
func (c *ActionSummaryClient) Create() *ActionSummaryCreate {
	mutation := newActionSummaryMutation(c.config, OpCreate)
	return &ActionSummaryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ActionSummary entities.
func (c *ActionSummaryClient) CreateBulk(builders ...*ActionSummaryCreate) *ActionSummaryCreateBulk {
	return &ActionSummaryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ActionSummaryClient) MapCreateBulk(slice any, setFunc func(*ActionSummaryCreate, int)) *ActionSummaryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ActionSummaryCreateBulk{err: fmt.Errorf("calling to ActionSummaryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ActionSummaryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ActionSummaryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ActionSummary.
func (c *ActionSummaryClient) Update() *ActionSummaryUpdate {
	mutation := newActionSummaryMutation(c.config, OpUpdate)
	return &ActionSummaryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ActionSummaryClient) UpdateOne(as *ActionSummary) *ActionSummaryUpdateOne {
	mutation := newActionSummaryMutation(c.config, OpUpdateOne, withActionSummary(as))
	return &ActionSummaryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ActionSummaryClient) UpdateOneID(id int64) *ActionSummaryUpdateOne {
	mutation := newActionSummaryMutation(c.config, OpUpdateOne, withActionSummaryID(id))
	return &ActionSummaryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ActionSummary.
func (c *ActionSummaryClient) Delete() *ActionSummaryDelete {
	mutation := newActionSummaryMutation(c.config, OpDelete)
	return &ActionSummaryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ActionSummaryClient) DeleteOne(as *ActionSummary) *ActionSummaryDeleteOne {
	return c.DeleteOneID(as.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ActionSummaryClient) DeleteOneID(id int64) *ActionSummaryDeleteOne {
	builder := c.Delete().Where(actionsummary.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ActionSummaryDeleteOne{builder}
}

// Query returns a query builder for ActionSummary.
func (c *ActionSummaryClient) Query() *ActionSummaryQuery {
	return &ActionSummaryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeActionSummary},
		inters: c.Interceptors(),
	}
}

// Get returns a ActionSummary entity by its id.
func (c *ActionSummaryClient) Get(ctx context.Context, id int64) (*ActionSummary, error) {
	return c.Query().Where(actionsummary.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ActionSummaryClient) GetX(ctx context.Context, id int64) *ActionSummary {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMetrics queries the metrics edge of a ActionSummary.
func (c *ActionSummaryClient) QueryMetrics(as *ActionSummary) *MetricsQuery {
	query := (&MetricsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := as.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(actionsummary.Table, actionsummary.FieldID, id),
			sqlgraph.To(metrics.Table, metrics.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, actionsummary.MetricsTable, actionsummary.MetricsColumn),
		)
		fromV = sqlgraph.Neighbors(as.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryActionData queries the action_data edge of a ActionSummary.
func (c *ActionSummaryClient) QueryActionData(as *ActionSummary) *ActionDataQuery {
	query := (&ActionDataClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := as.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(actionsummary.Table, actionsummary.FieldID, id),
			sqlgraph.To(actiondata.Table, actiondata.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, actionsummary.ActionDataTable, actionsummary.ActionDataColumn),
		)
		fromV = sqlgraph.Neighbors(as.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRunnerCount queries the runner_count edge of a ActionSummary.
func (c *ActionSummaryClient) QueryRunnerCount(as *ActionSummary) *RunnerCountQuery {
	query := (&RunnerCountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := as.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(actionsummary.Table, actionsummary.FieldID, id),
			sqlgraph.To(runnercount.Table, runnercount.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, actionsummary.RunnerCountTable, actionsummary.RunnerCountColumn),
		)
		fromV = sqlgraph.Neighbors(as.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryActionCacheStatistics queries the action_cache_statistics edge of a ActionSummary.
func (c *ActionSummaryClient) QueryActionCacheStatistics(as *ActionSummary) *ActionCacheStatisticsQuery {
	query := (&ActionCacheStatisticsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := as.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(actionsummary.Table, actionsummary.FieldID, id),
			sqlgraph.To(actioncachestatistics.Table, actioncachestatistics.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, actionsummary.ActionCacheStatisticsTable, actionsummary.ActionCacheStatisticsColumn),
		)
		fromV = sqlgraph.Neighbors(as.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ActionSummaryClient) Hooks() []Hook {
	return c.hooks.ActionSummary
}

// Interceptors returns the client interceptors.
func (c *ActionSummaryClient) Interceptors() []Interceptor {
	return c.inters.ActionSummary
}

func (c *ActionSummaryClient) mutate(ctx context.Context, m *ActionSummaryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ActionSummaryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ActionSummaryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ActionSummaryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ActionSummaryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ActionSummary mutation op: %q", m.Op())
	}
}

// ArtifactMetricsClient is a client for the ArtifactMetrics schema.
type ArtifactMetricsClient struct {
	config
}

// NewArtifactMetricsClient returns a client for the ArtifactMetrics from the given config.
func NewArtifactMetricsClient(c config) *ArtifactMetricsClient {
	return &ArtifactMetricsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `artifactmetrics.Hooks(f(g(h())))`.
func (c *ArtifactMetricsClient) Use(hooks ...Hook) {
	c.hooks.ArtifactMetrics = append(c.hooks.ArtifactMetrics, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `artifactmetrics.Intercept(f(g(h())))`.
func (c *ArtifactMetricsClient) Intercept(interceptors ...Interceptor) {
	c.inters.ArtifactMetrics = append(c.inters.ArtifactMetrics, interceptors...)
}

// Create returns a builder for creating a ArtifactMetrics entity.
func (c *ArtifactMetricsClient) Create() *ArtifactMetricsCreate {
	mutation := newArtifactMetricsMutation(c.config, OpCreate)
	return &ArtifactMetricsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ArtifactMetrics entities.
func (c *ArtifactMetricsClient) CreateBulk(builders ...*ArtifactMetricsCreate) *ArtifactMetricsCreateBulk {
	return &ArtifactMetricsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ArtifactMetricsClient) MapCreateBulk(slice any, setFunc func(*ArtifactMetricsCreate, int)) *ArtifactMetricsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ArtifactMetricsCreateBulk{err: fmt.Errorf("calling to ArtifactMetricsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ArtifactMetricsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ArtifactMetricsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ArtifactMetrics.
func (c *ArtifactMetricsClient) Update() *ArtifactMetricsUpdate {
	mutation := newArtifactMetricsMutation(c.config, OpUpdate)
	return &ArtifactMetricsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ArtifactMetricsClient) UpdateOne(am *ArtifactMetrics) *ArtifactMetricsUpdateOne {
	mutation := newArtifactMetricsMutation(c.config, OpUpdateOne, withArtifactMetrics(am))
	return &ArtifactMetricsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ArtifactMetricsClient) UpdateOneID(id int64) *ArtifactMetricsUpdateOne {
	mutation := newArtifactMetricsMutation(c.config, OpUpdateOne, withArtifactMetricsID(id))
	return &ArtifactMetricsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ArtifactMetrics.
func (c *ArtifactMetricsClient) Delete() *ArtifactMetricsDelete {
	mutation := newArtifactMetricsMutation(c.config, OpDelete)
	return &ArtifactMetricsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ArtifactMetricsClient) DeleteOne(am *ArtifactMetrics) *ArtifactMetricsDeleteOne {
	return c.DeleteOneID(am.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ArtifactMetricsClient) DeleteOneID(id int64) *ArtifactMetricsDeleteOne {
	builder := c.Delete().Where(artifactmetrics.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ArtifactMetricsDeleteOne{builder}
}

// Query returns a query builder for ArtifactMetrics.
func (c *ArtifactMetricsClient) Query() *ArtifactMetricsQuery {
	return &ArtifactMetricsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeArtifactMetrics},
		inters: c.Interceptors(),
	}
}

// Get returns a ArtifactMetrics entity by its id.
func (c *ArtifactMetricsClient) Get(ctx context.Context, id int64) (*ArtifactMetrics, error) {
	return c.Query().Where(artifactmetrics.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ArtifactMetricsClient) GetX(ctx context.Context, id int64) *ArtifactMetrics {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMetrics queries the metrics edge of a ArtifactMetrics.
func (c *ArtifactMetricsClient) QueryMetrics(am *ArtifactMetrics) *MetricsQuery {
	query := (&MetricsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := am.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(artifactmetrics.Table, artifactmetrics.FieldID, id),
			sqlgraph.To(metrics.Table, metrics.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, artifactmetrics.MetricsTable, artifactmetrics.MetricsColumn),
		)
		fromV = sqlgraph.Neighbors(am.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ArtifactMetricsClient) Hooks() []Hook {
	return c.hooks.ArtifactMetrics
}

// Interceptors returns the client interceptors.
func (c *ArtifactMetricsClient) Interceptors() []Interceptor {
	return c.inters.ArtifactMetrics
}

func (c *ArtifactMetricsClient) mutate(ctx context.Context, m *ArtifactMetricsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ArtifactMetricsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ArtifactMetricsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ArtifactMetricsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ArtifactMetricsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ArtifactMetrics mutation op: %q", m.Op())
	}
}

// AuthenticatedUserClient is a client for the AuthenticatedUser schema.
type AuthenticatedUserClient struct {
	config
}

// NewAuthenticatedUserClient returns a client for the AuthenticatedUser from the given config.
func NewAuthenticatedUserClient(c config) *AuthenticatedUserClient {
	return &AuthenticatedUserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `authenticateduser.Hooks(f(g(h())))`.
func (c *AuthenticatedUserClient) Use(hooks ...Hook) {
	c.hooks.AuthenticatedUser = append(c.hooks.AuthenticatedUser, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `authenticateduser.Intercept(f(g(h())))`.
func (c *AuthenticatedUserClient) Intercept(interceptors ...Interceptor) {
	c.inters.AuthenticatedUser = append(c.inters.AuthenticatedUser, interceptors...)
}

// Create returns a builder for creating a AuthenticatedUser entity.
func (c *AuthenticatedUserClient) Create() *AuthenticatedUserCreate {
	mutation := newAuthenticatedUserMutation(c.config, OpCreate)
	return &AuthenticatedUserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AuthenticatedUser entities.
func (c *AuthenticatedUserClient) CreateBulk(builders ...*AuthenticatedUserCreate) *AuthenticatedUserCreateBulk {
	return &AuthenticatedUserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AuthenticatedUserClient) MapCreateBulk(slice any, setFunc func(*AuthenticatedUserCreate, int)) *AuthenticatedUserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AuthenticatedUserCreateBulk{err: fmt.Errorf("calling to AuthenticatedUserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AuthenticatedUserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AuthenticatedUserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AuthenticatedUser.
func (c *AuthenticatedUserClient) Update() *AuthenticatedUserUpdate {
	mutation := newAuthenticatedUserMutation(c.config, OpUpdate)
	return &AuthenticatedUserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AuthenticatedUserClient) UpdateOne(au *AuthenticatedUser) *AuthenticatedUserUpdateOne {
	mutation := newAuthenticatedUserMutation(c.config, OpUpdateOne, withAuthenticatedUser(au))
	return &AuthenticatedUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AuthenticatedUserClient) UpdateOneID(id int64) *AuthenticatedUserUpdateOne {
	mutation := newAuthenticatedUserMutation(c.config, OpUpdateOne, withAuthenticatedUserID(id))
	return &AuthenticatedUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AuthenticatedUser.
func (c *AuthenticatedUserClient) Delete() *AuthenticatedUserDelete {
	mutation := newAuthenticatedUserMutation(c.config, OpDelete)
	return &AuthenticatedUserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AuthenticatedUserClient) DeleteOne(au *AuthenticatedUser) *AuthenticatedUserDeleteOne {
	return c.DeleteOneID(au.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AuthenticatedUserClient) DeleteOneID(id int64) *AuthenticatedUserDeleteOne {
	builder := c.Delete().Where(authenticateduser.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AuthenticatedUserDeleteOne{builder}
}

// Query returns a query builder for AuthenticatedUser.
func (c *AuthenticatedUserClient) Query() *AuthenticatedUserQuery {
	return &AuthenticatedUserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAuthenticatedUser},
		inters: c.Interceptors(),
	}
}

// Get returns a AuthenticatedUser entity by its id.
func (c *AuthenticatedUserClient) Get(ctx context.Context, id int64) (*AuthenticatedUser, error) {
	return c.Query().Where(authenticateduser.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AuthenticatedUserClient) GetX(ctx context.Context, id int64) *AuthenticatedUser {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBazelInvocations queries the bazel_invocations edge of a AuthenticatedUser.
func (c *AuthenticatedUserClient) QueryBazelInvocations(au *AuthenticatedUser) *BazelInvocationQuery {
	query := (&BazelInvocationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := au.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(authenticateduser.Table, authenticateduser.FieldID, id),
			sqlgraph.To(bazelinvocation.Table, bazelinvocation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, authenticateduser.BazelInvocationsTable, authenticateduser.BazelInvocationsColumn),
		)
		fromV = sqlgraph.Neighbors(au.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AuthenticatedUserClient) Hooks() []Hook {
	hooks := c.hooks.AuthenticatedUser
	return append(hooks[:len(hooks):len(hooks)], authenticateduser.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *AuthenticatedUserClient) Interceptors() []Interceptor {
	return c.inters.AuthenticatedUser
}

func (c *AuthenticatedUserClient) mutate(ctx context.Context, m *AuthenticatedUserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AuthenticatedUserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AuthenticatedUserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AuthenticatedUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AuthenticatedUserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AuthenticatedUser mutation op: %q", m.Op())
	}
}

// BazelInvocationClient is a client for the BazelInvocation schema.
type BazelInvocationClient struct {
	config
}

// NewBazelInvocationClient returns a client for the BazelInvocation from the given config.
func NewBazelInvocationClient(c config) *BazelInvocationClient {
	return &BazelInvocationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `bazelinvocation.Hooks(f(g(h())))`.
func (c *BazelInvocationClient) Use(hooks ...Hook) {
	c.hooks.BazelInvocation = append(c.hooks.BazelInvocation, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `bazelinvocation.Intercept(f(g(h())))`.
func (c *BazelInvocationClient) Intercept(interceptors ...Interceptor) {
	c.inters.BazelInvocation = append(c.inters.BazelInvocation, interceptors...)
}

// Create returns a builder for creating a BazelInvocation entity.
func (c *BazelInvocationClient) Create() *BazelInvocationCreate {
	mutation := newBazelInvocationMutation(c.config, OpCreate)
	return &BazelInvocationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BazelInvocation entities.
func (c *BazelInvocationClient) CreateBulk(builders ...*BazelInvocationCreate) *BazelInvocationCreateBulk {
	return &BazelInvocationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BazelInvocationClient) MapCreateBulk(slice any, setFunc func(*BazelInvocationCreate, int)) *BazelInvocationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BazelInvocationCreateBulk{err: fmt.Errorf("calling to BazelInvocationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BazelInvocationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BazelInvocationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BazelInvocation.
func (c *BazelInvocationClient) Update() *BazelInvocationUpdate {
	mutation := newBazelInvocationMutation(c.config, OpUpdate)
	return &BazelInvocationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BazelInvocationClient) UpdateOne(bi *BazelInvocation) *BazelInvocationUpdateOne {
	mutation := newBazelInvocationMutation(c.config, OpUpdateOne, withBazelInvocation(bi))
	return &BazelInvocationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BazelInvocationClient) UpdateOneID(id int64) *BazelInvocationUpdateOne {
	mutation := newBazelInvocationMutation(c.config, OpUpdateOne, withBazelInvocationID(id))
	return &BazelInvocationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BazelInvocation.
func (c *BazelInvocationClient) Delete() *BazelInvocationDelete {
	mutation := newBazelInvocationMutation(c.config, OpDelete)
	return &BazelInvocationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BazelInvocationClient) DeleteOne(bi *BazelInvocation) *BazelInvocationDeleteOne {
	return c.DeleteOneID(bi.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BazelInvocationClient) DeleteOneID(id int64) *BazelInvocationDeleteOne {
	builder := c.Delete().Where(bazelinvocation.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BazelInvocationDeleteOne{builder}
}

// Query returns a query builder for BazelInvocation.
func (c *BazelInvocationClient) Query() *BazelInvocationQuery {
	return &BazelInvocationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBazelInvocation},
		inters: c.Interceptors(),
	}
}

// Get returns a BazelInvocation entity by its id.
func (c *BazelInvocationClient) Get(ctx context.Context, id int64) (*BazelInvocation, error) {
	return c.Query().Where(bazelinvocation.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BazelInvocationClient) GetX(ctx context.Context, id int64) *BazelInvocation {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryInstanceName queries the instance_name edge of a BazelInvocation.
func (c *BazelInvocationClient) QueryInstanceName(bi *BazelInvocation) *InstanceNameQuery {
	query := (&InstanceNameClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(bazelinvocation.Table, bazelinvocation.FieldID, id),
			sqlgraph.To(instancename.Table, instancename.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, bazelinvocation.InstanceNameTable, bazelinvocation.InstanceNameColumn),
		)
		fromV = sqlgraph.Neighbors(bi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBuild queries the build edge of a BazelInvocation.
func (c *BazelInvocationClient) QueryBuild(bi *BazelInvocation) *BuildQuery {
	query := (&BuildClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(bazelinvocation.Table, bazelinvocation.FieldID, id),
			sqlgraph.To(build.Table, build.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, bazelinvocation.BuildTable, bazelinvocation.BuildColumn),
		)
		fromV = sqlgraph.Neighbors(bi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAuthenticatedUser queries the authenticated_user edge of a BazelInvocation.
func (c *BazelInvocationClient) QueryAuthenticatedUser(bi *BazelInvocation) *AuthenticatedUserQuery {
	query := (&AuthenticatedUserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(bazelinvocation.Table, bazelinvocation.FieldID, id),
			sqlgraph.To(authenticateduser.Table, authenticateduser.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, bazelinvocation.AuthenticatedUserTable, bazelinvocation.AuthenticatedUserColumn),
		)
		fromV = sqlgraph.Neighbors(bi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEventMetadata queries the event_metadata edge of a BazelInvocation.
func (c *BazelInvocationClient) QueryEventMetadata(bi *BazelInvocation) *EventMetadataQuery {
	query := (&EventMetadataClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(bazelinvocation.Table, bazelinvocation.FieldID, id),
			sqlgraph.To(eventmetadata.Table, eventmetadata.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, bazelinvocation.EventMetadataTable, bazelinvocation.EventMetadataColumn),
		)
		fromV = sqlgraph.Neighbors(bi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryConnectionMetadata queries the connection_metadata edge of a BazelInvocation.
func (c *BazelInvocationClient) QueryConnectionMetadata(bi *BazelInvocation) *ConnectionMetadataQuery {
	query := (&ConnectionMetadataClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(bazelinvocation.Table, bazelinvocation.FieldID, id),
			sqlgraph.To(connectionmetadata.Table, connectionmetadata.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, bazelinvocation.ConnectionMetadataTable, bazelinvocation.ConnectionMetadataColumn),
		)
		fromV = sqlgraph.Neighbors(bi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryConfigurations queries the configurations edge of a BazelInvocation.
func (c *BazelInvocationClient) QueryConfigurations(bi *BazelInvocation) *ConfigurationQuery {
	query := (&ConfigurationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(bazelinvocation.Table, bazelinvocation.FieldID, id),
			sqlgraph.To(configuration.Table, configuration.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, bazelinvocation.ConfigurationsTable, bazelinvocation.ConfigurationsColumn),
		)
		fromV = sqlgraph.Neighbors(bi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryActions queries the actions edge of a BazelInvocation.
func (c *BazelInvocationClient) QueryActions(bi *BazelInvocation) *ActionQuery {
	query := (&ActionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(bazelinvocation.Table, bazelinvocation.FieldID, id),
			sqlgraph.To(action.Table, action.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, bazelinvocation.ActionsTable, bazelinvocation.ActionsColumn),
		)
		fromV = sqlgraph.Neighbors(bi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProblems queries the problems edge of a BazelInvocation.
func (c *BazelInvocationClient) QueryProblems(bi *BazelInvocation) *BazelInvocationProblemQuery {
	query := (&BazelInvocationProblemClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(bazelinvocation.Table, bazelinvocation.FieldID, id),
			sqlgraph.To(bazelinvocationproblem.Table, bazelinvocationproblem.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, bazelinvocation.ProblemsTable, bazelinvocation.ProblemsColumn),
		)
		fromV = sqlgraph.Neighbors(bi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMetrics queries the metrics edge of a BazelInvocation.
func (c *BazelInvocationClient) QueryMetrics(bi *BazelInvocation) *MetricsQuery {
	query := (&MetricsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(bazelinvocation.Table, bazelinvocation.FieldID, id),
			sqlgraph.To(metrics.Table, metrics.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, bazelinvocation.MetricsTable, bazelinvocation.MetricsColumn),
		)
		fromV = sqlgraph.Neighbors(bi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIncompleteBuildLogs queries the incomplete_build_logs edge of a BazelInvocation.
func (c *BazelInvocationClient) QueryIncompleteBuildLogs(bi *BazelInvocation) *IncompleteBuildLogQuery {
	query := (&IncompleteBuildLogClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(bazelinvocation.Table, bazelinvocation.FieldID, id),
			sqlgraph.To(incompletebuildlog.Table, incompletebuildlog.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, bazelinvocation.IncompleteBuildLogsTable, bazelinvocation.IncompleteBuildLogsColumn),
		)
		fromV = sqlgraph.Neighbors(bi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBuildLogChunks queries the build_log_chunks edge of a BazelInvocation.
func (c *BazelInvocationClient) QueryBuildLogChunks(bi *BazelInvocation) *BuildLogChunkQuery {
	query := (&BuildLogChunkClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(bazelinvocation.Table, bazelinvocation.FieldID, id),
			sqlgraph.To(buildlogchunk.Table, buildlogchunk.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, bazelinvocation.BuildLogChunksTable, bazelinvocation.BuildLogChunksColumn),
		)
		fromV = sqlgraph.Neighbors(bi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInvocationFiles queries the invocation_files edge of a BazelInvocation.
func (c *BazelInvocationClient) QueryInvocationFiles(bi *BazelInvocation) *InvocationFilesQuery {
	query := (&InvocationFilesClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(bazelinvocation.Table, bazelinvocation.FieldID, id),
			sqlgraph.To(invocationfiles.Table, invocationfiles.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, bazelinvocation.InvocationFilesTable, bazelinvocation.InvocationFilesColumn),
		)
		fromV = sqlgraph.Neighbors(bi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInvocationTargets queries the invocation_targets edge of a BazelInvocation.
func (c *BazelInvocationClient) QueryInvocationTargets(bi *BazelInvocation) *InvocationTargetQuery {
	query := (&InvocationTargetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(bazelinvocation.Table, bazelinvocation.FieldID, id),
			sqlgraph.To(invocationtarget.Table, invocationtarget.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, bazelinvocation.InvocationTargetsTable, bazelinvocation.InvocationTargetsColumn),
		)
		fromV = sqlgraph.Neighbors(bi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTargetKindMappings queries the target_kind_mappings edge of a BazelInvocation.
func (c *BazelInvocationClient) QueryTargetKindMappings(bi *BazelInvocation) *TargetKindMappingQuery {
	query := (&TargetKindMappingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(bazelinvocation.Table, bazelinvocation.FieldID, id),
			sqlgraph.To(targetkindmapping.Table, targetkindmapping.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, bazelinvocation.TargetKindMappingsTable, bazelinvocation.TargetKindMappingsColumn),
		)
		fromV = sqlgraph.Neighbors(bi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySourceControl queries the source_control edge of a BazelInvocation.
func (c *BazelInvocationClient) QuerySourceControl(bi *BazelInvocation) *SourceControlQuery {
	query := (&SourceControlClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(bazelinvocation.Table, bazelinvocation.FieldID, id),
			sqlgraph.To(sourcecontrol.Table, sourcecontrol.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, bazelinvocation.SourceControlTable, bazelinvocation.SourceControlColumn),
		)
		fromV = sqlgraph.Neighbors(bi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BazelInvocationClient) Hooks() []Hook {
	hooks := c.hooks.BazelInvocation
	return append(hooks[:len(hooks):len(hooks)], bazelinvocation.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *BazelInvocationClient) Interceptors() []Interceptor {
	return c.inters.BazelInvocation
}

func (c *BazelInvocationClient) mutate(ctx context.Context, m *BazelInvocationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BazelInvocationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BazelInvocationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BazelInvocationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BazelInvocationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BazelInvocation mutation op: %q", m.Op())
	}
}

// BazelInvocationProblemClient is a client for the BazelInvocationProblem schema.
type BazelInvocationProblemClient struct {
	config
}

// NewBazelInvocationProblemClient returns a client for the BazelInvocationProblem from the given config.
func NewBazelInvocationProblemClient(c config) *BazelInvocationProblemClient {
	return &BazelInvocationProblemClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `bazelinvocationproblem.Hooks(f(g(h())))`.
func (c *BazelInvocationProblemClient) Use(hooks ...Hook) {
	c.hooks.BazelInvocationProblem = append(c.hooks.BazelInvocationProblem, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `bazelinvocationproblem.Intercept(f(g(h())))`.
func (c *BazelInvocationProblemClient) Intercept(interceptors ...Interceptor) {
	c.inters.BazelInvocationProblem = append(c.inters.BazelInvocationProblem, interceptors...)
}

// Create returns a builder for creating a BazelInvocationProblem entity.
func (c *BazelInvocationProblemClient) Create() *BazelInvocationProblemCreate {
	mutation := newBazelInvocationProblemMutation(c.config, OpCreate)
	return &BazelInvocationProblemCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BazelInvocationProblem entities.
func (c *BazelInvocationProblemClient) CreateBulk(builders ...*BazelInvocationProblemCreate) *BazelInvocationProblemCreateBulk {
	return &BazelInvocationProblemCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BazelInvocationProblemClient) MapCreateBulk(slice any, setFunc func(*BazelInvocationProblemCreate, int)) *BazelInvocationProblemCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BazelInvocationProblemCreateBulk{err: fmt.Errorf("calling to BazelInvocationProblemClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BazelInvocationProblemCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BazelInvocationProblemCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BazelInvocationProblem.
func (c *BazelInvocationProblemClient) Update() *BazelInvocationProblemUpdate {
	mutation := newBazelInvocationProblemMutation(c.config, OpUpdate)
	return &BazelInvocationProblemUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BazelInvocationProblemClient) UpdateOne(bip *BazelInvocationProblem) *BazelInvocationProblemUpdateOne {
	mutation := newBazelInvocationProblemMutation(c.config, OpUpdateOne, withBazelInvocationProblem(bip))
	return &BazelInvocationProblemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BazelInvocationProblemClient) UpdateOneID(id int64) *BazelInvocationProblemUpdateOne {
	mutation := newBazelInvocationProblemMutation(c.config, OpUpdateOne, withBazelInvocationProblemID(id))
	return &BazelInvocationProblemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BazelInvocationProblem.
func (c *BazelInvocationProblemClient) Delete() *BazelInvocationProblemDelete {
	mutation := newBazelInvocationProblemMutation(c.config, OpDelete)
	return &BazelInvocationProblemDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BazelInvocationProblemClient) DeleteOne(bip *BazelInvocationProblem) *BazelInvocationProblemDeleteOne {
	return c.DeleteOneID(bip.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BazelInvocationProblemClient) DeleteOneID(id int64) *BazelInvocationProblemDeleteOne {
	builder := c.Delete().Where(bazelinvocationproblem.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BazelInvocationProblemDeleteOne{builder}
}

// Query returns a query builder for BazelInvocationProblem.
func (c *BazelInvocationProblemClient) Query() *BazelInvocationProblemQuery {
	return &BazelInvocationProblemQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBazelInvocationProblem},
		inters: c.Interceptors(),
	}
}

// Get returns a BazelInvocationProblem entity by its id.
func (c *BazelInvocationProblemClient) Get(ctx context.Context, id int64) (*BazelInvocationProblem, error) {
	return c.Query().Where(bazelinvocationproblem.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BazelInvocationProblemClient) GetX(ctx context.Context, id int64) *BazelInvocationProblem {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBazelInvocation queries the bazel_invocation edge of a BazelInvocationProblem.
func (c *BazelInvocationProblemClient) QueryBazelInvocation(bip *BazelInvocationProblem) *BazelInvocationQuery {
	query := (&BazelInvocationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bip.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(bazelinvocationproblem.Table, bazelinvocationproblem.FieldID, id),
			sqlgraph.To(bazelinvocation.Table, bazelinvocation.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, bazelinvocationproblem.BazelInvocationTable, bazelinvocationproblem.BazelInvocationColumn),
		)
		fromV = sqlgraph.Neighbors(bip.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BazelInvocationProblemClient) Hooks() []Hook {
	return c.hooks.BazelInvocationProblem
}

// Interceptors returns the client interceptors.
func (c *BazelInvocationProblemClient) Interceptors() []Interceptor {
	return c.inters.BazelInvocationProblem
}

func (c *BazelInvocationProblemClient) mutate(ctx context.Context, m *BazelInvocationProblemMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BazelInvocationProblemCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BazelInvocationProblemUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BazelInvocationProblemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BazelInvocationProblemDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BazelInvocationProblem mutation op: %q", m.Op())
	}
}

// BlobClient is a client for the Blob schema.
type BlobClient struct {
	config
}

// NewBlobClient returns a client for the Blob from the given config.
func NewBlobClient(c config) *BlobClient {
	return &BlobClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `blob.Hooks(f(g(h())))`.
func (c *BlobClient) Use(hooks ...Hook) {
	c.hooks.Blob = append(c.hooks.Blob, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `blob.Intercept(f(g(h())))`.
func (c *BlobClient) Intercept(interceptors ...Interceptor) {
	c.inters.Blob = append(c.inters.Blob, interceptors...)
}

// Create returns a builder for creating a Blob entity.
func (c *BlobClient) Create() *BlobCreate {
	mutation := newBlobMutation(c.config, OpCreate)
	return &BlobCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Blob entities.
func (c *BlobClient) CreateBulk(builders ...*BlobCreate) *BlobCreateBulk {
	return &BlobCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BlobClient) MapCreateBulk(slice any, setFunc func(*BlobCreate, int)) *BlobCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BlobCreateBulk{err: fmt.Errorf("calling to BlobClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BlobCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BlobCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Blob.
func (c *BlobClient) Update() *BlobUpdate {
	mutation := newBlobMutation(c.config, OpUpdate)
	return &BlobUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BlobClient) UpdateOne(b *Blob) *BlobUpdateOne {
	mutation := newBlobMutation(c.config, OpUpdateOne, withBlob(b))
	return &BlobUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BlobClient) UpdateOneID(id int64) *BlobUpdateOne {
	mutation := newBlobMutation(c.config, OpUpdateOne, withBlobID(id))
	return &BlobUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Blob.
func (c *BlobClient) Delete() *BlobDelete {
	mutation := newBlobMutation(c.config, OpDelete)
	return &BlobDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BlobClient) DeleteOne(b *Blob) *BlobDeleteOne {
	return c.DeleteOneID(b.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BlobClient) DeleteOneID(id int64) *BlobDeleteOne {
	builder := c.Delete().Where(blob.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BlobDeleteOne{builder}
}

// Query returns a query builder for Blob.
func (c *BlobClient) Query() *BlobQuery {
	return &BlobQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBlob},
		inters: c.Interceptors(),
	}
}

// Get returns a Blob entity by its id.
func (c *BlobClient) Get(ctx context.Context, id int64) (*Blob, error) {
	return c.Query().Where(blob.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BlobClient) GetX(ctx context.Context, id int64) *Blob {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryInstanceName queries the instance_name edge of a Blob.
func (c *BlobClient) QueryInstanceName(b *Blob) *InstanceNameQuery {
	query := (&InstanceNameClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(blob.Table, blob.FieldID, id),
			sqlgraph.To(instancename.Table, instancename.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, blob.InstanceNameTable, blob.InstanceNameColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BlobClient) Hooks() []Hook {
	return c.hooks.Blob
}

// Interceptors returns the client interceptors.
func (c *BlobClient) Interceptors() []Interceptor {
	return c.inters.Blob
}

func (c *BlobClient) mutate(ctx context.Context, m *BlobMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BlobCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BlobUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BlobUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BlobDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Blob mutation op: %q", m.Op())
	}
}

// BuildClient is a client for the Build schema.
type BuildClient struct {
	config
}

// NewBuildClient returns a client for the Build from the given config.
func NewBuildClient(c config) *BuildClient {
	return &BuildClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `build.Hooks(f(g(h())))`.
func (c *BuildClient) Use(hooks ...Hook) {
	c.hooks.Build = append(c.hooks.Build, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `build.Intercept(f(g(h())))`.
func (c *BuildClient) Intercept(interceptors ...Interceptor) {
	c.inters.Build = append(c.inters.Build, interceptors...)
}

// Create returns a builder for creating a Build entity.
func (c *BuildClient) Create() *BuildCreate {
	mutation := newBuildMutation(c.config, OpCreate)
	return &BuildCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Build entities.
func (c *BuildClient) CreateBulk(builders ...*BuildCreate) *BuildCreateBulk {
	return &BuildCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BuildClient) MapCreateBulk(slice any, setFunc func(*BuildCreate, int)) *BuildCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BuildCreateBulk{err: fmt.Errorf("calling to BuildClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BuildCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BuildCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Build.
func (c *BuildClient) Update() *BuildUpdate {
	mutation := newBuildMutation(c.config, OpUpdate)
	return &BuildUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BuildClient) UpdateOne(b *Build) *BuildUpdateOne {
	mutation := newBuildMutation(c.config, OpUpdateOne, withBuild(b))
	return &BuildUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BuildClient) UpdateOneID(id int64) *BuildUpdateOne {
	mutation := newBuildMutation(c.config, OpUpdateOne, withBuildID(id))
	return &BuildUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Build.
func (c *BuildClient) Delete() *BuildDelete {
	mutation := newBuildMutation(c.config, OpDelete)
	return &BuildDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BuildClient) DeleteOne(b *Build) *BuildDeleteOne {
	return c.DeleteOneID(b.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BuildClient) DeleteOneID(id int64) *BuildDeleteOne {
	builder := c.Delete().Where(build.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BuildDeleteOne{builder}
}

// Query returns a query builder for Build.
func (c *BuildClient) Query() *BuildQuery {
	return &BuildQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBuild},
		inters: c.Interceptors(),
	}
}

// Get returns a Build entity by its id.
func (c *BuildClient) Get(ctx context.Context, id int64) (*Build, error) {
	return c.Query().Where(build.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BuildClient) GetX(ctx context.Context, id int64) *Build {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryInstanceName queries the instance_name edge of a Build.
func (c *BuildClient) QueryInstanceName(b *Build) *InstanceNameQuery {
	query := (&InstanceNameClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(build.Table, build.FieldID, id),
			sqlgraph.To(instancename.Table, instancename.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, build.InstanceNameTable, build.InstanceNameColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInvocations queries the invocations edge of a Build.
func (c *BuildClient) QueryInvocations(b *Build) *BazelInvocationQuery {
	query := (&BazelInvocationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(build.Table, build.FieldID, id),
			sqlgraph.To(bazelinvocation.Table, bazelinvocation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, build.InvocationsTable, build.InvocationsColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BuildClient) Hooks() []Hook {
	hooks := c.hooks.Build
	return append(hooks[:len(hooks):len(hooks)], build.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *BuildClient) Interceptors() []Interceptor {
	return c.inters.Build
}

func (c *BuildClient) mutate(ctx context.Context, m *BuildMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BuildCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BuildUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BuildUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BuildDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Build mutation op: %q", m.Op())
	}
}

// BuildGraphMetricsClient is a client for the BuildGraphMetrics schema.
type BuildGraphMetricsClient struct {
	config
}

// NewBuildGraphMetricsClient returns a client for the BuildGraphMetrics from the given config.
func NewBuildGraphMetricsClient(c config) *BuildGraphMetricsClient {
	return &BuildGraphMetricsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `buildgraphmetrics.Hooks(f(g(h())))`.
func (c *BuildGraphMetricsClient) Use(hooks ...Hook) {
	c.hooks.BuildGraphMetrics = append(c.hooks.BuildGraphMetrics, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `buildgraphmetrics.Intercept(f(g(h())))`.
func (c *BuildGraphMetricsClient) Intercept(interceptors ...Interceptor) {
	c.inters.BuildGraphMetrics = append(c.inters.BuildGraphMetrics, interceptors...)
}

// Create returns a builder for creating a BuildGraphMetrics entity.
func (c *BuildGraphMetricsClient) Create() *BuildGraphMetricsCreate {
	mutation := newBuildGraphMetricsMutation(c.config, OpCreate)
	return &BuildGraphMetricsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BuildGraphMetrics entities.
func (c *BuildGraphMetricsClient) CreateBulk(builders ...*BuildGraphMetricsCreate) *BuildGraphMetricsCreateBulk {
	return &BuildGraphMetricsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BuildGraphMetricsClient) MapCreateBulk(slice any, setFunc func(*BuildGraphMetricsCreate, int)) *BuildGraphMetricsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BuildGraphMetricsCreateBulk{err: fmt.Errorf("calling to BuildGraphMetricsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BuildGraphMetricsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BuildGraphMetricsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BuildGraphMetrics.
func (c *BuildGraphMetricsClient) Update() *BuildGraphMetricsUpdate {
	mutation := newBuildGraphMetricsMutation(c.config, OpUpdate)
	return &BuildGraphMetricsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BuildGraphMetricsClient) UpdateOne(bgm *BuildGraphMetrics) *BuildGraphMetricsUpdateOne {
	mutation := newBuildGraphMetricsMutation(c.config, OpUpdateOne, withBuildGraphMetrics(bgm))
	return &BuildGraphMetricsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BuildGraphMetricsClient) UpdateOneID(id int64) *BuildGraphMetricsUpdateOne {
	mutation := newBuildGraphMetricsMutation(c.config, OpUpdateOne, withBuildGraphMetricsID(id))
	return &BuildGraphMetricsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BuildGraphMetrics.
func (c *BuildGraphMetricsClient) Delete() *BuildGraphMetricsDelete {
	mutation := newBuildGraphMetricsMutation(c.config, OpDelete)
	return &BuildGraphMetricsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BuildGraphMetricsClient) DeleteOne(bgm *BuildGraphMetrics) *BuildGraphMetricsDeleteOne {
	return c.DeleteOneID(bgm.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BuildGraphMetricsClient) DeleteOneID(id int64) *BuildGraphMetricsDeleteOne {
	builder := c.Delete().Where(buildgraphmetrics.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BuildGraphMetricsDeleteOne{builder}
}

// Query returns a query builder for BuildGraphMetrics.
func (c *BuildGraphMetricsClient) Query() *BuildGraphMetricsQuery {
	return &BuildGraphMetricsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBuildGraphMetrics},
		inters: c.Interceptors(),
	}
}

// Get returns a BuildGraphMetrics entity by its id.
func (c *BuildGraphMetricsClient) Get(ctx context.Context, id int64) (*BuildGraphMetrics, error) {
	return c.Query().Where(buildgraphmetrics.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BuildGraphMetricsClient) GetX(ctx context.Context, id int64) *BuildGraphMetrics {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMetrics queries the metrics edge of a BuildGraphMetrics.
func (c *BuildGraphMetricsClient) QueryMetrics(bgm *BuildGraphMetrics) *MetricsQuery {
	query := (&MetricsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bgm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(buildgraphmetrics.Table, buildgraphmetrics.FieldID, id),
			sqlgraph.To(metrics.Table, metrics.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, buildgraphmetrics.MetricsTable, buildgraphmetrics.MetricsColumn),
		)
		fromV = sqlgraph.Neighbors(bgm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDirtiedValues queries the dirtied_values edge of a BuildGraphMetrics.
func (c *BuildGraphMetricsClient) QueryDirtiedValues(bgm *BuildGraphMetrics) *EvaluationStatQuery {
	query := (&EvaluationStatClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bgm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(buildgraphmetrics.Table, buildgraphmetrics.FieldID, id),
			sqlgraph.To(evaluationstat.Table, evaluationstat.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, buildgraphmetrics.DirtiedValuesTable, buildgraphmetrics.DirtiedValuesColumn),
		)
		fromV = sqlgraph.Neighbors(bgm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryChangedValues queries the changed_values edge of a BuildGraphMetrics.
func (c *BuildGraphMetricsClient) QueryChangedValues(bgm *BuildGraphMetrics) *EvaluationStatQuery {
	query := (&EvaluationStatClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bgm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(buildgraphmetrics.Table, buildgraphmetrics.FieldID, id),
			sqlgraph.To(evaluationstat.Table, evaluationstat.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, buildgraphmetrics.ChangedValuesTable, buildgraphmetrics.ChangedValuesColumn),
		)
		fromV = sqlgraph.Neighbors(bgm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBuiltValues queries the built_values edge of a BuildGraphMetrics.
func (c *BuildGraphMetricsClient) QueryBuiltValues(bgm *BuildGraphMetrics) *EvaluationStatQuery {
	query := (&EvaluationStatClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bgm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(buildgraphmetrics.Table, buildgraphmetrics.FieldID, id),
			sqlgraph.To(evaluationstat.Table, evaluationstat.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, buildgraphmetrics.BuiltValuesTable, buildgraphmetrics.BuiltValuesColumn),
		)
		fromV = sqlgraph.Neighbors(bgm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCleanedValues queries the cleaned_values edge of a BuildGraphMetrics.
func (c *BuildGraphMetricsClient) QueryCleanedValues(bgm *BuildGraphMetrics) *EvaluationStatQuery {
	query := (&EvaluationStatClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bgm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(buildgraphmetrics.Table, buildgraphmetrics.FieldID, id),
			sqlgraph.To(evaluationstat.Table, evaluationstat.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, buildgraphmetrics.CleanedValuesTable, buildgraphmetrics.CleanedValuesColumn),
		)
		fromV = sqlgraph.Neighbors(bgm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvaluatedValues queries the evaluated_values edge of a BuildGraphMetrics.
func (c *BuildGraphMetricsClient) QueryEvaluatedValues(bgm *BuildGraphMetrics) *EvaluationStatQuery {
	query := (&EvaluationStatClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bgm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(buildgraphmetrics.Table, buildgraphmetrics.FieldID, id),
			sqlgraph.To(evaluationstat.Table, evaluationstat.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, buildgraphmetrics.EvaluatedValuesTable, buildgraphmetrics.EvaluatedValuesColumn),
		)
		fromV = sqlgraph.Neighbors(bgm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BuildGraphMetricsClient) Hooks() []Hook {
	return c.hooks.BuildGraphMetrics
}

// Interceptors returns the client interceptors.
func (c *BuildGraphMetricsClient) Interceptors() []Interceptor {
	return c.inters.BuildGraphMetrics
}

func (c *BuildGraphMetricsClient) mutate(ctx context.Context, m *BuildGraphMetricsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BuildGraphMetricsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BuildGraphMetricsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BuildGraphMetricsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BuildGraphMetricsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BuildGraphMetrics mutation op: %q", m.Op())
	}
}

// BuildLogChunkClient is a client for the BuildLogChunk schema.
type BuildLogChunkClient struct {
	config
}

// NewBuildLogChunkClient returns a client for the BuildLogChunk from the given config.
func NewBuildLogChunkClient(c config) *BuildLogChunkClient {
	return &BuildLogChunkClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `buildlogchunk.Hooks(f(g(h())))`.
func (c *BuildLogChunkClient) Use(hooks ...Hook) {
	c.hooks.BuildLogChunk = append(c.hooks.BuildLogChunk, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `buildlogchunk.Intercept(f(g(h())))`.
func (c *BuildLogChunkClient) Intercept(interceptors ...Interceptor) {
	c.inters.BuildLogChunk = append(c.inters.BuildLogChunk, interceptors...)
}

// Create returns a builder for creating a BuildLogChunk entity.
func (c *BuildLogChunkClient) Create() *BuildLogChunkCreate {
	mutation := newBuildLogChunkMutation(c.config, OpCreate)
	return &BuildLogChunkCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BuildLogChunk entities.
func (c *BuildLogChunkClient) CreateBulk(builders ...*BuildLogChunkCreate) *BuildLogChunkCreateBulk {
	return &BuildLogChunkCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BuildLogChunkClient) MapCreateBulk(slice any, setFunc func(*BuildLogChunkCreate, int)) *BuildLogChunkCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BuildLogChunkCreateBulk{err: fmt.Errorf("calling to BuildLogChunkClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BuildLogChunkCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BuildLogChunkCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BuildLogChunk.
func (c *BuildLogChunkClient) Update() *BuildLogChunkUpdate {
	mutation := newBuildLogChunkMutation(c.config, OpUpdate)
	return &BuildLogChunkUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BuildLogChunkClient) UpdateOne(blc *BuildLogChunk) *BuildLogChunkUpdateOne {
	mutation := newBuildLogChunkMutation(c.config, OpUpdateOne, withBuildLogChunk(blc))
	return &BuildLogChunkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BuildLogChunkClient) UpdateOneID(id int64) *BuildLogChunkUpdateOne {
	mutation := newBuildLogChunkMutation(c.config, OpUpdateOne, withBuildLogChunkID(id))
	return &BuildLogChunkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BuildLogChunk.
func (c *BuildLogChunkClient) Delete() *BuildLogChunkDelete {
	mutation := newBuildLogChunkMutation(c.config, OpDelete)
	return &BuildLogChunkDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BuildLogChunkClient) DeleteOne(blc *BuildLogChunk) *BuildLogChunkDeleteOne {
	return c.DeleteOneID(blc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BuildLogChunkClient) DeleteOneID(id int64) *BuildLogChunkDeleteOne {
	builder := c.Delete().Where(buildlogchunk.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BuildLogChunkDeleteOne{builder}
}

// Query returns a query builder for BuildLogChunk.
func (c *BuildLogChunkClient) Query() *BuildLogChunkQuery {
	return &BuildLogChunkQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBuildLogChunk},
		inters: c.Interceptors(),
	}
}

// Get returns a BuildLogChunk entity by its id.
func (c *BuildLogChunkClient) Get(ctx context.Context, id int64) (*BuildLogChunk, error) {
	return c.Query().Where(buildlogchunk.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BuildLogChunkClient) GetX(ctx context.Context, id int64) *BuildLogChunk {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBazelInvocation queries the bazel_invocation edge of a BuildLogChunk.
func (c *BuildLogChunkClient) QueryBazelInvocation(blc *BuildLogChunk) *BazelInvocationQuery {
	query := (&BazelInvocationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := blc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(buildlogchunk.Table, buildlogchunk.FieldID, id),
			sqlgraph.To(bazelinvocation.Table, bazelinvocation.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, buildlogchunk.BazelInvocationTable, buildlogchunk.BazelInvocationColumn),
		)
		fromV = sqlgraph.Neighbors(blc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BuildLogChunkClient) Hooks() []Hook {
	return c.hooks.BuildLogChunk
}

// Interceptors returns the client interceptors.
func (c *BuildLogChunkClient) Interceptors() []Interceptor {
	return c.inters.BuildLogChunk
}

func (c *BuildLogChunkClient) mutate(ctx context.Context, m *BuildLogChunkMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BuildLogChunkCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BuildLogChunkUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BuildLogChunkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BuildLogChunkDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BuildLogChunk mutation op: %q", m.Op())
	}
}

// ConfigurationClient is a client for the Configuration schema.
type ConfigurationClient struct {
	config
}

// NewConfigurationClient returns a client for the Configuration from the given config.
func NewConfigurationClient(c config) *ConfigurationClient {
	return &ConfigurationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `configuration.Hooks(f(g(h())))`.
func (c *ConfigurationClient) Use(hooks ...Hook) {
	c.hooks.Configuration = append(c.hooks.Configuration, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `configuration.Intercept(f(g(h())))`.
func (c *ConfigurationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Configuration = append(c.inters.Configuration, interceptors...)
}

// Create returns a builder for creating a Configuration entity.
func (c *ConfigurationClient) Create() *ConfigurationCreate {
	mutation := newConfigurationMutation(c.config, OpCreate)
	return &ConfigurationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Configuration entities.
func (c *ConfigurationClient) CreateBulk(builders ...*ConfigurationCreate) *ConfigurationCreateBulk {
	return &ConfigurationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ConfigurationClient) MapCreateBulk(slice any, setFunc func(*ConfigurationCreate, int)) *ConfigurationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ConfigurationCreateBulk{err: fmt.Errorf("calling to ConfigurationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ConfigurationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ConfigurationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Configuration.
func (c *ConfigurationClient) Update() *ConfigurationUpdate {
	mutation := newConfigurationMutation(c.config, OpUpdate)
	return &ConfigurationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ConfigurationClient) UpdateOne(co *Configuration) *ConfigurationUpdateOne {
	mutation := newConfigurationMutation(c.config, OpUpdateOne, withConfiguration(co))
	return &ConfigurationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ConfigurationClient) UpdateOneID(id int64) *ConfigurationUpdateOne {
	mutation := newConfigurationMutation(c.config, OpUpdateOne, withConfigurationID(id))
	return &ConfigurationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Configuration.
func (c *ConfigurationClient) Delete() *ConfigurationDelete {
	mutation := newConfigurationMutation(c.config, OpDelete)
	return &ConfigurationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ConfigurationClient) DeleteOne(co *Configuration) *ConfigurationDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ConfigurationClient) DeleteOneID(id int64) *ConfigurationDeleteOne {
	builder := c.Delete().Where(configuration.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ConfigurationDeleteOne{builder}
}

// Query returns a query builder for Configuration.
func (c *ConfigurationClient) Query() *ConfigurationQuery {
	return &ConfigurationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeConfiguration},
		inters: c.Interceptors(),
	}
}

// Get returns a Configuration entity by its id.
func (c *ConfigurationClient) Get(ctx context.Context, id int64) (*Configuration, error) {
	return c.Query().Where(configuration.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ConfigurationClient) GetX(ctx context.Context, id int64) *Configuration {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBazelInvocation queries the bazel_invocation edge of a Configuration.
func (c *ConfigurationClient) QueryBazelInvocation(co *Configuration) *BazelInvocationQuery {
	query := (&BazelInvocationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(configuration.Table, configuration.FieldID, id),
			sqlgraph.To(bazelinvocation.Table, bazelinvocation.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, configuration.BazelInvocationTable, configuration.BazelInvocationColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInvocationTargets queries the invocation_targets edge of a Configuration.
func (c *ConfigurationClient) QueryInvocationTargets(co *Configuration) *InvocationTargetQuery {
	query := (&InvocationTargetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(configuration.Table, configuration.FieldID, id),
			sqlgraph.To(invocationtarget.Table, invocationtarget.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, configuration.InvocationTargetsTable, configuration.InvocationTargetsColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryActions queries the actions edge of a Configuration.
func (c *ConfigurationClient) QueryActions(co *Configuration) *ActionQuery {
	query := (&ActionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(configuration.Table, configuration.FieldID, id),
			sqlgraph.To(action.Table, action.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, configuration.ActionsTable, configuration.ActionsColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ConfigurationClient) Hooks() []Hook {
	return c.hooks.Configuration
}

// Interceptors returns the client interceptors.
func (c *ConfigurationClient) Interceptors() []Interceptor {
	return c.inters.Configuration
}

func (c *ConfigurationClient) mutate(ctx context.Context, m *ConfigurationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ConfigurationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ConfigurationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ConfigurationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ConfigurationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Configuration mutation op: %q", m.Op())
	}
}

// ConnectionMetadataClient is a client for the ConnectionMetadata schema.
type ConnectionMetadataClient struct {
	config
}

// NewConnectionMetadataClient returns a client for the ConnectionMetadata from the given config.
func NewConnectionMetadataClient(c config) *ConnectionMetadataClient {
	return &ConnectionMetadataClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `connectionmetadata.Hooks(f(g(h())))`.
func (c *ConnectionMetadataClient) Use(hooks ...Hook) {
	c.hooks.ConnectionMetadata = append(c.hooks.ConnectionMetadata, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `connectionmetadata.Intercept(f(g(h())))`.
func (c *ConnectionMetadataClient) Intercept(interceptors ...Interceptor) {
	c.inters.ConnectionMetadata = append(c.inters.ConnectionMetadata, interceptors...)
}

// Create returns a builder for creating a ConnectionMetadata entity.
func (c *ConnectionMetadataClient) Create() *ConnectionMetadataCreate {
	mutation := newConnectionMetadataMutation(c.config, OpCreate)
	return &ConnectionMetadataCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ConnectionMetadata entities.
func (c *ConnectionMetadataClient) CreateBulk(builders ...*ConnectionMetadataCreate) *ConnectionMetadataCreateBulk {
	return &ConnectionMetadataCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ConnectionMetadataClient) MapCreateBulk(slice any, setFunc func(*ConnectionMetadataCreate, int)) *ConnectionMetadataCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ConnectionMetadataCreateBulk{err: fmt.Errorf("calling to ConnectionMetadataClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ConnectionMetadataCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ConnectionMetadataCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ConnectionMetadata.
func (c *ConnectionMetadataClient) Update() *ConnectionMetadataUpdate {
	mutation := newConnectionMetadataMutation(c.config, OpUpdate)
	return &ConnectionMetadataUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ConnectionMetadataClient) UpdateOne(cm *ConnectionMetadata) *ConnectionMetadataUpdateOne {
	mutation := newConnectionMetadataMutation(c.config, OpUpdateOne, withConnectionMetadata(cm))
	return &ConnectionMetadataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ConnectionMetadataClient) UpdateOneID(id int64) *ConnectionMetadataUpdateOne {
	mutation := newConnectionMetadataMutation(c.config, OpUpdateOne, withConnectionMetadataID(id))
	return &ConnectionMetadataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ConnectionMetadata.
func (c *ConnectionMetadataClient) Delete() *ConnectionMetadataDelete {
	mutation := newConnectionMetadataMutation(c.config, OpDelete)
	return &ConnectionMetadataDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ConnectionMetadataClient) DeleteOne(cm *ConnectionMetadata) *ConnectionMetadataDeleteOne {
	return c.DeleteOneID(cm.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ConnectionMetadataClient) DeleteOneID(id int64) *ConnectionMetadataDeleteOne {
	builder := c.Delete().Where(connectionmetadata.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ConnectionMetadataDeleteOne{builder}
}

// Query returns a query builder for ConnectionMetadata.
func (c *ConnectionMetadataClient) Query() *ConnectionMetadataQuery {
	return &ConnectionMetadataQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeConnectionMetadata},
		inters: c.Interceptors(),
	}
}

// Get returns a ConnectionMetadata entity by its id.
func (c *ConnectionMetadataClient) Get(ctx context.Context, id int64) (*ConnectionMetadata, error) {
	return c.Query().Where(connectionmetadata.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ConnectionMetadataClient) GetX(ctx context.Context, id int64) *ConnectionMetadata {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBazelInvocation queries the bazel_invocation edge of a ConnectionMetadata.
func (c *ConnectionMetadataClient) QueryBazelInvocation(cm *ConnectionMetadata) *BazelInvocationQuery {
	query := (&BazelInvocationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(connectionmetadata.Table, connectionmetadata.FieldID, id),
			sqlgraph.To(bazelinvocation.Table, bazelinvocation.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, connectionmetadata.BazelInvocationTable, connectionmetadata.BazelInvocationColumn),
		)
		fromV = sqlgraph.Neighbors(cm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ConnectionMetadataClient) Hooks() []Hook {
	return c.hooks.ConnectionMetadata
}

// Interceptors returns the client interceptors.
func (c *ConnectionMetadataClient) Interceptors() []Interceptor {
	return c.inters.ConnectionMetadata
}

func (c *ConnectionMetadataClient) mutate(ctx context.Context, m *ConnectionMetadataMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ConnectionMetadataCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ConnectionMetadataUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ConnectionMetadataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ConnectionMetadataDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ConnectionMetadata mutation op: %q", m.Op())
	}
}

// CumulativeMetricsClient is a client for the CumulativeMetrics schema.
type CumulativeMetricsClient struct {
	config
}

// NewCumulativeMetricsClient returns a client for the CumulativeMetrics from the given config.
func NewCumulativeMetricsClient(c config) *CumulativeMetricsClient {
	return &CumulativeMetricsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `cumulativemetrics.Hooks(f(g(h())))`.
func (c *CumulativeMetricsClient) Use(hooks ...Hook) {
	c.hooks.CumulativeMetrics = append(c.hooks.CumulativeMetrics, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `cumulativemetrics.Intercept(f(g(h())))`.
func (c *CumulativeMetricsClient) Intercept(interceptors ...Interceptor) {
	c.inters.CumulativeMetrics = append(c.inters.CumulativeMetrics, interceptors...)
}

// Create returns a builder for creating a CumulativeMetrics entity.
func (c *CumulativeMetricsClient) Create() *CumulativeMetricsCreate {
	mutation := newCumulativeMetricsMutation(c.config, OpCreate)
	return &CumulativeMetricsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CumulativeMetrics entities.
func (c *CumulativeMetricsClient) CreateBulk(builders ...*CumulativeMetricsCreate) *CumulativeMetricsCreateBulk {
	return &CumulativeMetricsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CumulativeMetricsClient) MapCreateBulk(slice any, setFunc func(*CumulativeMetricsCreate, int)) *CumulativeMetricsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CumulativeMetricsCreateBulk{err: fmt.Errorf("calling to CumulativeMetricsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CumulativeMetricsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CumulativeMetricsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CumulativeMetrics.
func (c *CumulativeMetricsClient) Update() *CumulativeMetricsUpdate {
	mutation := newCumulativeMetricsMutation(c.config, OpUpdate)
	return &CumulativeMetricsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CumulativeMetricsClient) UpdateOne(cm *CumulativeMetrics) *CumulativeMetricsUpdateOne {
	mutation := newCumulativeMetricsMutation(c.config, OpUpdateOne, withCumulativeMetrics(cm))
	return &CumulativeMetricsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CumulativeMetricsClient) UpdateOneID(id int64) *CumulativeMetricsUpdateOne {
	mutation := newCumulativeMetricsMutation(c.config, OpUpdateOne, withCumulativeMetricsID(id))
	return &CumulativeMetricsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CumulativeMetrics.
func (c *CumulativeMetricsClient) Delete() *CumulativeMetricsDelete {
	mutation := newCumulativeMetricsMutation(c.config, OpDelete)
	return &CumulativeMetricsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CumulativeMetricsClient) DeleteOne(cm *CumulativeMetrics) *CumulativeMetricsDeleteOne {
	return c.DeleteOneID(cm.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CumulativeMetricsClient) DeleteOneID(id int64) *CumulativeMetricsDeleteOne {
	builder := c.Delete().Where(cumulativemetrics.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CumulativeMetricsDeleteOne{builder}
}

// Query returns a query builder for CumulativeMetrics.
func (c *CumulativeMetricsClient) Query() *CumulativeMetricsQuery {
	return &CumulativeMetricsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCumulativeMetrics},
		inters: c.Interceptors(),
	}
}

// Get returns a CumulativeMetrics entity by its id.
func (c *CumulativeMetricsClient) Get(ctx context.Context, id int64) (*CumulativeMetrics, error) {
	return c.Query().Where(cumulativemetrics.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CumulativeMetricsClient) GetX(ctx context.Context, id int64) *CumulativeMetrics {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMetrics queries the metrics edge of a CumulativeMetrics.
func (c *CumulativeMetricsClient) QueryMetrics(cm *CumulativeMetrics) *MetricsQuery {
	query := (&MetricsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(cumulativemetrics.Table, cumulativemetrics.FieldID, id),
			sqlgraph.To(metrics.Table, metrics.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, cumulativemetrics.MetricsTable, cumulativemetrics.MetricsColumn),
		)
		fromV = sqlgraph.Neighbors(cm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CumulativeMetricsClient) Hooks() []Hook {
	return c.hooks.CumulativeMetrics
}

// Interceptors returns the client interceptors.
func (c *CumulativeMetricsClient) Interceptors() []Interceptor {
	return c.inters.CumulativeMetrics
}

func (c *CumulativeMetricsClient) mutate(ctx context.Context, m *CumulativeMetricsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CumulativeMetricsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CumulativeMetricsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CumulativeMetricsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CumulativeMetricsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CumulativeMetrics mutation op: %q", m.Op())
	}
}

// EvaluationStatClient is a client for the EvaluationStat schema.
type EvaluationStatClient struct {
	config
}

// NewEvaluationStatClient returns a client for the EvaluationStat from the given config.
func NewEvaluationStatClient(c config) *EvaluationStatClient {
	return &EvaluationStatClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `evaluationstat.Hooks(f(g(h())))`.
func (c *EvaluationStatClient) Use(hooks ...Hook) {
	c.hooks.EvaluationStat = append(c.hooks.EvaluationStat, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `evaluationstat.Intercept(f(g(h())))`.
func (c *EvaluationStatClient) Intercept(interceptors ...Interceptor) {
	c.inters.EvaluationStat = append(c.inters.EvaluationStat, interceptors...)
}

// Create returns a builder for creating a EvaluationStat entity.
func (c *EvaluationStatClient) Create() *EvaluationStatCreate {
	mutation := newEvaluationStatMutation(c.config, OpCreate)
	return &EvaluationStatCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EvaluationStat entities.
func (c *EvaluationStatClient) CreateBulk(builders ...*EvaluationStatCreate) *EvaluationStatCreateBulk {
	return &EvaluationStatCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EvaluationStatClient) MapCreateBulk(slice any, setFunc func(*EvaluationStatCreate, int)) *EvaluationStatCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EvaluationStatCreateBulk{err: fmt.Errorf("calling to EvaluationStatClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EvaluationStatCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EvaluationStatCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EvaluationStat.
func (c *EvaluationStatClient) Update() *EvaluationStatUpdate {
	mutation := newEvaluationStatMutation(c.config, OpUpdate)
	return &EvaluationStatUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EvaluationStatClient) UpdateOne(es *EvaluationStat) *EvaluationStatUpdateOne {
	mutation := newEvaluationStatMutation(c.config, OpUpdateOne, withEvaluationStat(es))
	return &EvaluationStatUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EvaluationStatClient) UpdateOneID(id int64) *EvaluationStatUpdateOne {
	mutation := newEvaluationStatMutation(c.config, OpUpdateOne, withEvaluationStatID(id))
	return &EvaluationStatUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EvaluationStat.
func (c *EvaluationStatClient) Delete() *EvaluationStatDelete {
	mutation := newEvaluationStatMutation(c.config, OpDelete)
	return &EvaluationStatDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EvaluationStatClient) DeleteOne(es *EvaluationStat) *EvaluationStatDeleteOne {
	return c.DeleteOneID(es.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EvaluationStatClient) DeleteOneID(id int64) *EvaluationStatDeleteOne {
	builder := c.Delete().Where(evaluationstat.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EvaluationStatDeleteOne{builder}
}

// Query returns a query builder for EvaluationStat.
func (c *EvaluationStatClient) Query() *EvaluationStatQuery {
	return &EvaluationStatQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEvaluationStat},
		inters: c.Interceptors(),
	}
}

// Get returns a EvaluationStat entity by its id.
func (c *EvaluationStatClient) Get(ctx context.Context, id int64) (*EvaluationStat, error) {
	return c.Query().Where(evaluationstat.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EvaluationStatClient) GetX(ctx context.Context, id int64) *EvaluationStat {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBuildGraphMetrics queries the build_graph_metrics edge of a EvaluationStat.
func (c *EvaluationStatClient) QueryBuildGraphMetrics(es *EvaluationStat) *BuildGraphMetricsQuery {
	query := (&BuildGraphMetricsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := es.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(evaluationstat.Table, evaluationstat.FieldID, id),
			sqlgraph.To(buildgraphmetrics.Table, buildgraphmetrics.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, evaluationstat.BuildGraphMetricsTable, evaluationstat.BuildGraphMetricsColumn),
		)
		fromV = sqlgraph.Neighbors(es.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EvaluationStatClient) Hooks() []Hook {
	return c.hooks.EvaluationStat
}

// Interceptors returns the client interceptors.
func (c *EvaluationStatClient) Interceptors() []Interceptor {
	return c.inters.EvaluationStat
}

func (c *EvaluationStatClient) mutate(ctx context.Context, m *EvaluationStatMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EvaluationStatCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EvaluationStatUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EvaluationStatUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EvaluationStatDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown EvaluationStat mutation op: %q", m.Op())
	}
}

// EventMetadataClient is a client for the EventMetadata schema.
type EventMetadataClient struct {
	config
}

// NewEventMetadataClient returns a client for the EventMetadata from the given config.
func NewEventMetadataClient(c config) *EventMetadataClient {
	return &EventMetadataClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `eventmetadata.Hooks(f(g(h())))`.
func (c *EventMetadataClient) Use(hooks ...Hook) {
	c.hooks.EventMetadata = append(c.hooks.EventMetadata, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `eventmetadata.Intercept(f(g(h())))`.
func (c *EventMetadataClient) Intercept(interceptors ...Interceptor) {
	c.inters.EventMetadata = append(c.inters.EventMetadata, interceptors...)
}

// Create returns a builder for creating a EventMetadata entity.
func (c *EventMetadataClient) Create() *EventMetadataCreate {
	mutation := newEventMetadataMutation(c.config, OpCreate)
	return &EventMetadataCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EventMetadata entities.
func (c *EventMetadataClient) CreateBulk(builders ...*EventMetadataCreate) *EventMetadataCreateBulk {
	return &EventMetadataCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EventMetadataClient) MapCreateBulk(slice any, setFunc func(*EventMetadataCreate, int)) *EventMetadataCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EventMetadataCreateBulk{err: fmt.Errorf("calling to EventMetadataClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EventMetadataCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EventMetadataCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EventMetadata.
func (c *EventMetadataClient) Update() *EventMetadataUpdate {
	mutation := newEventMetadataMutation(c.config, OpUpdate)
	return &EventMetadataUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EventMetadataClient) UpdateOne(em *EventMetadata) *EventMetadataUpdateOne {
	mutation := newEventMetadataMutation(c.config, OpUpdateOne, withEventMetadata(em))
	return &EventMetadataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EventMetadataClient) UpdateOneID(id int64) *EventMetadataUpdateOne {
	mutation := newEventMetadataMutation(c.config, OpUpdateOne, withEventMetadataID(id))
	return &EventMetadataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EventMetadata.
func (c *EventMetadataClient) Delete() *EventMetadataDelete {
	mutation := newEventMetadataMutation(c.config, OpDelete)
	return &EventMetadataDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EventMetadataClient) DeleteOne(em *EventMetadata) *EventMetadataDeleteOne {
	return c.DeleteOneID(em.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EventMetadataClient) DeleteOneID(id int64) *EventMetadataDeleteOne {
	builder := c.Delete().Where(eventmetadata.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EventMetadataDeleteOne{builder}
}

// Query returns a query builder for EventMetadata.
func (c *EventMetadataClient) Query() *EventMetadataQuery {
	return &EventMetadataQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEventMetadata},
		inters: c.Interceptors(),
	}
}

// Get returns a EventMetadata entity by its id.
func (c *EventMetadataClient) Get(ctx context.Context, id int64) (*EventMetadata, error) {
	return c.Query().Where(eventmetadata.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EventMetadataClient) GetX(ctx context.Context, id int64) *EventMetadata {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBazelInvocation queries the bazel_invocation edge of a EventMetadata.
func (c *EventMetadataClient) QueryBazelInvocation(em *EventMetadata) *BazelInvocationQuery {
	query := (&BazelInvocationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := em.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(eventmetadata.Table, eventmetadata.FieldID, id),
			sqlgraph.To(bazelinvocation.Table, bazelinvocation.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, eventmetadata.BazelInvocationTable, eventmetadata.BazelInvocationColumn),
		)
		fromV = sqlgraph.Neighbors(em.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EventMetadataClient) Hooks() []Hook {
	return c.hooks.EventMetadata
}

// Interceptors returns the client interceptors.
func (c *EventMetadataClient) Interceptors() []Interceptor {
	return c.inters.EventMetadata
}

func (c *EventMetadataClient) mutate(ctx context.Context, m *EventMetadataMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EventMetadataCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EventMetadataUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EventMetadataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EventMetadataDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown EventMetadata mutation op: %q", m.Op())
	}
}

// GarbageMetricsClient is a client for the GarbageMetrics schema.
type GarbageMetricsClient struct {
	config
}

// NewGarbageMetricsClient returns a client for the GarbageMetrics from the given config.
func NewGarbageMetricsClient(c config) *GarbageMetricsClient {
	return &GarbageMetricsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `garbagemetrics.Hooks(f(g(h())))`.
func (c *GarbageMetricsClient) Use(hooks ...Hook) {
	c.hooks.GarbageMetrics = append(c.hooks.GarbageMetrics, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `garbagemetrics.Intercept(f(g(h())))`.
func (c *GarbageMetricsClient) Intercept(interceptors ...Interceptor) {
	c.inters.GarbageMetrics = append(c.inters.GarbageMetrics, interceptors...)
}

// Create returns a builder for creating a GarbageMetrics entity.
func (c *GarbageMetricsClient) Create() *GarbageMetricsCreate {
	mutation := newGarbageMetricsMutation(c.config, OpCreate)
	return &GarbageMetricsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of GarbageMetrics entities.
func (c *GarbageMetricsClient) CreateBulk(builders ...*GarbageMetricsCreate) *GarbageMetricsCreateBulk {
	return &GarbageMetricsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *GarbageMetricsClient) MapCreateBulk(slice any, setFunc func(*GarbageMetricsCreate, int)) *GarbageMetricsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &GarbageMetricsCreateBulk{err: fmt.Errorf("calling to GarbageMetricsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*GarbageMetricsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &GarbageMetricsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for GarbageMetrics.
func (c *GarbageMetricsClient) Update() *GarbageMetricsUpdate {
	mutation := newGarbageMetricsMutation(c.config, OpUpdate)
	return &GarbageMetricsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GarbageMetricsClient) UpdateOne(gm *GarbageMetrics) *GarbageMetricsUpdateOne {
	mutation := newGarbageMetricsMutation(c.config, OpUpdateOne, withGarbageMetrics(gm))
	return &GarbageMetricsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GarbageMetricsClient) UpdateOneID(id int64) *GarbageMetricsUpdateOne {
	mutation := newGarbageMetricsMutation(c.config, OpUpdateOne, withGarbageMetricsID(id))
	return &GarbageMetricsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GarbageMetrics.
func (c *GarbageMetricsClient) Delete() *GarbageMetricsDelete {
	mutation := newGarbageMetricsMutation(c.config, OpDelete)
	return &GarbageMetricsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GarbageMetricsClient) DeleteOne(gm *GarbageMetrics) *GarbageMetricsDeleteOne {
	return c.DeleteOneID(gm.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GarbageMetricsClient) DeleteOneID(id int64) *GarbageMetricsDeleteOne {
	builder := c.Delete().Where(garbagemetrics.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GarbageMetricsDeleteOne{builder}
}

// Query returns a query builder for GarbageMetrics.
func (c *GarbageMetricsClient) Query() *GarbageMetricsQuery {
	return &GarbageMetricsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeGarbageMetrics},
		inters: c.Interceptors(),
	}
}

// Get returns a GarbageMetrics entity by its id.
func (c *GarbageMetricsClient) Get(ctx context.Context, id int64) (*GarbageMetrics, error) {
	return c.Query().Where(garbagemetrics.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GarbageMetricsClient) GetX(ctx context.Context, id int64) *GarbageMetrics {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMemoryMetrics queries the memory_metrics edge of a GarbageMetrics.
func (c *GarbageMetricsClient) QueryMemoryMetrics(gm *GarbageMetrics) *MemoryMetricsQuery {
	query := (&MemoryMetricsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(garbagemetrics.Table, garbagemetrics.FieldID, id),
			sqlgraph.To(memorymetrics.Table, memorymetrics.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, garbagemetrics.MemoryMetricsTable, garbagemetrics.MemoryMetricsColumn),
		)
		fromV = sqlgraph.Neighbors(gm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *GarbageMetricsClient) Hooks() []Hook {
	return c.hooks.GarbageMetrics
}

// Interceptors returns the client interceptors.
func (c *GarbageMetricsClient) Interceptors() []Interceptor {
	return c.inters.GarbageMetrics
}

func (c *GarbageMetricsClient) mutate(ctx context.Context, m *GarbageMetricsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GarbageMetricsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GarbageMetricsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GarbageMetricsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GarbageMetricsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown GarbageMetrics mutation op: %q", m.Op())
	}
}

// IncompleteBuildLogClient is a client for the IncompleteBuildLog schema.
type IncompleteBuildLogClient struct {
	config
}

// NewIncompleteBuildLogClient returns a client for the IncompleteBuildLog from the given config.
func NewIncompleteBuildLogClient(c config) *IncompleteBuildLogClient {
	return &IncompleteBuildLogClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `incompletebuildlog.Hooks(f(g(h())))`.
func (c *IncompleteBuildLogClient) Use(hooks ...Hook) {
	c.hooks.IncompleteBuildLog = append(c.hooks.IncompleteBuildLog, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `incompletebuildlog.Intercept(f(g(h())))`.
func (c *IncompleteBuildLogClient) Intercept(interceptors ...Interceptor) {
	c.inters.IncompleteBuildLog = append(c.inters.IncompleteBuildLog, interceptors...)
}

// Create returns a builder for creating a IncompleteBuildLog entity.
func (c *IncompleteBuildLogClient) Create() *IncompleteBuildLogCreate {
	mutation := newIncompleteBuildLogMutation(c.config, OpCreate)
	return &IncompleteBuildLogCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IncompleteBuildLog entities.
func (c *IncompleteBuildLogClient) CreateBulk(builders ...*IncompleteBuildLogCreate) *IncompleteBuildLogCreateBulk {
	return &IncompleteBuildLogCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IncompleteBuildLogClient) MapCreateBulk(slice any, setFunc func(*IncompleteBuildLogCreate, int)) *IncompleteBuildLogCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IncompleteBuildLogCreateBulk{err: fmt.Errorf("calling to IncompleteBuildLogClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IncompleteBuildLogCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IncompleteBuildLogCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IncompleteBuildLog.
func (c *IncompleteBuildLogClient) Update() *IncompleteBuildLogUpdate {
	mutation := newIncompleteBuildLogMutation(c.config, OpUpdate)
	return &IncompleteBuildLogUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IncompleteBuildLogClient) UpdateOne(ibl *IncompleteBuildLog) *IncompleteBuildLogUpdateOne {
	mutation := newIncompleteBuildLogMutation(c.config, OpUpdateOne, withIncompleteBuildLog(ibl))
	return &IncompleteBuildLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IncompleteBuildLogClient) UpdateOneID(id int64) *IncompleteBuildLogUpdateOne {
	mutation := newIncompleteBuildLogMutation(c.config, OpUpdateOne, withIncompleteBuildLogID(id))
	return &IncompleteBuildLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IncompleteBuildLog.
func (c *IncompleteBuildLogClient) Delete() *IncompleteBuildLogDelete {
	mutation := newIncompleteBuildLogMutation(c.config, OpDelete)
	return &IncompleteBuildLogDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IncompleteBuildLogClient) DeleteOne(ibl *IncompleteBuildLog) *IncompleteBuildLogDeleteOne {
	return c.DeleteOneID(ibl.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IncompleteBuildLogClient) DeleteOneID(id int64) *IncompleteBuildLogDeleteOne {
	builder := c.Delete().Where(incompletebuildlog.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IncompleteBuildLogDeleteOne{builder}
}

// Query returns a query builder for IncompleteBuildLog.
func (c *IncompleteBuildLogClient) Query() *IncompleteBuildLogQuery {
	return &IncompleteBuildLogQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIncompleteBuildLog},
		inters: c.Interceptors(),
	}
}

// Get returns a IncompleteBuildLog entity by its id.
func (c *IncompleteBuildLogClient) Get(ctx context.Context, id int64) (*IncompleteBuildLog, error) {
	return c.Query().Where(incompletebuildlog.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IncompleteBuildLogClient) GetX(ctx context.Context, id int64) *IncompleteBuildLog {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBazelInvocation queries the bazel_invocation edge of a IncompleteBuildLog.
func (c *IncompleteBuildLogClient) QueryBazelInvocation(ibl *IncompleteBuildLog) *BazelInvocationQuery {
	query := (&BazelInvocationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ibl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incompletebuildlog.Table, incompletebuildlog.FieldID, id),
			sqlgraph.To(bazelinvocation.Table, bazelinvocation.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, incompletebuildlog.BazelInvocationTable, incompletebuildlog.BazelInvocationColumn),
		)
		fromV = sqlgraph.Neighbors(ibl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IncompleteBuildLogClient) Hooks() []Hook {
	return c.hooks.IncompleteBuildLog
}

// Interceptors returns the client interceptors.
func (c *IncompleteBuildLogClient) Interceptors() []Interceptor {
	return c.inters.IncompleteBuildLog
}

func (c *IncompleteBuildLogClient) mutate(ctx context.Context, m *IncompleteBuildLogMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IncompleteBuildLogCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IncompleteBuildLogUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IncompleteBuildLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IncompleteBuildLogDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown IncompleteBuildLog mutation op: %q", m.Op())
	}
}

// InstanceNameClient is a client for the InstanceName schema.
type InstanceNameClient struct {
	config
}

// NewInstanceNameClient returns a client for the InstanceName from the given config.
func NewInstanceNameClient(c config) *InstanceNameClient {
	return &InstanceNameClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `instancename.Hooks(f(g(h())))`.
func (c *InstanceNameClient) Use(hooks ...Hook) {
	c.hooks.InstanceName = append(c.hooks.InstanceName, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `instancename.Intercept(f(g(h())))`.
func (c *InstanceNameClient) Intercept(interceptors ...Interceptor) {
	c.inters.InstanceName = append(c.inters.InstanceName, interceptors...)
}

// Create returns a builder for creating a InstanceName entity.
func (c *InstanceNameClient) Create() *InstanceNameCreate {
	mutation := newInstanceNameMutation(c.config, OpCreate)
	return &InstanceNameCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of InstanceName entities.
func (c *InstanceNameClient) CreateBulk(builders ...*InstanceNameCreate) *InstanceNameCreateBulk {
	return &InstanceNameCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *InstanceNameClient) MapCreateBulk(slice any, setFunc func(*InstanceNameCreate, int)) *InstanceNameCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &InstanceNameCreateBulk{err: fmt.Errorf("calling to InstanceNameClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*InstanceNameCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &InstanceNameCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for InstanceName.
func (c *InstanceNameClient) Update() *InstanceNameUpdate {
	mutation := newInstanceNameMutation(c.config, OpUpdate)
	return &InstanceNameUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *InstanceNameClient) UpdateOne(in *InstanceName) *InstanceNameUpdateOne {
	mutation := newInstanceNameMutation(c.config, OpUpdateOne, withInstanceName(in))
	return &InstanceNameUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *InstanceNameClient) UpdateOneID(id int64) *InstanceNameUpdateOne {
	mutation := newInstanceNameMutation(c.config, OpUpdateOne, withInstanceNameID(id))
	return &InstanceNameUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for InstanceName.
func (c *InstanceNameClient) Delete() *InstanceNameDelete {
	mutation := newInstanceNameMutation(c.config, OpDelete)
	return &InstanceNameDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *InstanceNameClient) DeleteOne(in *InstanceName) *InstanceNameDeleteOne {
	return c.DeleteOneID(in.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *InstanceNameClient) DeleteOneID(id int64) *InstanceNameDeleteOne {
	builder := c.Delete().Where(instancename.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &InstanceNameDeleteOne{builder}
}

// Query returns a query builder for InstanceName.
func (c *InstanceNameClient) Query() *InstanceNameQuery {
	return &InstanceNameQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeInstanceName},
		inters: c.Interceptors(),
	}
}

// Get returns a InstanceName entity by its id.
func (c *InstanceNameClient) Get(ctx context.Context, id int64) (*InstanceName, error) {
	return c.Query().Where(instancename.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *InstanceNameClient) GetX(ctx context.Context, id int64) *InstanceName {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBazelInvocations queries the bazel_invocations edge of a InstanceName.
func (c *InstanceNameClient) QueryBazelInvocations(in *InstanceName) *BazelInvocationQuery {
	query := (&BazelInvocationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := in.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(instancename.Table, instancename.FieldID, id),
			sqlgraph.To(bazelinvocation.Table, bazelinvocation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, instancename.BazelInvocationsTable, instancename.BazelInvocationsColumn),
		)
		fromV = sqlgraph.Neighbors(in.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBuilds queries the builds edge of a InstanceName.
func (c *InstanceNameClient) QueryBuilds(in *InstanceName) *BuildQuery {
	query := (&BuildClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := in.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(instancename.Table, instancename.FieldID, id),
			sqlgraph.To(build.Table, build.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, instancename.BuildsTable, instancename.BuildsColumn),
		)
		fromV = sqlgraph.Neighbors(in.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBlobs queries the blobs edge of a InstanceName.
func (c *InstanceNameClient) QueryBlobs(in *InstanceName) *BlobQuery {
	query := (&BlobClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := in.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(instancename.Table, instancename.FieldID, id),
			sqlgraph.To(blob.Table, blob.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, instancename.BlobsTable, instancename.BlobsColumn),
		)
		fromV = sqlgraph.Neighbors(in.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTargets queries the targets edge of a InstanceName.
func (c *InstanceNameClient) QueryTargets(in *InstanceName) *TargetQuery {
	query := (&TargetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := in.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(instancename.Table, instancename.FieldID, id),
			sqlgraph.To(target.Table, target.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, instancename.TargetsTable, instancename.TargetsColumn),
		)
		fromV = sqlgraph.Neighbors(in.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *InstanceNameClient) Hooks() []Hook {
	return c.hooks.InstanceName
}

// Interceptors returns the client interceptors.
func (c *InstanceNameClient) Interceptors() []Interceptor {
	return c.inters.InstanceName
}

func (c *InstanceNameClient) mutate(ctx context.Context, m *InstanceNameMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&InstanceNameCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&InstanceNameUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&InstanceNameUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&InstanceNameDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown InstanceName mutation op: %q", m.Op())
	}
}

// InvocationFilesClient is a client for the InvocationFiles schema.
type InvocationFilesClient struct {
	config
}

// NewInvocationFilesClient returns a client for the InvocationFiles from the given config.
func NewInvocationFilesClient(c config) *InvocationFilesClient {
	return &InvocationFilesClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `invocationfiles.Hooks(f(g(h())))`.
func (c *InvocationFilesClient) Use(hooks ...Hook) {
	c.hooks.InvocationFiles = append(c.hooks.InvocationFiles, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `invocationfiles.Intercept(f(g(h())))`.
func (c *InvocationFilesClient) Intercept(interceptors ...Interceptor) {
	c.inters.InvocationFiles = append(c.inters.InvocationFiles, interceptors...)
}

// Create returns a builder for creating a InvocationFiles entity.
func (c *InvocationFilesClient) Create() *InvocationFilesCreate {
	mutation := newInvocationFilesMutation(c.config, OpCreate)
	return &InvocationFilesCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of InvocationFiles entities.
func (c *InvocationFilesClient) CreateBulk(builders ...*InvocationFilesCreate) *InvocationFilesCreateBulk {
	return &InvocationFilesCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *InvocationFilesClient) MapCreateBulk(slice any, setFunc func(*InvocationFilesCreate, int)) *InvocationFilesCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &InvocationFilesCreateBulk{err: fmt.Errorf("calling to InvocationFilesClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*InvocationFilesCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &InvocationFilesCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for InvocationFiles.
func (c *InvocationFilesClient) Update() *InvocationFilesUpdate {
	mutation := newInvocationFilesMutation(c.config, OpUpdate)
	return &InvocationFilesUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *InvocationFilesClient) UpdateOne(_if *InvocationFiles) *InvocationFilesUpdateOne {
	mutation := newInvocationFilesMutation(c.config, OpUpdateOne, withInvocationFiles(_if))
	return &InvocationFilesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *InvocationFilesClient) UpdateOneID(id int64) *InvocationFilesUpdateOne {
	mutation := newInvocationFilesMutation(c.config, OpUpdateOne, withInvocationFilesID(id))
	return &InvocationFilesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for InvocationFiles.
func (c *InvocationFilesClient) Delete() *InvocationFilesDelete {
	mutation := newInvocationFilesMutation(c.config, OpDelete)
	return &InvocationFilesDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *InvocationFilesClient) DeleteOne(_if *InvocationFiles) *InvocationFilesDeleteOne {
	return c.DeleteOneID(_if.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *InvocationFilesClient) DeleteOneID(id int64) *InvocationFilesDeleteOne {
	builder := c.Delete().Where(invocationfiles.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &InvocationFilesDeleteOne{builder}
}

// Query returns a query builder for InvocationFiles.
func (c *InvocationFilesClient) Query() *InvocationFilesQuery {
	return &InvocationFilesQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeInvocationFiles},
		inters: c.Interceptors(),
	}
}

// Get returns a InvocationFiles entity by its id.
func (c *InvocationFilesClient) Get(ctx context.Context, id int64) (*InvocationFiles, error) {
	return c.Query().Where(invocationfiles.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *InvocationFilesClient) GetX(ctx context.Context, id int64) *InvocationFiles {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBazelInvocation queries the bazel_invocation edge of a InvocationFiles.
func (c *InvocationFilesClient) QueryBazelInvocation(_if *InvocationFiles) *BazelInvocationQuery {
	query := (&BazelInvocationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _if.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(invocationfiles.Table, invocationfiles.FieldID, id),
			sqlgraph.To(bazelinvocation.Table, bazelinvocation.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, invocationfiles.BazelInvocationTable, invocationfiles.BazelInvocationColumn),
		)
		fromV = sqlgraph.Neighbors(_if.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *InvocationFilesClient) Hooks() []Hook {
	return c.hooks.InvocationFiles
}

// Interceptors returns the client interceptors.
func (c *InvocationFilesClient) Interceptors() []Interceptor {
	return c.inters.InvocationFiles
}

func (c *InvocationFilesClient) mutate(ctx context.Context, m *InvocationFilesMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&InvocationFilesCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&InvocationFilesUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&InvocationFilesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&InvocationFilesDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown InvocationFiles mutation op: %q", m.Op())
	}
}

// InvocationTargetClient is a client for the InvocationTarget schema.
type InvocationTargetClient struct {
	config
}

// NewInvocationTargetClient returns a client for the InvocationTarget from the given config.
func NewInvocationTargetClient(c config) *InvocationTargetClient {
	return &InvocationTargetClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `invocationtarget.Hooks(f(g(h())))`.
func (c *InvocationTargetClient) Use(hooks ...Hook) {
	c.hooks.InvocationTarget = append(c.hooks.InvocationTarget, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `invocationtarget.Intercept(f(g(h())))`.
func (c *InvocationTargetClient) Intercept(interceptors ...Interceptor) {
	c.inters.InvocationTarget = append(c.inters.InvocationTarget, interceptors...)
}

// Create returns a builder for creating a InvocationTarget entity.
func (c *InvocationTargetClient) Create() *InvocationTargetCreate {
	mutation := newInvocationTargetMutation(c.config, OpCreate)
	return &InvocationTargetCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of InvocationTarget entities.
func (c *InvocationTargetClient) CreateBulk(builders ...*InvocationTargetCreate) *InvocationTargetCreateBulk {
	return &InvocationTargetCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *InvocationTargetClient) MapCreateBulk(slice any, setFunc func(*InvocationTargetCreate, int)) *InvocationTargetCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &InvocationTargetCreateBulk{err: fmt.Errorf("calling to InvocationTargetClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*InvocationTargetCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &InvocationTargetCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for InvocationTarget.
func (c *InvocationTargetClient) Update() *InvocationTargetUpdate {
	mutation := newInvocationTargetMutation(c.config, OpUpdate)
	return &InvocationTargetUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *InvocationTargetClient) UpdateOne(it *InvocationTarget) *InvocationTargetUpdateOne {
	mutation := newInvocationTargetMutation(c.config, OpUpdateOne, withInvocationTarget(it))
	return &InvocationTargetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *InvocationTargetClient) UpdateOneID(id int64) *InvocationTargetUpdateOne {
	mutation := newInvocationTargetMutation(c.config, OpUpdateOne, withInvocationTargetID(id))
	return &InvocationTargetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for InvocationTarget.
func (c *InvocationTargetClient) Delete() *InvocationTargetDelete {
	mutation := newInvocationTargetMutation(c.config, OpDelete)
	return &InvocationTargetDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *InvocationTargetClient) DeleteOne(it *InvocationTarget) *InvocationTargetDeleteOne {
	return c.DeleteOneID(it.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *InvocationTargetClient) DeleteOneID(id int64) *InvocationTargetDeleteOne {
	builder := c.Delete().Where(invocationtarget.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &InvocationTargetDeleteOne{builder}
}

// Query returns a query builder for InvocationTarget.
func (c *InvocationTargetClient) Query() *InvocationTargetQuery {
	return &InvocationTargetQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeInvocationTarget},
		inters: c.Interceptors(),
	}
}

// Get returns a InvocationTarget entity by its id.
func (c *InvocationTargetClient) Get(ctx context.Context, id int64) (*InvocationTarget, error) {
	return c.Query().Where(invocationtarget.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *InvocationTargetClient) GetX(ctx context.Context, id int64) *InvocationTarget {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBazelInvocation queries the bazel_invocation edge of a InvocationTarget.
func (c *InvocationTargetClient) QueryBazelInvocation(it *InvocationTarget) *BazelInvocationQuery {
	query := (&BazelInvocationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := it.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(invocationtarget.Table, invocationtarget.FieldID, id),
			sqlgraph.To(bazelinvocation.Table, bazelinvocation.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, invocationtarget.BazelInvocationTable, invocationtarget.BazelInvocationColumn),
		)
		fromV = sqlgraph.Neighbors(it.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTarget queries the target edge of a InvocationTarget.
func (c *InvocationTargetClient) QueryTarget(it *InvocationTarget) *TargetQuery {
	query := (&TargetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := it.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(invocationtarget.Table, invocationtarget.FieldID, id),
			sqlgraph.To(target.Table, target.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, invocationtarget.TargetTable, invocationtarget.TargetColumn),
		)
		fromV = sqlgraph.Neighbors(it.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryConfiguration queries the configuration edge of a InvocationTarget.
func (c *InvocationTargetClient) QueryConfiguration(it *InvocationTarget) *ConfigurationQuery {
	query := (&ConfigurationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := it.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(invocationtarget.Table, invocationtarget.FieldID, id),
			sqlgraph.To(configuration.Table, configuration.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, invocationtarget.ConfigurationTable, invocationtarget.ConfigurationColumn),
		)
		fromV = sqlgraph.Neighbors(it.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTestSummary queries the test_summary edge of a InvocationTarget.
func (c *InvocationTargetClient) QueryTestSummary(it *InvocationTarget) *TestSummaryQuery {
	query := (&TestSummaryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := it.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(invocationtarget.Table, invocationtarget.FieldID, id),
			sqlgraph.To(testsummary.Table, testsummary.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, invocationtarget.TestSummaryTable, invocationtarget.TestSummaryColumn),
		)
		fromV = sqlgraph.Neighbors(it.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *InvocationTargetClient) Hooks() []Hook {
	return c.hooks.InvocationTarget
}

// Interceptors returns the client interceptors.
func (c *InvocationTargetClient) Interceptors() []Interceptor {
	return c.inters.InvocationTarget
}

func (c *InvocationTargetClient) mutate(ctx context.Context, m *InvocationTargetMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&InvocationTargetCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&InvocationTargetUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&InvocationTargetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&InvocationTargetDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown InvocationTarget mutation op: %q", m.Op())
	}
}

// MemoryMetricsClient is a client for the MemoryMetrics schema.
type MemoryMetricsClient struct {
	config
}

// NewMemoryMetricsClient returns a client for the MemoryMetrics from the given config.
func NewMemoryMetricsClient(c config) *MemoryMetricsClient {
	return &MemoryMetricsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `memorymetrics.Hooks(f(g(h())))`.
func (c *MemoryMetricsClient) Use(hooks ...Hook) {
	c.hooks.MemoryMetrics = append(c.hooks.MemoryMetrics, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `memorymetrics.Intercept(f(g(h())))`.
func (c *MemoryMetricsClient) Intercept(interceptors ...Interceptor) {
	c.inters.MemoryMetrics = append(c.inters.MemoryMetrics, interceptors...)
}

// Create returns a builder for creating a MemoryMetrics entity.
func (c *MemoryMetricsClient) Create() *MemoryMetricsCreate {
	mutation := newMemoryMetricsMutation(c.config, OpCreate)
	return &MemoryMetricsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MemoryMetrics entities.
func (c *MemoryMetricsClient) CreateBulk(builders ...*MemoryMetricsCreate) *MemoryMetricsCreateBulk {
	return &MemoryMetricsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MemoryMetricsClient) MapCreateBulk(slice any, setFunc func(*MemoryMetricsCreate, int)) *MemoryMetricsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MemoryMetricsCreateBulk{err: fmt.Errorf("calling to MemoryMetricsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MemoryMetricsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MemoryMetricsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MemoryMetrics.
func (c *MemoryMetricsClient) Update() *MemoryMetricsUpdate {
	mutation := newMemoryMetricsMutation(c.config, OpUpdate)
	return &MemoryMetricsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MemoryMetricsClient) UpdateOne(mm *MemoryMetrics) *MemoryMetricsUpdateOne {
	mutation := newMemoryMetricsMutation(c.config, OpUpdateOne, withMemoryMetrics(mm))
	return &MemoryMetricsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MemoryMetricsClient) UpdateOneID(id int64) *MemoryMetricsUpdateOne {
	mutation := newMemoryMetricsMutation(c.config, OpUpdateOne, withMemoryMetricsID(id))
	return &MemoryMetricsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MemoryMetrics.
func (c *MemoryMetricsClient) Delete() *MemoryMetricsDelete {
	mutation := newMemoryMetricsMutation(c.config, OpDelete)
	return &MemoryMetricsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MemoryMetricsClient) DeleteOne(mm *MemoryMetrics) *MemoryMetricsDeleteOne {
	return c.DeleteOneID(mm.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MemoryMetricsClient) DeleteOneID(id int64) *MemoryMetricsDeleteOne {
	builder := c.Delete().Where(memorymetrics.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MemoryMetricsDeleteOne{builder}
}

// Query returns a query builder for MemoryMetrics.
func (c *MemoryMetricsClient) Query() *MemoryMetricsQuery {
	return &MemoryMetricsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMemoryMetrics},
		inters: c.Interceptors(),
	}
}

// Get returns a MemoryMetrics entity by its id.
func (c *MemoryMetricsClient) Get(ctx context.Context, id int64) (*MemoryMetrics, error) {
	return c.Query().Where(memorymetrics.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MemoryMetricsClient) GetX(ctx context.Context, id int64) *MemoryMetrics {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMetrics queries the metrics edge of a MemoryMetrics.
func (c *MemoryMetricsClient) QueryMetrics(mm *MemoryMetrics) *MetricsQuery {
	query := (&MetricsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(memorymetrics.Table, memorymetrics.FieldID, id),
			sqlgraph.To(metrics.Table, metrics.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, memorymetrics.MetricsTable, memorymetrics.MetricsColumn),
		)
		fromV = sqlgraph.Neighbors(mm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGarbageMetrics queries the garbage_metrics edge of a MemoryMetrics.
func (c *MemoryMetricsClient) QueryGarbageMetrics(mm *MemoryMetrics) *GarbageMetricsQuery {
	query := (&GarbageMetricsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(memorymetrics.Table, memorymetrics.FieldID, id),
			sqlgraph.To(garbagemetrics.Table, garbagemetrics.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, memorymetrics.GarbageMetricsTable, memorymetrics.GarbageMetricsColumn),
		)
		fromV = sqlgraph.Neighbors(mm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MemoryMetricsClient) Hooks() []Hook {
	return c.hooks.MemoryMetrics
}

// Interceptors returns the client interceptors.
func (c *MemoryMetricsClient) Interceptors() []Interceptor {
	return c.inters.MemoryMetrics
}

func (c *MemoryMetricsClient) mutate(ctx context.Context, m *MemoryMetricsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MemoryMetricsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MemoryMetricsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MemoryMetricsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MemoryMetricsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MemoryMetrics mutation op: %q", m.Op())
	}
}

// MetricsClient is a client for the Metrics schema.
type MetricsClient struct {
	config
}

// NewMetricsClient returns a client for the Metrics from the given config.
func NewMetricsClient(c config) *MetricsClient {
	return &MetricsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `metrics.Hooks(f(g(h())))`.
func (c *MetricsClient) Use(hooks ...Hook) {
	c.hooks.Metrics = append(c.hooks.Metrics, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `metrics.Intercept(f(g(h())))`.
func (c *MetricsClient) Intercept(interceptors ...Interceptor) {
	c.inters.Metrics = append(c.inters.Metrics, interceptors...)
}

// Create returns a builder for creating a Metrics entity.
func (c *MetricsClient) Create() *MetricsCreate {
	mutation := newMetricsMutation(c.config, OpCreate)
	return &MetricsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Metrics entities.
func (c *MetricsClient) CreateBulk(builders ...*MetricsCreate) *MetricsCreateBulk {
	return &MetricsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MetricsClient) MapCreateBulk(slice any, setFunc func(*MetricsCreate, int)) *MetricsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MetricsCreateBulk{err: fmt.Errorf("calling to MetricsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MetricsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MetricsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Metrics.
func (c *MetricsClient) Update() *MetricsUpdate {
	mutation := newMetricsMutation(c.config, OpUpdate)
	return &MetricsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MetricsClient) UpdateOne(m *Metrics) *MetricsUpdateOne {
	mutation := newMetricsMutation(c.config, OpUpdateOne, withMetrics(m))
	return &MetricsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MetricsClient) UpdateOneID(id int64) *MetricsUpdateOne {
	mutation := newMetricsMutation(c.config, OpUpdateOne, withMetricsID(id))
	return &MetricsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Metrics.
func (c *MetricsClient) Delete() *MetricsDelete {
	mutation := newMetricsMutation(c.config, OpDelete)
	return &MetricsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MetricsClient) DeleteOne(m *Metrics) *MetricsDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MetricsClient) DeleteOneID(id int64) *MetricsDeleteOne {
	builder := c.Delete().Where(metrics.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MetricsDeleteOne{builder}
}

// Query returns a query builder for Metrics.
func (c *MetricsClient) Query() *MetricsQuery {
	return &MetricsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMetrics},
		inters: c.Interceptors(),
	}
}

// Get returns a Metrics entity by its id.
func (c *MetricsClient) Get(ctx context.Context, id int64) (*Metrics, error) {
	return c.Query().Where(metrics.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MetricsClient) GetX(ctx context.Context, id int64) *Metrics {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBazelInvocation queries the bazel_invocation edge of a Metrics.
func (c *MetricsClient) QueryBazelInvocation(m *Metrics) *BazelInvocationQuery {
	query := (&BazelInvocationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(metrics.Table, metrics.FieldID, id),
			sqlgraph.To(bazelinvocation.Table, bazelinvocation.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, metrics.BazelInvocationTable, metrics.BazelInvocationColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryActionSummary queries the action_summary edge of a Metrics.
func (c *MetricsClient) QueryActionSummary(m *Metrics) *ActionSummaryQuery {
	query := (&ActionSummaryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(metrics.Table, metrics.FieldID, id),
			sqlgraph.To(actionsummary.Table, actionsummary.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, metrics.ActionSummaryTable, metrics.ActionSummaryColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMemoryMetrics queries the memory_metrics edge of a Metrics.
func (c *MetricsClient) QueryMemoryMetrics(m *Metrics) *MemoryMetricsQuery {
	query := (&MemoryMetricsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(metrics.Table, metrics.FieldID, id),
			sqlgraph.To(memorymetrics.Table, memorymetrics.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, metrics.MemoryMetricsTable, metrics.MemoryMetricsColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTargetMetrics queries the target_metrics edge of a Metrics.
func (c *MetricsClient) QueryTargetMetrics(m *Metrics) *TargetMetricsQuery {
	query := (&TargetMetricsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(metrics.Table, metrics.FieldID, id),
			sqlgraph.To(targetmetrics.Table, targetmetrics.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, metrics.TargetMetricsTable, metrics.TargetMetricsColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPackageMetrics queries the package_metrics edge of a Metrics.
func (c *MetricsClient) QueryPackageMetrics(m *Metrics) *PackageMetricsQuery {
	query := (&PackageMetricsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(metrics.Table, metrics.FieldID, id),
			sqlgraph.To(packagemetrics.Table, packagemetrics.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, metrics.PackageMetricsTable, metrics.PackageMetricsColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTimingMetrics queries the timing_metrics edge of a Metrics.
func (c *MetricsClient) QueryTimingMetrics(m *Metrics) *TimingMetricsQuery {
	query := (&TimingMetricsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(metrics.Table, metrics.FieldID, id),
			sqlgraph.To(timingmetrics.Table, timingmetrics.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, metrics.TimingMetricsTable, metrics.TimingMetricsColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCumulativeMetrics queries the cumulative_metrics edge of a Metrics.
func (c *MetricsClient) QueryCumulativeMetrics(m *Metrics) *CumulativeMetricsQuery {
	query := (&CumulativeMetricsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(metrics.Table, metrics.FieldID, id),
			sqlgraph.To(cumulativemetrics.Table, cumulativemetrics.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, metrics.CumulativeMetricsTable, metrics.CumulativeMetricsColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryArtifactMetrics queries the artifact_metrics edge of a Metrics.
func (c *MetricsClient) QueryArtifactMetrics(m *Metrics) *ArtifactMetricsQuery {
	query := (&ArtifactMetricsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(metrics.Table, metrics.FieldID, id),
			sqlgraph.To(artifactmetrics.Table, artifactmetrics.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, metrics.ArtifactMetricsTable, metrics.ArtifactMetricsColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNetworkMetrics queries the network_metrics edge of a Metrics.
func (c *MetricsClient) QueryNetworkMetrics(m *Metrics) *NetworkMetricsQuery {
	query := (&NetworkMetricsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(metrics.Table, metrics.FieldID, id),
			sqlgraph.To(networkmetrics.Table, networkmetrics.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, metrics.NetworkMetricsTable, metrics.NetworkMetricsColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBuildGraphMetrics queries the build_graph_metrics edge of a Metrics.
func (c *MetricsClient) QueryBuildGraphMetrics(m *Metrics) *BuildGraphMetricsQuery {
	query := (&BuildGraphMetricsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(metrics.Table, metrics.FieldID, id),
			sqlgraph.To(buildgraphmetrics.Table, buildgraphmetrics.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, metrics.BuildGraphMetricsTable, metrics.BuildGraphMetricsColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MetricsClient) Hooks() []Hook {
	return c.hooks.Metrics
}

// Interceptors returns the client interceptors.
func (c *MetricsClient) Interceptors() []Interceptor {
	return c.inters.Metrics
}

func (c *MetricsClient) mutate(ctx context.Context, m *MetricsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MetricsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MetricsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MetricsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MetricsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Metrics mutation op: %q", m.Op())
	}
}

// MissDetailClient is a client for the MissDetail schema.
type MissDetailClient struct {
	config
}

// NewMissDetailClient returns a client for the MissDetail from the given config.
func NewMissDetailClient(c config) *MissDetailClient {
	return &MissDetailClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `missdetail.Hooks(f(g(h())))`.
func (c *MissDetailClient) Use(hooks ...Hook) {
	c.hooks.MissDetail = append(c.hooks.MissDetail, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `missdetail.Intercept(f(g(h())))`.
func (c *MissDetailClient) Intercept(interceptors ...Interceptor) {
	c.inters.MissDetail = append(c.inters.MissDetail, interceptors...)
}

// Create returns a builder for creating a MissDetail entity.
func (c *MissDetailClient) Create() *MissDetailCreate {
	mutation := newMissDetailMutation(c.config, OpCreate)
	return &MissDetailCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MissDetail entities.
func (c *MissDetailClient) CreateBulk(builders ...*MissDetailCreate) *MissDetailCreateBulk {
	return &MissDetailCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MissDetailClient) MapCreateBulk(slice any, setFunc func(*MissDetailCreate, int)) *MissDetailCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MissDetailCreateBulk{err: fmt.Errorf("calling to MissDetailClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MissDetailCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MissDetailCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MissDetail.
func (c *MissDetailClient) Update() *MissDetailUpdate {
	mutation := newMissDetailMutation(c.config, OpUpdate)
	return &MissDetailUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MissDetailClient) UpdateOne(md *MissDetail) *MissDetailUpdateOne {
	mutation := newMissDetailMutation(c.config, OpUpdateOne, withMissDetail(md))
	return &MissDetailUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MissDetailClient) UpdateOneID(id int64) *MissDetailUpdateOne {
	mutation := newMissDetailMutation(c.config, OpUpdateOne, withMissDetailID(id))
	return &MissDetailUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MissDetail.
func (c *MissDetailClient) Delete() *MissDetailDelete {
	mutation := newMissDetailMutation(c.config, OpDelete)
	return &MissDetailDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MissDetailClient) DeleteOne(md *MissDetail) *MissDetailDeleteOne {
	return c.DeleteOneID(md.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MissDetailClient) DeleteOneID(id int64) *MissDetailDeleteOne {
	builder := c.Delete().Where(missdetail.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MissDetailDeleteOne{builder}
}

// Query returns a query builder for MissDetail.
func (c *MissDetailClient) Query() *MissDetailQuery {
	return &MissDetailQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMissDetail},
		inters: c.Interceptors(),
	}
}

// Get returns a MissDetail entity by its id.
func (c *MissDetailClient) Get(ctx context.Context, id int64) (*MissDetail, error) {
	return c.Query().Where(missdetail.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MissDetailClient) GetX(ctx context.Context, id int64) *MissDetail {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryActionCacheStatistics queries the action_cache_statistics edge of a MissDetail.
func (c *MissDetailClient) QueryActionCacheStatistics(md *MissDetail) *ActionCacheStatisticsQuery {
	query := (&ActionCacheStatisticsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := md.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(missdetail.Table, missdetail.FieldID, id),
			sqlgraph.To(actioncachestatistics.Table, actioncachestatistics.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, missdetail.ActionCacheStatisticsTable, missdetail.ActionCacheStatisticsColumn),
		)
		fromV = sqlgraph.Neighbors(md.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MissDetailClient) Hooks() []Hook {
	return c.hooks.MissDetail
}

// Interceptors returns the client interceptors.
func (c *MissDetailClient) Interceptors() []Interceptor {
	return c.inters.MissDetail
}

func (c *MissDetailClient) mutate(ctx context.Context, m *MissDetailMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MissDetailCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MissDetailUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MissDetailUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MissDetailDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MissDetail mutation op: %q", m.Op())
	}
}

// NetworkMetricsClient is a client for the NetworkMetrics schema.
type NetworkMetricsClient struct {
	config
}

// NewNetworkMetricsClient returns a client for the NetworkMetrics from the given config.
func NewNetworkMetricsClient(c config) *NetworkMetricsClient {
	return &NetworkMetricsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `networkmetrics.Hooks(f(g(h())))`.
func (c *NetworkMetricsClient) Use(hooks ...Hook) {
	c.hooks.NetworkMetrics = append(c.hooks.NetworkMetrics, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `networkmetrics.Intercept(f(g(h())))`.
func (c *NetworkMetricsClient) Intercept(interceptors ...Interceptor) {
	c.inters.NetworkMetrics = append(c.inters.NetworkMetrics, interceptors...)
}

// Create returns a builder for creating a NetworkMetrics entity.
func (c *NetworkMetricsClient) Create() *NetworkMetricsCreate {
	mutation := newNetworkMetricsMutation(c.config, OpCreate)
	return &NetworkMetricsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of NetworkMetrics entities.
func (c *NetworkMetricsClient) CreateBulk(builders ...*NetworkMetricsCreate) *NetworkMetricsCreateBulk {
	return &NetworkMetricsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *NetworkMetricsClient) MapCreateBulk(slice any, setFunc func(*NetworkMetricsCreate, int)) *NetworkMetricsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &NetworkMetricsCreateBulk{err: fmt.Errorf("calling to NetworkMetricsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*NetworkMetricsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &NetworkMetricsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for NetworkMetrics.
func (c *NetworkMetricsClient) Update() *NetworkMetricsUpdate {
	mutation := newNetworkMetricsMutation(c.config, OpUpdate)
	return &NetworkMetricsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *NetworkMetricsClient) UpdateOne(nm *NetworkMetrics) *NetworkMetricsUpdateOne {
	mutation := newNetworkMetricsMutation(c.config, OpUpdateOne, withNetworkMetrics(nm))
	return &NetworkMetricsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *NetworkMetricsClient) UpdateOneID(id int64) *NetworkMetricsUpdateOne {
	mutation := newNetworkMetricsMutation(c.config, OpUpdateOne, withNetworkMetricsID(id))
	return &NetworkMetricsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for NetworkMetrics.
func (c *NetworkMetricsClient) Delete() *NetworkMetricsDelete {
	mutation := newNetworkMetricsMutation(c.config, OpDelete)
	return &NetworkMetricsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *NetworkMetricsClient) DeleteOne(nm *NetworkMetrics) *NetworkMetricsDeleteOne {
	return c.DeleteOneID(nm.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *NetworkMetricsClient) DeleteOneID(id int64) *NetworkMetricsDeleteOne {
	builder := c.Delete().Where(networkmetrics.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &NetworkMetricsDeleteOne{builder}
}

// Query returns a query builder for NetworkMetrics.
func (c *NetworkMetricsClient) Query() *NetworkMetricsQuery {
	return &NetworkMetricsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeNetworkMetrics},
		inters: c.Interceptors(),
	}
}

// Get returns a NetworkMetrics entity by its id.
func (c *NetworkMetricsClient) Get(ctx context.Context, id int64) (*NetworkMetrics, error) {
	return c.Query().Where(networkmetrics.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *NetworkMetricsClient) GetX(ctx context.Context, id int64) *NetworkMetrics {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMetrics queries the metrics edge of a NetworkMetrics.
func (c *NetworkMetricsClient) QueryMetrics(nm *NetworkMetrics) *MetricsQuery {
	query := (&MetricsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := nm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(networkmetrics.Table, networkmetrics.FieldID, id),
			sqlgraph.To(metrics.Table, metrics.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, networkmetrics.MetricsTable, networkmetrics.MetricsColumn),
		)
		fromV = sqlgraph.Neighbors(nm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySystemNetworkStats queries the system_network_stats edge of a NetworkMetrics.
func (c *NetworkMetricsClient) QuerySystemNetworkStats(nm *NetworkMetrics) *SystemNetworkStatsQuery {
	query := (&SystemNetworkStatsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := nm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(networkmetrics.Table, networkmetrics.FieldID, id),
			sqlgraph.To(systemnetworkstats.Table, systemnetworkstats.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, networkmetrics.SystemNetworkStatsTable, networkmetrics.SystemNetworkStatsColumn),
		)
		fromV = sqlgraph.Neighbors(nm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *NetworkMetricsClient) Hooks() []Hook {
	return c.hooks.NetworkMetrics
}

// Interceptors returns the client interceptors.
func (c *NetworkMetricsClient) Interceptors() []Interceptor {
	return c.inters.NetworkMetrics
}

func (c *NetworkMetricsClient) mutate(ctx context.Context, m *NetworkMetricsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&NetworkMetricsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&NetworkMetricsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&NetworkMetricsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&NetworkMetricsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown NetworkMetrics mutation op: %q", m.Op())
	}
}

// PackageLoadMetricsClient is a client for the PackageLoadMetrics schema.
type PackageLoadMetricsClient struct {
	config
}

// NewPackageLoadMetricsClient returns a client for the PackageLoadMetrics from the given config.
func NewPackageLoadMetricsClient(c config) *PackageLoadMetricsClient {
	return &PackageLoadMetricsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `packageloadmetrics.Hooks(f(g(h())))`.
func (c *PackageLoadMetricsClient) Use(hooks ...Hook) {
	c.hooks.PackageLoadMetrics = append(c.hooks.PackageLoadMetrics, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `packageloadmetrics.Intercept(f(g(h())))`.
func (c *PackageLoadMetricsClient) Intercept(interceptors ...Interceptor) {
	c.inters.PackageLoadMetrics = append(c.inters.PackageLoadMetrics, interceptors...)
}

// Create returns a builder for creating a PackageLoadMetrics entity.
func (c *PackageLoadMetricsClient) Create() *PackageLoadMetricsCreate {
	mutation := newPackageLoadMetricsMutation(c.config, OpCreate)
	return &PackageLoadMetricsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PackageLoadMetrics entities.
func (c *PackageLoadMetricsClient) CreateBulk(builders ...*PackageLoadMetricsCreate) *PackageLoadMetricsCreateBulk {
	return &PackageLoadMetricsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PackageLoadMetricsClient) MapCreateBulk(slice any, setFunc func(*PackageLoadMetricsCreate, int)) *PackageLoadMetricsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PackageLoadMetricsCreateBulk{err: fmt.Errorf("calling to PackageLoadMetricsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PackageLoadMetricsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PackageLoadMetricsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PackageLoadMetrics.
func (c *PackageLoadMetricsClient) Update() *PackageLoadMetricsUpdate {
	mutation := newPackageLoadMetricsMutation(c.config, OpUpdate)
	return &PackageLoadMetricsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PackageLoadMetricsClient) UpdateOne(plm *PackageLoadMetrics) *PackageLoadMetricsUpdateOne {
	mutation := newPackageLoadMetricsMutation(c.config, OpUpdateOne, withPackageLoadMetrics(plm))
	return &PackageLoadMetricsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PackageLoadMetricsClient) UpdateOneID(id int64) *PackageLoadMetricsUpdateOne {
	mutation := newPackageLoadMetricsMutation(c.config, OpUpdateOne, withPackageLoadMetricsID(id))
	return &PackageLoadMetricsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PackageLoadMetrics.
func (c *PackageLoadMetricsClient) Delete() *PackageLoadMetricsDelete {
	mutation := newPackageLoadMetricsMutation(c.config, OpDelete)
	return &PackageLoadMetricsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PackageLoadMetricsClient) DeleteOne(plm *PackageLoadMetrics) *PackageLoadMetricsDeleteOne {
	return c.DeleteOneID(plm.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PackageLoadMetricsClient) DeleteOneID(id int64) *PackageLoadMetricsDeleteOne {
	builder := c.Delete().Where(packageloadmetrics.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PackageLoadMetricsDeleteOne{builder}
}

// Query returns a query builder for PackageLoadMetrics.
func (c *PackageLoadMetricsClient) Query() *PackageLoadMetricsQuery {
	return &PackageLoadMetricsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePackageLoadMetrics},
		inters: c.Interceptors(),
	}
}

// Get returns a PackageLoadMetrics entity by its id.
func (c *PackageLoadMetricsClient) Get(ctx context.Context, id int64) (*PackageLoadMetrics, error) {
	return c.Query().Where(packageloadmetrics.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PackageLoadMetricsClient) GetX(ctx context.Context, id int64) *PackageLoadMetrics {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPackageMetrics queries the package_metrics edge of a PackageLoadMetrics.
func (c *PackageLoadMetricsClient) QueryPackageMetrics(plm *PackageLoadMetrics) *PackageMetricsQuery {
	query := (&PackageMetricsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := plm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(packageloadmetrics.Table, packageloadmetrics.FieldID, id),
			sqlgraph.To(packagemetrics.Table, packagemetrics.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, packageloadmetrics.PackageMetricsTable, packageloadmetrics.PackageMetricsColumn),
		)
		fromV = sqlgraph.Neighbors(plm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PackageLoadMetricsClient) Hooks() []Hook {
	return c.hooks.PackageLoadMetrics
}

// Interceptors returns the client interceptors.
func (c *PackageLoadMetricsClient) Interceptors() []Interceptor {
	return c.inters.PackageLoadMetrics
}

func (c *PackageLoadMetricsClient) mutate(ctx context.Context, m *PackageLoadMetricsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PackageLoadMetricsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PackageLoadMetricsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PackageLoadMetricsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PackageLoadMetricsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PackageLoadMetrics mutation op: %q", m.Op())
	}
}

// PackageMetricsClient is a client for the PackageMetrics schema.
type PackageMetricsClient struct {
	config
}

// NewPackageMetricsClient returns a client for the PackageMetrics from the given config.
func NewPackageMetricsClient(c config) *PackageMetricsClient {
	return &PackageMetricsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `packagemetrics.Hooks(f(g(h())))`.
func (c *PackageMetricsClient) Use(hooks ...Hook) {
	c.hooks.PackageMetrics = append(c.hooks.PackageMetrics, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `packagemetrics.Intercept(f(g(h())))`.
func (c *PackageMetricsClient) Intercept(interceptors ...Interceptor) {
	c.inters.PackageMetrics = append(c.inters.PackageMetrics, interceptors...)
}

// Create returns a builder for creating a PackageMetrics entity.
func (c *PackageMetricsClient) Create() *PackageMetricsCreate {
	mutation := newPackageMetricsMutation(c.config, OpCreate)
	return &PackageMetricsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PackageMetrics entities.
func (c *PackageMetricsClient) CreateBulk(builders ...*PackageMetricsCreate) *PackageMetricsCreateBulk {
	return &PackageMetricsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PackageMetricsClient) MapCreateBulk(slice any, setFunc func(*PackageMetricsCreate, int)) *PackageMetricsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PackageMetricsCreateBulk{err: fmt.Errorf("calling to PackageMetricsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PackageMetricsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PackageMetricsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PackageMetrics.
func (c *PackageMetricsClient) Update() *PackageMetricsUpdate {
	mutation := newPackageMetricsMutation(c.config, OpUpdate)
	return &PackageMetricsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PackageMetricsClient) UpdateOne(pm *PackageMetrics) *PackageMetricsUpdateOne {
	mutation := newPackageMetricsMutation(c.config, OpUpdateOne, withPackageMetrics(pm))
	return &PackageMetricsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PackageMetricsClient) UpdateOneID(id int64) *PackageMetricsUpdateOne {
	mutation := newPackageMetricsMutation(c.config, OpUpdateOne, withPackageMetricsID(id))
	return &PackageMetricsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PackageMetrics.
func (c *PackageMetricsClient) Delete() *PackageMetricsDelete {
	mutation := newPackageMetricsMutation(c.config, OpDelete)
	return &PackageMetricsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PackageMetricsClient) DeleteOne(pm *PackageMetrics) *PackageMetricsDeleteOne {
	return c.DeleteOneID(pm.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PackageMetricsClient) DeleteOneID(id int64) *PackageMetricsDeleteOne {
	builder := c.Delete().Where(packagemetrics.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PackageMetricsDeleteOne{builder}
}

// Query returns a query builder for PackageMetrics.
func (c *PackageMetricsClient) Query() *PackageMetricsQuery {
	return &PackageMetricsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePackageMetrics},
		inters: c.Interceptors(),
	}
}

// Get returns a PackageMetrics entity by its id.
func (c *PackageMetricsClient) Get(ctx context.Context, id int64) (*PackageMetrics, error) {
	return c.Query().Where(packagemetrics.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PackageMetricsClient) GetX(ctx context.Context, id int64) *PackageMetrics {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMetrics queries the metrics edge of a PackageMetrics.
func (c *PackageMetricsClient) QueryMetrics(pm *PackageMetrics) *MetricsQuery {
	query := (&MetricsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(packagemetrics.Table, packagemetrics.FieldID, id),
			sqlgraph.To(metrics.Table, metrics.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, packagemetrics.MetricsTable, packagemetrics.MetricsColumn),
		)
		fromV = sqlgraph.Neighbors(pm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPackageLoadMetrics queries the package_load_metrics edge of a PackageMetrics.
func (c *PackageMetricsClient) QueryPackageLoadMetrics(pm *PackageMetrics) *PackageLoadMetricsQuery {
	query := (&PackageLoadMetricsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(packagemetrics.Table, packagemetrics.FieldID, id),
			sqlgraph.To(packageloadmetrics.Table, packageloadmetrics.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, packagemetrics.PackageLoadMetricsTable, packagemetrics.PackageLoadMetricsColumn),
		)
		fromV = sqlgraph.Neighbors(pm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PackageMetricsClient) Hooks() []Hook {
	return c.hooks.PackageMetrics
}

// Interceptors returns the client interceptors.
func (c *PackageMetricsClient) Interceptors() []Interceptor {
	return c.inters.PackageMetrics
}

func (c *PackageMetricsClient) mutate(ctx context.Context, m *PackageMetricsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PackageMetricsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PackageMetricsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PackageMetricsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PackageMetricsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PackageMetrics mutation op: %q", m.Op())
	}
}

// RunnerCountClient is a client for the RunnerCount schema.
type RunnerCountClient struct {
	config
}

// NewRunnerCountClient returns a client for the RunnerCount from the given config.
func NewRunnerCountClient(c config) *RunnerCountClient {
	return &RunnerCountClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `runnercount.Hooks(f(g(h())))`.
func (c *RunnerCountClient) Use(hooks ...Hook) {
	c.hooks.RunnerCount = append(c.hooks.RunnerCount, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `runnercount.Intercept(f(g(h())))`.
func (c *RunnerCountClient) Intercept(interceptors ...Interceptor) {
	c.inters.RunnerCount = append(c.inters.RunnerCount, interceptors...)
}

// Create returns a builder for creating a RunnerCount entity.
func (c *RunnerCountClient) Create() *RunnerCountCreate {
	mutation := newRunnerCountMutation(c.config, OpCreate)
	return &RunnerCountCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of RunnerCount entities.
func (c *RunnerCountClient) CreateBulk(builders ...*RunnerCountCreate) *RunnerCountCreateBulk {
	return &RunnerCountCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RunnerCountClient) MapCreateBulk(slice any, setFunc func(*RunnerCountCreate, int)) *RunnerCountCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RunnerCountCreateBulk{err: fmt.Errorf("calling to RunnerCountClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RunnerCountCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RunnerCountCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for RunnerCount.
func (c *RunnerCountClient) Update() *RunnerCountUpdate {
	mutation := newRunnerCountMutation(c.config, OpUpdate)
	return &RunnerCountUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RunnerCountClient) UpdateOne(rc *RunnerCount) *RunnerCountUpdateOne {
	mutation := newRunnerCountMutation(c.config, OpUpdateOne, withRunnerCount(rc))
	return &RunnerCountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RunnerCountClient) UpdateOneID(id int64) *RunnerCountUpdateOne {
	mutation := newRunnerCountMutation(c.config, OpUpdateOne, withRunnerCountID(id))
	return &RunnerCountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for RunnerCount.
func (c *RunnerCountClient) Delete() *RunnerCountDelete {
	mutation := newRunnerCountMutation(c.config, OpDelete)
	return &RunnerCountDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RunnerCountClient) DeleteOne(rc *RunnerCount) *RunnerCountDeleteOne {
	return c.DeleteOneID(rc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RunnerCountClient) DeleteOneID(id int64) *RunnerCountDeleteOne {
	builder := c.Delete().Where(runnercount.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RunnerCountDeleteOne{builder}
}

// Query returns a query builder for RunnerCount.
func (c *RunnerCountClient) Query() *RunnerCountQuery {
	return &RunnerCountQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRunnerCount},
		inters: c.Interceptors(),
	}
}

// Get returns a RunnerCount entity by its id.
func (c *RunnerCountClient) Get(ctx context.Context, id int64) (*RunnerCount, error) {
	return c.Query().Where(runnercount.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RunnerCountClient) GetX(ctx context.Context, id int64) *RunnerCount {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryActionSummary queries the action_summary edge of a RunnerCount.
func (c *RunnerCountClient) QueryActionSummary(rc *RunnerCount) *ActionSummaryQuery {
	query := (&ActionSummaryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(runnercount.Table, runnercount.FieldID, id),
			sqlgraph.To(actionsummary.Table, actionsummary.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, runnercount.ActionSummaryTable, runnercount.ActionSummaryColumn),
		)
		fromV = sqlgraph.Neighbors(rc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RunnerCountClient) Hooks() []Hook {
	return c.hooks.RunnerCount
}

// Interceptors returns the client interceptors.
func (c *RunnerCountClient) Interceptors() []Interceptor {
	return c.inters.RunnerCount
}

func (c *RunnerCountClient) mutate(ctx context.Context, m *RunnerCountMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RunnerCountCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RunnerCountUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RunnerCountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RunnerCountDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown RunnerCount mutation op: %q", m.Op())
	}
}

// SourceControlClient is a client for the SourceControl schema.
type SourceControlClient struct {
	config
}

// NewSourceControlClient returns a client for the SourceControl from the given config.
func NewSourceControlClient(c config) *SourceControlClient {
	return &SourceControlClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `sourcecontrol.Hooks(f(g(h())))`.
func (c *SourceControlClient) Use(hooks ...Hook) {
	c.hooks.SourceControl = append(c.hooks.SourceControl, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `sourcecontrol.Intercept(f(g(h())))`.
func (c *SourceControlClient) Intercept(interceptors ...Interceptor) {
	c.inters.SourceControl = append(c.inters.SourceControl, interceptors...)
}

// Create returns a builder for creating a SourceControl entity.
func (c *SourceControlClient) Create() *SourceControlCreate {
	mutation := newSourceControlMutation(c.config, OpCreate)
	return &SourceControlCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SourceControl entities.
func (c *SourceControlClient) CreateBulk(builders ...*SourceControlCreate) *SourceControlCreateBulk {
	return &SourceControlCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SourceControlClient) MapCreateBulk(slice any, setFunc func(*SourceControlCreate, int)) *SourceControlCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SourceControlCreateBulk{err: fmt.Errorf("calling to SourceControlClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SourceControlCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SourceControlCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SourceControl.
func (c *SourceControlClient) Update() *SourceControlUpdate {
	mutation := newSourceControlMutation(c.config, OpUpdate)
	return &SourceControlUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SourceControlClient) UpdateOne(sc *SourceControl) *SourceControlUpdateOne {
	mutation := newSourceControlMutation(c.config, OpUpdateOne, withSourceControl(sc))
	return &SourceControlUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SourceControlClient) UpdateOneID(id int64) *SourceControlUpdateOne {
	mutation := newSourceControlMutation(c.config, OpUpdateOne, withSourceControlID(id))
	return &SourceControlUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SourceControl.
func (c *SourceControlClient) Delete() *SourceControlDelete {
	mutation := newSourceControlMutation(c.config, OpDelete)
	return &SourceControlDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SourceControlClient) DeleteOne(sc *SourceControl) *SourceControlDeleteOne {
	return c.DeleteOneID(sc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SourceControlClient) DeleteOneID(id int64) *SourceControlDeleteOne {
	builder := c.Delete().Where(sourcecontrol.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SourceControlDeleteOne{builder}
}

// Query returns a query builder for SourceControl.
func (c *SourceControlClient) Query() *SourceControlQuery {
	return &SourceControlQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSourceControl},
		inters: c.Interceptors(),
	}
}

// Get returns a SourceControl entity by its id.
func (c *SourceControlClient) Get(ctx context.Context, id int64) (*SourceControl, error) {
	return c.Query().Where(sourcecontrol.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SourceControlClient) GetX(ctx context.Context, id int64) *SourceControl {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBazelInvocation queries the bazel_invocation edge of a SourceControl.
func (c *SourceControlClient) QueryBazelInvocation(sc *SourceControl) *BazelInvocationQuery {
	query := (&BazelInvocationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sourcecontrol.Table, sourcecontrol.FieldID, id),
			sqlgraph.To(bazelinvocation.Table, bazelinvocation.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, sourcecontrol.BazelInvocationTable, sourcecontrol.BazelInvocationColumn),
		)
		fromV = sqlgraph.Neighbors(sc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SourceControlClient) Hooks() []Hook {
	return c.hooks.SourceControl
}

// Interceptors returns the client interceptors.
func (c *SourceControlClient) Interceptors() []Interceptor {
	return c.inters.SourceControl
}

func (c *SourceControlClient) mutate(ctx context.Context, m *SourceControlMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SourceControlCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SourceControlUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SourceControlUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SourceControlDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SourceControl mutation op: %q", m.Op())
	}
}

// SystemNetworkStatsClient is a client for the SystemNetworkStats schema.
type SystemNetworkStatsClient struct {
	config
}

// NewSystemNetworkStatsClient returns a client for the SystemNetworkStats from the given config.
func NewSystemNetworkStatsClient(c config) *SystemNetworkStatsClient {
	return &SystemNetworkStatsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `systemnetworkstats.Hooks(f(g(h())))`.
func (c *SystemNetworkStatsClient) Use(hooks ...Hook) {
	c.hooks.SystemNetworkStats = append(c.hooks.SystemNetworkStats, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `systemnetworkstats.Intercept(f(g(h())))`.
func (c *SystemNetworkStatsClient) Intercept(interceptors ...Interceptor) {
	c.inters.SystemNetworkStats = append(c.inters.SystemNetworkStats, interceptors...)
}

// Create returns a builder for creating a SystemNetworkStats entity.
func (c *SystemNetworkStatsClient) Create() *SystemNetworkStatsCreate {
	mutation := newSystemNetworkStatsMutation(c.config, OpCreate)
	return &SystemNetworkStatsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SystemNetworkStats entities.
func (c *SystemNetworkStatsClient) CreateBulk(builders ...*SystemNetworkStatsCreate) *SystemNetworkStatsCreateBulk {
	return &SystemNetworkStatsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SystemNetworkStatsClient) MapCreateBulk(slice any, setFunc func(*SystemNetworkStatsCreate, int)) *SystemNetworkStatsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SystemNetworkStatsCreateBulk{err: fmt.Errorf("calling to SystemNetworkStatsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SystemNetworkStatsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SystemNetworkStatsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SystemNetworkStats.
func (c *SystemNetworkStatsClient) Update() *SystemNetworkStatsUpdate {
	mutation := newSystemNetworkStatsMutation(c.config, OpUpdate)
	return &SystemNetworkStatsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SystemNetworkStatsClient) UpdateOne(sns *SystemNetworkStats) *SystemNetworkStatsUpdateOne {
	mutation := newSystemNetworkStatsMutation(c.config, OpUpdateOne, withSystemNetworkStats(sns))
	return &SystemNetworkStatsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SystemNetworkStatsClient) UpdateOneID(id int64) *SystemNetworkStatsUpdateOne {
	mutation := newSystemNetworkStatsMutation(c.config, OpUpdateOne, withSystemNetworkStatsID(id))
	return &SystemNetworkStatsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SystemNetworkStats.
func (c *SystemNetworkStatsClient) Delete() *SystemNetworkStatsDelete {
	mutation := newSystemNetworkStatsMutation(c.config, OpDelete)
	return &SystemNetworkStatsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SystemNetworkStatsClient) DeleteOne(sns *SystemNetworkStats) *SystemNetworkStatsDeleteOne {
	return c.DeleteOneID(sns.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SystemNetworkStatsClient) DeleteOneID(id int64) *SystemNetworkStatsDeleteOne {
	builder := c.Delete().Where(systemnetworkstats.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SystemNetworkStatsDeleteOne{builder}
}

// Query returns a query builder for SystemNetworkStats.
func (c *SystemNetworkStatsClient) Query() *SystemNetworkStatsQuery {
	return &SystemNetworkStatsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSystemNetworkStats},
		inters: c.Interceptors(),
	}
}

// Get returns a SystemNetworkStats entity by its id.
func (c *SystemNetworkStatsClient) Get(ctx context.Context, id int64) (*SystemNetworkStats, error) {
	return c.Query().Where(systemnetworkstats.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SystemNetworkStatsClient) GetX(ctx context.Context, id int64) *SystemNetworkStats {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryNetworkMetrics queries the network_metrics edge of a SystemNetworkStats.
func (c *SystemNetworkStatsClient) QueryNetworkMetrics(sns *SystemNetworkStats) *NetworkMetricsQuery {
	query := (&NetworkMetricsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sns.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(systemnetworkstats.Table, systemnetworkstats.FieldID, id),
			sqlgraph.To(networkmetrics.Table, networkmetrics.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, systemnetworkstats.NetworkMetricsTable, systemnetworkstats.NetworkMetricsColumn),
		)
		fromV = sqlgraph.Neighbors(sns.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SystemNetworkStatsClient) Hooks() []Hook {
	return c.hooks.SystemNetworkStats
}

// Interceptors returns the client interceptors.
func (c *SystemNetworkStatsClient) Interceptors() []Interceptor {
	return c.inters.SystemNetworkStats
}

func (c *SystemNetworkStatsClient) mutate(ctx context.Context, m *SystemNetworkStatsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SystemNetworkStatsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SystemNetworkStatsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SystemNetworkStatsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SystemNetworkStatsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SystemNetworkStats mutation op: %q", m.Op())
	}
}

// TargetClient is a client for the Target schema.
type TargetClient struct {
	config
}

// NewTargetClient returns a client for the Target from the given config.
func NewTargetClient(c config) *TargetClient {
	return &TargetClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `target.Hooks(f(g(h())))`.
func (c *TargetClient) Use(hooks ...Hook) {
	c.hooks.Target = append(c.hooks.Target, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `target.Intercept(f(g(h())))`.
func (c *TargetClient) Intercept(interceptors ...Interceptor) {
	c.inters.Target = append(c.inters.Target, interceptors...)
}

// Create returns a builder for creating a Target entity.
func (c *TargetClient) Create() *TargetCreate {
	mutation := newTargetMutation(c.config, OpCreate)
	return &TargetCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Target entities.
func (c *TargetClient) CreateBulk(builders ...*TargetCreate) *TargetCreateBulk {
	return &TargetCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TargetClient) MapCreateBulk(slice any, setFunc func(*TargetCreate, int)) *TargetCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TargetCreateBulk{err: fmt.Errorf("calling to TargetClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TargetCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TargetCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Target.
func (c *TargetClient) Update() *TargetUpdate {
	mutation := newTargetMutation(c.config, OpUpdate)
	return &TargetUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TargetClient) UpdateOne(t *Target) *TargetUpdateOne {
	mutation := newTargetMutation(c.config, OpUpdateOne, withTarget(t))
	return &TargetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TargetClient) UpdateOneID(id int64) *TargetUpdateOne {
	mutation := newTargetMutation(c.config, OpUpdateOne, withTargetID(id))
	return &TargetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Target.
func (c *TargetClient) Delete() *TargetDelete {
	mutation := newTargetMutation(c.config, OpDelete)
	return &TargetDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TargetClient) DeleteOne(t *Target) *TargetDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TargetClient) DeleteOneID(id int64) *TargetDeleteOne {
	builder := c.Delete().Where(target.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TargetDeleteOne{builder}
}

// Query returns a query builder for Target.
func (c *TargetClient) Query() *TargetQuery {
	return &TargetQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTarget},
		inters: c.Interceptors(),
	}
}

// Get returns a Target entity by its id.
func (c *TargetClient) Get(ctx context.Context, id int64) (*Target, error) {
	return c.Query().Where(target.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TargetClient) GetX(ctx context.Context, id int64) *Target {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryInstanceName queries the instance_name edge of a Target.
func (c *TargetClient) QueryInstanceName(t *Target) *InstanceNameQuery {
	query := (&InstanceNameClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(target.Table, target.FieldID, id),
			sqlgraph.To(instancename.Table, instancename.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, target.InstanceNameTable, target.InstanceNameColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInvocationTargets queries the invocation_targets edge of a Target.
func (c *TargetClient) QueryInvocationTargets(t *Target) *InvocationTargetQuery {
	query := (&InvocationTargetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(target.Table, target.FieldID, id),
			sqlgraph.To(invocationtarget.Table, invocationtarget.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, target.InvocationTargetsTable, target.InvocationTargetsColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTargetKindMappings queries the target_kind_mappings edge of a Target.
func (c *TargetClient) QueryTargetKindMappings(t *Target) *TargetKindMappingQuery {
	query := (&TargetKindMappingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(target.Table, target.FieldID, id),
			sqlgraph.To(targetkindmapping.Table, targetkindmapping.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, target.TargetKindMappingsTable, target.TargetKindMappingsColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TargetClient) Hooks() []Hook {
	hooks := c.hooks.Target
	return append(hooks[:len(hooks):len(hooks)], target.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *TargetClient) Interceptors() []Interceptor {
	return c.inters.Target
}

func (c *TargetClient) mutate(ctx context.Context, m *TargetMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TargetCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TargetUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TargetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TargetDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Target mutation op: %q", m.Op())
	}
}

// TargetKindMappingClient is a client for the TargetKindMapping schema.
type TargetKindMappingClient struct {
	config
}

// NewTargetKindMappingClient returns a client for the TargetKindMapping from the given config.
func NewTargetKindMappingClient(c config) *TargetKindMappingClient {
	return &TargetKindMappingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `targetkindmapping.Hooks(f(g(h())))`.
func (c *TargetKindMappingClient) Use(hooks ...Hook) {
	c.hooks.TargetKindMapping = append(c.hooks.TargetKindMapping, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `targetkindmapping.Intercept(f(g(h())))`.
func (c *TargetKindMappingClient) Intercept(interceptors ...Interceptor) {
	c.inters.TargetKindMapping = append(c.inters.TargetKindMapping, interceptors...)
}

// Create returns a builder for creating a TargetKindMapping entity.
func (c *TargetKindMappingClient) Create() *TargetKindMappingCreate {
	mutation := newTargetKindMappingMutation(c.config, OpCreate)
	return &TargetKindMappingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TargetKindMapping entities.
func (c *TargetKindMappingClient) CreateBulk(builders ...*TargetKindMappingCreate) *TargetKindMappingCreateBulk {
	return &TargetKindMappingCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TargetKindMappingClient) MapCreateBulk(slice any, setFunc func(*TargetKindMappingCreate, int)) *TargetKindMappingCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TargetKindMappingCreateBulk{err: fmt.Errorf("calling to TargetKindMappingClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TargetKindMappingCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TargetKindMappingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TargetKindMapping.
func (c *TargetKindMappingClient) Update() *TargetKindMappingUpdate {
	mutation := newTargetKindMappingMutation(c.config, OpUpdate)
	return &TargetKindMappingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TargetKindMappingClient) UpdateOne(tkm *TargetKindMapping) *TargetKindMappingUpdateOne {
	mutation := newTargetKindMappingMutation(c.config, OpUpdateOne, withTargetKindMapping(tkm))
	return &TargetKindMappingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TargetKindMappingClient) UpdateOneID(id int64) *TargetKindMappingUpdateOne {
	mutation := newTargetKindMappingMutation(c.config, OpUpdateOne, withTargetKindMappingID(id))
	return &TargetKindMappingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TargetKindMapping.
func (c *TargetKindMappingClient) Delete() *TargetKindMappingDelete {
	mutation := newTargetKindMappingMutation(c.config, OpDelete)
	return &TargetKindMappingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TargetKindMappingClient) DeleteOne(tkm *TargetKindMapping) *TargetKindMappingDeleteOne {
	return c.DeleteOneID(tkm.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TargetKindMappingClient) DeleteOneID(id int64) *TargetKindMappingDeleteOne {
	builder := c.Delete().Where(targetkindmapping.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TargetKindMappingDeleteOne{builder}
}

// Query returns a query builder for TargetKindMapping.
func (c *TargetKindMappingClient) Query() *TargetKindMappingQuery {
	return &TargetKindMappingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTargetKindMapping},
		inters: c.Interceptors(),
	}
}

// Get returns a TargetKindMapping entity by its id.
func (c *TargetKindMappingClient) Get(ctx context.Context, id int64) (*TargetKindMapping, error) {
	return c.Query().Where(targetkindmapping.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TargetKindMappingClient) GetX(ctx context.Context, id int64) *TargetKindMapping {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBazelInvocation queries the bazel_invocation edge of a TargetKindMapping.
func (c *TargetKindMappingClient) QueryBazelInvocation(tkm *TargetKindMapping) *BazelInvocationQuery {
	query := (&BazelInvocationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tkm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(targetkindmapping.Table, targetkindmapping.FieldID, id),
			sqlgraph.To(bazelinvocation.Table, bazelinvocation.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, targetkindmapping.BazelInvocationTable, targetkindmapping.BazelInvocationColumn),
		)
		fromV = sqlgraph.Neighbors(tkm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTarget queries the target edge of a TargetKindMapping.
func (c *TargetKindMappingClient) QueryTarget(tkm *TargetKindMapping) *TargetQuery {
	query := (&TargetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tkm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(targetkindmapping.Table, targetkindmapping.FieldID, id),
			sqlgraph.To(target.Table, target.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, targetkindmapping.TargetTable, targetkindmapping.TargetColumn),
		)
		fromV = sqlgraph.Neighbors(tkm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TargetKindMappingClient) Hooks() []Hook {
	return c.hooks.TargetKindMapping
}

// Interceptors returns the client interceptors.
func (c *TargetKindMappingClient) Interceptors() []Interceptor {
	return c.inters.TargetKindMapping
}

func (c *TargetKindMappingClient) mutate(ctx context.Context, m *TargetKindMappingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TargetKindMappingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TargetKindMappingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TargetKindMappingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TargetKindMappingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TargetKindMapping mutation op: %q", m.Op())
	}
}

// TargetMetricsClient is a client for the TargetMetrics schema.
type TargetMetricsClient struct {
	config
}

// NewTargetMetricsClient returns a client for the TargetMetrics from the given config.
func NewTargetMetricsClient(c config) *TargetMetricsClient {
	return &TargetMetricsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `targetmetrics.Hooks(f(g(h())))`.
func (c *TargetMetricsClient) Use(hooks ...Hook) {
	c.hooks.TargetMetrics = append(c.hooks.TargetMetrics, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `targetmetrics.Intercept(f(g(h())))`.
func (c *TargetMetricsClient) Intercept(interceptors ...Interceptor) {
	c.inters.TargetMetrics = append(c.inters.TargetMetrics, interceptors...)
}

// Create returns a builder for creating a TargetMetrics entity.
func (c *TargetMetricsClient) Create() *TargetMetricsCreate {
	mutation := newTargetMetricsMutation(c.config, OpCreate)
	return &TargetMetricsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TargetMetrics entities.
func (c *TargetMetricsClient) CreateBulk(builders ...*TargetMetricsCreate) *TargetMetricsCreateBulk {
	return &TargetMetricsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TargetMetricsClient) MapCreateBulk(slice any, setFunc func(*TargetMetricsCreate, int)) *TargetMetricsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TargetMetricsCreateBulk{err: fmt.Errorf("calling to TargetMetricsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TargetMetricsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TargetMetricsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TargetMetrics.
func (c *TargetMetricsClient) Update() *TargetMetricsUpdate {
	mutation := newTargetMetricsMutation(c.config, OpUpdate)
	return &TargetMetricsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TargetMetricsClient) UpdateOne(tm *TargetMetrics) *TargetMetricsUpdateOne {
	mutation := newTargetMetricsMutation(c.config, OpUpdateOne, withTargetMetrics(tm))
	return &TargetMetricsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TargetMetricsClient) UpdateOneID(id int64) *TargetMetricsUpdateOne {
	mutation := newTargetMetricsMutation(c.config, OpUpdateOne, withTargetMetricsID(id))
	return &TargetMetricsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TargetMetrics.
func (c *TargetMetricsClient) Delete() *TargetMetricsDelete {
	mutation := newTargetMetricsMutation(c.config, OpDelete)
	return &TargetMetricsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TargetMetricsClient) DeleteOne(tm *TargetMetrics) *TargetMetricsDeleteOne {
	return c.DeleteOneID(tm.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TargetMetricsClient) DeleteOneID(id int64) *TargetMetricsDeleteOne {
	builder := c.Delete().Where(targetmetrics.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TargetMetricsDeleteOne{builder}
}

// Query returns a query builder for TargetMetrics.
func (c *TargetMetricsClient) Query() *TargetMetricsQuery {
	return &TargetMetricsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTargetMetrics},
		inters: c.Interceptors(),
	}
}

// Get returns a TargetMetrics entity by its id.
func (c *TargetMetricsClient) Get(ctx context.Context, id int64) (*TargetMetrics, error) {
	return c.Query().Where(targetmetrics.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TargetMetricsClient) GetX(ctx context.Context, id int64) *TargetMetrics {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMetrics queries the metrics edge of a TargetMetrics.
func (c *TargetMetricsClient) QueryMetrics(tm *TargetMetrics) *MetricsQuery {
	query := (&MetricsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(targetmetrics.Table, targetmetrics.FieldID, id),
			sqlgraph.To(metrics.Table, metrics.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, targetmetrics.MetricsTable, targetmetrics.MetricsColumn),
		)
		fromV = sqlgraph.Neighbors(tm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TargetMetricsClient) Hooks() []Hook {
	return c.hooks.TargetMetrics
}

// Interceptors returns the client interceptors.
func (c *TargetMetricsClient) Interceptors() []Interceptor {
	return c.inters.TargetMetrics
}

func (c *TargetMetricsClient) mutate(ctx context.Context, m *TargetMetricsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TargetMetricsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TargetMetricsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TargetMetricsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TargetMetricsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TargetMetrics mutation op: %q", m.Op())
	}
}

// TestResultClient is a client for the TestResult schema.
type TestResultClient struct {
	config
}

// NewTestResultClient returns a client for the TestResult from the given config.
func NewTestResultClient(c config) *TestResultClient {
	return &TestResultClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `testresult.Hooks(f(g(h())))`.
func (c *TestResultClient) Use(hooks ...Hook) {
	c.hooks.TestResult = append(c.hooks.TestResult, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `testresult.Intercept(f(g(h())))`.
func (c *TestResultClient) Intercept(interceptors ...Interceptor) {
	c.inters.TestResult = append(c.inters.TestResult, interceptors...)
}

// Create returns a builder for creating a TestResult entity.
func (c *TestResultClient) Create() *TestResultCreate {
	mutation := newTestResultMutation(c.config, OpCreate)
	return &TestResultCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TestResult entities.
func (c *TestResultClient) CreateBulk(builders ...*TestResultCreate) *TestResultCreateBulk {
	return &TestResultCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TestResultClient) MapCreateBulk(slice any, setFunc func(*TestResultCreate, int)) *TestResultCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TestResultCreateBulk{err: fmt.Errorf("calling to TestResultClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TestResultCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TestResultCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TestResult.
func (c *TestResultClient) Update() *TestResultUpdate {
	mutation := newTestResultMutation(c.config, OpUpdate)
	return &TestResultUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TestResultClient) UpdateOne(tr *TestResult) *TestResultUpdateOne {
	mutation := newTestResultMutation(c.config, OpUpdateOne, withTestResult(tr))
	return &TestResultUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TestResultClient) UpdateOneID(id int64) *TestResultUpdateOne {
	mutation := newTestResultMutation(c.config, OpUpdateOne, withTestResultID(id))
	return &TestResultUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TestResult.
func (c *TestResultClient) Delete() *TestResultDelete {
	mutation := newTestResultMutation(c.config, OpDelete)
	return &TestResultDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TestResultClient) DeleteOne(tr *TestResult) *TestResultDeleteOne {
	return c.DeleteOneID(tr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TestResultClient) DeleteOneID(id int64) *TestResultDeleteOne {
	builder := c.Delete().Where(testresult.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TestResultDeleteOne{builder}
}

// Query returns a query builder for TestResult.
func (c *TestResultClient) Query() *TestResultQuery {
	return &TestResultQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTestResult},
		inters: c.Interceptors(),
	}
}

// Get returns a TestResult entity by its id.
func (c *TestResultClient) Get(ctx context.Context, id int64) (*TestResult, error) {
	return c.Query().Where(testresult.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TestResultClient) GetX(ctx context.Context, id int64) *TestResult {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTestSummary queries the test_summary edge of a TestResult.
func (c *TestResultClient) QueryTestSummary(tr *TestResult) *TestSummaryQuery {
	query := (&TestSummaryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(testresult.Table, testresult.FieldID, id),
			sqlgraph.To(testsummary.Table, testsummary.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, testresult.TestSummaryTable, testresult.TestSummaryColumn),
		)
		fromV = sqlgraph.Neighbors(tr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TestResultClient) Hooks() []Hook {
	return c.hooks.TestResult
}

// Interceptors returns the client interceptors.
func (c *TestResultClient) Interceptors() []Interceptor {
	return c.inters.TestResult
}

func (c *TestResultClient) mutate(ctx context.Context, m *TestResultMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TestResultCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TestResultUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TestResultUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TestResultDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TestResult mutation op: %q", m.Op())
	}
}

// TestSummaryClient is a client for the TestSummary schema.
type TestSummaryClient struct {
	config
}

// NewTestSummaryClient returns a client for the TestSummary from the given config.
func NewTestSummaryClient(c config) *TestSummaryClient {
	return &TestSummaryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `testsummary.Hooks(f(g(h())))`.
func (c *TestSummaryClient) Use(hooks ...Hook) {
	c.hooks.TestSummary = append(c.hooks.TestSummary, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `testsummary.Intercept(f(g(h())))`.
func (c *TestSummaryClient) Intercept(interceptors ...Interceptor) {
	c.inters.TestSummary = append(c.inters.TestSummary, interceptors...)
}

// Create returns a builder for creating a TestSummary entity.
func (c *TestSummaryClient) Create() *TestSummaryCreate {
	mutation := newTestSummaryMutation(c.config, OpCreate)
	return &TestSummaryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TestSummary entities.
func (c *TestSummaryClient) CreateBulk(builders ...*TestSummaryCreate) *TestSummaryCreateBulk {
	return &TestSummaryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TestSummaryClient) MapCreateBulk(slice any, setFunc func(*TestSummaryCreate, int)) *TestSummaryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TestSummaryCreateBulk{err: fmt.Errorf("calling to TestSummaryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TestSummaryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TestSummaryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TestSummary.
func (c *TestSummaryClient) Update() *TestSummaryUpdate {
	mutation := newTestSummaryMutation(c.config, OpUpdate)
	return &TestSummaryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TestSummaryClient) UpdateOne(ts *TestSummary) *TestSummaryUpdateOne {
	mutation := newTestSummaryMutation(c.config, OpUpdateOne, withTestSummary(ts))
	return &TestSummaryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TestSummaryClient) UpdateOneID(id int64) *TestSummaryUpdateOne {
	mutation := newTestSummaryMutation(c.config, OpUpdateOne, withTestSummaryID(id))
	return &TestSummaryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TestSummary.
func (c *TestSummaryClient) Delete() *TestSummaryDelete {
	mutation := newTestSummaryMutation(c.config, OpDelete)
	return &TestSummaryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TestSummaryClient) DeleteOne(ts *TestSummary) *TestSummaryDeleteOne {
	return c.DeleteOneID(ts.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TestSummaryClient) DeleteOneID(id int64) *TestSummaryDeleteOne {
	builder := c.Delete().Where(testsummary.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TestSummaryDeleteOne{builder}
}

// Query returns a query builder for TestSummary.
func (c *TestSummaryClient) Query() *TestSummaryQuery {
	return &TestSummaryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTestSummary},
		inters: c.Interceptors(),
	}
}

// Get returns a TestSummary entity by its id.
func (c *TestSummaryClient) Get(ctx context.Context, id int64) (*TestSummary, error) {
	return c.Query().Where(testsummary.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TestSummaryClient) GetX(ctx context.Context, id int64) *TestSummary {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryInvocationTarget queries the invocation_target edge of a TestSummary.
func (c *TestSummaryClient) QueryInvocationTarget(ts *TestSummary) *InvocationTargetQuery {
	query := (&InvocationTargetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ts.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(testsummary.Table, testsummary.FieldID, id),
			sqlgraph.To(invocationtarget.Table, invocationtarget.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, testsummary.InvocationTargetTable, testsummary.InvocationTargetColumn),
		)
		fromV = sqlgraph.Neighbors(ts.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTestResults queries the test_results edge of a TestSummary.
func (c *TestSummaryClient) QueryTestResults(ts *TestSummary) *TestResultQuery {
	query := (&TestResultClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ts.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(testsummary.Table, testsummary.FieldID, id),
			sqlgraph.To(testresult.Table, testresult.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, testsummary.TestResultsTable, testsummary.TestResultsColumn),
		)
		fromV = sqlgraph.Neighbors(ts.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TestSummaryClient) Hooks() []Hook {
	hooks := c.hooks.TestSummary
	return append(hooks[:len(hooks):len(hooks)], testsummary.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *TestSummaryClient) Interceptors() []Interceptor {
	return c.inters.TestSummary
}

func (c *TestSummaryClient) mutate(ctx context.Context, m *TestSummaryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TestSummaryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TestSummaryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TestSummaryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TestSummaryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TestSummary mutation op: %q", m.Op())
	}
}

// TimingMetricsClient is a client for the TimingMetrics schema.
type TimingMetricsClient struct {
	config
}

// NewTimingMetricsClient returns a client for the TimingMetrics from the given config.
func NewTimingMetricsClient(c config) *TimingMetricsClient {
	return &TimingMetricsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `timingmetrics.Hooks(f(g(h())))`.
func (c *TimingMetricsClient) Use(hooks ...Hook) {
	c.hooks.TimingMetrics = append(c.hooks.TimingMetrics, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `timingmetrics.Intercept(f(g(h())))`.
func (c *TimingMetricsClient) Intercept(interceptors ...Interceptor) {
	c.inters.TimingMetrics = append(c.inters.TimingMetrics, interceptors...)
}

// Create returns a builder for creating a TimingMetrics entity.
func (c *TimingMetricsClient) Create() *TimingMetricsCreate {
	mutation := newTimingMetricsMutation(c.config, OpCreate)
	return &TimingMetricsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TimingMetrics entities.
func (c *TimingMetricsClient) CreateBulk(builders ...*TimingMetricsCreate) *TimingMetricsCreateBulk {
	return &TimingMetricsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TimingMetricsClient) MapCreateBulk(slice any, setFunc func(*TimingMetricsCreate, int)) *TimingMetricsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TimingMetricsCreateBulk{err: fmt.Errorf("calling to TimingMetricsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TimingMetricsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TimingMetricsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TimingMetrics.
func (c *TimingMetricsClient) Update() *TimingMetricsUpdate {
	mutation := newTimingMetricsMutation(c.config, OpUpdate)
	return &TimingMetricsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TimingMetricsClient) UpdateOne(tm *TimingMetrics) *TimingMetricsUpdateOne {
	mutation := newTimingMetricsMutation(c.config, OpUpdateOne, withTimingMetrics(tm))
	return &TimingMetricsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TimingMetricsClient) UpdateOneID(id int64) *TimingMetricsUpdateOne {
	mutation := newTimingMetricsMutation(c.config, OpUpdateOne, withTimingMetricsID(id))
	return &TimingMetricsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TimingMetrics.
func (c *TimingMetricsClient) Delete() *TimingMetricsDelete {
	mutation := newTimingMetricsMutation(c.config, OpDelete)
	return &TimingMetricsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TimingMetricsClient) DeleteOne(tm *TimingMetrics) *TimingMetricsDeleteOne {
	return c.DeleteOneID(tm.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TimingMetricsClient) DeleteOneID(id int64) *TimingMetricsDeleteOne {
	builder := c.Delete().Where(timingmetrics.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TimingMetricsDeleteOne{builder}
}

// Query returns a query builder for TimingMetrics.
func (c *TimingMetricsClient) Query() *TimingMetricsQuery {
	return &TimingMetricsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTimingMetrics},
		inters: c.Interceptors(),
	}
}

// Get returns a TimingMetrics entity by its id.
func (c *TimingMetricsClient) Get(ctx context.Context, id int64) (*TimingMetrics, error) {
	return c.Query().Where(timingmetrics.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TimingMetricsClient) GetX(ctx context.Context, id int64) *TimingMetrics {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMetrics queries the metrics edge of a TimingMetrics.
func (c *TimingMetricsClient) QueryMetrics(tm *TimingMetrics) *MetricsQuery {
	query := (&MetricsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(timingmetrics.Table, timingmetrics.FieldID, id),
			sqlgraph.To(metrics.Table, metrics.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, timingmetrics.MetricsTable, timingmetrics.MetricsColumn),
		)
		fromV = sqlgraph.Neighbors(tm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TimingMetricsClient) Hooks() []Hook {
	return c.hooks.TimingMetrics
}

// Interceptors returns the client interceptors.
func (c *TimingMetricsClient) Interceptors() []Interceptor {
	return c.inters.TimingMetrics
}

func (c *TimingMetricsClient) mutate(ctx context.Context, m *TimingMetricsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TimingMetricsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TimingMetricsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TimingMetricsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TimingMetricsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TimingMetrics mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Action, ActionCacheStatistics, ActionData, ActionSummary, ArtifactMetrics,
		AuthenticatedUser, BazelInvocation, BazelInvocationProblem, Blob, Build,
		BuildGraphMetrics, BuildLogChunk, Configuration, ConnectionMetadata,
		CumulativeMetrics, EvaluationStat, EventMetadata, GarbageMetrics,
		IncompleteBuildLog, InstanceName, InvocationFiles, InvocationTarget,
		MemoryMetrics, Metrics, MissDetail, NetworkMetrics, PackageLoadMetrics,
		PackageMetrics, RunnerCount, SourceControl, SystemNetworkStats, Target,
		TargetKindMapping, TargetMetrics, TestResult, TestSummary,
		TimingMetrics []ent.Hook
	}
	inters struct {
		Action, ActionCacheStatistics, ActionData, ActionSummary, ArtifactMetrics,
		AuthenticatedUser, BazelInvocation, BazelInvocationProblem, Blob, Build,
		BuildGraphMetrics, BuildLogChunk, Configuration, ConnectionMetadata,
		CumulativeMetrics, EvaluationStat, EventMetadata, GarbageMetrics,
		IncompleteBuildLog, InstanceName, InvocationFiles, InvocationTarget,
		MemoryMetrics, Metrics, MissDetail, NetworkMetrics, PackageLoadMetrics,
		PackageMetrics, RunnerCount, SourceControl, SystemNetworkStats, Target,
		TargetKindMapping, TargetMetrics, TestResult, TestSummary,
		TimingMetrics []ent.Interceptor
	}
)

// ExecContext allows calling the underlying ExecContext method of the driver if it is supported by it.
// See, database/sql#DB.ExecContext for more information.
func (c *config) ExecContext(ctx context.Context, query string, args ...any) (stdsql.Result, error) {
	ex, ok := c.driver.(interface {
		ExecContext(context.Context, string, ...any) (stdsql.Result, error)
	})
	if !ok {
		return nil, fmt.Errorf("Driver.ExecContext is not supported")
	}
	return ex.ExecContext(ctx, query, args...)
}

// QueryContext allows calling the underlying QueryContext method of the driver if it is supported by it.
// See, database/sql#DB.QueryContext for more information.
func (c *config) QueryContext(ctx context.Context, query string, args ...any) (*stdsql.Rows, error) {
	q, ok := c.driver.(interface {
		QueryContext(context.Context, string, ...any) (*stdsql.Rows, error)
	})
	if !ok {
		return nil, fmt.Errorf("Driver.QueryContext is not supported")
	}
	return q.QueryContext(ctx, query, args...)
}
