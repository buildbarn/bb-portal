package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.76

import (
	"context"
	"errors"
	"fmt"
	"strings"

	"github.com/buildbarn/bb-portal/ent/gen/ent"
	"github.com/buildbarn/bb-portal/ent/gen/ent/authenticateduser"
	"github.com/buildbarn/bb-portal/ent/gen/ent/bazelinvocation"
	"github.com/buildbarn/bb-portal/ent/gen/ent/build"
	"github.com/buildbarn/bb-portal/ent/gen/ent/instancename"
	"github.com/buildbarn/bb-portal/ent/gen/ent/invocationfiles"
	"github.com/buildbarn/bb-portal/ent/gen/ent/invocationtarget"
	"github.com/buildbarn/bb-portal/ent/gen/ent/target"
	"github.com/buildbarn/bb-portal/internal/graphql/helpers"
	"github.com/buildbarn/bb-portal/internal/graphql/model"
	"github.com/google/uuid"
)

// BazelCommand is the resolver for the bazelCommand field.
func (r *bazelInvocationResolver) BazelCommand(ctx context.Context, obj *ent.BazelInvocation) (*model.BazelCommand, error) {
	return &model.BazelCommand{
		// TODO: Scalar ID
		Command:                obj.CommandLineCommand,
		Executable:             obj.CommandLineExecutable,
		Residual:               obj.CommandLineResidual,
		ExplicitCmdLine:        strings.Join(obj.ExplicitCommandLine, " "),
		CmdLine:                helpers.StringSliceArrayToPointerArray(obj.CommandLine),
		StartupOptions:         helpers.StringSliceArrayToPointerArray(obj.StartupOptions),
		ExplicitStartupOptions: helpers.StringSliceArrayToPointerArray(obj.ExplicitStartupOptions),
	}, nil
}

// User is the resolver for the user field.
func (r *bazelInvocationResolver) User(ctx context.Context, obj *ent.BazelInvocation) (*model.User, error) {
	return &model.User{
		Email: obj.UserEmail,
		Ldap:  obj.UserLdap,
	}, nil
}

// Profile is the resolver for the profile field.
func (r *bazelInvocationResolver) Profile(ctx context.Context, obj *ent.BazelInvocation) (*model.Profile, error) {
	profile, err := obj.QueryInvocationFiles().Where(invocationfiles.NameEQ(obj.ProfileName)).Only(ctx)
	if err != nil {
		return nil, nil
	}

	if profile == nil || profile.Name == "" || profile.Digest == "" || profile.SizeBytes == 0 || profile.DigestFunction == "" {
		return nil, nil
	}

	return &model.Profile{
		Name:           profile.Name,
		Digest:         profile.Digest,
		SizeInBytes:    int(profile.SizeBytes),
		DigestFunction: profile.DigestFunction,
	}, nil
}

// BazelInvocation is the resolver for the bazelInvocation field.
func (r *queryResolver) BazelInvocation(ctx context.Context, invocationID string) (*ent.BazelInvocation, error) {
	invocationUUID, err := uuid.Parse(invocationID)
	if err != nil {
		return nil, fmt.Errorf("invocationID was not a UUID: %w", err)
	}
	return r.client.BazelInvocation.Query().Where(bazelinvocation.InvocationID(invocationUUID)).First(ctx)
}

// GetAuthenticatedUser is the resolver for the getAuthenticatedUser field.
func (r *queryResolver) GetAuthenticatedUser(ctx context.Context, userUUID *uuid.UUID) (*ent.AuthenticatedUser, error) {
	if userUUID == nil {
		return nil, errors.New("userUUID must be provided")
	}
	return r.client.AuthenticatedUser.Query().Where(authenticateduser.UserUUID(*userUUID)).First(ctx)
}

// GetBuild is the resolver for the getBuild field.
func (r *queryResolver) GetBuild(ctx context.Context, buildURL *string, buildUUID *uuid.UUID) (*ent.Build, error) {
	if buildUUID == nil {
		return nil, errors.New("buildUUID must be provided")
	}
	return r.client.Build.Query().Where(build.BuildUUID(*buildUUID)).First(ctx)
}

// GetTarget is the resolver for the getTarget field.
func (r *queryResolver) GetTarget(ctx context.Context, instanceName, label, aspect, targetKind string) (*ent.Target, error) {
	return r.client.Target.Query().Where(
		target.LabelEQ(label),
		target.Aspect(aspect),
		target.TargetKind(targetKind),
		target.HasInstanceNameWith(
			instancename.Name(instanceName),
		),
	).Only(ctx)
}

// InvocationTargetsTotalDurationMillis is the resolver for the invocationTargetsTotalDurationMillis field.
func (r *targetResolver) InvocationTargetsTotalDurationMillis(ctx context.Context, obj *ent.Target) (int, error) {
	// If there are no invocation targets with a duration, SUM in SQL yields NULL
	// which can cause a scan error. Count first and return 0 if no rows match.
	count, err := obj.QueryInvocationTargets().
		Where(invocationtarget.DurationInMsNotNil()).
		Count(ctx)
	if err != nil {
		return 0, err
	}
	if count == 0 {
		return 0, nil
	}

	return obj.QueryInvocationTargets().
		Where(invocationtarget.DurationInMsNotNil()).
		Aggregate(ent.Sum(invocationtarget.FieldDurationInMs)).
		Int(ctx)
}
