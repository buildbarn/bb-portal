package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.76

import (
	"context"
	"strings"

	"github.com/buildbarn/bb-portal/ent/gen/ent"
	"github.com/buildbarn/bb-portal/ent/gen/ent/authenticateduser"
	"github.com/buildbarn/bb-portal/ent/gen/ent/bazelinvocation"
	"github.com/buildbarn/bb-portal/ent/gen/ent/build"
	"github.com/buildbarn/bb-portal/ent/gen/ent/instancename"
	"github.com/buildbarn/bb-portal/ent/gen/ent/invocationfiles"
	"github.com/buildbarn/bb-portal/ent/gen/ent/invocationtarget"
	"github.com/buildbarn/bb-portal/ent/gen/ent/target"
	"github.com/buildbarn/bb-portal/internal/graphql/helpers"
	"github.com/buildbarn/bb-portal/internal/graphql/model"
	"github.com/google/uuid"
)

// BazelCommand is the resolver for the bazelCommand field.
func (r *bazelInvocationResolver) BazelCommand(ctx context.Context, obj *ent.BazelInvocation) (*model.BazelCommand, error) {
	return &model.BazelCommand{
		// TODO: Scalar ID
		Command:                obj.CommandLineCommand,
		Executable:             obj.CommandLineExecutable,
		Residual:               obj.CommandLineResidual,
		ExplicitCmdLine:        strings.Join(obj.ExplicitCommandLine, " "),
		CmdLine:                helpers.StringSliceArrayToPointerArray(obj.CommandLine),
		StartupOptions:         helpers.StringSliceArrayToPointerArray(obj.StartupOptions),
		ExplicitStartupOptions: helpers.StringSliceArrayToPointerArray(obj.ExplicitStartupOptions),
	}, nil
}

// User is the resolver for the user field.
func (r *bazelInvocationResolver) User(ctx context.Context, obj *ent.BazelInvocation) (*model.User, error) {
	return &model.User{
		Email: obj.UserEmail,
		Ldap:  obj.UserLdap,
	}, nil
}

// Profile is the resolver for the profile field.
func (r *bazelInvocationResolver) Profile(ctx context.Context, obj *ent.BazelInvocation) (*model.Profile, error) {
	profile, err := obj.QueryInvocationFiles().Where(invocationfiles.NameEQ(obj.ProfileName)).Only(ctx)
	if err != nil {
		return nil, nil
	}

	if profile == nil || profile.Name == "" || profile.Digest == "" || profile.SizeBytes == 0 || profile.DigestFunction == "" {
		return nil, nil
	}

	return &model.Profile{
		Name:           profile.Name,
		Digest:         profile.Digest,
		SizeInBytes:    int(profile.SizeBytes),
		DigestFunction: profile.DigestFunction,
	}, nil
}

// GetAuthenticatedUser is the resolver for the getAuthenticatedUser field.
func (r *queryResolver) GetAuthenticatedUser(ctx context.Context, userUUID uuid.UUID) (*ent.AuthenticatedUser, error) {
	// CollectFields here is used to avoid the N+1 query problem. Ent shouldn't
	// need it, but somehow it does.
	query, err := r.client.AuthenticatedUser.Query().Where(authenticateduser.UserUUID(userUUID)).CollectFields(ctx)
	if err != nil {
		return nil, err
	}
	return query.First(ctx)
}

// GetBazelInvocation is the resolver for the getBazelInvocation field.
func (r *queryResolver) GetBazelInvocation(ctx context.Context, invocationID uuid.UUID) (*ent.BazelInvocation, error) {
	// CollectFields here is used to avoid the N+1 query problem. Ent shouldn't
	// need it, but somehow it does.
	query, err := r.client.BazelInvocation.Query().Where(bazelinvocation.InvocationID(invocationID)).CollectFields(ctx)
	if err != nil {
		return nil, err
	}
	return query.First(ctx)
}

// GetBuild is the resolver for the getBuild field.
func (r *queryResolver) GetBuild(ctx context.Context, buildUUID uuid.UUID) (*ent.Build, error) {
	// CollectFields here is used to avoid the N+1 query problem. Ent shouldn't
	// need it, but somehow it does.
	query, err := r.client.Build.Query().Where(build.BuildUUID(buildUUID)).CollectFields(ctx)
	if err != nil {
		return nil, err
	}
	return query.First(ctx)
}

// GetTarget is the resolver for the getTarget field.
func (r *queryResolver) GetTarget(ctx context.Context, instanceName, label, aspect, targetKind string) (*ent.Target, error) {
	// CollectFields here is used to avoid the N+1 query problem. Ent shouldn't
	// need it, but somehow it does.
	query, err := r.client.Target.Query().Where(
		target.LabelEQ(label),
		target.Aspect(aspect),
		target.TargetKind(targetKind),
		target.HasInstanceNameWith(
			instancename.Name(instanceName),
		),
	).CollectFields(ctx)
	if err != nil {
		return nil, err
	}
	return query.First(ctx)
}

// InvocationTargetsTotalDurationMillis is the resolver for the invocationTargetsTotalDurationMillis field.
func (r *targetResolver) InvocationTargetsTotalDurationMillis(ctx context.Context, obj *ent.Target) (int, error) {
	// If there are no invocation targets with a duration, SUM in SQL yields NULL
	// which can cause a scan error. Count first and return 0 if no rows match.
	count, err := obj.QueryInvocationTargets().
		Where(invocationtarget.DurationInMsNotNil()).
		Count(ctx)
	if err != nil {
		return 0, err
	}
	if count == 0 {
		return 0, nil
	}

	return obj.QueryInvocationTargets().
		Where(invocationtarget.DurationInMsNotNil()).
		Aggregate(ent.Sum(invocationtarget.FieldDurationInMs)).
		Int(ctx)
}
