package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.76

import (
	"context"
	"errors"
	"fmt"
	"net/url"
	"strings"

	bes "github.com/bazelbuild/bazel/src/main/java/com/google/devtools/build/lib/buildeventstream/proto"
	"github.com/buildbarn/bb-portal/ent/gen/ent"
	"github.com/buildbarn/bb-portal/ent/gen/ent/authenticateduser"
	"github.com/buildbarn/bb-portal/ent/gen/ent/bazelinvocation"
	"github.com/buildbarn/bb-portal/ent/gen/ent/blob"
	"github.com/buildbarn/bb-portal/ent/gen/ent/build"
	"github.com/buildbarn/bb-portal/ent/gen/ent/instancename"
	"github.com/buildbarn/bb-portal/ent/gen/ent/invocationfiles"
	"github.com/buildbarn/bb-portal/ent/gen/ent/invocationtarget"
	"github.com/buildbarn/bb-portal/ent/gen/ent/target"
	"github.com/buildbarn/bb-portal/internal/graphql/helpers"
	"github.com/buildbarn/bb-portal/internal/graphql/model"
	"github.com/google/uuid"
)

// Stdout is the resolver for the stdout field.
func (r *actionProblemResolver) Stdout(ctx context.Context, obj *model.ActionProblem) (*model.BlobReference, error) {
	return helpers.BlobReferenceForFile(ctx, r.client, func(ctx context.Context) (*bes.File, error) {
		action, err := helpers.GetAction(ctx, obj.Problem)
		if err != nil {
			return nil, err
		}
		return action.GetStdout(), nil
	})
}

// Stderr is the resolver for the stderr field.
func (r *actionProblemResolver) Stderr(ctx context.Context, obj *model.ActionProblem) (*model.BlobReference, error) {
	return helpers.BlobReferenceForFile(ctx, r.client, func(ctx context.Context) (*bes.File, error) {
		action, err := helpers.GetAction(ctx, obj.Problem)
		if err != nil {
			return nil, err
		}
		return action.GetStderr(), nil
	})
}

// BazelCommand is the resolver for the bazelCommand field.
func (r *bazelInvocationResolver) BazelCommand(ctx context.Context, obj *ent.BazelInvocation) (*model.BazelCommand, error) {
	return &model.BazelCommand{
		// TODO: Scalar ID
		Command:                obj.CommandLineCommand,
		Executable:             obj.CommandLineExecutable,
		Residual:               obj.CommandLineResidual,
		ExplicitCmdLine:        strings.Join(obj.ExplicitCommandLine, " "),
		CmdLine:                helpers.StringSliceArrayToPointerArray(obj.CommandLine),
		StartupOptions:         helpers.StringSliceArrayToPointerArray(obj.StartupOptions),
		ExplicitStartupOptions: helpers.StringSliceArrayToPointerArray(obj.ExplicitStartupOptions),
	}, nil
}

// User is the resolver for the user field.
func (r *bazelInvocationResolver) User(ctx context.Context, obj *ent.BazelInvocation) (*model.User, error) {
	return &model.User{
		Email: obj.UserEmail,
		Ldap:  obj.UserLdap,
	}, nil
}

// Problems is the resolver for the problems field.
func (r *bazelInvocationResolver) Problems(ctx context.Context, obj *ent.BazelInvocation) ([]model.Problem, error) {
	problems, err := obj.QueryProblems().All(ctx)
	if err != nil {
		return nil, fmt.Errorf("could not fetch problems: %w", err)
	}

	return r.helper.DBProblemsToAPIProblems(ctx, problems)
}

// Profile is the resolver for the profile field.
func (r *bazelInvocationResolver) Profile(ctx context.Context, obj *ent.BazelInvocation) (*model.Profile, error) {
	profile, err := obj.QueryInvocationFiles().Where(invocationfiles.NameEQ(obj.ProfileName)).Only(ctx)
	if err != nil {
		return nil, nil
	}

	if profile == nil || profile.Name == "" || profile.Digest == "" || profile.SizeBytes == 0 || profile.DigestFunction == "" {
		return nil, nil
	}

	return &model.Profile{
		Name:           profile.Name,
		Digest:         profile.Digest,
		SizeInBytes:    int(profile.SizeBytes),
		DigestFunction: profile.DigestFunction,
	}, nil
}

// DownloadURL is the resolver for the downloadURL field.
func (r *blobReferenceResolver) DownloadURL(ctx context.Context, obj *model.BlobReference) (string, error) {
	if obj.Blob == nil {
		panic("Got a name but not blob")
	}
	return fmt.Sprintf("/api/v1/blobs/%d/%s", obj.Blob.ID, url.PathEscape(obj.Name)), nil
}

// SizeInBytes is the resolver for the sizeInBytes field.
func (r *blobReferenceResolver) SizeInBytes(ctx context.Context, obj *model.BlobReference) (*int, error) {
	if obj.Blob == nil {
		return nil, nil
	}
	v := int(obj.Blob.SizeBytes)
	return &v, nil
}

// AvailabilityStatus is the resolver for the availabilityStatus field.
func (r *blobReferenceResolver) AvailabilityStatus(ctx context.Context, obj *model.BlobReference) (model.ActionOutputStatus, error) {
	if obj.Blob == nil {
		return model.ActionOutputStatusUnavailable, nil
	}
	switch obj.Blob.ArchivingStatus {
	case blob.ArchivingStatusQUEUED:
		fallthrough
	case blob.ArchivingStatusARCHIVING:
		return model.ActionOutputStatusProcessing, nil
	case blob.ArchivingStatusSUCCESS:
		return model.ActionOutputStatusAvailable, nil
	case blob.ArchivingStatusFAILED:
		fallthrough
	default:
		return model.ActionOutputStatusUnavailable, nil
	}
}

// EphemeralUrl is the resolver for the downloadURL field.
func (r *blobReferenceResolver) EphemeralURL(ctx context.Context, obj *model.BlobReference) (string, error) {
	if obj.Blob == nil {
		panic("Got a name but not blob")
	}
	if obj.Blob.ArchivingStatus != blob.ArchivingStatusBYTESTREAM {
		return "", nil
	}
	_tmp := strings.Split(obj.Blob.URI, "/blobs/")[1]
	_split := strings.Split(_tmp, "/")
	hash, size := _split[0], _split[1]

	return fmt.Sprintf("/blobs/sha256/file/%s-%s/%s", hash, size, url.PathEscape(obj.Name)), nil
}

// BazelInvocation is the resolver for the bazelInvocation field.
func (r *queryResolver) BazelInvocation(ctx context.Context, invocationID string) (*ent.BazelInvocation, error) {
	invocationUUID, err := uuid.Parse(invocationID)
	if err != nil {
		return nil, fmt.Errorf("invocationID was not a UUID: %w", err)
	}
	return r.client.BazelInvocation.Query().Where(bazelinvocation.InvocationID(invocationUUID)).First(ctx)
}

// GetAuthenticatedUser is the resolver for the getAuthenticatedUser field.
func (r *queryResolver) GetAuthenticatedUser(ctx context.Context, userUUID *uuid.UUID) (*ent.AuthenticatedUser, error) {
	if userUUID == nil {
		return nil, errors.New("userUUID must be provided")
	}
	return r.client.AuthenticatedUser.Query().Where(authenticateduser.UserUUID(*userUUID)).First(ctx)
}

// GetBuild is the resolver for the getBuild field.
func (r *queryResolver) GetBuild(ctx context.Context, buildURL *string, buildUUID *uuid.UUID) (*ent.Build, error) {
	if buildUUID == nil {
		return nil, errors.New("buildUUID must be provided")
	}
	return r.client.Build.Query().Where(build.BuildUUID(*buildUUID)).First(ctx)
}

// GetTarget is the resolver for the getTarget field.
func (r *queryResolver) GetTarget(ctx context.Context, instanceName, label, aspect, targetKind string) (*ent.Target, error) {
	return r.client.Target.Query().Where(
		target.LabelEQ(label),
		target.Aspect(aspect),
		target.TargetKind(targetKind),
		target.HasInstanceNameWith(
			instancename.Name(instanceName),
		),
	).Only(ctx)
}

// InvocationTargetsTotalDurationMillis is the resolver for the invocationTargetsTotalDurationMillis field.
func (r *targetResolver) InvocationTargetsTotalDurationMillis(ctx context.Context, obj *ent.Target) (int, error) {
	// If there are no invocation targets with a duration, SUM in SQL yields NULL
	// which can cause a scan error. Count first and return 0 if no rows match.
	count, err := obj.QueryInvocationTargets().
		Where(invocationtarget.DurationInMsNotNil()).
		Count(ctx)
	if err != nil {
		return 0, err
	}
	if count == 0 {
		return 0, nil
	}

	return obj.QueryInvocationTargets().
		Where(invocationtarget.DurationInMsNotNil()).
		Aggregate(ent.Sum(invocationtarget.FieldDurationInMs)).
		Int(ctx)
}

// ActionProblem returns ActionProblemResolver implementation.
func (r *Resolver) ActionProblem() ActionProblemResolver { return &actionProblemResolver{r} }

// BlobReference returns BlobReferenceResolver implementation.
func (r *Resolver) BlobReference() BlobReferenceResolver { return &blobReferenceResolver{r} }

type (
	actionProblemResolver struct{ *Resolver }
	blobReferenceResolver struct{ *Resolver }
)
