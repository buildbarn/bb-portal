package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.43

import (
	"cmp"
	"context"
	"fmt"
	"net/url"
	"slices"
	"strings"

	"github.com/buildbarn/bb-portal/ent/gen/ent"
	"github.com/buildbarn/bb-portal/ent/gen/ent/bazelinvocation"
	"github.com/buildbarn/bb-portal/ent/gen/ent/blob"
	"github.com/buildbarn/bb-portal/ent/gen/ent/build"
	"github.com/buildbarn/bb-portal/internal/graphql/helpers"
	"github.com/buildbarn/bb-portal/internal/graphql/model"
	"github.com/buildbarn/bb-portal/third_party/bazel/gen/bes"
	"github.com/google/uuid"
)

// Stdout is the resolver for the stdout field.
func (r *actionProblemResolver) Stdout(ctx context.Context, obj *model.ActionProblem) (*model.BlobReference, error) {
	return helpers.BlobReferenceForFile(ctx, r.client, func(ctx context.Context) (*bes.File, error) {
		action, err := helpers.GetAction(ctx, obj.Problem)
		if err != nil {
			return nil, err
		}
		return action.GetStdout(), nil
	})
}

// Stderr is the resolver for the stderr field.
func (r *actionProblemResolver) Stderr(ctx context.Context, obj *model.ActionProblem) (*model.BlobReference, error) {
	return helpers.BlobReferenceForFile(ctx, r.client, func(ctx context.Context) (*bes.File, error) {
		action, err := helpers.GetAction(ctx, obj.Problem)
		if err != nil {
			return nil, err
		}
		return action.GetStderr(), nil
	})
}

// BazelCommand is the resolver for the bazelCommand field.
func (r *bazelInvocationResolver) BazelCommand(ctx context.Context, obj *ent.BazelInvocation) (*model.BazelCommand, error) {
	bcl := obj.Summary.BazelCommandLine
	return &model.BazelCommand{
		// TODO: Scalar ID
		Command:    bcl.Command,
		Executable: bcl.Executable,
		Options:    strings.Join(bcl.Options, " "),
		Residual:   bcl.Residual,
	}, nil
}

// State is the resolver for the state field.
func (r *bazelInvocationResolver) State(ctx context.Context, obj *ent.BazelInvocation) (*model.BazelInvocationState, error) {
	return &model.BazelInvocationState{
		// TODO: Scalar ID
		BuildEndTime:   obj.EndedAt,
		BuildStartTime: obj.EndedAt,
		ExitCode: &model.ExitCode{
			// TODO: Scalar ID
			Code: obj.Summary.ExitCode.Code,
			Name: obj.Summary.ExitCode.Name,
		},
		BepCompleted: obj.BepCompleted,
	}, nil
}

// RelatedFiles is the resolver for the relatedFiles field.
func (r *bazelInvocationResolver) RelatedFiles(ctx context.Context, obj *ent.BazelInvocation) ([]*model.NamedFile, error) {
	namedFiles := make([]*model.NamedFile, 0, len(obj.RelatedFiles))
	for relatedFileName, relatedFileURL := range obj.RelatedFiles {
		namedFiles = append(namedFiles, &model.NamedFile{
			Name: relatedFileName,
			URL:  relatedFileURL,
		})
	}
	slices.SortFunc(namedFiles, func(a, b *model.NamedFile) int {
		return cmp.Compare(a.Name, b.Name)
	})
	return namedFiles, nil
}

// Problems is the resolver for the problems field.
func (r *bazelInvocationResolver) Problems(ctx context.Context, obj *ent.BazelInvocation) ([]model.Problem, error) {
	problems, err := obj.QueryProblems().All(ctx)
	if err != nil {
		return nil, fmt.Errorf("could not fetch problems: %w", err)
	}

	return r.helper.DBProblemsToAPIProblems(ctx, problems)
}

// DownloadURL is the resolver for the downloadURL field.
func (r *blobReferenceResolver) DownloadURL(ctx context.Context, obj *model.BlobReference) (string, error) {
	if obj.Blob == nil {
		panic("Got a name but not blob")
	}
	return fmt.Sprintf("/api/v1/blobs/%d/%s", obj.Blob.ID, url.PathEscape(obj.Name)), nil
}

// SizeInBytes is the resolver for the sizeInBytes field.
func (r *blobReferenceResolver) SizeInBytes(ctx context.Context, obj *model.BlobReference) (*int, error) {
	if obj.Blob == nil {
		return nil, nil
	}
	v := int(obj.Blob.SizeBytes)
	return &v, nil
}

// AvailabilityStatus is the resolver for the availabilityStatus field.
func (r *blobReferenceResolver) AvailabilityStatus(ctx context.Context, obj *model.BlobReference) (model.ActionOutputStatus, error) {
	if obj.Blob == nil {
		return model.ActionOutputStatusUnavailable, nil
	}
	switch obj.Blob.ArchivingStatus {
	case blob.ArchivingStatusQUEUED:
		fallthrough
	case blob.ArchivingStatusARCHIVING:
		return model.ActionOutputStatusProcessing, nil
	case blob.ArchivingStatusSUCCESS:
		return model.ActionOutputStatusAvailable, nil
	case blob.ArchivingStatusFAILED:
		fallthrough
	default:
		return model.ActionOutputStatusUnavailable, nil
	}
}

// Env is the resolver for the env field.
func (r *buildResolver) Env(ctx context.Context, obj *ent.Build) ([]*model.EnvVar, error) {
	envVars := make([]*model.EnvVar, 0, len(obj.Env))
	for k, v := range obj.Env {
		envVars = append(envVars, &model.EnvVar{
			Key:   k,
			Value: v,
		})
	}
	// Stable sort, mostly for testing purposes.
	slices.SortFunc(envVars, func(a, b *model.EnvVar) int {
		return cmp.Compare(a.Key, b.Key)
	})
	return envVars, nil
}

// BazelInvocation is the resolver for the bazelInvocation field.
func (r *queryResolver) BazelInvocation(ctx context.Context, invocationID string) (*ent.BazelInvocation, error) {
	invocationUUID, err := uuid.Parse(invocationID)
	if err != nil {
		return nil, fmt.Errorf("invocationID was not a UUID: %w", err)
	}
	return r.client.BazelInvocation.Query().Where(bazelinvocation.InvocationID(invocationUUID)).First(ctx)
}

// GetBuild is the resolver for the getBuild field.
func (r *queryResolver) GetBuild(ctx context.Context, buildURL *string, buildUUID *uuid.UUID) (*ent.Build, error) {
	if buildURL == nil && buildUUID == nil {
		return nil, helpers.ErrOnlyURLOrUUID
	}
	if buildURL != nil && *buildURL != "" && buildUUID != nil {
		return nil, helpers.ErrOnlyURLOrUUID
	}
	if buildURL != nil && *buildURL != "" {
		calculatedBuildUUID := uuid.NewSHA1(uuid.NameSpaceURL, []byte(*buildURL))
		buildUUID = &calculatedBuildUUID
	}
	return r.client.Build.Query().Where(build.BuildUUID(*buildUUID)).First(ctx)
}

// ActionLogOutput is the resolver for the actionLogOutput field.
func (r *testResultResolver) ActionLogOutput(ctx context.Context, obj *model.TestResult) (*model.BlobReference, error) {
	return helpers.GetTestResultActionLogOutput(ctx, r.client, obj)
}

// UndeclaredTestOutputs is the resolver for the undeclaredTestOutputs field.
func (r *testResultResolver) UndeclaredTestOutputs(ctx context.Context, obj *model.TestResult) (*model.BlobReference, error) {
	return helpers.GetTestResultUndeclaredTestOutputs(ctx, r.client, obj)
}

// ActionProblem returns ActionProblemResolver implementation.
func (r *Resolver) ActionProblem() ActionProblemResolver { return &actionProblemResolver{r} }

// BlobReference returns BlobReferenceResolver implementation.
func (r *Resolver) BlobReference() BlobReferenceResolver { return &blobReferenceResolver{r} }

// TestResult returns TestResultResolver implementation.
func (r *Resolver) TestResult() TestResultResolver { return &testResultResolver{r} }

type (
	actionProblemResolver struct{ *Resolver }
	blobReferenceResolver struct{ *Resolver }
	testResultResolver    struct{ *Resolver }
)
