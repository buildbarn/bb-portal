extend type Query {
  bazelInvocation(invocationId: String!): BazelInvocation!
  getAuthenticatedUser(userUUID: UUID): AuthenticatedUser
  getBuild(buildURL: String, buildUUID: UUID): Build
  getTarget(
    instanceName: String!
    label: String!
    aspect: String!
    targetKind: String!
  ): Target
  getUniqueTestLabels(param: String): [String]
  getTestDurationAggregation(label: String): [TargetAggregate]
  getTestPassAggregation(label: String): [TargetAggregate]
  getTestsWithOffset(
    label: String
    offset: Int
    limit: Int
    sortBy: String
    direction: String
  ): TestGridResult
  getAveragePassPercentageForLabel(label: String!): Float
}

type TargetAggregate {
  label: String
  count: Int
  sum: Int
  min: Int
  max: Int
  avg: Int
  pass: Int
}

type TestGridResult {
  total: Int
  result: [TestGridRow]
}

type TestGridRow {
  label: String
  count: Int
  sum: Int
  min: Int
  max: Int
  avg: Float
  passRate: Float
  cells: [TestGridCell]
}

type TestGridCell {
  invocationId: UUID
  status: TestCollectionOverallStatus
}

type BazelCommand {
  id: ID!
  command: String!
  executable: String!
  residual: String!
  explicitCmdLine: String!
  cmdLine: [String]
  startupOptions: [String]
  explicitStartupOptions: [String]
}

extend type BazelInvocation {
  bazelCommand: BazelCommand!
}


type User {
  id: ID!
  Email: String!
  LDAP: String!
}

extend type BazelInvocation {
  user: User
}

interface Problem implements Node {
  id: ID!
  label: String!
}

enum ActionOutputStatus {
  PROCESSING
  AVAILABLE
  UNAVAILABLE
  BYTESTREAM
}

type BlobReference {
  name: String!
  downloadURL: String! @goField(forceResolver: true)
  sizeInBytes: Int @goField(forceResolver: true)
  availabilityStatus: ActionOutputStatus! @goField(forceResolver: true)
  ephemeralURL: String! @goField(forceResolver: true)
}

type ActionProblem implements Node & Problem {
  id: ID!
  label: String!
  type: String!
  stdout: BlobReference @goField(forceResolver: true)
  stderr: BlobReference @goField(forceResolver: true)
}

type ProgressProblem implements Node & Problem {
  id: ID!
  label: String!
  #  TODO: Possibly store these as blobs?
  output: String!
}

type TargetProblem implements Node & Problem {
  id: ID!
  label: String!
}

type TestProblem implements Node & Problem {
  id: ID!
  label: String!
  status: String!
  results: [TestResult!]!
}

type TestResult implements Node {
  id: ID!
  run: Int!
  shard: Int!
  attempt: Int!
  status: String!
  actionLogOutput: BlobReference! @goField(forceResolver: true)
  undeclaredTestOutputs: BlobReference @goField(forceResolver: true)
}

extend type BazelInvocation {
  problems: [Problem!]!
}

enum BuildStepStatus {
  Successful
  Failed
  Cancelled
  Unknown
}

interface BuildStep {
  id: ID!
  stepLabel: String!
  buildStepStatus: BuildStepStatus!
}

type Profile {
  id: ID!
  name: String!
  digest: String!
  sizeInBytes: Int!
  digestFunction: String!
}

extend type BazelInvocation {
  profile: Profile
}

extend type Target {
  invocationTargetsTotalDurationMillis: Int! @goField(forceResolver: true)
}
