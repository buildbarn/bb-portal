// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: test_result.sql

package sqlc

import (
	"context"
	"time"

	"github.com/lib/pq"
)

const createTestResultsBulk = `-- name: CreateTestResultsBulk :execrows
INSERT INTO test_results (
    test_summary_test_results,
    run,
    shard,
    attempt,
    status,
    status_details,
    cached_locally,
    test_attempt_start,
    test_attempt_duration_in_ms,
    warning,
    strategy,
    cached_remotely,
    exit_code,
    hostname,
    timing_breakdown
)
SELECT
    ts.id,
    resolved_inputs.run,
    resolved_inputs.shard,
    resolved_inputs.attempt,
    resolved_inputs.status,
    resolved_inputs.status_details,
    resolved_inputs.cached_locally,
    resolved_inputs.test_attempt_start,
    resolved_inputs.test_attempt_duration_in_ms,
    resolved_inputs.warning::jsonb,
    resolved_inputs.strategy,
    resolved_inputs.cached_remotely,
    resolved_inputs.exit_code,
    resolved_inputs.hostname,
    resolved_inputs.timing_breakdown::jsonb
FROM (
    -- STAGE 1: Resolve Target IDs immediately using the Index
    -- We join the massive input arrays against the Targets table first.
    SELECT
        input.config_id,
        t.id AS target_id,
        input.run,
        input.shard,
        input.attempt,
        input.status,
        input.status_details,
        input.cached_locally,
        input.test_attempt_start,
        input.test_attempt_duration_in_ms,
        input.warning,
        input.strategy,
        input.cached_remotely,
        input.exit_code,
        input.hostname,
        input.timing_breakdown
    FROM (
        SELECT
            $1::bigint as instance_name_id,
            unnest($2::text[]) as label,
            unnest($3::text[]) as config_id,
            unnest($4::integer[]) AS run,
            unnest($5::integer[]) AS shard,
            unnest($6::integer[]) AS attempt,
            unnest($7::text[]) AS status,
            unnest($8::text[]) AS status_details,
            unnest($9::boolean[]) AS cached_locally,
            unnest($10::timestamptz[]) AS test_attempt_start,
            unnest($11::bigint[]) AS test_attempt_duration_in_ms,
            unnest($12::text[]) AS warning,
            unnest($13::text[]) AS strategy,
            unnest($14::boolean[]) AS cached_remotely,
            unnest($15::integer[]) AS exit_code,
            unnest($16::text[]) AS hostname,
            unnest($17::text[]) AS timing_breakdown
    ) AS input
    JOIN targets t
        ON t.instance_name_targets = input.instance_name_id
        AND t.label = input.label
        AND t.aspect = ''
    -- We use OFFSET 0 here to force this block to execute first
    OFFSET 0
) AS resolved_inputs
JOIN configurations c
    ON c.bazel_invocation_id = $18
    AND c.configuration_id = resolved_inputs.config_id
JOIN invocation_targets it
    ON it.target_invocation_targets = resolved_inputs.target_id
    AND it.invocation_target_configuration = c.id
    AND it.bazel_invocation_invocation_targets = $18
JOIN test_summaries ts
    ON ts.invocation_target_test_summary = it.id
`

type CreateTestResultsBulkParams struct {
	InstanceNameID       int64
	Labels               []string
	ConfigIds            []string
	Runs                 []int32
	Shards               []int32
	Attempts             []int32
	Statuses             []string
	StatusDetailss       []string
	CachedLocallys       []bool
	TestAttemptStarts    []time.Time
	TestAttemptDurations []int64
	Warnings             []string
	Strategies           []string
	CachedRemotelys      []bool
	ExitCodes            []int32
	Hostnames            []string
	TimingBreakdowns     []string
	BazelInvocationID    int64
}

// STAGE 2: Join the rest using the specific Target IDs we found
func (q *Queries) CreateTestResultsBulk(ctx context.Context, arg CreateTestResultsBulkParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, createTestResultsBulk,
		arg.InstanceNameID,
		pq.Array(arg.Labels),
		pq.Array(arg.ConfigIds),
		pq.Array(arg.Runs),
		pq.Array(arg.Shards),
		pq.Array(arg.Attempts),
		pq.Array(arg.Statuses),
		pq.Array(arg.StatusDetailss),
		pq.Array(arg.CachedLocallys),
		pq.Array(arg.TestAttemptStarts),
		pq.Array(arg.TestAttemptDurations),
		pq.Array(arg.Warnings),
		pq.Array(arg.Strategies),
		pq.Array(arg.CachedRemotelys),
		pq.Array(arg.ExitCodes),
		pq.Array(arg.Hostnames),
		pq.Array(arg.TimingBreakdowns),
		arg.BazelInvocationID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
