// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: test_summary.sql

package sqlc

import (
	"context"
	"time"

	"github.com/lib/pq"
)

const createTestSummariesBulk = `-- name: CreateTestSummariesBulk :execrows
INSERT INTO test_summaries (
    invocation_target_test_summary
)
SELECT
    it.id
FROM (
    -- STAGE 1: Resolve Target IDs immediately using the Index
    SELECT
        input.config_id,
        t.id AS target_id
    FROM (
        SELECT
            $1::bigint as instance_name_id,
            unnest($2::text[]) as label,
            unnest($3::text[]) as config_id
    ) AS input
    JOIN targets t
        ON t.instance_name_targets = input.instance_name_id
        AND t.label = input.label
        AND t.aspect = ''
    -- We use OFFSET 0 here to force this block to execute first, which is alot faster
    OFFSET 0
) AS resolved_targets
JOIN configurations c
    ON c.bazel_invocation_id = $4
    AND c.configuration_id = resolved_targets.config_id
JOIN invocation_targets it
    ON it.target_invocation_targets = resolved_targets.target_id
    AND it.invocation_target_configuration = c.id
    AND it.bazel_invocation_invocation_targets = $4
`

type CreateTestSummariesBulkParams struct {
	InstanceNameID    int64
	Labels            []string
	ConfigIds         []string
	BazelInvocationID int64
}

// STAGE 2: Join the rest using the specific Target IDs we found
func (q *Queries) CreateTestSummariesBulk(ctx context.Context, arg CreateTestSummariesBulkParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, createTestSummariesBulk,
		arg.InstanceNameID,
		pq.Array(arg.Labels),
		pq.Array(arg.ConfigIds),
		arg.BazelInvocationID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateTestSummariesBulk = `-- name: UpdateTestSummariesBulk :execrows
UPDATE test_summaries ts
SET
    overall_status = source.overall_status,
    total_run_count = source.total_run_count,
    run_count = source.run_count,
    attempt_count = source.attempt_count,
    shard_count = source.shard_count,
    total_num_cached = source.total_num_cached,
    first_start_time = source.first_start_time,
    last_stop_time = source.last_stop_time,
    total_run_duration_in_ms = source.total_run_duration_in_ms
FROM (
    SELECT
        it.id AS invocation_target_id,
        resolved_targets.overall_status,
        resolved_targets.total_run_count,
        resolved_targets.run_count,
        resolved_targets.attempt_count,
        resolved_targets.shard_count,
        resolved_targets.total_num_cached,
        resolved_targets.first_start_time,
        resolved_targets.last_stop_time,
        resolved_targets.total_run_duration_in_ms
    FROM (
        -- STAGE 1: Resolve Target IDs immediately using the Index
        SELECT
            input.config_id,
            input.overall_status,
            input.total_run_count,
            input.run_count,
            input.attempt_count,
            input.shard_count,
            input.total_num_cached,
            input.first_start_time,
            input.last_stop_time,
            input.total_run_duration_in_ms,
            t.id AS target_id
        FROM (
            SELECT
                $1::bigint as instance_name_id,
                unnest($2::text[]) as label,
                unnest($3::text[]) as config_id,
                unnest($4::text[]) as overall_status,
                unnest($5::int[]) as total_run_count,
                unnest($6::int[]) as run_count,
                unnest($7::int[]) as attempt_count,
                unnest($8::int[]) as shard_count,
                unnest($9::int[]) as total_num_cached,
                unnest($10::timestamptz[]) as first_start_time,
                unnest($11::timestamptz[]) as last_stop_time,
                unnest($12::bigint[]) as total_run_duration_in_ms
        ) AS input
        JOIN targets t
            ON t.instance_name_targets = input.instance_name_id
            AND t.label = input.label
            AND t.aspect = ''
        -- Optimization: Force this block to execute first
        OFFSET 0
    ) AS resolved_targets
    -- STAGE 2: Join the rest using the specific Target IDs we found
    JOIN configurations c
        ON c.bazel_invocation_id = $13
        AND c.configuration_id = resolved_targets.config_id
    JOIN invocation_targets it
        ON it.target_invocation_targets = resolved_targets.target_id
        AND it.invocation_target_configuration = c.id
        AND it.bazel_invocation_invocation_targets = $13
) AS source
WHERE 
    ts.invocation_target_test_summary = source.invocation_target_id
`

type UpdateTestSummariesBulkParams struct {
	InstanceNameID    int64
	Labels            []string
	ConfigIds         []string
	OverallStatuses   []string
	TotalRunCounts    []int32
	RunCounts         []int32
	AttemptCounts     []int32
	ShardCounts       []int32
	TotalNumCacheds   []int32
	StartTimes        []time.Time
	StopTimes         []time.Time
	Durations         []int64
	BazelInvocationID int64
}

func (q *Queries) UpdateTestSummariesBulk(ctx context.Context, arg UpdateTestSummariesBulkParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateTestSummariesBulk,
		arg.InstanceNameID,
		pq.Array(arg.Labels),
		pq.Array(arg.ConfigIds),
		pq.Array(arg.OverallStatuses),
		pq.Array(arg.TotalRunCounts),
		pq.Array(arg.RunCounts),
		pq.Array(arg.AttemptCounts),
		pq.Array(arg.ShardCounts),
		pq.Array(arg.TotalNumCacheds),
		pq.Array(arg.StartTimes),
		pq.Array(arg.StopTimes),
		pq.Array(arg.Durations),
		arg.BazelInvocationID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
