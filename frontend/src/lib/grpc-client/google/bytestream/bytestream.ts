// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               v3.19.1
// source: google/bytestream/bytestream.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { type CallContext, type CallOptions } from "nice-grpc-common";

export const protobufPackage = "google.bytestream";

/** Request object for ByteStream.Read. */
export interface ReadRequest {
  /** The name of the resource to read. */
  resourceName: string;
  /**
   * The offset for the first byte to return in the read, relative to the start
   * of the resource.
   *
   * A `read_offset` that is negative or greater than the size of the resource
   * will cause an `OUT_OF_RANGE` error.
   */
  readOffset: string;
  /**
   * The maximum number of `data` bytes the server is allowed to return in the
   * sum of all `ReadResponse` messages. A `read_limit` of zero indicates that
   * there is no limit, and a negative `read_limit` will cause an error.
   *
   * If the stream returns fewer bytes than allowed by the `read_limit` and no
   * error occurred, the stream includes all data from the `read_offset` to the
   * end of the resource.
   */
  readLimit: string;
}

/** Response object for ByteStream.Read. */
export interface ReadResponse {
  /**
   * A portion of the data for the resource. The service **may** leave `data`
   * empty for any given `ReadResponse`. This enables the service to inform the
   * client that the request is still live while it is running an operation to
   * generate more data.
   */
  data: Uint8Array;
}

/** Request object for ByteStream.Write. */
export interface WriteRequest {
  /**
   * The name of the resource to write. This **must** be set on the first
   * `WriteRequest` of each `Write()` action. If it is set on subsequent calls,
   * it **must** match the value of the first request.
   */
  resourceName: string;
  /**
   * The offset from the beginning of the resource at which the data should be
   * written. It is required on all `WriteRequest`s.
   *
   * In the first `WriteRequest` of a `Write()` action, it indicates
   * the initial offset for the `Write()` call. The value **must** be equal to
   * the `committed_size` that a call to `QueryWriteStatus()` would return.
   *
   * On subsequent calls, this value **must** be set and **must** be equal to
   * the sum of the first `write_offset` and the sizes of all `data` bundles
   * sent previously on this stream.
   *
   * An incorrect value will cause an error.
   */
  writeOffset: string;
  /**
   * If `true`, this indicates that the write is complete. Sending any
   * `WriteRequest`s subsequent to one in which `finish_write` is `true` will
   * cause an error.
   */
  finishWrite: boolean;
  /**
   * A portion of the data for the resource. The client **may** leave `data`
   * empty for any given `WriteRequest`. This enables the client to inform the
   * service that the request is still live while it is running an operation to
   * generate more data.
   */
  data: Uint8Array;
}

/** Response object for ByteStream.Write. */
export interface WriteResponse {
  /** The number of bytes that have been processed for the given resource. */
  committedSize: string;
}

/** Request object for ByteStream.QueryWriteStatus. */
export interface QueryWriteStatusRequest {
  /** The name of the resource whose write status is being requested. */
  resourceName: string;
}

/** Response object for ByteStream.QueryWriteStatus. */
export interface QueryWriteStatusResponse {
  /** The number of bytes that have been processed for the given resource. */
  committedSize: string;
  /**
   * `complete` is `true` only if the client has sent a `WriteRequest` with
   * `finish_write` set to true, and the server has processed that request.
   */
  complete: boolean;
}

function createBaseReadRequest(): ReadRequest {
  return { resourceName: "", readOffset: "0", readLimit: "0" };
}

export const ReadRequest: MessageFns<ReadRequest> = {
  encode(message: ReadRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resourceName !== "") {
      writer.uint32(10).string(message.resourceName);
    }
    if (message.readOffset !== "0") {
      writer.uint32(16).int64(message.readOffset);
    }
    if (message.readLimit !== "0") {
      writer.uint32(24).int64(message.readLimit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReadRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReadRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.resourceName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.readOffset = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.readLimit = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReadRequest {
    return {
      resourceName: isSet(object.resourceName) ? globalThis.String(object.resourceName) : "",
      readOffset: isSet(object.readOffset) ? globalThis.String(object.readOffset) : "0",
      readLimit: isSet(object.readLimit) ? globalThis.String(object.readLimit) : "0",
    };
  },

  toJSON(message: ReadRequest): unknown {
    const obj: any = {};
    if (message.resourceName !== "") {
      obj.resourceName = message.resourceName;
    }
    if (message.readOffset !== "0") {
      obj.readOffset = message.readOffset;
    }
    if (message.readLimit !== "0") {
      obj.readLimit = message.readLimit;
    }
    return obj;
  },

  create(base?: DeepPartial<ReadRequest>): ReadRequest {
    return ReadRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReadRequest>): ReadRequest {
    const message = createBaseReadRequest();
    message.resourceName = object.resourceName ?? "";
    message.readOffset = object.readOffset ?? "0";
    message.readLimit = object.readLimit ?? "0";
    return message;
  },
};

function createBaseReadResponse(): ReadResponse {
  return { data: new Uint8Array(0) };
}

export const ReadResponse: MessageFns<ReadResponse> = {
  encode(message: ReadResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data.length !== 0) {
      writer.uint32(82).bytes(message.data);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReadResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReadResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReadResponse {
    return { data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0) };
  },

  toJSON(message: ReadResponse): unknown {
    const obj: any = {};
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create(base?: DeepPartial<ReadResponse>): ReadResponse {
    return ReadResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReadResponse>): ReadResponse {
    const message = createBaseReadResponse();
    message.data = object.data ?? new Uint8Array(0);
    return message;
  },
};

function createBaseWriteRequest(): WriteRequest {
  return { resourceName: "", writeOffset: "0", finishWrite: false, data: new Uint8Array(0) };
}

export const WriteRequest: MessageFns<WriteRequest> = {
  encode(message: WriteRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resourceName !== "") {
      writer.uint32(10).string(message.resourceName);
    }
    if (message.writeOffset !== "0") {
      writer.uint32(16).int64(message.writeOffset);
    }
    if (message.finishWrite !== false) {
      writer.uint32(24).bool(message.finishWrite);
    }
    if (message.data.length !== 0) {
      writer.uint32(82).bytes(message.data);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WriteRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWriteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.resourceName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.writeOffset = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.finishWrite = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WriteRequest {
    return {
      resourceName: isSet(object.resourceName) ? globalThis.String(object.resourceName) : "",
      writeOffset: isSet(object.writeOffset) ? globalThis.String(object.writeOffset) : "0",
      finishWrite: isSet(object.finishWrite) ? globalThis.Boolean(object.finishWrite) : false,
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
    };
  },

  toJSON(message: WriteRequest): unknown {
    const obj: any = {};
    if (message.resourceName !== "") {
      obj.resourceName = message.resourceName;
    }
    if (message.writeOffset !== "0") {
      obj.writeOffset = message.writeOffset;
    }
    if (message.finishWrite !== false) {
      obj.finishWrite = message.finishWrite;
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create(base?: DeepPartial<WriteRequest>): WriteRequest {
    return WriteRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WriteRequest>): WriteRequest {
    const message = createBaseWriteRequest();
    message.resourceName = object.resourceName ?? "";
    message.writeOffset = object.writeOffset ?? "0";
    message.finishWrite = object.finishWrite ?? false;
    message.data = object.data ?? new Uint8Array(0);
    return message;
  },
};

function createBaseWriteResponse(): WriteResponse {
  return { committedSize: "0" };
}

export const WriteResponse: MessageFns<WriteResponse> = {
  encode(message: WriteResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.committedSize !== "0") {
      writer.uint32(8).int64(message.committedSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WriteResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWriteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.committedSize = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WriteResponse {
    return { committedSize: isSet(object.committedSize) ? globalThis.String(object.committedSize) : "0" };
  },

  toJSON(message: WriteResponse): unknown {
    const obj: any = {};
    if (message.committedSize !== "0") {
      obj.committedSize = message.committedSize;
    }
    return obj;
  },

  create(base?: DeepPartial<WriteResponse>): WriteResponse {
    return WriteResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WriteResponse>): WriteResponse {
    const message = createBaseWriteResponse();
    message.committedSize = object.committedSize ?? "0";
    return message;
  },
};

function createBaseQueryWriteStatusRequest(): QueryWriteStatusRequest {
  return { resourceName: "" };
}

export const QueryWriteStatusRequest: MessageFns<QueryWriteStatusRequest> = {
  encode(message: QueryWriteStatusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resourceName !== "") {
      writer.uint32(10).string(message.resourceName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryWriteStatusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryWriteStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.resourceName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryWriteStatusRequest {
    return { resourceName: isSet(object.resourceName) ? globalThis.String(object.resourceName) : "" };
  },

  toJSON(message: QueryWriteStatusRequest): unknown {
    const obj: any = {};
    if (message.resourceName !== "") {
      obj.resourceName = message.resourceName;
    }
    return obj;
  },

  create(base?: DeepPartial<QueryWriteStatusRequest>): QueryWriteStatusRequest {
    return QueryWriteStatusRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryWriteStatusRequest>): QueryWriteStatusRequest {
    const message = createBaseQueryWriteStatusRequest();
    message.resourceName = object.resourceName ?? "";
    return message;
  },
};

function createBaseQueryWriteStatusResponse(): QueryWriteStatusResponse {
  return { committedSize: "0", complete: false };
}

export const QueryWriteStatusResponse: MessageFns<QueryWriteStatusResponse> = {
  encode(message: QueryWriteStatusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.committedSize !== "0") {
      writer.uint32(8).int64(message.committedSize);
    }
    if (message.complete !== false) {
      writer.uint32(16).bool(message.complete);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryWriteStatusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryWriteStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.committedSize = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.complete = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryWriteStatusResponse {
    return {
      committedSize: isSet(object.committedSize) ? globalThis.String(object.committedSize) : "0",
      complete: isSet(object.complete) ? globalThis.Boolean(object.complete) : false,
    };
  },

  toJSON(message: QueryWriteStatusResponse): unknown {
    const obj: any = {};
    if (message.committedSize !== "0") {
      obj.committedSize = message.committedSize;
    }
    if (message.complete !== false) {
      obj.complete = message.complete;
    }
    return obj;
  },

  create(base?: DeepPartial<QueryWriteStatusResponse>): QueryWriteStatusResponse {
    return QueryWriteStatusResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryWriteStatusResponse>): QueryWriteStatusResponse {
    const message = createBaseQueryWriteStatusResponse();
    message.committedSize = object.committedSize ?? "0";
    message.complete = object.complete ?? false;
    return message;
  },
};

/**
 * #### Introduction
 *
 * The Byte Stream API enables a client to read and write a stream of bytes to
 * and from a resource. Resources have names, and these names are supplied in
 * the API calls below to identify the resource that is being read from or
 * written to.
 *
 * All implementations of the Byte Stream API export the interface defined here:
 *
 * * `Read()`: Reads the contents of a resource.
 *
 * * `Write()`: Writes the contents of a resource. The client can call `Write()`
 *   multiple times with the same resource and can check the status of the write
 *   by calling `QueryWriteStatus()`.
 *
 * #### Service parameters and metadata
 *
 * The ByteStream API provides no direct way to access/modify any metadata
 * associated with the resource.
 *
 * #### Errors
 *
 * The errors returned by the service are in the Google canonical error space.
 */
export type ByteStreamDefinition = typeof ByteStreamDefinition;
export const ByteStreamDefinition = {
  name: "ByteStream",
  fullName: "google.bytestream.ByteStream",
  methods: {
    /**
     * `Read()` is used to retrieve the contents of a resource as a sequence
     * of bytes. The bytes are returned in a sequence of responses, and the
     * responses are delivered as the results of a server-side streaming RPC.
     */
    read: {
      name: "Read",
      requestType: ReadRequest,
      requestStream: false,
      responseType: ReadResponse,
      responseStream: true,
      options: {},
    },
    /**
     * `Write()` is used to send the contents of a resource as a sequence of
     * bytes. The bytes are sent in a sequence of request protos of a client-side
     * streaming RPC.
     *
     * A `Write()` action is resumable. If there is an error or the connection is
     * broken during the `Write()`, the client should check the status of the
     * `Write()` by calling `QueryWriteStatus()` and continue writing from the
     * returned `committed_size`. This may be less than the amount of data the
     * client previously sent.
     *
     * Calling `Write()` on a resource name that was previously written and
     * finalized could cause an error, depending on whether the underlying service
     * allows over-writing of previously written resources.
     *
     * When the client closes the request channel, the service will respond with
     * a `WriteResponse`. The service will not view the resource as `complete`
     * until the client has sent a `WriteRequest` with `finish_write` set to
     * `true`. Sending any requests on a stream after sending a request with
     * `finish_write` set to `true` will cause an error. The client **should**
     * check the `WriteResponse` it receives to determine how much data the
     * service was able to commit and whether the service views the resource as
     * `complete` or not.
     */
    write: {
      name: "Write",
      requestType: WriteRequest,
      requestStream: true,
      responseType: WriteResponse,
      responseStream: false,
      options: {},
    },
    /**
     * `QueryWriteStatus()` is used to find the `committed_size` for a resource
     * that is being written, which can then be used as the `write_offset` for
     * the next `Write()` call.
     *
     * If the resource does not exist (i.e., the resource has been deleted, or the
     * first `Write()` has not yet reached the service), this method returns the
     * error `NOT_FOUND`.
     *
     * The client **may** call `QueryWriteStatus()` at any time to determine how
     * much data has been processed for this resource. This is useful if the
     * client is buffering data and needs to know which data can be safely
     * evicted. For any sequence of `QueryWriteStatus()` calls for a given
     * resource name, the sequence of returned `committed_size` values will be
     * non-decreasing.
     */
    queryWriteStatus: {
      name: "QueryWriteStatus",
      requestType: QueryWriteStatusRequest,
      requestStream: false,
      responseType: QueryWriteStatusResponse,
      responseStream: false,
      options: {},
    },
  },
} as const;

export interface ByteStreamServiceImplementation<CallContextExt = {}> {
  /**
   * `Read()` is used to retrieve the contents of a resource as a sequence
   * of bytes. The bytes are returned in a sequence of responses, and the
   * responses are delivered as the results of a server-side streaming RPC.
   */
  read(
    request: ReadRequest,
    context: CallContext & CallContextExt,
  ): ServerStreamingMethodResult<DeepPartial<ReadResponse>>;
  /**
   * `Write()` is used to send the contents of a resource as a sequence of
   * bytes. The bytes are sent in a sequence of request protos of a client-side
   * streaming RPC.
   *
   * A `Write()` action is resumable. If there is an error or the connection is
   * broken during the `Write()`, the client should check the status of the
   * `Write()` by calling `QueryWriteStatus()` and continue writing from the
   * returned `committed_size`. This may be less than the amount of data the
   * client previously sent.
   *
   * Calling `Write()` on a resource name that was previously written and
   * finalized could cause an error, depending on whether the underlying service
   * allows over-writing of previously written resources.
   *
   * When the client closes the request channel, the service will respond with
   * a `WriteResponse`. The service will not view the resource as `complete`
   * until the client has sent a `WriteRequest` with `finish_write` set to
   * `true`. Sending any requests on a stream after sending a request with
   * `finish_write` set to `true` will cause an error. The client **should**
   * check the `WriteResponse` it receives to determine how much data the
   * service was able to commit and whether the service views the resource as
   * `complete` or not.
   */
  write(
    request: AsyncIterable<WriteRequest>,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<WriteResponse>>;
  /**
   * `QueryWriteStatus()` is used to find the `committed_size` for a resource
   * that is being written, which can then be used as the `write_offset` for
   * the next `Write()` call.
   *
   * If the resource does not exist (i.e., the resource has been deleted, or the
   * first `Write()` has not yet reached the service), this method returns the
   * error `NOT_FOUND`.
   *
   * The client **may** call `QueryWriteStatus()` at any time to determine how
   * much data has been processed for this resource. This is useful if the
   * client is buffering data and needs to know which data can be safely
   * evicted. For any sequence of `QueryWriteStatus()` calls for a given
   * resource name, the sequence of returned `committed_size` values will be
   * non-decreasing.
   */
  queryWriteStatus(
    request: QueryWriteStatusRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<QueryWriteStatusResponse>>;
}

export interface ByteStreamClient<CallOptionsExt = {}> {
  /**
   * `Read()` is used to retrieve the contents of a resource as a sequence
   * of bytes. The bytes are returned in a sequence of responses, and the
   * responses are delivered as the results of a server-side streaming RPC.
   */
  read(request: DeepPartial<ReadRequest>, options?: CallOptions & CallOptionsExt): AsyncIterable<ReadResponse>;
  /**
   * `Write()` is used to send the contents of a resource as a sequence of
   * bytes. The bytes are sent in a sequence of request protos of a client-side
   * streaming RPC.
   *
   * A `Write()` action is resumable. If there is an error or the connection is
   * broken during the `Write()`, the client should check the status of the
   * `Write()` by calling `QueryWriteStatus()` and continue writing from the
   * returned `committed_size`. This may be less than the amount of data the
   * client previously sent.
   *
   * Calling `Write()` on a resource name that was previously written and
   * finalized could cause an error, depending on whether the underlying service
   * allows over-writing of previously written resources.
   *
   * When the client closes the request channel, the service will respond with
   * a `WriteResponse`. The service will not view the resource as `complete`
   * until the client has sent a `WriteRequest` with `finish_write` set to
   * `true`. Sending any requests on a stream after sending a request with
   * `finish_write` set to `true` will cause an error. The client **should**
   * check the `WriteResponse` it receives to determine how much data the
   * service was able to commit and whether the service views the resource as
   * `complete` or not.
   */
  write(
    request: AsyncIterable<DeepPartial<WriteRequest>>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<WriteResponse>;
  /**
   * `QueryWriteStatus()` is used to find the `committed_size` for a resource
   * that is being written, which can then be used as the `write_offset` for
   * the next `Write()` call.
   *
   * If the resource does not exist (i.e., the resource has been deleted, or the
   * first `Write()` has not yet reached the service), this method returns the
   * error `NOT_FOUND`.
   *
   * The client **may** call `QueryWriteStatus()` at any time to determine how
   * much data has been processed for this resource. This is useful if the
   * client is buffering data and needs to know which data can be safely
   * evicted. For any sequence of `QueryWriteStatus()` calls for a given
   * resource name, the sequence of returned `committed_size` values will be
   * non-decreasing.
   */
  queryWriteStatus(
    request: DeepPartial<QueryWriteStatusRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<QueryWriteStatusResponse>;
}

function bytesFromBase64(b64: string): Uint8Array {
  const bin = globalThis.atob(b64);
  const arr = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; ++i) {
    arr[i] = bin.charCodeAt(i);
  }
  return arr;
}

function base64FromBytes(arr: Uint8Array): string {
  const bin: string[] = [];
  arr.forEach((byte) => {
    bin.push(globalThis.String.fromCharCode(byte));
  });
  return globalThis.btoa(bin.join(""));
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export type ServerStreamingMethodResult<Response> = { [Symbol.asyncIterator](): AsyncIterator<Response, void> };

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
