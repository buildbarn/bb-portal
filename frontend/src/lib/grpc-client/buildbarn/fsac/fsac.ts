// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               v3.19.1
// source: buildbarn/fsac/fsac.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import {
  Digest,
  DigestFunction_Value,
  digestFunction_ValueFromJSON,
  digestFunction_ValueToJSON,
} from "../../build/bazel/remote/execution/v2/remote_execution";
import { Empty } from "../../google/protobuf/empty";

export const protobufPackage = "buildbarn.fsac";

/** The file system access profile of a build action. */
export interface FileSystemAccessProfile {
  /**
   * A Bloom filter that captures paths of regular files and directories
   * in the input root whose contents have been read. In case files with
   * the same digest are present in the input root multiple times, there
   * is no guarantee that all paths are added to the Bloom filter.
   *
   * This Bloom filter can be used by workers to perform readahead of
   * Content Addressable Storage (CAS) objects, thereby reducing the
   * probability of execution of actions getting suspended to load data
   * over the network.
   *
   * Hashes are computed by taking the FNV-1a hash of the path in the
   * input root, modulo the size of the Bloom filter. The path uses the
   * following pattern:
   *
   *     (/${filename})* /*
   *
   * This means that the root directory uses the empty path. A file
   * contained in the root directory may use path "/hello.txt". Between
   * [0, k) trailing slashes are added to the path to obtain k
   * independent hashes.
   *
   * The size of the Bloom filter in bits (m) SHOULD be prime. To be
   * able to reobtain the exact size in bits, the bits in the final byte
   * are terminated with a 1 bit, followed by zero or more 0 bits.
   */
  bloomFilter: Uint8Array;
  /**
   * The number of hash functions (k) that should be considered when
   * querying the Bloom filter.
   */
  bloomFilterHashFunctions: number;
}

export interface GetFileSystemAccessProfileRequest {
  /** The instance of the execution system to operate against. */
  instanceName: string;
  /** The digest function that was used to compute the reduced action digest. */
  digestFunction: DigestFunction_Value;
  /**
   * The digest of a trimmed down Action message for which a file system
   * access profile is requested. This digest is obtained by removing
   * all fields from the original Action, except for 'command_digest'
   * and 'platform'.
   *
   * This means that contents of the input root, the Action's timeout
   * and the do_not_cache flag are ignored.
   */
  reducedActionDigest: Digest | undefined;
}

export interface UpdateFileSystemAccessProfileRequest {
  /** The instance of the execution system to operate against. */
  instanceName: string;
  /** The digest function that was used to compute the reduced action digest. */
  digestFunction: DigestFunction_Value;
  /**
   * The digest of a trimmed down Action message for which a file system
   * access profile is being stored.
   */
  reducedActionDigest:
    | Digest
    | undefined;
  /** The file system access profile to store. */
  fileSystemAccessProfile: FileSystemAccessProfile | undefined;
}

function createBaseFileSystemAccessProfile(): FileSystemAccessProfile {
  return { bloomFilter: new Uint8Array(0), bloomFilterHashFunctions: 0 };
}

export const FileSystemAccessProfile: MessageFns<FileSystemAccessProfile> = {
  encode(message: FileSystemAccessProfile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bloomFilter.length !== 0) {
      writer.uint32(10).bytes(message.bloomFilter);
    }
    if (message.bloomFilterHashFunctions !== 0) {
      writer.uint32(16).uint32(message.bloomFilterHashFunctions);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FileSystemAccessProfile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileSystemAccessProfile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bloomFilter = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.bloomFilterHashFunctions = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileSystemAccessProfile {
    return {
      bloomFilter: isSet(object.bloomFilter) ? bytesFromBase64(object.bloomFilter) : new Uint8Array(0),
      bloomFilterHashFunctions: isSet(object.bloomFilterHashFunctions)
        ? globalThis.Number(object.bloomFilterHashFunctions)
        : 0,
    };
  },

  toJSON(message: FileSystemAccessProfile): unknown {
    const obj: any = {};
    if (message.bloomFilter.length !== 0) {
      obj.bloomFilter = base64FromBytes(message.bloomFilter);
    }
    if (message.bloomFilterHashFunctions !== 0) {
      obj.bloomFilterHashFunctions = Math.round(message.bloomFilterHashFunctions);
    }
    return obj;
  },

  create(base?: DeepPartial<FileSystemAccessProfile>): FileSystemAccessProfile {
    return FileSystemAccessProfile.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FileSystemAccessProfile>): FileSystemAccessProfile {
    const message = createBaseFileSystemAccessProfile();
    message.bloomFilter = object.bloomFilter ?? new Uint8Array(0);
    message.bloomFilterHashFunctions = object.bloomFilterHashFunctions ?? 0;
    return message;
  },
};

function createBaseGetFileSystemAccessProfileRequest(): GetFileSystemAccessProfileRequest {
  return { instanceName: "", digestFunction: 0, reducedActionDigest: undefined };
}

export const GetFileSystemAccessProfileRequest: MessageFns<GetFileSystemAccessProfileRequest> = {
  encode(message: GetFileSystemAccessProfileRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.instanceName !== "") {
      writer.uint32(10).string(message.instanceName);
    }
    if (message.digestFunction !== 0) {
      writer.uint32(16).int32(message.digestFunction);
    }
    if (message.reducedActionDigest !== undefined) {
      Digest.encode(message.reducedActionDigest, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetFileSystemAccessProfileRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFileSystemAccessProfileRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.instanceName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.digestFunction = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reducedActionDigest = Digest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetFileSystemAccessProfileRequest {
    return {
      instanceName: isSet(object.instanceName) ? globalThis.String(object.instanceName) : "",
      digestFunction: isSet(object.digestFunction) ? digestFunction_ValueFromJSON(object.digestFunction) : 0,
      reducedActionDigest: isSet(object.reducedActionDigest) ? Digest.fromJSON(object.reducedActionDigest) : undefined,
    };
  },

  toJSON(message: GetFileSystemAccessProfileRequest): unknown {
    const obj: any = {};
    if (message.instanceName !== "") {
      obj.instanceName = message.instanceName;
    }
    if (message.digestFunction !== 0) {
      obj.digestFunction = digestFunction_ValueToJSON(message.digestFunction);
    }
    if (message.reducedActionDigest !== undefined) {
      obj.reducedActionDigest = Digest.toJSON(message.reducedActionDigest);
    }
    return obj;
  },

  create(base?: DeepPartial<GetFileSystemAccessProfileRequest>): GetFileSystemAccessProfileRequest {
    return GetFileSystemAccessProfileRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetFileSystemAccessProfileRequest>): GetFileSystemAccessProfileRequest {
    const message = createBaseGetFileSystemAccessProfileRequest();
    message.instanceName = object.instanceName ?? "";
    message.digestFunction = object.digestFunction ?? 0;
    message.reducedActionDigest = (object.reducedActionDigest !== undefined && object.reducedActionDigest !== null)
      ? Digest.fromPartial(object.reducedActionDigest)
      : undefined;
    return message;
  },
};

function createBaseUpdateFileSystemAccessProfileRequest(): UpdateFileSystemAccessProfileRequest {
  return { instanceName: "", digestFunction: 0, reducedActionDigest: undefined, fileSystemAccessProfile: undefined };
}

export const UpdateFileSystemAccessProfileRequest: MessageFns<UpdateFileSystemAccessProfileRequest> = {
  encode(message: UpdateFileSystemAccessProfileRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.instanceName !== "") {
      writer.uint32(10).string(message.instanceName);
    }
    if (message.digestFunction !== 0) {
      writer.uint32(16).int32(message.digestFunction);
    }
    if (message.reducedActionDigest !== undefined) {
      Digest.encode(message.reducedActionDigest, writer.uint32(26).fork()).join();
    }
    if (message.fileSystemAccessProfile !== undefined) {
      FileSystemAccessProfile.encode(message.fileSystemAccessProfile, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateFileSystemAccessProfileRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateFileSystemAccessProfileRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.instanceName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.digestFunction = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reducedActionDigest = Digest.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.fileSystemAccessProfile = FileSystemAccessProfile.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateFileSystemAccessProfileRequest {
    return {
      instanceName: isSet(object.instanceName) ? globalThis.String(object.instanceName) : "",
      digestFunction: isSet(object.digestFunction) ? digestFunction_ValueFromJSON(object.digestFunction) : 0,
      reducedActionDigest: isSet(object.reducedActionDigest) ? Digest.fromJSON(object.reducedActionDigest) : undefined,
      fileSystemAccessProfile: isSet(object.fileSystemAccessProfile)
        ? FileSystemAccessProfile.fromJSON(object.fileSystemAccessProfile)
        : undefined,
    };
  },

  toJSON(message: UpdateFileSystemAccessProfileRequest): unknown {
    const obj: any = {};
    if (message.instanceName !== "") {
      obj.instanceName = message.instanceName;
    }
    if (message.digestFunction !== 0) {
      obj.digestFunction = digestFunction_ValueToJSON(message.digestFunction);
    }
    if (message.reducedActionDigest !== undefined) {
      obj.reducedActionDigest = Digest.toJSON(message.reducedActionDigest);
    }
    if (message.fileSystemAccessProfile !== undefined) {
      obj.fileSystemAccessProfile = FileSystemAccessProfile.toJSON(message.fileSystemAccessProfile);
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateFileSystemAccessProfileRequest>): UpdateFileSystemAccessProfileRequest {
    return UpdateFileSystemAccessProfileRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateFileSystemAccessProfileRequest>): UpdateFileSystemAccessProfileRequest {
    const message = createBaseUpdateFileSystemAccessProfileRequest();
    message.instanceName = object.instanceName ?? "";
    message.digestFunction = object.digestFunction ?? 0;
    message.reducedActionDigest = (object.reducedActionDigest !== undefined && object.reducedActionDigest !== null)
      ? Digest.fromPartial(object.reducedActionDigest)
      : undefined;
    message.fileSystemAccessProfile =
      (object.fileSystemAccessProfile !== undefined && object.fileSystemAccessProfile !== null)
        ? FileSystemAccessProfile.fromPartial(object.fileSystemAccessProfile)
        : undefined;
    return message;
  },
};

/**
 * The File System Access Cache (FSAC) is a Buildbarn specific data
 * store that workers can use to store information on how build actions
 * access the data stored in the input root. This information can be
 * used during subsequent executions of similar actions to speed up file
 * system access.
 */
export type FileSystemAccessCacheDefinition = typeof FileSystemAccessCacheDefinition;
export const FileSystemAccessCacheDefinition = {
  name: "FileSystemAccessCache",
  fullName: "buildbarn.fsac.FileSystemAccessCache",
  methods: {
    /**
     * GetFileSystemAccessProfile() reads a single FileSystemAccessProfile
     * from the FSAC.
     */
    getFileSystemAccessProfile: {
      name: "GetFileSystemAccessProfile",
      requestType: GetFileSystemAccessProfileRequest,
      requestStream: false,
      responseType: FileSystemAccessProfile,
      responseStream: false,
      options: {},
    },
    /**
     * UpdateFileSystemAccessProfile() writes a single
     * FileSystemAccessProfile message into the FSAC.
     */
    updateFileSystemAccessProfile: {
      name: "UpdateFileSystemAccessProfile",
      requestType: UpdateFileSystemAccessProfileRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
  },
} as const;

export interface FileSystemAccessCacheServiceImplementation<CallContextExt = {}> {
  /**
   * GetFileSystemAccessProfile() reads a single FileSystemAccessProfile
   * from the FSAC.
   */
  getFileSystemAccessProfile(
    request: GetFileSystemAccessProfileRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<FileSystemAccessProfile>>;
  /**
   * UpdateFileSystemAccessProfile() writes a single
   * FileSystemAccessProfile message into the FSAC.
   */
  updateFileSystemAccessProfile(
    request: UpdateFileSystemAccessProfileRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
}

export interface FileSystemAccessCacheClient<CallOptionsExt = {}> {
  /**
   * GetFileSystemAccessProfile() reads a single FileSystemAccessProfile
   * from the FSAC.
   */
  getFileSystemAccessProfile(
    request: DeepPartial<GetFileSystemAccessProfileRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<FileSystemAccessProfile>;
  /**
   * UpdateFileSystemAccessProfile() writes a single
   * FileSystemAccessProfile message into the FSAC.
   */
  updateFileSystemAccessProfile(
    request: DeepPartial<UpdateFileSystemAccessProfileRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
}

function bytesFromBase64(b64: string): Uint8Array {
  const bin = globalThis.atob(b64);
  const arr = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; ++i) {
    arr[i] = bin.charCodeAt(i);
  }
  return arr;
}

function base64FromBytes(arr: Uint8Array): string {
  const bin: string[] = [];
  arr.forEach((byte) => {
    bin.push(globalThis.String.fromCharCode(byte));
  });
  return globalThis.btoa(bin.join(""));
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
