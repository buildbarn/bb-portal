// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               v3.19.1
// source: buildbarn/resourceusage/resourceusage.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Duration } from "../../google/protobuf/duration";

export const protobufPackage = "buildbarn.resourceusage";

/**
 * File pool resource usage statistics. File pools are used by bb_worker
 * to allocate temporary files that are created by build actions.
 * Temporary files include output files created through the FUSE file
 * system.
 */
export interface FilePoolResourceUsage {
  /** Total number of files created. */
  filesCreated: string;
  /** Maximum number of files that existed at some point in time. */
  filesCountPeak: string;
  /** Maximum total size of all files at some point in time. */
  filesSizeBytesPeak: string;
  /** Total number of ReadAt() calls performed. */
  readsCount: string;
  /** Total amount of data returned by all ReadAt() calls. */
  readsSizeBytes: string;
  /** Total number of WriteAt() calls performed. */
  writesCount: string;
  /** Total amount of data processed by all WriteAt() calls. */
  writesSizeBytes: string;
  /** Total number of Truncate() calls performed. */
  truncatesCount: string;
}

/**
 * The equivalent of 'struct rusage' in POSIX, generally returned by
 * getrusage(2) or wait4(2).
 */
export interface POSIXResourceUsage {
  /** ru_utime: Amount of CPU time in seconds spent in userspace. */
  userTime:
    | Duration
    | undefined;
  /** ru_stime: Amount of CPU time in seconds spent in kernelspace. */
  systemTime:
    | Duration
    | undefined;
  /** ru_maxrss: Maximum amount of resident memory in bytes. */
  maximumResidentSetSize: string;
  /** ru_minflt: Page reclaims. */
  pageReclaims: string;
  /** ru_majflt: Page faults. */
  pageFaults: string;
  /** ru_nswap: Number of swaps. */
  swaps: string;
  /** ru_inblock: Block input operations. */
  blockInputOperations: string;
  /** ru_oublock: Block output operations. */
  blockOutputOperations: string;
  /** ru_msgsnd: Messages sent. */
  messagesSent: string;
  /** ru_msgrcv: Messages received. */
  messagesReceived: string;
  /** ru_nsignals: Signals received. */
  signalsReceived: string;
  /** ru_nvcsw: Voluntary context switches. */
  voluntaryContextSwitches: string;
  /** ru_nivcsw: Involuntary context switches. */
  involuntaryContextSwitches: string;
  /**
   * If abnormal process termination occurred, the name of the signal
   * that was delivered, without the "SIG" prefix (e.g., "BUS", "KILL",
   * "SEGV").
   *
   * Abnormal process termination can occur by calling abort(), or by
   * receiving a signal for which no signal handler is installed.
   */
  terminationSignal: string;
}

/**
 * A representation of unique factors that may be aggregated to
 * compute a given build action's total price.
 */
export interface MonetaryResourceUsage {
  /** A mapping of expense categories to their respective costs. */
  expenses: { [key: string]: MonetaryResourceUsage_Expense };
}

export interface MonetaryResourceUsage_Expense {
  /**
   * The type of currency the cost is measured in. Required to be in
   * ISO 4217 format: https://en.wikipedia.org/wiki/ISO_4217#Active_codes
   */
  currency: string;
  /** The value of a specific expense for a build action. */
  cost: number;
}

export interface MonetaryResourceUsage_ExpensesEntry {
  key: string;
  value: MonetaryResourceUsage_Expense | undefined;
}

/**
 * Input root resource usage statistics. These statistics indicate how
 * many directories and files inside the virtual file system were
 * accessed. These statistics are only reported if prefetching is
 * enabled, as they are computed together with the Bloom filter.
 */
export interface InputRootResourceUsage {
  /**
   * The number of directories in the input root that have been
   * resolved. This equates to the total number of directories that are
   * present in all directories that have been read.
   */
  directoriesResolved: string;
  /**
   * The number of directories whose contents have been read from the
   * Content Addressable Storage (CAS).
   */
  directoriesRead: string;
  /**
   * The number of files whose contents have been read from the Content
   * Addressable Storage (CAS).
   */
  filesRead: string;
}

function createBaseFilePoolResourceUsage(): FilePoolResourceUsage {
  return {
    filesCreated: "0",
    filesCountPeak: "0",
    filesSizeBytesPeak: "0",
    readsCount: "0",
    readsSizeBytes: "0",
    writesCount: "0",
    writesSizeBytes: "0",
    truncatesCount: "0",
  };
}

export const FilePoolResourceUsage: MessageFns<FilePoolResourceUsage> = {
  encode(message: FilePoolResourceUsage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filesCreated !== "0") {
      writer.uint32(8).uint64(message.filesCreated);
    }
    if (message.filesCountPeak !== "0") {
      writer.uint32(16).uint64(message.filesCountPeak);
    }
    if (message.filesSizeBytesPeak !== "0") {
      writer.uint32(24).uint64(message.filesSizeBytesPeak);
    }
    if (message.readsCount !== "0") {
      writer.uint32(32).uint64(message.readsCount);
    }
    if (message.readsSizeBytes !== "0") {
      writer.uint32(40).uint64(message.readsSizeBytes);
    }
    if (message.writesCount !== "0") {
      writer.uint32(48).uint64(message.writesCount);
    }
    if (message.writesSizeBytes !== "0") {
      writer.uint32(56).uint64(message.writesSizeBytes);
    }
    if (message.truncatesCount !== "0") {
      writer.uint32(64).uint64(message.truncatesCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FilePoolResourceUsage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFilePoolResourceUsage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.filesCreated = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.filesCountPeak = reader.uint64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.filesSizeBytesPeak = reader.uint64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.readsCount = reader.uint64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.readsSizeBytes = reader.uint64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.writesCount = reader.uint64().toString();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.writesSizeBytes = reader.uint64().toString();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.truncatesCount = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FilePoolResourceUsage {
    return {
      filesCreated: isSet(object.filesCreated) ? globalThis.String(object.filesCreated) : "0",
      filesCountPeak: isSet(object.filesCountPeak) ? globalThis.String(object.filesCountPeak) : "0",
      filesSizeBytesPeak: isSet(object.filesSizeBytesPeak) ? globalThis.String(object.filesSizeBytesPeak) : "0",
      readsCount: isSet(object.readsCount) ? globalThis.String(object.readsCount) : "0",
      readsSizeBytes: isSet(object.readsSizeBytes) ? globalThis.String(object.readsSizeBytes) : "0",
      writesCount: isSet(object.writesCount) ? globalThis.String(object.writesCount) : "0",
      writesSizeBytes: isSet(object.writesSizeBytes) ? globalThis.String(object.writesSizeBytes) : "0",
      truncatesCount: isSet(object.truncatesCount) ? globalThis.String(object.truncatesCount) : "0",
    };
  },

  toJSON(message: FilePoolResourceUsage): unknown {
    const obj: any = {};
    if (message.filesCreated !== "0") {
      obj.filesCreated = message.filesCreated;
    }
    if (message.filesCountPeak !== "0") {
      obj.filesCountPeak = message.filesCountPeak;
    }
    if (message.filesSizeBytesPeak !== "0") {
      obj.filesSizeBytesPeak = message.filesSizeBytesPeak;
    }
    if (message.readsCount !== "0") {
      obj.readsCount = message.readsCount;
    }
    if (message.readsSizeBytes !== "0") {
      obj.readsSizeBytes = message.readsSizeBytes;
    }
    if (message.writesCount !== "0") {
      obj.writesCount = message.writesCount;
    }
    if (message.writesSizeBytes !== "0") {
      obj.writesSizeBytes = message.writesSizeBytes;
    }
    if (message.truncatesCount !== "0") {
      obj.truncatesCount = message.truncatesCount;
    }
    return obj;
  },

  create(base?: DeepPartial<FilePoolResourceUsage>): FilePoolResourceUsage {
    return FilePoolResourceUsage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FilePoolResourceUsage>): FilePoolResourceUsage {
    const message = createBaseFilePoolResourceUsage();
    message.filesCreated = object.filesCreated ?? "0";
    message.filesCountPeak = object.filesCountPeak ?? "0";
    message.filesSizeBytesPeak = object.filesSizeBytesPeak ?? "0";
    message.readsCount = object.readsCount ?? "0";
    message.readsSizeBytes = object.readsSizeBytes ?? "0";
    message.writesCount = object.writesCount ?? "0";
    message.writesSizeBytes = object.writesSizeBytes ?? "0";
    message.truncatesCount = object.truncatesCount ?? "0";
    return message;
  },
};

function createBasePOSIXResourceUsage(): POSIXResourceUsage {
  return {
    userTime: undefined,
    systemTime: undefined,
    maximumResidentSetSize: "0",
    pageReclaims: "0",
    pageFaults: "0",
    swaps: "0",
    blockInputOperations: "0",
    blockOutputOperations: "0",
    messagesSent: "0",
    messagesReceived: "0",
    signalsReceived: "0",
    voluntaryContextSwitches: "0",
    involuntaryContextSwitches: "0",
    terminationSignal: "",
  };
}

export const POSIXResourceUsage: MessageFns<POSIXResourceUsage> = {
  encode(message: POSIXResourceUsage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userTime !== undefined) {
      Duration.encode(message.userTime, writer.uint32(10).fork()).join();
    }
    if (message.systemTime !== undefined) {
      Duration.encode(message.systemTime, writer.uint32(18).fork()).join();
    }
    if (message.maximumResidentSetSize !== "0") {
      writer.uint32(24).int64(message.maximumResidentSetSize);
    }
    if (message.pageReclaims !== "0") {
      writer.uint32(56).int64(message.pageReclaims);
    }
    if (message.pageFaults !== "0") {
      writer.uint32(64).int64(message.pageFaults);
    }
    if (message.swaps !== "0") {
      writer.uint32(72).int64(message.swaps);
    }
    if (message.blockInputOperations !== "0") {
      writer.uint32(80).int64(message.blockInputOperations);
    }
    if (message.blockOutputOperations !== "0") {
      writer.uint32(88).int64(message.blockOutputOperations);
    }
    if (message.messagesSent !== "0") {
      writer.uint32(96).int64(message.messagesSent);
    }
    if (message.messagesReceived !== "0") {
      writer.uint32(104).int64(message.messagesReceived);
    }
    if (message.signalsReceived !== "0") {
      writer.uint32(112).int64(message.signalsReceived);
    }
    if (message.voluntaryContextSwitches !== "0") {
      writer.uint32(120).int64(message.voluntaryContextSwitches);
    }
    if (message.involuntaryContextSwitches !== "0") {
      writer.uint32(128).int64(message.involuntaryContextSwitches);
    }
    if (message.terminationSignal !== "") {
      writer.uint32(138).string(message.terminationSignal);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): POSIXResourceUsage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePOSIXResourceUsage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userTime = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.systemTime = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.maximumResidentSetSize = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.pageReclaims = reader.int64().toString();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.pageFaults = reader.int64().toString();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.swaps = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.blockInputOperations = reader.int64().toString();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.blockOutputOperations = reader.int64().toString();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.messagesSent = reader.int64().toString();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.messagesReceived = reader.int64().toString();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.signalsReceived = reader.int64().toString();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.voluntaryContextSwitches = reader.int64().toString();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.involuntaryContextSwitches = reader.int64().toString();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.terminationSignal = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): POSIXResourceUsage {
    return {
      userTime: isSet(object.userTime) ? Duration.fromJSON(object.userTime) : undefined,
      systemTime: isSet(object.systemTime) ? Duration.fromJSON(object.systemTime) : undefined,
      maximumResidentSetSize: isSet(object.maximumResidentSetSize)
        ? globalThis.String(object.maximumResidentSetSize)
        : "0",
      pageReclaims: isSet(object.pageReclaims) ? globalThis.String(object.pageReclaims) : "0",
      pageFaults: isSet(object.pageFaults) ? globalThis.String(object.pageFaults) : "0",
      swaps: isSet(object.swaps) ? globalThis.String(object.swaps) : "0",
      blockInputOperations: isSet(object.blockInputOperations) ? globalThis.String(object.blockInputOperations) : "0",
      blockOutputOperations: isSet(object.blockOutputOperations)
        ? globalThis.String(object.blockOutputOperations)
        : "0",
      messagesSent: isSet(object.messagesSent) ? globalThis.String(object.messagesSent) : "0",
      messagesReceived: isSet(object.messagesReceived) ? globalThis.String(object.messagesReceived) : "0",
      signalsReceived: isSet(object.signalsReceived) ? globalThis.String(object.signalsReceived) : "0",
      voluntaryContextSwitches: isSet(object.voluntaryContextSwitches)
        ? globalThis.String(object.voluntaryContextSwitches)
        : "0",
      involuntaryContextSwitches: isSet(object.involuntaryContextSwitches)
        ? globalThis.String(object.involuntaryContextSwitches)
        : "0",
      terminationSignal: isSet(object.terminationSignal) ? globalThis.String(object.terminationSignal) : "",
    };
  },

  toJSON(message: POSIXResourceUsage): unknown {
    const obj: any = {};
    if (message.userTime !== undefined) {
      obj.userTime = Duration.toJSON(message.userTime);
    }
    if (message.systemTime !== undefined) {
      obj.systemTime = Duration.toJSON(message.systemTime);
    }
    if (message.maximumResidentSetSize !== "0") {
      obj.maximumResidentSetSize = message.maximumResidentSetSize;
    }
    if (message.pageReclaims !== "0") {
      obj.pageReclaims = message.pageReclaims;
    }
    if (message.pageFaults !== "0") {
      obj.pageFaults = message.pageFaults;
    }
    if (message.swaps !== "0") {
      obj.swaps = message.swaps;
    }
    if (message.blockInputOperations !== "0") {
      obj.blockInputOperations = message.blockInputOperations;
    }
    if (message.blockOutputOperations !== "0") {
      obj.blockOutputOperations = message.blockOutputOperations;
    }
    if (message.messagesSent !== "0") {
      obj.messagesSent = message.messagesSent;
    }
    if (message.messagesReceived !== "0") {
      obj.messagesReceived = message.messagesReceived;
    }
    if (message.signalsReceived !== "0") {
      obj.signalsReceived = message.signalsReceived;
    }
    if (message.voluntaryContextSwitches !== "0") {
      obj.voluntaryContextSwitches = message.voluntaryContextSwitches;
    }
    if (message.involuntaryContextSwitches !== "0") {
      obj.involuntaryContextSwitches = message.involuntaryContextSwitches;
    }
    if (message.terminationSignal !== "") {
      obj.terminationSignal = message.terminationSignal;
    }
    return obj;
  },

  create(base?: DeepPartial<POSIXResourceUsage>): POSIXResourceUsage {
    return POSIXResourceUsage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<POSIXResourceUsage>): POSIXResourceUsage {
    const message = createBasePOSIXResourceUsage();
    message.userTime = (object.userTime !== undefined && object.userTime !== null)
      ? Duration.fromPartial(object.userTime)
      : undefined;
    message.systemTime = (object.systemTime !== undefined && object.systemTime !== null)
      ? Duration.fromPartial(object.systemTime)
      : undefined;
    message.maximumResidentSetSize = object.maximumResidentSetSize ?? "0";
    message.pageReclaims = object.pageReclaims ?? "0";
    message.pageFaults = object.pageFaults ?? "0";
    message.swaps = object.swaps ?? "0";
    message.blockInputOperations = object.blockInputOperations ?? "0";
    message.blockOutputOperations = object.blockOutputOperations ?? "0";
    message.messagesSent = object.messagesSent ?? "0";
    message.messagesReceived = object.messagesReceived ?? "0";
    message.signalsReceived = object.signalsReceived ?? "0";
    message.voluntaryContextSwitches = object.voluntaryContextSwitches ?? "0";
    message.involuntaryContextSwitches = object.involuntaryContextSwitches ?? "0";
    message.terminationSignal = object.terminationSignal ?? "";
    return message;
  },
};

function createBaseMonetaryResourceUsage(): MonetaryResourceUsage {
  return { expenses: {} };
}

export const MonetaryResourceUsage: MessageFns<MonetaryResourceUsage> = {
  encode(message: MonetaryResourceUsage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.expenses).forEach(([key, value]) => {
      MonetaryResourceUsage_ExpensesEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MonetaryResourceUsage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMonetaryResourceUsage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = MonetaryResourceUsage_ExpensesEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.expenses[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MonetaryResourceUsage {
    return {
      expenses: isObject(object.expenses)
        ? Object.entries(object.expenses).reduce<{ [key: string]: MonetaryResourceUsage_Expense }>(
          (acc, [key, value]) => {
            acc[key] = MonetaryResourceUsage_Expense.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: MonetaryResourceUsage): unknown {
    const obj: any = {};
    if (message.expenses) {
      const entries = Object.entries(message.expenses);
      if (entries.length > 0) {
        obj.expenses = {};
        entries.forEach(([k, v]) => {
          obj.expenses[k] = MonetaryResourceUsage_Expense.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<MonetaryResourceUsage>): MonetaryResourceUsage {
    return MonetaryResourceUsage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MonetaryResourceUsage>): MonetaryResourceUsage {
    const message = createBaseMonetaryResourceUsage();
    message.expenses = Object.entries(object.expenses ?? {}).reduce<{ [key: string]: MonetaryResourceUsage_Expense }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = MonetaryResourceUsage_Expense.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseMonetaryResourceUsage_Expense(): MonetaryResourceUsage_Expense {
  return { currency: "", cost: 0 };
}

export const MonetaryResourceUsage_Expense: MessageFns<MonetaryResourceUsage_Expense> = {
  encode(message: MonetaryResourceUsage_Expense, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.currency !== "") {
      writer.uint32(10).string(message.currency);
    }
    if (message.cost !== 0) {
      writer.uint32(17).double(message.cost);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MonetaryResourceUsage_Expense {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMonetaryResourceUsage_Expense();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.cost = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MonetaryResourceUsage_Expense {
    return {
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      cost: isSet(object.cost) ? globalThis.Number(object.cost) : 0,
    };
  },

  toJSON(message: MonetaryResourceUsage_Expense): unknown {
    const obj: any = {};
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.cost !== 0) {
      obj.cost = message.cost;
    }
    return obj;
  },

  create(base?: DeepPartial<MonetaryResourceUsage_Expense>): MonetaryResourceUsage_Expense {
    return MonetaryResourceUsage_Expense.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MonetaryResourceUsage_Expense>): MonetaryResourceUsage_Expense {
    const message = createBaseMonetaryResourceUsage_Expense();
    message.currency = object.currency ?? "";
    message.cost = object.cost ?? 0;
    return message;
  },
};

function createBaseMonetaryResourceUsage_ExpensesEntry(): MonetaryResourceUsage_ExpensesEntry {
  return { key: "", value: undefined };
}

export const MonetaryResourceUsage_ExpensesEntry: MessageFns<MonetaryResourceUsage_ExpensesEntry> = {
  encode(message: MonetaryResourceUsage_ExpensesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      MonetaryResourceUsage_Expense.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MonetaryResourceUsage_ExpensesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMonetaryResourceUsage_ExpensesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = MonetaryResourceUsage_Expense.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MonetaryResourceUsage_ExpensesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? MonetaryResourceUsage_Expense.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: MonetaryResourceUsage_ExpensesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = MonetaryResourceUsage_Expense.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<MonetaryResourceUsage_ExpensesEntry>): MonetaryResourceUsage_ExpensesEntry {
    return MonetaryResourceUsage_ExpensesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MonetaryResourceUsage_ExpensesEntry>): MonetaryResourceUsage_ExpensesEntry {
    const message = createBaseMonetaryResourceUsage_ExpensesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? MonetaryResourceUsage_Expense.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseInputRootResourceUsage(): InputRootResourceUsage {
  return { directoriesResolved: "0", directoriesRead: "0", filesRead: "0" };
}

export const InputRootResourceUsage: MessageFns<InputRootResourceUsage> = {
  encode(message: InputRootResourceUsage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.directoriesResolved !== "0") {
      writer.uint32(8).uint64(message.directoriesResolved);
    }
    if (message.directoriesRead !== "0") {
      writer.uint32(16).uint64(message.directoriesRead);
    }
    if (message.filesRead !== "0") {
      writer.uint32(24).uint64(message.filesRead);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InputRootResourceUsage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInputRootResourceUsage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.directoriesResolved = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.directoriesRead = reader.uint64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.filesRead = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InputRootResourceUsage {
    return {
      directoriesResolved: isSet(object.directoriesResolved) ? globalThis.String(object.directoriesResolved) : "0",
      directoriesRead: isSet(object.directoriesRead) ? globalThis.String(object.directoriesRead) : "0",
      filesRead: isSet(object.filesRead) ? globalThis.String(object.filesRead) : "0",
    };
  },

  toJSON(message: InputRootResourceUsage): unknown {
    const obj: any = {};
    if (message.directoriesResolved !== "0") {
      obj.directoriesResolved = message.directoriesResolved;
    }
    if (message.directoriesRead !== "0") {
      obj.directoriesRead = message.directoriesRead;
    }
    if (message.filesRead !== "0") {
      obj.filesRead = message.filesRead;
    }
    return obj;
  },

  create(base?: DeepPartial<InputRootResourceUsage>): InputRootResourceUsage {
    return InputRootResourceUsage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InputRootResourceUsage>): InputRootResourceUsage {
    const message = createBaseInputRootResourceUsage();
    message.directoriesResolved = object.directoriesResolved ?? "0";
    message.directoriesRead = object.directoriesRead ?? "0";
    message.filesRead = object.filesRead ?? "0";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
