// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               v3.19.1
// source: buildbarn/buildqueuestate/buildqueuestate.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import {
  Digest,
  DigestFunction_Value,
  digestFunction_ValueFromJSON,
  digestFunction_ValueToJSON,
  ExecuteResponse,
  ExecutionStage_Value,
  executionStage_ValueFromJSON,
  executionStage_ValueToJSON,
  Platform,
} from "../../build/bazel/remote/execution/v2/remote_execution";
import { Any } from "../../google/protobuf/any";
import { Duration } from "../../google/protobuf/duration";
import { Empty } from "../../google/protobuf/empty";
import { Timestamp } from "../../google/protobuf/timestamp";
import { Status } from "../../google/rpc/status";

export const protobufPackage = "buildbarn.buildqueuestate";

export interface PaginationInfo {
  /**
   * The zero-based index of the first element returned by this
   * function, relative to the full list of data that may be returned by
   * this method.
   */
  startIndex: number;
  /**
   * The total number of entries in the full list of data that may be
   * returned by this method.
   */
  totalEntries: number;
}

export interface PlatformQueueName {
  /**
   * The REv2 instance name prefix that workers associated with this
   * platform queue announced to the scheduler.
   */
  instanceNamePrefix: string;
  /**
   * The REv2 platform properties that workers associated with this
   * platform queue announced to the scheduler.
   */
  platform: Platform | undefined;
}

export interface SizeClassQueueName {
  /** The platform queue in which the size class queue is placed. */
  platformQueueName:
    | PlatformQueueName
    | undefined;
  /**
   * The size of the workers relative to other workers in the same
   * platform queue.
   */
  sizeClass: number;
}

export interface InvocationName {
  /** The size class queue in which the invocation is placed. */
  sizeClassQueueName:
    | SizeClassQueueName
    | undefined;
  /** Sequence of invocation IDs that is used to identify the invocation. */
  ids: Any[];
}

export interface OperationState {
  /**
   * The name of the operation. In the case of bb_scheduler, the
   * operation name will be a UUID.
   */
  name: string;
  /** The invocation in which the operation is placed. */
  invocationName:
    | InvocationName
    | undefined;
  /** The expected amount of time this operation takes to complete. */
  expectedDuration:
    | Duration
    | undefined;
  /**
   * The time at which the client enqueued the operation by calling
   * Execute().
   */
  queuedTimestamp:
    | Date
    | undefined;
  /**
   * The digest of the Action message that the client instructed the
   * worker to execute.
   */
  actionDigest:
    | Digest
    | undefined;
  /**
   * When not set, it indicates that one or more Execute() or
   * WaitExecution() calls are currently taking place for this
   * operation. The scheduler will continue to maintain this operation.
   *
   * When set, it indicates that no Execute() or WaitExecution() calls
   * are currently taking place for this operation. The client has
   * abandoned this operation. This timestamp indicates when the
   * scheduler will remove this operation.
   *
   * If this operation is in the EXECUTING execution stage at the time
   * of removal (and this operation hasn't been in-flight deduplicated
   * against an operation created by some other client), its worker will
   * be instructed to stop execution.
   */
  timeout:
    | Date
    | undefined;
  /** The operation is in the QUEUED stage. */
  queued?:
    | Empty
    | undefined;
  /**
   * The operation is in the EXECUTING stage.
   * TODO: Would we want this to use type WorkerState, so that we can
   * get the ID of the worker on which an operation is executing?
   */
  executing?:
    | Empty
    | undefined;
  /** The operation is in the COMPLETED stage. */
  completed?:
    | ExecuteResponse
    | undefined;
  /**
   * A client-provided identifier for the target which produced this
   * operation.
   */
  targetId: string;
  /**
   * The priority of the operation, as provided by the client through
   * REv2's ExecutionPolicy.
   */
  priority: number;
  /**
   * Additional components that the client provided as part of
   * ExecuteRequest.instance_name that are not part of the
   * PlatformQueueName's instance_name_prefix.
   */
  instanceNameSuffix: string;
  /** The digest function that was used to compute the action digest. */
  digestFunction: DigestFunction_Value;
}

export interface SizeClassQueueState {
  /**
   * The size of the workers relative to other workers in the same
   * platform queue.
   */
  sizeClass: number;
  /**
   * When not set, it indicates that one or more workers exist in the
   * platform queue.
   *
   * When set, it indicates that all workers have disappeared.
   * Operations scheduled by clients using Execute() are still being
   * queued, as this may be a transient condition. This timestamp
   * indicates when the scheduler will remove the platform queue,
   * thereby causing all Execute() requests for this instance name and
   * platform properties to fail.
   */
  timeout:
    | Date
    | undefined;
  /** The total number of workers associated with this platform queue. */
  workersCount: number;
  /**
   * The total number of drains associated with this platform queue that
   * were created using AddDrain().
   */
  drainsCount: number;
  /**
   * Information about all operations that are part of this size class
   * queue, and utilization of workers.
   */
  rootInvocation: InvocationState | undefined;
}

export interface PlatformQueueState {
  /** The identifier of this platform queue. */
  name:
    | PlatformQueueName
    | undefined;
  /** The state of the platform queue per worker size class. */
  sizeClassQueues: SizeClassQueueState[];
}

export interface InvocationState {
  /**
   * The total number of operations associated with this platform queue
   * and invocation that are in the QUEUED execution stage.
   */
  queuedOperationsCount: number;
  /**
   * The total number of workers for this size class queue that are
   * currently executing an operation belonging to this invocation. This
   * equals the number of operations associated with this platform queue
   * and invocation that are in the EXECUTING execution stage.
   */
  executingWorkersCount: number;
  /**
   * The total number of workers for this size class queue that are
   * currently idle and most recently completed an operation belonging
   * to this invocation.
   */
  idleWorkersCount: number;
  /**
   * The total number of workers for this size class queue that are
   * currently idle and most recently executed an action belonging to
   * this invocation and synchronizing against the scheduler.
   *
   * These are the workers that will most preferably be used to execute
   * successive operations scheduled as part of this invocation.
   */
  idleSynchronizingWorkersCount: number;
  /**
   * The total number of client invocations for which one or more
   * operations in either the QUEUED or EXECUTING execution stage exist,
   * or for which one or more workers exist that most recently executed
   * a task belonging to this invocation.
   */
  childrenCount: number;
  /**
   * The total number of client invocations for which one or more
   * operations in either the QUEUED or EXECUTING execution stage exist.
   */
  activeChildrenCount: number;
  /**
   * The total number of client invocations for which one or more
   * operations in the QUEUED execution stage exist.
   */
  queuedChildrenCount: number;
}

export interface InvocationChildState {
  /**
   * An identifier for a set of operations that should be scheduled
   * collectively and fairly with respect to other sets.
   *
   * If operations are created by an REv2 client, this field typically
   * contains an REv2 RequestMetadata message. Only the
   * 'tool_invocation_id' field will be set, as that field is sufficient
   * for identifying a single build. All other fields are cleared.
   *
   * If the operation was created because the scheduler wanted to test
   * the execution of an action on a size class for which there is a
   * high probability of failure, this field contains a
   * BackgroundLearning message.
   *
   * This field may also contain other kinds of messages in case the
   * scheduler is configured to provide fairness not at the Bazel
   * invocation ID level, but using some alternative heuristics.
   */
  id:
    | Any
    | undefined;
  /** State of the child invocation. */
  state: InvocationState | undefined;
}

export interface WorkerState {
  /**
   * The labels that uniquely identifies the worker inside this size
   * class queue.
   */
  id: { [key: string]: string };
  /**
   * When not set, it indicates that the worker is currently calling
   * Synchronize() to report its current status, potentially blocking on
   * the scheduler to provide it a new task to execute.
   *
   * When set, it indicates that the worker is currently not calling
   * Synchronize(). This may either be because it's executing a task and
   * will only report its state periodically, or because the worker has
   * disappeared. This timestamp indicates when the scheduler will
   * remove this worker and terminate any operation it is running,
   * assuming the worker does not call Synchronize() before this time.
   */
  timeout:
    | Date
    | undefined;
  /**
   * The properties of the operation that is currently executed by this
   * worker. This option is not set when the worker is idle.
   *
   * The 'size_class_queue' and 'stage' fields are omitted, as their
   * values are implied.
   */
  currentOperation:
    | OperationState
    | undefined;
  /**
   * Set if one or more drains exist whose worker ID patterns match the
   * ID of the worker. When set, the worker is permitted to complete the
   * task it is currently execution, but will not receive any further
   * tasks to execute.
   */
  drained: boolean;
}

export interface WorkerState_IdEntry {
  key: string;
  value: string;
}

export interface DrainState {
  /**
   * The pattern of matching workers to drain. This pattern matches all
   * workers for which the worker ID is a superset of the pattern. An
   * empty worker ID pattern would match all workers.
   */
  workerIdPattern: { [key: string]: string };
  /** The time at which this drain was created. */
  createdTimestamp: Date | undefined;
}

export interface DrainState_WorkerIdPatternEntry {
  key: string;
  value: string;
}

export interface GetOperationRequest {
  /** The name of the operation for which the state needs to be obtained. */
  operationName: string;
}

export interface GetOperationResponse {
  /**
   * The state of the operation that needed to be obtain.
   *
   * The 'name' field of the operation is omitted, as its value is
   * implied.
   */
  operation: OperationState | undefined;
}

export interface ListOperationsRequest {
  /**
   * The number of operations to be returned. The response may contain
   * fewer operations, iff fewer than page_size operations exist after
   * the starting position.
   */
  pageSize: number;
  /**
   * When not set, return the first operations known by the scheduler.
   * When set, return the first operations after the provided starting
   * point.
   */
  startAfter:
    | ListOperationsRequest_StartAfter
    | undefined;
  /**
   * If set, only return operations having an invocation ID that
   * matches the provided value.
   */
  filterInvocationId:
    | Any
    | undefined;
  /**
   * If set, only return operations whose execution stage matches the
   * provided value.
   */
  filterStage: ExecutionStage_Value;
}

export interface ListOperationsRequest_StartAfter {
  /** The name of the operation. */
  operationName: string;
}

export interface ListOperationsResponse {
  /** The state of operations known by the scheduler. */
  operations: OperationState[];
  /**
   * The position at which the resulting operations are stored in the
   * list of all operations.
   */
  paginationInfo: PaginationInfo | undefined;
}

export interface KillOperationsRequest {
  /** Limit the operations to kill according to a filter. */
  filter:
    | KillOperationsRequest_Filter
    | undefined;
  /** The error to return to clients as part of the ExecuteResponse. */
  status: Status | undefined;
}

export interface KillOperationsRequest_Filter {
  /** Kill one operation, having a given name. */
  operationName?:
    | string
    | undefined;
  /**
   * Kill all operations within a given size class queue, only if the
   * size class queue has zero workers.
   *
   * This filter can be used by autoscaler processes to report to
   * clients that they are attempting to use a size class queue for
   * which no workers can be created.
   */
  sizeClassQueueWithoutWorkers?: SizeClassQueueName | undefined;
}

export interface ListPlatformQueuesResponse {
  /** The state of all platform queued managed by the scheduler. */
  platformQueues: PlatformQueueState[];
}

export interface ListInvocationChildrenRequest {
  /** The name of the invocation whose children need to be listed. */
  invocationName:
    | InvocationName
    | undefined;
  /** Limit the results according to a filter. */
  filter: ListInvocationChildrenRequest_Filter;
}

export enum ListInvocationChildrenRequest_Filter {
  /**
   * ALL - Return invocations for which one or more operations that are in
   * the QUEUED or EXECUTING stages exist, or for which one or more
   * workers exist that most recently executed a task belonging to
   * this invocation.
   *
   * Invocations are sorted alphabetically by invocation ID.
   */
  ALL = 0,
  /**
   * ACTIVE - Return invocations for which one or more operations that are in
   * the QUEUED or EXECUTING stages exist.
   *
   * Invocations are sorted alphabetically by invocation ID.
   */
  ACTIVE = 1,
  /**
   * QUEUED - Return invocations for which one or more operations that are in
   * the QUEUED stage exist.
   *
   * Invocations are sorted by the order in which the scheduler will
   * prefer scheduling operations from these invocations, in
   * descending order.
   */
  QUEUED = 2,
  UNRECOGNIZED = -1,
}

export function listInvocationChildrenRequest_FilterFromJSON(object: any): ListInvocationChildrenRequest_Filter {
  switch (object) {
    case 0:
    case "ALL":
      return ListInvocationChildrenRequest_Filter.ALL;
    case 1:
    case "ACTIVE":
      return ListInvocationChildrenRequest_Filter.ACTIVE;
    case 2:
    case "QUEUED":
      return ListInvocationChildrenRequest_Filter.QUEUED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ListInvocationChildrenRequest_Filter.UNRECOGNIZED;
  }
}

export function listInvocationChildrenRequest_FilterToJSON(object: ListInvocationChildrenRequest_Filter): string {
  switch (object) {
    case ListInvocationChildrenRequest_Filter.ALL:
      return "ALL";
    case ListInvocationChildrenRequest_Filter.ACTIVE:
      return "ACTIVE";
    case ListInvocationChildrenRequest_Filter.QUEUED:
      return "QUEUED";
    case ListInvocationChildrenRequest_Filter.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface ListInvocationChildrenResponse {
  /**
   * The state of all invocations known by the scheduler that are
   * contained within the provided invocation.
   */
  children: InvocationChildState[];
}

export interface ListQueuedOperationsRequest {
  /**
   * The invocation whose list of queued operations needs to be
   * returned.
   */
  invocationName:
    | InvocationName
    | undefined;
  /**
   * The number of operations to be returned. The response may contain
   * fewer operations, iff fewer than page_size operations exist after
   * the starting position.
   */
  pageSize: number;
  /**
   * When not set, return the first queued operations known by the
   * scheduler for the provided platform queue and invocation ID. When
   * set, return the first operations after the provided starting point.
   */
  startAfter: ListQueuedOperationsRequest_StartAfter | undefined;
}

export interface ListQueuedOperationsRequest_StartAfter {
  /** The priority of the queued operation. */
  priority: number;
  /**
   * The expected amount of time that this operation takes to
   * complete.
   */
  expectedDuration:
    | Duration
    | undefined;
  /** The timestamp at which the operation was queued. */
  queuedTimestamp: Date | undefined;
}

export interface ListQueuedOperationsResponse {
  /**
   * The state of operations that are in the QUEUED stage that are part
   * of the provided platform queue and invocation ID.
   *
   * The 'size_class_queue' and 'invocation_ids' fields are omitted, as
   * their values are implied.
   */
  queuedOperations: OperationState[];
  /**
   * The position at which the resulting operations are stored in the
   * list of all queued operations for the provided platform queue and
   * invocation ID.
   */
  paginationInfo: PaginationInfo | undefined;
}

export interface ListWorkersRequest {
  /** Limit the results according to a filter. */
  filter:
    | ListWorkersRequest_Filter
    | undefined;
  /**
   * The number of workers to be returned. The response may contain
   * fewer workers, iff fewer than page_size workers exist after the
   * starting position.
   */
  pageSize: number;
  /**
   * When not set, return the first workers known by the scheduler for
   * the provided platform queue. When set, return the first workers
   * after the provided starting point.
   */
  startAfter: ListWorkersRequest_StartAfter | undefined;
}

export interface ListWorkersRequest_Filter {
  /** List all of the workers in a given size class queue. */
  all?:
    | SizeClassQueueName
    | undefined;
  /**
   * List all of the workers that are executing an operation
   * belonging to a given invocation, or one of its transitive child
   * invocations.
   */
  executing?:
    | InvocationName
    | undefined;
  /**
   * List all of the workers that are idle and are synchronizing
   * against the scheduler that most recently executed an operation
   * belonging to a given invocation.
   */
  idleSynchronizing?: InvocationName | undefined;
}

export interface ListWorkersRequest_StartAfter {
  /**
   * The labels that uniquely identifies the worker inside this size
   * class queue.
   */
  workerId: { [key: string]: string };
}

export interface ListWorkersRequest_StartAfter_WorkerIdEntry {
  key: string;
  value: string;
}

export interface ListWorkersResponse {
  /** The state of workers that are part of the provided platform queue. */
  workers: WorkerState[];
  /**
   * The position at which the resulting workers are stored in the list
   * of all workers for the provided platform queue.
   */
  paginationInfo: PaginationInfo | undefined;
}

export interface TerminateWorkersRequest {
  /**
   * The pattern of matching workers to terminate. This pattern matches
   * all workers for which the worker ID is a superset of the pattern.
   * An empty worker ID pattern would match all workers.
   */
  workerIdPattern: { [key: string]: string };
}

export interface TerminateWorkersRequest_WorkerIdPatternEntry {
  key: string;
  value: string;
}

export interface ListDrainsRequest {
  /** The platform queue whose list of drains needs to be returned. */
  sizeClassQueueName: SizeClassQueueName | undefined;
}

export interface ListDrainsResponse {
  /** The state of drains that are part of the provided platform queue. */
  drains: DrainState[];
}

export interface AddOrRemoveDrainRequest {
  /** The platform queue whose list of drains needs to be altered. */
  sizeClassQueueName:
    | SizeClassQueueName
    | undefined;
  /**
   * The pattern of matching workers for which a drain needs to be added
   * or removed.
   */
  workerIdPattern: { [key: string]: string };
}

export interface AddOrRemoveDrainRequest_WorkerIdPatternEntry {
  key: string;
  value: string;
}

/**
 * A special message type that is used as an invocation ID to indicate
 * that an operation was created, because the scheduler wanted to test
 * the execution of an action on a size class for which there is a high
 * probability of failure. Background learning is performed to ensure
 * that execution statistics remain calibrated.
 */
export interface BackgroundLearning {
}

function createBasePaginationInfo(): PaginationInfo {
  return { startIndex: 0, totalEntries: 0 };
}

export const PaginationInfo: MessageFns<PaginationInfo> = {
  encode(message: PaginationInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startIndex !== 0) {
      writer.uint32(8).uint32(message.startIndex);
    }
    if (message.totalEntries !== 0) {
      writer.uint32(16).uint32(message.totalEntries);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaginationInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaginationInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.startIndex = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalEntries = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaginationInfo {
    return {
      startIndex: isSet(object.startIndex) ? globalThis.Number(object.startIndex) : 0,
      totalEntries: isSet(object.totalEntries) ? globalThis.Number(object.totalEntries) : 0,
    };
  },

  toJSON(message: PaginationInfo): unknown {
    const obj: any = {};
    if (message.startIndex !== 0) {
      obj.startIndex = Math.round(message.startIndex);
    }
    if (message.totalEntries !== 0) {
      obj.totalEntries = Math.round(message.totalEntries);
    }
    return obj;
  },

  create(base?: DeepPartial<PaginationInfo>): PaginationInfo {
    return PaginationInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PaginationInfo>): PaginationInfo {
    const message = createBasePaginationInfo();
    message.startIndex = object.startIndex ?? 0;
    message.totalEntries = object.totalEntries ?? 0;
    return message;
  },
};

function createBasePlatformQueueName(): PlatformQueueName {
  return { instanceNamePrefix: "", platform: undefined };
}

export const PlatformQueueName: MessageFns<PlatformQueueName> = {
  encode(message: PlatformQueueName, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.instanceNamePrefix !== "") {
      writer.uint32(10).string(message.instanceNamePrefix);
    }
    if (message.platform !== undefined) {
      Platform.encode(message.platform, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlatformQueueName {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlatformQueueName();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.instanceNamePrefix = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.platform = Platform.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlatformQueueName {
    return {
      instanceNamePrefix: isSet(object.instanceNamePrefix) ? globalThis.String(object.instanceNamePrefix) : "",
      platform: isSet(object.platform) ? Platform.fromJSON(object.platform) : undefined,
    };
  },

  toJSON(message: PlatformQueueName): unknown {
    const obj: any = {};
    if (message.instanceNamePrefix !== "") {
      obj.instanceNamePrefix = message.instanceNamePrefix;
    }
    if (message.platform !== undefined) {
      obj.platform = Platform.toJSON(message.platform);
    }
    return obj;
  },

  create(base?: DeepPartial<PlatformQueueName>): PlatformQueueName {
    return PlatformQueueName.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PlatformQueueName>): PlatformQueueName {
    const message = createBasePlatformQueueName();
    message.instanceNamePrefix = object.instanceNamePrefix ?? "";
    message.platform = (object.platform !== undefined && object.platform !== null)
      ? Platform.fromPartial(object.platform)
      : undefined;
    return message;
  },
};

function createBaseSizeClassQueueName(): SizeClassQueueName {
  return { platformQueueName: undefined, sizeClass: 0 };
}

export const SizeClassQueueName: MessageFns<SizeClassQueueName> = {
  encode(message: SizeClassQueueName, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.platformQueueName !== undefined) {
      PlatformQueueName.encode(message.platformQueueName, writer.uint32(10).fork()).join();
    }
    if (message.sizeClass !== 0) {
      writer.uint32(16).uint32(message.sizeClass);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SizeClassQueueName {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSizeClassQueueName();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.platformQueueName = PlatformQueueName.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.sizeClass = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SizeClassQueueName {
    return {
      platformQueueName: isSet(object.platformQueueName)
        ? PlatformQueueName.fromJSON(object.platformQueueName)
        : undefined,
      sizeClass: isSet(object.sizeClass) ? globalThis.Number(object.sizeClass) : 0,
    };
  },

  toJSON(message: SizeClassQueueName): unknown {
    const obj: any = {};
    if (message.platformQueueName !== undefined) {
      obj.platformQueueName = PlatformQueueName.toJSON(message.platformQueueName);
    }
    if (message.sizeClass !== 0) {
      obj.sizeClass = Math.round(message.sizeClass);
    }
    return obj;
  },

  create(base?: DeepPartial<SizeClassQueueName>): SizeClassQueueName {
    return SizeClassQueueName.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SizeClassQueueName>): SizeClassQueueName {
    const message = createBaseSizeClassQueueName();
    message.platformQueueName = (object.platformQueueName !== undefined && object.platformQueueName !== null)
      ? PlatformQueueName.fromPartial(object.platformQueueName)
      : undefined;
    message.sizeClass = object.sizeClass ?? 0;
    return message;
  },
};

function createBaseInvocationName(): InvocationName {
  return { sizeClassQueueName: undefined, ids: [] };
}

export const InvocationName: MessageFns<InvocationName> = {
  encode(message: InvocationName, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sizeClassQueueName !== undefined) {
      SizeClassQueueName.encode(message.sizeClassQueueName, writer.uint32(10).fork()).join();
    }
    for (const v of message.ids) {
      Any.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InvocationName {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvocationName();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sizeClassQueueName = SizeClassQueueName.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ids.push(Any.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InvocationName {
    return {
      sizeClassQueueName: isSet(object.sizeClassQueueName)
        ? SizeClassQueueName.fromJSON(object.sizeClassQueueName)
        : undefined,
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => Any.fromJSON(e)) : [],
    };
  },

  toJSON(message: InvocationName): unknown {
    const obj: any = {};
    if (message.sizeClassQueueName !== undefined) {
      obj.sizeClassQueueName = SizeClassQueueName.toJSON(message.sizeClassQueueName);
    }
    if (message.ids?.length) {
      obj.ids = message.ids.map((e) => Any.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<InvocationName>): InvocationName {
    return InvocationName.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InvocationName>): InvocationName {
    const message = createBaseInvocationName();
    message.sizeClassQueueName = (object.sizeClassQueueName !== undefined && object.sizeClassQueueName !== null)
      ? SizeClassQueueName.fromPartial(object.sizeClassQueueName)
      : undefined;
    message.ids = object.ids?.map((e) => Any.fromPartial(e)) || [];
    return message;
  },
};

function createBaseOperationState(): OperationState {
  return {
    name: "",
    invocationName: undefined,
    expectedDuration: undefined,
    queuedTimestamp: undefined,
    actionDigest: undefined,
    timeout: undefined,
    queued: undefined,
    executing: undefined,
    completed: undefined,
    targetId: "",
    priority: 0,
    instanceNameSuffix: "",
    digestFunction: 0,
  };
}

export const OperationState: MessageFns<OperationState> = {
  encode(message: OperationState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.invocationName !== undefined) {
      InvocationName.encode(message.invocationName, writer.uint32(18).fork()).join();
    }
    if (message.expectedDuration !== undefined) {
      Duration.encode(message.expectedDuration, writer.uint32(114).fork()).join();
    }
    if (message.queuedTimestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.queuedTimestamp), writer.uint32(34).fork()).join();
    }
    if (message.actionDigest !== undefined) {
      Digest.encode(message.actionDigest, writer.uint32(42).fork()).join();
    }
    if (message.timeout !== undefined) {
      Timestamp.encode(toTimestamp(message.timeout), writer.uint32(58).fork()).join();
    }
    if (message.queued !== undefined) {
      Empty.encode(message.queued, writer.uint32(66).fork()).join();
    }
    if (message.executing !== undefined) {
      Empty.encode(message.executing, writer.uint32(74).fork()).join();
    }
    if (message.completed !== undefined) {
      ExecuteResponse.encode(message.completed, writer.uint32(82).fork()).join();
    }
    if (message.targetId !== "") {
      writer.uint32(90).string(message.targetId);
    }
    if (message.priority !== 0) {
      writer.uint32(96).int32(message.priority);
    }
    if (message.instanceNameSuffix !== "") {
      writer.uint32(106).string(message.instanceNameSuffix);
    }
    if (message.digestFunction !== 0) {
      writer.uint32(120).int32(message.digestFunction);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OperationState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.invocationName = InvocationName.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.expectedDuration = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.queuedTimestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.actionDigest = Digest.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.timeout = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.queued = Empty.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.executing = Empty.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.completed = ExecuteResponse.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.targetId = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.priority = reader.int32();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.instanceNameSuffix = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.digestFunction = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperationState {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      invocationName: isSet(object.invocationName) ? InvocationName.fromJSON(object.invocationName) : undefined,
      expectedDuration: isSet(object.expectedDuration) ? Duration.fromJSON(object.expectedDuration) : undefined,
      queuedTimestamp: isSet(object.queuedTimestamp) ? fromJsonTimestamp(object.queuedTimestamp) : undefined,
      actionDigest: isSet(object.actionDigest) ? Digest.fromJSON(object.actionDigest) : undefined,
      timeout: isSet(object.timeout) ? fromJsonTimestamp(object.timeout) : undefined,
      queued: isSet(object.queued) ? Empty.fromJSON(object.queued) : undefined,
      executing: isSet(object.executing) ? Empty.fromJSON(object.executing) : undefined,
      completed: isSet(object.completed) ? ExecuteResponse.fromJSON(object.completed) : undefined,
      targetId: isSet(object.targetId) ? globalThis.String(object.targetId) : "",
      priority: isSet(object.priority) ? globalThis.Number(object.priority) : 0,
      instanceNameSuffix: isSet(object.instanceNameSuffix) ? globalThis.String(object.instanceNameSuffix) : "",
      digestFunction: isSet(object.digestFunction) ? digestFunction_ValueFromJSON(object.digestFunction) : 0,
    };
  },

  toJSON(message: OperationState): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.invocationName !== undefined) {
      obj.invocationName = InvocationName.toJSON(message.invocationName);
    }
    if (message.expectedDuration !== undefined) {
      obj.expectedDuration = Duration.toJSON(message.expectedDuration);
    }
    if (message.queuedTimestamp !== undefined) {
      obj.queuedTimestamp = message.queuedTimestamp.toISOString();
    }
    if (message.actionDigest !== undefined) {
      obj.actionDigest = Digest.toJSON(message.actionDigest);
    }
    if (message.timeout !== undefined) {
      obj.timeout = message.timeout.toISOString();
    }
    if (message.queued !== undefined) {
      obj.queued = Empty.toJSON(message.queued);
    }
    if (message.executing !== undefined) {
      obj.executing = Empty.toJSON(message.executing);
    }
    if (message.completed !== undefined) {
      obj.completed = ExecuteResponse.toJSON(message.completed);
    }
    if (message.targetId !== "") {
      obj.targetId = message.targetId;
    }
    if (message.priority !== 0) {
      obj.priority = Math.round(message.priority);
    }
    if (message.instanceNameSuffix !== "") {
      obj.instanceNameSuffix = message.instanceNameSuffix;
    }
    if (message.digestFunction !== 0) {
      obj.digestFunction = digestFunction_ValueToJSON(message.digestFunction);
    }
    return obj;
  },

  create(base?: DeepPartial<OperationState>): OperationState {
    return OperationState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OperationState>): OperationState {
    const message = createBaseOperationState();
    message.name = object.name ?? "";
    message.invocationName = (object.invocationName !== undefined && object.invocationName !== null)
      ? InvocationName.fromPartial(object.invocationName)
      : undefined;
    message.expectedDuration = (object.expectedDuration !== undefined && object.expectedDuration !== null)
      ? Duration.fromPartial(object.expectedDuration)
      : undefined;
    message.queuedTimestamp = object.queuedTimestamp ?? undefined;
    message.actionDigest = (object.actionDigest !== undefined && object.actionDigest !== null)
      ? Digest.fromPartial(object.actionDigest)
      : undefined;
    message.timeout = object.timeout ?? undefined;
    message.queued = (object.queued !== undefined && object.queued !== null)
      ? Empty.fromPartial(object.queued)
      : undefined;
    message.executing = (object.executing !== undefined && object.executing !== null)
      ? Empty.fromPartial(object.executing)
      : undefined;
    message.completed = (object.completed !== undefined && object.completed !== null)
      ? ExecuteResponse.fromPartial(object.completed)
      : undefined;
    message.targetId = object.targetId ?? "";
    message.priority = object.priority ?? 0;
    message.instanceNameSuffix = object.instanceNameSuffix ?? "";
    message.digestFunction = object.digestFunction ?? 0;
    return message;
  },
};

function createBaseSizeClassQueueState(): SizeClassQueueState {
  return { sizeClass: 0, timeout: undefined, workersCount: 0, drainsCount: 0, rootInvocation: undefined };
}

export const SizeClassQueueState: MessageFns<SizeClassQueueState> = {
  encode(message: SizeClassQueueState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sizeClass !== 0) {
      writer.uint32(8).uint32(message.sizeClass);
    }
    if (message.timeout !== undefined) {
      Timestamp.encode(toTimestamp(message.timeout), writer.uint32(18).fork()).join();
    }
    if (message.workersCount !== 0) {
      writer.uint32(40).uint32(message.workersCount);
    }
    if (message.drainsCount !== 0) {
      writer.uint32(56).uint32(message.drainsCount);
    }
    if (message.rootInvocation !== undefined) {
      InvocationState.encode(message.rootInvocation, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SizeClassQueueState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSizeClassQueueState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.sizeClass = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.timeout = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.workersCount = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.drainsCount = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.rootInvocation = InvocationState.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SizeClassQueueState {
    return {
      sizeClass: isSet(object.sizeClass) ? globalThis.Number(object.sizeClass) : 0,
      timeout: isSet(object.timeout) ? fromJsonTimestamp(object.timeout) : undefined,
      workersCount: isSet(object.workersCount) ? globalThis.Number(object.workersCount) : 0,
      drainsCount: isSet(object.drainsCount) ? globalThis.Number(object.drainsCount) : 0,
      rootInvocation: isSet(object.rootInvocation) ? InvocationState.fromJSON(object.rootInvocation) : undefined,
    };
  },

  toJSON(message: SizeClassQueueState): unknown {
    const obj: any = {};
    if (message.sizeClass !== 0) {
      obj.sizeClass = Math.round(message.sizeClass);
    }
    if (message.timeout !== undefined) {
      obj.timeout = message.timeout.toISOString();
    }
    if (message.workersCount !== 0) {
      obj.workersCount = Math.round(message.workersCount);
    }
    if (message.drainsCount !== 0) {
      obj.drainsCount = Math.round(message.drainsCount);
    }
    if (message.rootInvocation !== undefined) {
      obj.rootInvocation = InvocationState.toJSON(message.rootInvocation);
    }
    return obj;
  },

  create(base?: DeepPartial<SizeClassQueueState>): SizeClassQueueState {
    return SizeClassQueueState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SizeClassQueueState>): SizeClassQueueState {
    const message = createBaseSizeClassQueueState();
    message.sizeClass = object.sizeClass ?? 0;
    message.timeout = object.timeout ?? undefined;
    message.workersCount = object.workersCount ?? 0;
    message.drainsCount = object.drainsCount ?? 0;
    message.rootInvocation = (object.rootInvocation !== undefined && object.rootInvocation !== null)
      ? InvocationState.fromPartial(object.rootInvocation)
      : undefined;
    return message;
  },
};

function createBasePlatformQueueState(): PlatformQueueState {
  return { name: undefined, sizeClassQueues: [] };
}

export const PlatformQueueState: MessageFns<PlatformQueueState> = {
  encode(message: PlatformQueueState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined) {
      PlatformQueueName.encode(message.name, writer.uint32(10).fork()).join();
    }
    for (const v of message.sizeClassQueues) {
      SizeClassQueueState.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlatformQueueState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlatformQueueState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = PlatformQueueName.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sizeClassQueues.push(SizeClassQueueState.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlatformQueueState {
    return {
      name: isSet(object.name) ? PlatformQueueName.fromJSON(object.name) : undefined,
      sizeClassQueues: globalThis.Array.isArray(object?.sizeClassQueues)
        ? object.sizeClassQueues.map((e: any) => SizeClassQueueState.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PlatformQueueState): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = PlatformQueueName.toJSON(message.name);
    }
    if (message.sizeClassQueues?.length) {
      obj.sizeClassQueues = message.sizeClassQueues.map((e) => SizeClassQueueState.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<PlatformQueueState>): PlatformQueueState {
    return PlatformQueueState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PlatformQueueState>): PlatformQueueState {
    const message = createBasePlatformQueueState();
    message.name = (object.name !== undefined && object.name !== null)
      ? PlatformQueueName.fromPartial(object.name)
      : undefined;
    message.sizeClassQueues = object.sizeClassQueues?.map((e) => SizeClassQueueState.fromPartial(e)) || [];
    return message;
  },
};

function createBaseInvocationState(): InvocationState {
  return {
    queuedOperationsCount: 0,
    executingWorkersCount: 0,
    idleWorkersCount: 0,
    idleSynchronizingWorkersCount: 0,
    childrenCount: 0,
    activeChildrenCount: 0,
    queuedChildrenCount: 0,
  };
}

export const InvocationState: MessageFns<InvocationState> = {
  encode(message: InvocationState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.queuedOperationsCount !== 0) {
      writer.uint32(16).uint32(message.queuedOperationsCount);
    }
    if (message.executingWorkersCount !== 0) {
      writer.uint32(32).uint32(message.executingWorkersCount);
    }
    if (message.idleWorkersCount !== 0) {
      writer.uint32(40).uint32(message.idleWorkersCount);
    }
    if (message.idleSynchronizingWorkersCount !== 0) {
      writer.uint32(48).uint32(message.idleSynchronizingWorkersCount);
    }
    if (message.childrenCount !== 0) {
      writer.uint32(56).uint32(message.childrenCount);
    }
    if (message.activeChildrenCount !== 0) {
      writer.uint32(64).uint32(message.activeChildrenCount);
    }
    if (message.queuedChildrenCount !== 0) {
      writer.uint32(72).uint32(message.queuedChildrenCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InvocationState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvocationState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.queuedOperationsCount = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.executingWorkersCount = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.idleWorkersCount = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.idleSynchronizingWorkersCount = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.childrenCount = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.activeChildrenCount = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.queuedChildrenCount = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InvocationState {
    return {
      queuedOperationsCount: isSet(object.queuedOperationsCount) ? globalThis.Number(object.queuedOperationsCount) : 0,
      executingWorkersCount: isSet(object.executingWorkersCount) ? globalThis.Number(object.executingWorkersCount) : 0,
      idleWorkersCount: isSet(object.idleWorkersCount) ? globalThis.Number(object.idleWorkersCount) : 0,
      idleSynchronizingWorkersCount: isSet(object.idleSynchronizingWorkersCount)
        ? globalThis.Number(object.idleSynchronizingWorkersCount)
        : 0,
      childrenCount: isSet(object.childrenCount) ? globalThis.Number(object.childrenCount) : 0,
      activeChildrenCount: isSet(object.activeChildrenCount) ? globalThis.Number(object.activeChildrenCount) : 0,
      queuedChildrenCount: isSet(object.queuedChildrenCount) ? globalThis.Number(object.queuedChildrenCount) : 0,
    };
  },

  toJSON(message: InvocationState): unknown {
    const obj: any = {};
    if (message.queuedOperationsCount !== 0) {
      obj.queuedOperationsCount = Math.round(message.queuedOperationsCount);
    }
    if (message.executingWorkersCount !== 0) {
      obj.executingWorkersCount = Math.round(message.executingWorkersCount);
    }
    if (message.idleWorkersCount !== 0) {
      obj.idleWorkersCount = Math.round(message.idleWorkersCount);
    }
    if (message.idleSynchronizingWorkersCount !== 0) {
      obj.idleSynchronizingWorkersCount = Math.round(message.idleSynchronizingWorkersCount);
    }
    if (message.childrenCount !== 0) {
      obj.childrenCount = Math.round(message.childrenCount);
    }
    if (message.activeChildrenCount !== 0) {
      obj.activeChildrenCount = Math.round(message.activeChildrenCount);
    }
    if (message.queuedChildrenCount !== 0) {
      obj.queuedChildrenCount = Math.round(message.queuedChildrenCount);
    }
    return obj;
  },

  create(base?: DeepPartial<InvocationState>): InvocationState {
    return InvocationState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InvocationState>): InvocationState {
    const message = createBaseInvocationState();
    message.queuedOperationsCount = object.queuedOperationsCount ?? 0;
    message.executingWorkersCount = object.executingWorkersCount ?? 0;
    message.idleWorkersCount = object.idleWorkersCount ?? 0;
    message.idleSynchronizingWorkersCount = object.idleSynchronizingWorkersCount ?? 0;
    message.childrenCount = object.childrenCount ?? 0;
    message.activeChildrenCount = object.activeChildrenCount ?? 0;
    message.queuedChildrenCount = object.queuedChildrenCount ?? 0;
    return message;
  },
};

function createBaseInvocationChildState(): InvocationChildState {
  return { id: undefined, state: undefined };
}

export const InvocationChildState: MessageFns<InvocationChildState> = {
  encode(message: InvocationChildState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined) {
      Any.encode(message.id, writer.uint32(10).fork()).join();
    }
    if (message.state !== undefined) {
      InvocationState.encode(message.state, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InvocationChildState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvocationChildState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = Any.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.state = InvocationState.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InvocationChildState {
    return {
      id: isSet(object.id) ? Any.fromJSON(object.id) : undefined,
      state: isSet(object.state) ? InvocationState.fromJSON(object.state) : undefined,
    };
  },

  toJSON(message: InvocationChildState): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = Any.toJSON(message.id);
    }
    if (message.state !== undefined) {
      obj.state = InvocationState.toJSON(message.state);
    }
    return obj;
  },

  create(base?: DeepPartial<InvocationChildState>): InvocationChildState {
    return InvocationChildState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InvocationChildState>): InvocationChildState {
    const message = createBaseInvocationChildState();
    message.id = (object.id !== undefined && object.id !== null) ? Any.fromPartial(object.id) : undefined;
    message.state = (object.state !== undefined && object.state !== null)
      ? InvocationState.fromPartial(object.state)
      : undefined;
    return message;
  },
};

function createBaseWorkerState(): WorkerState {
  return { id: {}, timeout: undefined, currentOperation: undefined, drained: false };
}

export const WorkerState: MessageFns<WorkerState> = {
  encode(message: WorkerState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.id).forEach(([key, value]) => {
      WorkerState_IdEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    if (message.timeout !== undefined) {
      Timestamp.encode(toTimestamp(message.timeout), writer.uint32(18).fork()).join();
    }
    if (message.currentOperation !== undefined) {
      OperationState.encode(message.currentOperation, writer.uint32(26).fork()).join();
    }
    if (message.drained !== false) {
      writer.uint32(32).bool(message.drained);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkerState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkerState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = WorkerState_IdEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.id[entry1.key] = entry1.value;
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.timeout = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.currentOperation = OperationState.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.drained = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkerState {
    return {
      id: isObject(object.id)
        ? Object.entries(object.id).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      timeout: isSet(object.timeout) ? fromJsonTimestamp(object.timeout) : undefined,
      currentOperation: isSet(object.currentOperation) ? OperationState.fromJSON(object.currentOperation) : undefined,
      drained: isSet(object.drained) ? globalThis.Boolean(object.drained) : false,
    };
  },

  toJSON(message: WorkerState): unknown {
    const obj: any = {};
    if (message.id) {
      const entries = Object.entries(message.id);
      if (entries.length > 0) {
        obj.id = {};
        entries.forEach(([k, v]) => {
          obj.id[k] = v;
        });
      }
    }
    if (message.timeout !== undefined) {
      obj.timeout = message.timeout.toISOString();
    }
    if (message.currentOperation !== undefined) {
      obj.currentOperation = OperationState.toJSON(message.currentOperation);
    }
    if (message.drained !== false) {
      obj.drained = message.drained;
    }
    return obj;
  },

  create(base?: DeepPartial<WorkerState>): WorkerState {
    return WorkerState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkerState>): WorkerState {
    const message = createBaseWorkerState();
    message.id = Object.entries(object.id ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.timeout = object.timeout ?? undefined;
    message.currentOperation = (object.currentOperation !== undefined && object.currentOperation !== null)
      ? OperationState.fromPartial(object.currentOperation)
      : undefined;
    message.drained = object.drained ?? false;
    return message;
  },
};

function createBaseWorkerState_IdEntry(): WorkerState_IdEntry {
  return { key: "", value: "" };
}

export const WorkerState_IdEntry: MessageFns<WorkerState_IdEntry> = {
  encode(message: WorkerState_IdEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkerState_IdEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkerState_IdEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkerState_IdEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: WorkerState_IdEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<WorkerState_IdEntry>): WorkerState_IdEntry {
    return WorkerState_IdEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkerState_IdEntry>): WorkerState_IdEntry {
    const message = createBaseWorkerState_IdEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseDrainState(): DrainState {
  return { workerIdPattern: {}, createdTimestamp: undefined };
}

export const DrainState: MessageFns<DrainState> = {
  encode(message: DrainState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.workerIdPattern).forEach(([key, value]) => {
      DrainState_WorkerIdPatternEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    if (message.createdTimestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.createdTimestamp), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DrainState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDrainState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = DrainState_WorkerIdPatternEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.workerIdPattern[entry1.key] = entry1.value;
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.createdTimestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DrainState {
    return {
      workerIdPattern: isObject(object.workerIdPattern)
        ? Object.entries(object.workerIdPattern).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      createdTimestamp: isSet(object.createdTimestamp) ? fromJsonTimestamp(object.createdTimestamp) : undefined,
    };
  },

  toJSON(message: DrainState): unknown {
    const obj: any = {};
    if (message.workerIdPattern) {
      const entries = Object.entries(message.workerIdPattern);
      if (entries.length > 0) {
        obj.workerIdPattern = {};
        entries.forEach(([k, v]) => {
          obj.workerIdPattern[k] = v;
        });
      }
    }
    if (message.createdTimestamp !== undefined) {
      obj.createdTimestamp = message.createdTimestamp.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<DrainState>): DrainState {
    return DrainState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DrainState>): DrainState {
    const message = createBaseDrainState();
    message.workerIdPattern = Object.entries(object.workerIdPattern ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.createdTimestamp = object.createdTimestamp ?? undefined;
    return message;
  },
};

function createBaseDrainState_WorkerIdPatternEntry(): DrainState_WorkerIdPatternEntry {
  return { key: "", value: "" };
}

export const DrainState_WorkerIdPatternEntry: MessageFns<DrainState_WorkerIdPatternEntry> = {
  encode(message: DrainState_WorkerIdPatternEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DrainState_WorkerIdPatternEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDrainState_WorkerIdPatternEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DrainState_WorkerIdPatternEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: DrainState_WorkerIdPatternEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<DrainState_WorkerIdPatternEntry>): DrainState_WorkerIdPatternEntry {
    return DrainState_WorkerIdPatternEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DrainState_WorkerIdPatternEntry>): DrainState_WorkerIdPatternEntry {
    const message = createBaseDrainState_WorkerIdPatternEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseGetOperationRequest(): GetOperationRequest {
  return { operationName: "" };
}

export const GetOperationRequest: MessageFns<GetOperationRequest> = {
  encode(message: GetOperationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operationName !== "") {
      writer.uint32(10).string(message.operationName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOperationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOperationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.operationName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOperationRequest {
    return { operationName: isSet(object.operationName) ? globalThis.String(object.operationName) : "" };
  },

  toJSON(message: GetOperationRequest): unknown {
    const obj: any = {};
    if (message.operationName !== "") {
      obj.operationName = message.operationName;
    }
    return obj;
  },

  create(base?: DeepPartial<GetOperationRequest>): GetOperationRequest {
    return GetOperationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetOperationRequest>): GetOperationRequest {
    const message = createBaseGetOperationRequest();
    message.operationName = object.operationName ?? "";
    return message;
  },
};

function createBaseGetOperationResponse(): GetOperationResponse {
  return { operation: undefined };
}

export const GetOperationResponse: MessageFns<GetOperationResponse> = {
  encode(message: GetOperationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operation !== undefined) {
      OperationState.encode(message.operation, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOperationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOperationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.operation = OperationState.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOperationResponse {
    return { operation: isSet(object.operation) ? OperationState.fromJSON(object.operation) : undefined };
  },

  toJSON(message: GetOperationResponse): unknown {
    const obj: any = {};
    if (message.operation !== undefined) {
      obj.operation = OperationState.toJSON(message.operation);
    }
    return obj;
  },

  create(base?: DeepPartial<GetOperationResponse>): GetOperationResponse {
    return GetOperationResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetOperationResponse>): GetOperationResponse {
    const message = createBaseGetOperationResponse();
    message.operation = (object.operation !== undefined && object.operation !== null)
      ? OperationState.fromPartial(object.operation)
      : undefined;
    return message;
  },
};

function createBaseListOperationsRequest(): ListOperationsRequest {
  return { pageSize: 0, startAfter: undefined, filterInvocationId: undefined, filterStage: 0 };
}

export const ListOperationsRequest: MessageFns<ListOperationsRequest> = {
  encode(message: ListOperationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pageSize !== 0) {
      writer.uint32(8).uint32(message.pageSize);
    }
    if (message.startAfter !== undefined) {
      ListOperationsRequest_StartAfter.encode(message.startAfter, writer.uint32(18).fork()).join();
    }
    if (message.filterInvocationId !== undefined) {
      Any.encode(message.filterInvocationId, writer.uint32(26).fork()).join();
    }
    if (message.filterStage !== 0) {
      writer.uint32(32).int32(message.filterStage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListOperationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListOperationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.pageSize = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.startAfter = ListOperationsRequest_StartAfter.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.filterInvocationId = Any.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.filterStage = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListOperationsRequest {
    return {
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      startAfter: isSet(object.startAfter) ? ListOperationsRequest_StartAfter.fromJSON(object.startAfter) : undefined,
      filterInvocationId: isSet(object.filterInvocationId) ? Any.fromJSON(object.filterInvocationId) : undefined,
      filterStage: isSet(object.filterStage) ? executionStage_ValueFromJSON(object.filterStage) : 0,
    };
  },

  toJSON(message: ListOperationsRequest): unknown {
    const obj: any = {};
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.startAfter !== undefined) {
      obj.startAfter = ListOperationsRequest_StartAfter.toJSON(message.startAfter);
    }
    if (message.filterInvocationId !== undefined) {
      obj.filterInvocationId = Any.toJSON(message.filterInvocationId);
    }
    if (message.filterStage !== 0) {
      obj.filterStage = executionStage_ValueToJSON(message.filterStage);
    }
    return obj;
  },

  create(base?: DeepPartial<ListOperationsRequest>): ListOperationsRequest {
    return ListOperationsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListOperationsRequest>): ListOperationsRequest {
    const message = createBaseListOperationsRequest();
    message.pageSize = object.pageSize ?? 0;
    message.startAfter = (object.startAfter !== undefined && object.startAfter !== null)
      ? ListOperationsRequest_StartAfter.fromPartial(object.startAfter)
      : undefined;
    message.filterInvocationId = (object.filterInvocationId !== undefined && object.filterInvocationId !== null)
      ? Any.fromPartial(object.filterInvocationId)
      : undefined;
    message.filterStage = object.filterStage ?? 0;
    return message;
  },
};

function createBaseListOperationsRequest_StartAfter(): ListOperationsRequest_StartAfter {
  return { operationName: "" };
}

export const ListOperationsRequest_StartAfter: MessageFns<ListOperationsRequest_StartAfter> = {
  encode(message: ListOperationsRequest_StartAfter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operationName !== "") {
      writer.uint32(10).string(message.operationName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListOperationsRequest_StartAfter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListOperationsRequest_StartAfter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.operationName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListOperationsRequest_StartAfter {
    return { operationName: isSet(object.operationName) ? globalThis.String(object.operationName) : "" };
  },

  toJSON(message: ListOperationsRequest_StartAfter): unknown {
    const obj: any = {};
    if (message.operationName !== "") {
      obj.operationName = message.operationName;
    }
    return obj;
  },

  create(base?: DeepPartial<ListOperationsRequest_StartAfter>): ListOperationsRequest_StartAfter {
    return ListOperationsRequest_StartAfter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListOperationsRequest_StartAfter>): ListOperationsRequest_StartAfter {
    const message = createBaseListOperationsRequest_StartAfter();
    message.operationName = object.operationName ?? "";
    return message;
  },
};

function createBaseListOperationsResponse(): ListOperationsResponse {
  return { operations: [], paginationInfo: undefined };
}

export const ListOperationsResponse: MessageFns<ListOperationsResponse> = {
  encode(message: ListOperationsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.operations) {
      OperationState.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.paginationInfo !== undefined) {
      PaginationInfo.encode(message.paginationInfo, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListOperationsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListOperationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.operations.push(OperationState.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.paginationInfo = PaginationInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListOperationsResponse {
    return {
      operations: globalThis.Array.isArray(object?.operations)
        ? object.operations.map((e: any) => OperationState.fromJSON(e))
        : [],
      paginationInfo: isSet(object.paginationInfo) ? PaginationInfo.fromJSON(object.paginationInfo) : undefined,
    };
  },

  toJSON(message: ListOperationsResponse): unknown {
    const obj: any = {};
    if (message.operations?.length) {
      obj.operations = message.operations.map((e) => OperationState.toJSON(e));
    }
    if (message.paginationInfo !== undefined) {
      obj.paginationInfo = PaginationInfo.toJSON(message.paginationInfo);
    }
    return obj;
  },

  create(base?: DeepPartial<ListOperationsResponse>): ListOperationsResponse {
    return ListOperationsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListOperationsResponse>): ListOperationsResponse {
    const message = createBaseListOperationsResponse();
    message.operations = object.operations?.map((e) => OperationState.fromPartial(e)) || [];
    message.paginationInfo = (object.paginationInfo !== undefined && object.paginationInfo !== null)
      ? PaginationInfo.fromPartial(object.paginationInfo)
      : undefined;
    return message;
  },
};

function createBaseKillOperationsRequest(): KillOperationsRequest {
  return { filter: undefined, status: undefined };
}

export const KillOperationsRequest: MessageFns<KillOperationsRequest> = {
  encode(message: KillOperationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filter !== undefined) {
      KillOperationsRequest_Filter.encode(message.filter, writer.uint32(10).fork()).join();
    }
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KillOperationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKillOperationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filter = KillOperationsRequest_Filter.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KillOperationsRequest {
    return {
      filter: isSet(object.filter) ? KillOperationsRequest_Filter.fromJSON(object.filter) : undefined,
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
    };
  },

  toJSON(message: KillOperationsRequest): unknown {
    const obj: any = {};
    if (message.filter !== undefined) {
      obj.filter = KillOperationsRequest_Filter.toJSON(message.filter);
    }
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    return obj;
  },

  create(base?: DeepPartial<KillOperationsRequest>): KillOperationsRequest {
    return KillOperationsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<KillOperationsRequest>): KillOperationsRequest {
    const message = createBaseKillOperationsRequest();
    message.filter = (object.filter !== undefined && object.filter !== null)
      ? KillOperationsRequest_Filter.fromPartial(object.filter)
      : undefined;
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    return message;
  },
};

function createBaseKillOperationsRequest_Filter(): KillOperationsRequest_Filter {
  return { operationName: undefined, sizeClassQueueWithoutWorkers: undefined };
}

export const KillOperationsRequest_Filter: MessageFns<KillOperationsRequest_Filter> = {
  encode(message: KillOperationsRequest_Filter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operationName !== undefined) {
      writer.uint32(10).string(message.operationName);
    }
    if (message.sizeClassQueueWithoutWorkers !== undefined) {
      SizeClassQueueName.encode(message.sizeClassQueueWithoutWorkers, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KillOperationsRequest_Filter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKillOperationsRequest_Filter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.operationName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sizeClassQueueWithoutWorkers = SizeClassQueueName.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KillOperationsRequest_Filter {
    return {
      operationName: isSet(object.operationName) ? globalThis.String(object.operationName) : undefined,
      sizeClassQueueWithoutWorkers: isSet(object.sizeClassQueueWithoutWorkers)
        ? SizeClassQueueName.fromJSON(object.sizeClassQueueWithoutWorkers)
        : undefined,
    };
  },

  toJSON(message: KillOperationsRequest_Filter): unknown {
    const obj: any = {};
    if (message.operationName !== undefined) {
      obj.operationName = message.operationName;
    }
    if (message.sizeClassQueueWithoutWorkers !== undefined) {
      obj.sizeClassQueueWithoutWorkers = SizeClassQueueName.toJSON(message.sizeClassQueueWithoutWorkers);
    }
    return obj;
  },

  create(base?: DeepPartial<KillOperationsRequest_Filter>): KillOperationsRequest_Filter {
    return KillOperationsRequest_Filter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<KillOperationsRequest_Filter>): KillOperationsRequest_Filter {
    const message = createBaseKillOperationsRequest_Filter();
    message.operationName = object.operationName ?? undefined;
    message.sizeClassQueueWithoutWorkers =
      (object.sizeClassQueueWithoutWorkers !== undefined && object.sizeClassQueueWithoutWorkers !== null)
        ? SizeClassQueueName.fromPartial(object.sizeClassQueueWithoutWorkers)
        : undefined;
    return message;
  },
};

function createBaseListPlatformQueuesResponse(): ListPlatformQueuesResponse {
  return { platformQueues: [] };
}

export const ListPlatformQueuesResponse: MessageFns<ListPlatformQueuesResponse> = {
  encode(message: ListPlatformQueuesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.platformQueues) {
      PlatformQueueState.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPlatformQueuesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPlatformQueuesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.platformQueues.push(PlatformQueueState.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPlatformQueuesResponse {
    return {
      platformQueues: globalThis.Array.isArray(object?.platformQueues)
        ? object.platformQueues.map((e: any) => PlatformQueueState.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListPlatformQueuesResponse): unknown {
    const obj: any = {};
    if (message.platformQueues?.length) {
      obj.platformQueues = message.platformQueues.map((e) => PlatformQueueState.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListPlatformQueuesResponse>): ListPlatformQueuesResponse {
    return ListPlatformQueuesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListPlatformQueuesResponse>): ListPlatformQueuesResponse {
    const message = createBaseListPlatformQueuesResponse();
    message.platformQueues = object.platformQueues?.map((e) => PlatformQueueState.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListInvocationChildrenRequest(): ListInvocationChildrenRequest {
  return { invocationName: undefined, filter: 0 };
}

export const ListInvocationChildrenRequest: MessageFns<ListInvocationChildrenRequest> = {
  encode(message: ListInvocationChildrenRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.invocationName !== undefined) {
      InvocationName.encode(message.invocationName, writer.uint32(10).fork()).join();
    }
    if (message.filter !== 0) {
      writer.uint32(16).int32(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListInvocationChildrenRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListInvocationChildrenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.invocationName = InvocationName.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.filter = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListInvocationChildrenRequest {
    return {
      invocationName: isSet(object.invocationName) ? InvocationName.fromJSON(object.invocationName) : undefined,
      filter: isSet(object.filter) ? listInvocationChildrenRequest_FilterFromJSON(object.filter) : 0,
    };
  },

  toJSON(message: ListInvocationChildrenRequest): unknown {
    const obj: any = {};
    if (message.invocationName !== undefined) {
      obj.invocationName = InvocationName.toJSON(message.invocationName);
    }
    if (message.filter !== 0) {
      obj.filter = listInvocationChildrenRequest_FilterToJSON(message.filter);
    }
    return obj;
  },

  create(base?: DeepPartial<ListInvocationChildrenRequest>): ListInvocationChildrenRequest {
    return ListInvocationChildrenRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListInvocationChildrenRequest>): ListInvocationChildrenRequest {
    const message = createBaseListInvocationChildrenRequest();
    message.invocationName = (object.invocationName !== undefined && object.invocationName !== null)
      ? InvocationName.fromPartial(object.invocationName)
      : undefined;
    message.filter = object.filter ?? 0;
    return message;
  },
};

function createBaseListInvocationChildrenResponse(): ListInvocationChildrenResponse {
  return { children: [] };
}

export const ListInvocationChildrenResponse: MessageFns<ListInvocationChildrenResponse> = {
  encode(message: ListInvocationChildrenResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.children) {
      InvocationChildState.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListInvocationChildrenResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListInvocationChildrenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.children.push(InvocationChildState.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListInvocationChildrenResponse {
    return {
      children: globalThis.Array.isArray(object?.children)
        ? object.children.map((e: any) => InvocationChildState.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListInvocationChildrenResponse): unknown {
    const obj: any = {};
    if (message.children?.length) {
      obj.children = message.children.map((e) => InvocationChildState.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListInvocationChildrenResponse>): ListInvocationChildrenResponse {
    return ListInvocationChildrenResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListInvocationChildrenResponse>): ListInvocationChildrenResponse {
    const message = createBaseListInvocationChildrenResponse();
    message.children = object.children?.map((e) => InvocationChildState.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListQueuedOperationsRequest(): ListQueuedOperationsRequest {
  return { invocationName: undefined, pageSize: 0, startAfter: undefined };
}

export const ListQueuedOperationsRequest: MessageFns<ListQueuedOperationsRequest> = {
  encode(message: ListQueuedOperationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.invocationName !== undefined) {
      InvocationName.encode(message.invocationName, writer.uint32(10).fork()).join();
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).uint32(message.pageSize);
    }
    if (message.startAfter !== undefined) {
      ListQueuedOperationsRequest_StartAfter.encode(message.startAfter, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListQueuedOperationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListQueuedOperationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.invocationName = InvocationName.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.startAfter = ListQueuedOperationsRequest_StartAfter.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListQueuedOperationsRequest {
    return {
      invocationName: isSet(object.invocationName) ? InvocationName.fromJSON(object.invocationName) : undefined,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      startAfter: isSet(object.startAfter)
        ? ListQueuedOperationsRequest_StartAfter.fromJSON(object.startAfter)
        : undefined,
    };
  },

  toJSON(message: ListQueuedOperationsRequest): unknown {
    const obj: any = {};
    if (message.invocationName !== undefined) {
      obj.invocationName = InvocationName.toJSON(message.invocationName);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.startAfter !== undefined) {
      obj.startAfter = ListQueuedOperationsRequest_StartAfter.toJSON(message.startAfter);
    }
    return obj;
  },

  create(base?: DeepPartial<ListQueuedOperationsRequest>): ListQueuedOperationsRequest {
    return ListQueuedOperationsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListQueuedOperationsRequest>): ListQueuedOperationsRequest {
    const message = createBaseListQueuedOperationsRequest();
    message.invocationName = (object.invocationName !== undefined && object.invocationName !== null)
      ? InvocationName.fromPartial(object.invocationName)
      : undefined;
    message.pageSize = object.pageSize ?? 0;
    message.startAfter = (object.startAfter !== undefined && object.startAfter !== null)
      ? ListQueuedOperationsRequest_StartAfter.fromPartial(object.startAfter)
      : undefined;
    return message;
  },
};

function createBaseListQueuedOperationsRequest_StartAfter(): ListQueuedOperationsRequest_StartAfter {
  return { priority: 0, expectedDuration: undefined, queuedTimestamp: undefined };
}

export const ListQueuedOperationsRequest_StartAfter: MessageFns<ListQueuedOperationsRequest_StartAfter> = {
  encode(message: ListQueuedOperationsRequest_StartAfter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.priority !== 0) {
      writer.uint32(8).int32(message.priority);
    }
    if (message.expectedDuration !== undefined) {
      Duration.encode(message.expectedDuration, writer.uint32(26).fork()).join();
    }
    if (message.queuedTimestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.queuedTimestamp), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListQueuedOperationsRequest_StartAfter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListQueuedOperationsRequest_StartAfter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.priority = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.expectedDuration = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.queuedTimestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListQueuedOperationsRequest_StartAfter {
    return {
      priority: isSet(object.priority) ? globalThis.Number(object.priority) : 0,
      expectedDuration: isSet(object.expectedDuration) ? Duration.fromJSON(object.expectedDuration) : undefined,
      queuedTimestamp: isSet(object.queuedTimestamp) ? fromJsonTimestamp(object.queuedTimestamp) : undefined,
    };
  },

  toJSON(message: ListQueuedOperationsRequest_StartAfter): unknown {
    const obj: any = {};
    if (message.priority !== 0) {
      obj.priority = Math.round(message.priority);
    }
    if (message.expectedDuration !== undefined) {
      obj.expectedDuration = Duration.toJSON(message.expectedDuration);
    }
    if (message.queuedTimestamp !== undefined) {
      obj.queuedTimestamp = message.queuedTimestamp.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<ListQueuedOperationsRequest_StartAfter>): ListQueuedOperationsRequest_StartAfter {
    return ListQueuedOperationsRequest_StartAfter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListQueuedOperationsRequest_StartAfter>): ListQueuedOperationsRequest_StartAfter {
    const message = createBaseListQueuedOperationsRequest_StartAfter();
    message.priority = object.priority ?? 0;
    message.expectedDuration = (object.expectedDuration !== undefined && object.expectedDuration !== null)
      ? Duration.fromPartial(object.expectedDuration)
      : undefined;
    message.queuedTimestamp = object.queuedTimestamp ?? undefined;
    return message;
  },
};

function createBaseListQueuedOperationsResponse(): ListQueuedOperationsResponse {
  return { queuedOperations: [], paginationInfo: undefined };
}

export const ListQueuedOperationsResponse: MessageFns<ListQueuedOperationsResponse> = {
  encode(message: ListQueuedOperationsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.queuedOperations) {
      OperationState.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.paginationInfo !== undefined) {
      PaginationInfo.encode(message.paginationInfo, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListQueuedOperationsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListQueuedOperationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.queuedOperations.push(OperationState.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.paginationInfo = PaginationInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListQueuedOperationsResponse {
    return {
      queuedOperations: globalThis.Array.isArray(object?.queuedOperations)
        ? object.queuedOperations.map((e: any) => OperationState.fromJSON(e))
        : [],
      paginationInfo: isSet(object.paginationInfo) ? PaginationInfo.fromJSON(object.paginationInfo) : undefined,
    };
  },

  toJSON(message: ListQueuedOperationsResponse): unknown {
    const obj: any = {};
    if (message.queuedOperations?.length) {
      obj.queuedOperations = message.queuedOperations.map((e) => OperationState.toJSON(e));
    }
    if (message.paginationInfo !== undefined) {
      obj.paginationInfo = PaginationInfo.toJSON(message.paginationInfo);
    }
    return obj;
  },

  create(base?: DeepPartial<ListQueuedOperationsResponse>): ListQueuedOperationsResponse {
    return ListQueuedOperationsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListQueuedOperationsResponse>): ListQueuedOperationsResponse {
    const message = createBaseListQueuedOperationsResponse();
    message.queuedOperations = object.queuedOperations?.map((e) => OperationState.fromPartial(e)) || [];
    message.paginationInfo = (object.paginationInfo !== undefined && object.paginationInfo !== null)
      ? PaginationInfo.fromPartial(object.paginationInfo)
      : undefined;
    return message;
  },
};

function createBaseListWorkersRequest(): ListWorkersRequest {
  return { filter: undefined, pageSize: 0, startAfter: undefined };
}

export const ListWorkersRequest: MessageFns<ListWorkersRequest> = {
  encode(message: ListWorkersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filter !== undefined) {
      ListWorkersRequest_Filter.encode(message.filter, writer.uint32(10).fork()).join();
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).uint32(message.pageSize);
    }
    if (message.startAfter !== undefined) {
      ListWorkersRequest_StartAfter.encode(message.startAfter, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListWorkersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListWorkersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filter = ListWorkersRequest_Filter.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.startAfter = ListWorkersRequest_StartAfter.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListWorkersRequest {
    return {
      filter: isSet(object.filter) ? ListWorkersRequest_Filter.fromJSON(object.filter) : undefined,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      startAfter: isSet(object.startAfter) ? ListWorkersRequest_StartAfter.fromJSON(object.startAfter) : undefined,
    };
  },

  toJSON(message: ListWorkersRequest): unknown {
    const obj: any = {};
    if (message.filter !== undefined) {
      obj.filter = ListWorkersRequest_Filter.toJSON(message.filter);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.startAfter !== undefined) {
      obj.startAfter = ListWorkersRequest_StartAfter.toJSON(message.startAfter);
    }
    return obj;
  },

  create(base?: DeepPartial<ListWorkersRequest>): ListWorkersRequest {
    return ListWorkersRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListWorkersRequest>): ListWorkersRequest {
    const message = createBaseListWorkersRequest();
    message.filter = (object.filter !== undefined && object.filter !== null)
      ? ListWorkersRequest_Filter.fromPartial(object.filter)
      : undefined;
    message.pageSize = object.pageSize ?? 0;
    message.startAfter = (object.startAfter !== undefined && object.startAfter !== null)
      ? ListWorkersRequest_StartAfter.fromPartial(object.startAfter)
      : undefined;
    return message;
  },
};

function createBaseListWorkersRequest_Filter(): ListWorkersRequest_Filter {
  return { all: undefined, executing: undefined, idleSynchronizing: undefined };
}

export const ListWorkersRequest_Filter: MessageFns<ListWorkersRequest_Filter> = {
  encode(message: ListWorkersRequest_Filter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.all !== undefined) {
      SizeClassQueueName.encode(message.all, writer.uint32(10).fork()).join();
    }
    if (message.executing !== undefined) {
      InvocationName.encode(message.executing, writer.uint32(18).fork()).join();
    }
    if (message.idleSynchronizing !== undefined) {
      InvocationName.encode(message.idleSynchronizing, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListWorkersRequest_Filter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListWorkersRequest_Filter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.all = SizeClassQueueName.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.executing = InvocationName.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.idleSynchronizing = InvocationName.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListWorkersRequest_Filter {
    return {
      all: isSet(object.all) ? SizeClassQueueName.fromJSON(object.all) : undefined,
      executing: isSet(object.executing) ? InvocationName.fromJSON(object.executing) : undefined,
      idleSynchronizing: isSet(object.idleSynchronizing)
        ? InvocationName.fromJSON(object.idleSynchronizing)
        : undefined,
    };
  },

  toJSON(message: ListWorkersRequest_Filter): unknown {
    const obj: any = {};
    if (message.all !== undefined) {
      obj.all = SizeClassQueueName.toJSON(message.all);
    }
    if (message.executing !== undefined) {
      obj.executing = InvocationName.toJSON(message.executing);
    }
    if (message.idleSynchronizing !== undefined) {
      obj.idleSynchronizing = InvocationName.toJSON(message.idleSynchronizing);
    }
    return obj;
  },

  create(base?: DeepPartial<ListWorkersRequest_Filter>): ListWorkersRequest_Filter {
    return ListWorkersRequest_Filter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListWorkersRequest_Filter>): ListWorkersRequest_Filter {
    const message = createBaseListWorkersRequest_Filter();
    message.all = (object.all !== undefined && object.all !== null)
      ? SizeClassQueueName.fromPartial(object.all)
      : undefined;
    message.executing = (object.executing !== undefined && object.executing !== null)
      ? InvocationName.fromPartial(object.executing)
      : undefined;
    message.idleSynchronizing = (object.idleSynchronizing !== undefined && object.idleSynchronizing !== null)
      ? InvocationName.fromPartial(object.idleSynchronizing)
      : undefined;
    return message;
  },
};

function createBaseListWorkersRequest_StartAfter(): ListWorkersRequest_StartAfter {
  return { workerId: {} };
}

export const ListWorkersRequest_StartAfter: MessageFns<ListWorkersRequest_StartAfter> = {
  encode(message: ListWorkersRequest_StartAfter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.workerId).forEach(([key, value]) => {
      ListWorkersRequest_StartAfter_WorkerIdEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListWorkersRequest_StartAfter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListWorkersRequest_StartAfter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = ListWorkersRequest_StartAfter_WorkerIdEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.workerId[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListWorkersRequest_StartAfter {
    return {
      workerId: isObject(object.workerId)
        ? Object.entries(object.workerId).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ListWorkersRequest_StartAfter): unknown {
    const obj: any = {};
    if (message.workerId) {
      const entries = Object.entries(message.workerId);
      if (entries.length > 0) {
        obj.workerId = {};
        entries.forEach(([k, v]) => {
          obj.workerId[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<ListWorkersRequest_StartAfter>): ListWorkersRequest_StartAfter {
    return ListWorkersRequest_StartAfter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListWorkersRequest_StartAfter>): ListWorkersRequest_StartAfter {
    const message = createBaseListWorkersRequest_StartAfter();
    message.workerId = Object.entries(object.workerId ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseListWorkersRequest_StartAfter_WorkerIdEntry(): ListWorkersRequest_StartAfter_WorkerIdEntry {
  return { key: "", value: "" };
}

export const ListWorkersRequest_StartAfter_WorkerIdEntry: MessageFns<ListWorkersRequest_StartAfter_WorkerIdEntry> = {
  encode(
    message: ListWorkersRequest_StartAfter_WorkerIdEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListWorkersRequest_StartAfter_WorkerIdEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListWorkersRequest_StartAfter_WorkerIdEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListWorkersRequest_StartAfter_WorkerIdEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ListWorkersRequest_StartAfter_WorkerIdEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<ListWorkersRequest_StartAfter_WorkerIdEntry>): ListWorkersRequest_StartAfter_WorkerIdEntry {
    return ListWorkersRequest_StartAfter_WorkerIdEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ListWorkersRequest_StartAfter_WorkerIdEntry>,
  ): ListWorkersRequest_StartAfter_WorkerIdEntry {
    const message = createBaseListWorkersRequest_StartAfter_WorkerIdEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseListWorkersResponse(): ListWorkersResponse {
  return { workers: [], paginationInfo: undefined };
}

export const ListWorkersResponse: MessageFns<ListWorkersResponse> = {
  encode(message: ListWorkersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.workers) {
      WorkerState.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.paginationInfo !== undefined) {
      PaginationInfo.encode(message.paginationInfo, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListWorkersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListWorkersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.workers.push(WorkerState.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.paginationInfo = PaginationInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListWorkersResponse {
    return {
      workers: globalThis.Array.isArray(object?.workers) ? object.workers.map((e: any) => WorkerState.fromJSON(e)) : [],
      paginationInfo: isSet(object.paginationInfo) ? PaginationInfo.fromJSON(object.paginationInfo) : undefined,
    };
  },

  toJSON(message: ListWorkersResponse): unknown {
    const obj: any = {};
    if (message.workers?.length) {
      obj.workers = message.workers.map((e) => WorkerState.toJSON(e));
    }
    if (message.paginationInfo !== undefined) {
      obj.paginationInfo = PaginationInfo.toJSON(message.paginationInfo);
    }
    return obj;
  },

  create(base?: DeepPartial<ListWorkersResponse>): ListWorkersResponse {
    return ListWorkersResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListWorkersResponse>): ListWorkersResponse {
    const message = createBaseListWorkersResponse();
    message.workers = object.workers?.map((e) => WorkerState.fromPartial(e)) || [];
    message.paginationInfo = (object.paginationInfo !== undefined && object.paginationInfo !== null)
      ? PaginationInfo.fromPartial(object.paginationInfo)
      : undefined;
    return message;
  },
};

function createBaseTerminateWorkersRequest(): TerminateWorkersRequest {
  return { workerIdPattern: {} };
}

export const TerminateWorkersRequest: MessageFns<TerminateWorkersRequest> = {
  encode(message: TerminateWorkersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.workerIdPattern).forEach(([key, value]) => {
      TerminateWorkersRequest_WorkerIdPatternEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TerminateWorkersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTerminateWorkersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = TerminateWorkersRequest_WorkerIdPatternEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.workerIdPattern[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TerminateWorkersRequest {
    return {
      workerIdPattern: isObject(object.workerIdPattern)
        ? Object.entries(object.workerIdPattern).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: TerminateWorkersRequest): unknown {
    const obj: any = {};
    if (message.workerIdPattern) {
      const entries = Object.entries(message.workerIdPattern);
      if (entries.length > 0) {
        obj.workerIdPattern = {};
        entries.forEach(([k, v]) => {
          obj.workerIdPattern[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<TerminateWorkersRequest>): TerminateWorkersRequest {
    return TerminateWorkersRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TerminateWorkersRequest>): TerminateWorkersRequest {
    const message = createBaseTerminateWorkersRequest();
    message.workerIdPattern = Object.entries(object.workerIdPattern ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseTerminateWorkersRequest_WorkerIdPatternEntry(): TerminateWorkersRequest_WorkerIdPatternEntry {
  return { key: "", value: "" };
}

export const TerminateWorkersRequest_WorkerIdPatternEntry: MessageFns<TerminateWorkersRequest_WorkerIdPatternEntry> = {
  encode(
    message: TerminateWorkersRequest_WorkerIdPatternEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TerminateWorkersRequest_WorkerIdPatternEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTerminateWorkersRequest_WorkerIdPatternEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TerminateWorkersRequest_WorkerIdPatternEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: TerminateWorkersRequest_WorkerIdPatternEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(
    base?: DeepPartial<TerminateWorkersRequest_WorkerIdPatternEntry>,
  ): TerminateWorkersRequest_WorkerIdPatternEntry {
    return TerminateWorkersRequest_WorkerIdPatternEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<TerminateWorkersRequest_WorkerIdPatternEntry>,
  ): TerminateWorkersRequest_WorkerIdPatternEntry {
    const message = createBaseTerminateWorkersRequest_WorkerIdPatternEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseListDrainsRequest(): ListDrainsRequest {
  return { sizeClassQueueName: undefined };
}

export const ListDrainsRequest: MessageFns<ListDrainsRequest> = {
  encode(message: ListDrainsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sizeClassQueueName !== undefined) {
      SizeClassQueueName.encode(message.sizeClassQueueName, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListDrainsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDrainsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sizeClassQueueName = SizeClassQueueName.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDrainsRequest {
    return {
      sizeClassQueueName: isSet(object.sizeClassQueueName)
        ? SizeClassQueueName.fromJSON(object.sizeClassQueueName)
        : undefined,
    };
  },

  toJSON(message: ListDrainsRequest): unknown {
    const obj: any = {};
    if (message.sizeClassQueueName !== undefined) {
      obj.sizeClassQueueName = SizeClassQueueName.toJSON(message.sizeClassQueueName);
    }
    return obj;
  },

  create(base?: DeepPartial<ListDrainsRequest>): ListDrainsRequest {
    return ListDrainsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListDrainsRequest>): ListDrainsRequest {
    const message = createBaseListDrainsRequest();
    message.sizeClassQueueName = (object.sizeClassQueueName !== undefined && object.sizeClassQueueName !== null)
      ? SizeClassQueueName.fromPartial(object.sizeClassQueueName)
      : undefined;
    return message;
  },
};

function createBaseListDrainsResponse(): ListDrainsResponse {
  return { drains: [] };
}

export const ListDrainsResponse: MessageFns<ListDrainsResponse> = {
  encode(message: ListDrainsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.drains) {
      DrainState.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListDrainsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDrainsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.drains.push(DrainState.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDrainsResponse {
    return {
      drains: globalThis.Array.isArray(object?.drains) ? object.drains.map((e: any) => DrainState.fromJSON(e)) : [],
    };
  },

  toJSON(message: ListDrainsResponse): unknown {
    const obj: any = {};
    if (message.drains?.length) {
      obj.drains = message.drains.map((e) => DrainState.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListDrainsResponse>): ListDrainsResponse {
    return ListDrainsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListDrainsResponse>): ListDrainsResponse {
    const message = createBaseListDrainsResponse();
    message.drains = object.drains?.map((e) => DrainState.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAddOrRemoveDrainRequest(): AddOrRemoveDrainRequest {
  return { sizeClassQueueName: undefined, workerIdPattern: {} };
}

export const AddOrRemoveDrainRequest: MessageFns<AddOrRemoveDrainRequest> = {
  encode(message: AddOrRemoveDrainRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sizeClassQueueName !== undefined) {
      SizeClassQueueName.encode(message.sizeClassQueueName, writer.uint32(10).fork()).join();
    }
    Object.entries(message.workerIdPattern).forEach(([key, value]) => {
      AddOrRemoveDrainRequest_WorkerIdPatternEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddOrRemoveDrainRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddOrRemoveDrainRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sizeClassQueueName = SizeClassQueueName.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = AddOrRemoveDrainRequest_WorkerIdPatternEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.workerIdPattern[entry2.key] = entry2.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddOrRemoveDrainRequest {
    return {
      sizeClassQueueName: isSet(object.sizeClassQueueName)
        ? SizeClassQueueName.fromJSON(object.sizeClassQueueName)
        : undefined,
      workerIdPattern: isObject(object.workerIdPattern)
        ? Object.entries(object.workerIdPattern).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: AddOrRemoveDrainRequest): unknown {
    const obj: any = {};
    if (message.sizeClassQueueName !== undefined) {
      obj.sizeClassQueueName = SizeClassQueueName.toJSON(message.sizeClassQueueName);
    }
    if (message.workerIdPattern) {
      const entries = Object.entries(message.workerIdPattern);
      if (entries.length > 0) {
        obj.workerIdPattern = {};
        entries.forEach(([k, v]) => {
          obj.workerIdPattern[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<AddOrRemoveDrainRequest>): AddOrRemoveDrainRequest {
    return AddOrRemoveDrainRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AddOrRemoveDrainRequest>): AddOrRemoveDrainRequest {
    const message = createBaseAddOrRemoveDrainRequest();
    message.sizeClassQueueName = (object.sizeClassQueueName !== undefined && object.sizeClassQueueName !== null)
      ? SizeClassQueueName.fromPartial(object.sizeClassQueueName)
      : undefined;
    message.workerIdPattern = Object.entries(object.workerIdPattern ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseAddOrRemoveDrainRequest_WorkerIdPatternEntry(): AddOrRemoveDrainRequest_WorkerIdPatternEntry {
  return { key: "", value: "" };
}

export const AddOrRemoveDrainRequest_WorkerIdPatternEntry: MessageFns<AddOrRemoveDrainRequest_WorkerIdPatternEntry> = {
  encode(
    message: AddOrRemoveDrainRequest_WorkerIdPatternEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddOrRemoveDrainRequest_WorkerIdPatternEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddOrRemoveDrainRequest_WorkerIdPatternEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddOrRemoveDrainRequest_WorkerIdPatternEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: AddOrRemoveDrainRequest_WorkerIdPatternEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(
    base?: DeepPartial<AddOrRemoveDrainRequest_WorkerIdPatternEntry>,
  ): AddOrRemoveDrainRequest_WorkerIdPatternEntry {
    return AddOrRemoveDrainRequest_WorkerIdPatternEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AddOrRemoveDrainRequest_WorkerIdPatternEntry>,
  ): AddOrRemoveDrainRequest_WorkerIdPatternEntry {
    const message = createBaseAddOrRemoveDrainRequest_WorkerIdPatternEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseBackgroundLearning(): BackgroundLearning {
  return {};
}

export const BackgroundLearning: MessageFns<BackgroundLearning> = {
  encode(_: BackgroundLearning, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BackgroundLearning {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBackgroundLearning();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): BackgroundLearning {
    return {};
  },

  toJSON(_: BackgroundLearning): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<BackgroundLearning>): BackgroundLearning {
    return BackgroundLearning.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<BackgroundLearning>): BackgroundLearning {
    const message = createBaseBackgroundLearning();
    return message;
  },
};

/**
 * BuildQueueState can be used to inspect the internal state of
 * InMemoryBuildQueue and perform administrative operations against it.
 * It is used by bb_scheduler's web UI.
 */
export type BuildQueueStateDefinition = typeof BuildQueueStateDefinition;
export const BuildQueueStateDefinition = {
  name: "BuildQueueState",
  fullName: "buildbarn.buildqueuestate.BuildQueueState",
  methods: {
    /**
     * Get information about an operation that is currently known by the
     * scheduler.
     */
    getOperation: {
      name: "GetOperation",
      requestType: GetOperationRequest,
      requestStream: false,
      responseType: GetOperationResponse,
      responseStream: false,
      options: {},
    },
    /**
     * List information about all operations that are currently known by
     * the scheduler.
     */
    listOperations: {
      name: "ListOperations",
      requestType: ListOperationsRequest,
      requestStream: false,
      responseType: ListOperationsResponse,
      responseStream: false,
      options: {},
    },
    /**
     * Forcefully terminate one or more operations that are either in the
     * QUEUED or EXECUTING execution stage with a provided gRPC status.
     */
    killOperations: {
      name: "KillOperations",
      requestType: KillOperationsRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /**
     * List information about all platform queues that are currently
     * registered by the scheduler.
     *
     * Platform queues are responsible for tracking all workers and
     * operations for a single execution platform. Platform queues are
     * identified by an REv2 instance name and Platform message.
     *
     * TODO: Should this call support pagination, or is the number of
     * platform queues low enough that it's not needed?
     */
    listPlatformQueues: {
      name: "ListPlatformQueues",
      requestType: Empty,
      requestStream: false,
      responseType: ListPlatformQueuesResponse,
      responseStream: false,
      options: {},
    },
    /**
     * List information about all client invocations for which one or more
     * operations exist that are in the QUEUED or EXECUTING execution
     * stage for a given platform queue.
     *
     * TODO: Should this call support pagination, or is the number of
     * invocations low enough that it's not needed?
     */
    listInvocationChildren: {
      name: "ListInvocationChildren",
      requestType: ListInvocationChildrenRequest,
      requestStream: false,
      responseType: ListInvocationChildrenResponse,
      responseStream: false,
      options: {},
    },
    /**
     * List information about all operations that are in the QUEUED
     * execution stage for a given client invocation.
     */
    listQueuedOperations: {
      name: "ListQueuedOperations",
      requestType: ListQueuedOperationsRequest,
      requestStream: false,
      responseType: ListQueuedOperationsResponse,
      responseStream: false,
      options: {},
    },
    /**
     * List information about all workers that are requesting tasks from a
     * given platform queue.
     */
    listWorkers: {
      name: "ListWorkers",
      requestType: ListWorkersRequest,
      requestStream: false,
      responseType: ListWorkersResponse,
      responseStream: false,
      options: {},
    },
    /**
     * Mark workers in a platform queue as about to be terminated. This
     * causes the workers to no longer receive new tasks after completing
     * the task they are currently assigned.
     *
     * This method blocks until all workers matched by the provided
     * pattern are idle. Once completed, it is safe to terminate the
     * matching workers without disrupting execution of tasks.
     */
    terminateWorkers: {
      name: "TerminateWorkers",
      requestType: TerminateWorkersRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /**
     * List worker ID patterns that are used to prevent workers from
     * receiving new tasks.
     */
    listDrains: {
      name: "ListDrains",
      requestType: ListDrainsRequest,
      requestStream: false,
      responseType: ListDrainsResponse,
      responseStream: false,
      options: {},
    },
    /**
     * Add a new worker ID pattern that prevents workers from receiving
     * new tasks. The difference between AddDrain() and TerminateWorkers()
     * is that entries created by the former can be removed with
     * RemoveDrain(). Patterns are also retained, regardless of whether
     * workers disappear and reappear in the meantime.
     */
    addDrain: {
      name: "AddDrain",
      requestType: AddOrRemoveDrainRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /**
     * Remove an existent worker ID pattern that prevents workers from
     * receiving new tasks. This method is the inverse of AddDrain().
     */
    removeDrain: {
      name: "RemoveDrain",
      requestType: AddOrRemoveDrainRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
  },
} as const;

export interface BuildQueueStateServiceImplementation<CallContextExt = {}> {
  /**
   * Get information about an operation that is currently known by the
   * scheduler.
   */
  getOperation(
    request: GetOperationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetOperationResponse>>;
  /**
   * List information about all operations that are currently known by
   * the scheduler.
   */
  listOperations(
    request: ListOperationsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListOperationsResponse>>;
  /**
   * Forcefully terminate one or more operations that are either in the
   * QUEUED or EXECUTING execution stage with a provided gRPC status.
   */
  killOperations(request: KillOperationsRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /**
   * List information about all platform queues that are currently
   * registered by the scheduler.
   *
   * Platform queues are responsible for tracking all workers and
   * operations for a single execution platform. Platform queues are
   * identified by an REv2 instance name and Platform message.
   *
   * TODO: Should this call support pagination, or is the number of
   * platform queues low enough that it's not needed?
   */
  listPlatformQueues(
    request: Empty,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListPlatformQueuesResponse>>;
  /**
   * List information about all client invocations for which one or more
   * operations exist that are in the QUEUED or EXECUTING execution
   * stage for a given platform queue.
   *
   * TODO: Should this call support pagination, or is the number of
   * invocations low enough that it's not needed?
   */
  listInvocationChildren(
    request: ListInvocationChildrenRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListInvocationChildrenResponse>>;
  /**
   * List information about all operations that are in the QUEUED
   * execution stage for a given client invocation.
   */
  listQueuedOperations(
    request: ListQueuedOperationsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListQueuedOperationsResponse>>;
  /**
   * List information about all workers that are requesting tasks from a
   * given platform queue.
   */
  listWorkers(
    request: ListWorkersRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListWorkersResponse>>;
  /**
   * Mark workers in a platform queue as about to be terminated. This
   * causes the workers to no longer receive new tasks after completing
   * the task they are currently assigned.
   *
   * This method blocks until all workers matched by the provided
   * pattern are idle. Once completed, it is safe to terminate the
   * matching workers without disrupting execution of tasks.
   */
  terminateWorkers(
    request: TerminateWorkersRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /**
   * List worker ID patterns that are used to prevent workers from
   * receiving new tasks.
   */
  listDrains(
    request: ListDrainsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListDrainsResponse>>;
  /**
   * Add a new worker ID pattern that prevents workers from receiving
   * new tasks. The difference between AddDrain() and TerminateWorkers()
   * is that entries created by the former can be removed with
   * RemoveDrain(). Patterns are also retained, regardless of whether
   * workers disappear and reappear in the meantime.
   */
  addDrain(request: AddOrRemoveDrainRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /**
   * Remove an existent worker ID pattern that prevents workers from
   * receiving new tasks. This method is the inverse of AddDrain().
   */
  removeDrain(request: AddOrRemoveDrainRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
}

export interface BuildQueueStateClient<CallOptionsExt = {}> {
  /**
   * Get information about an operation that is currently known by the
   * scheduler.
   */
  getOperation(
    request: DeepPartial<GetOperationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetOperationResponse>;
  /**
   * List information about all operations that are currently known by
   * the scheduler.
   */
  listOperations(
    request: DeepPartial<ListOperationsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListOperationsResponse>;
  /**
   * Forcefully terminate one or more operations that are either in the
   * QUEUED or EXECUTING execution stage with a provided gRPC status.
   */
  killOperations(request: DeepPartial<KillOperationsRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /**
   * List information about all platform queues that are currently
   * registered by the scheduler.
   *
   * Platform queues are responsible for tracking all workers and
   * operations for a single execution platform. Platform queues are
   * identified by an REv2 instance name and Platform message.
   *
   * TODO: Should this call support pagination, or is the number of
   * platform queues low enough that it's not needed?
   */
  listPlatformQueues(
    request: DeepPartial<Empty>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListPlatformQueuesResponse>;
  /**
   * List information about all client invocations for which one or more
   * operations exist that are in the QUEUED or EXECUTING execution
   * stage for a given platform queue.
   *
   * TODO: Should this call support pagination, or is the number of
   * invocations low enough that it's not needed?
   */
  listInvocationChildren(
    request: DeepPartial<ListInvocationChildrenRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListInvocationChildrenResponse>;
  /**
   * List information about all operations that are in the QUEUED
   * execution stage for a given client invocation.
   */
  listQueuedOperations(
    request: DeepPartial<ListQueuedOperationsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListQueuedOperationsResponse>;
  /**
   * List information about all workers that are requesting tasks from a
   * given platform queue.
   */
  listWorkers(
    request: DeepPartial<ListWorkersRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListWorkersResponse>;
  /**
   * Mark workers in a platform queue as about to be terminated. This
   * causes the workers to no longer receive new tasks after completing
   * the task they are currently assigned.
   *
   * This method blocks until all workers matched by the provided
   * pattern are idle. Once completed, it is safe to terminate the
   * matching workers without disrupting execution of tasks.
   */
  terminateWorkers(
    request: DeepPartial<TerminateWorkersRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /**
   * List worker ID patterns that are used to prevent workers from
   * receiving new tasks.
   */
  listDrains(
    request: DeepPartial<ListDrainsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListDrainsResponse>;
  /**
   * Add a new worker ID pattern that prevents workers from receiving
   * new tasks. The difference between AddDrain() and TerminateWorkers()
   * is that entries created by the former can be removed with
   * RemoveDrain(). Patterns are also retained, regardless of whether
   * workers disappear and reappear in the meantime.
   */
  addDrain(request: DeepPartial<AddOrRemoveDrainRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /**
   * Remove an existent worker ID pattern that prevents workers from
   * receiving new tasks. This method is the inverse of AddDrain().
   */
  removeDrain(request: DeepPartial<AddOrRemoveDrainRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000).toString();
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (globalThis.Number(t.seconds) || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
