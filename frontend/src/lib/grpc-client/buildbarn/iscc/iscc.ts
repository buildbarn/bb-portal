// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               v3.19.1
// source: buildbarn/iscc/iscc.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import {
  Digest,
  DigestFunction_Value,
  digestFunction_ValueFromJSON,
  digestFunction_ValueToJSON,
} from "../../build/bazel/remote/execution/v2/remote_execution";
import { Duration } from "../../google/protobuf/duration";
import { Empty } from "../../google/protobuf/empty";
import { Timestamp } from "../../google/protobuf/timestamp";

export const protobufPackage = "buildbarn.iscc";

/** The outcome of a single action at some point in the past. */
export interface PreviousExecution {
  /** Execution failed with an error. */
  failed?:
    | Empty
    | undefined;
  /** Execution failed due to a timeout. The timeout value is stored. */
  timedOut?:
    | Duration
    | undefined;
  /** Execution succeeded. The virtual execution duration is stored. */
  succeeded?: Duration | undefined;
}

/** Outcomes of actions for a given size class. */
export interface PerSizeClassStats {
  /**
   * The most recent outcomes for this size class, where the last entry
   * corresponds to the most recent one.
   */
  previousExecutions: PreviousExecution[];
  /**
   * An initial probability value to be used for PageRank computation.
   * These values may correspond to outcomes of previous PageRank
   * computations. Reloading them may make it possible to recompute
   * future PageRank probabilities values more quickly.
   */
  initialPageRankProbability: number;
}

export interface PreviousExecutionStats {
  /** Outcomes of previous executions of actions, per size class. */
  sizeClasses: { [key: number]: PerSizeClassStats };
  /** The time at which this action failed on the largest size class. */
  lastSeenFailure: Date | undefined;
}

export interface PreviousExecutionStats_SizeClassesEntry {
  key: number;
  value: PerSizeClassStats | undefined;
}

export interface GetPreviousExecutionStatsRequest {
  /** The instance of the execution system to operate against. */
  instanceName: string;
  /**
   * The digest of a trimmed down Action message for which statistics
   * are requested. This digest is obtained by removing all fields from
   * the original Action, except for 'command_digest' and 'platform'.
   *
   * This means that contents of the input root, the Action's timeout
   * and the do_not_cache flag are ignored.
   */
  reducedActionDigest:
    | Digest
    | undefined;
  /** The digest function that was used to compute the reduced action digest. */
  digestFunction: DigestFunction_Value;
}

export interface UpdatePreviousExecutionStatsRequest {
  /** The instance of the execution system to operate against. */
  instanceName: string;
  /**
   * The digest of a trimmed down Action message for which statistics
   * are being stored.
   */
  reducedActionDigest:
    | Digest
    | undefined;
  /** The statistics to store. */
  previousExecutionStats:
    | PreviousExecutionStats
    | undefined;
  /** The digest function that was used to compute the reduced action digest. */
  digestFunction: DigestFunction_Value;
}

function createBasePreviousExecution(): PreviousExecution {
  return { failed: undefined, timedOut: undefined, succeeded: undefined };
}

export const PreviousExecution: MessageFns<PreviousExecution> = {
  encode(message: PreviousExecution, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.failed !== undefined) {
      Empty.encode(message.failed, writer.uint32(10).fork()).join();
    }
    if (message.timedOut !== undefined) {
      Duration.encode(message.timedOut, writer.uint32(18).fork()).join();
    }
    if (message.succeeded !== undefined) {
      Duration.encode(message.succeeded, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PreviousExecution {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePreviousExecution();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.failed = Empty.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.timedOut = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.succeeded = Duration.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PreviousExecution {
    return {
      failed: isSet(object.failed) ? Empty.fromJSON(object.failed) : undefined,
      timedOut: isSet(object.timedOut) ? Duration.fromJSON(object.timedOut) : undefined,
      succeeded: isSet(object.succeeded) ? Duration.fromJSON(object.succeeded) : undefined,
    };
  },

  toJSON(message: PreviousExecution): unknown {
    const obj: any = {};
    if (message.failed !== undefined) {
      obj.failed = Empty.toJSON(message.failed);
    }
    if (message.timedOut !== undefined) {
      obj.timedOut = Duration.toJSON(message.timedOut);
    }
    if (message.succeeded !== undefined) {
      obj.succeeded = Duration.toJSON(message.succeeded);
    }
    return obj;
  },

  create(base?: DeepPartial<PreviousExecution>): PreviousExecution {
    return PreviousExecution.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PreviousExecution>): PreviousExecution {
    const message = createBasePreviousExecution();
    message.failed = (object.failed !== undefined && object.failed !== null)
      ? Empty.fromPartial(object.failed)
      : undefined;
    message.timedOut = (object.timedOut !== undefined && object.timedOut !== null)
      ? Duration.fromPartial(object.timedOut)
      : undefined;
    message.succeeded = (object.succeeded !== undefined && object.succeeded !== null)
      ? Duration.fromPartial(object.succeeded)
      : undefined;
    return message;
  },
};

function createBasePerSizeClassStats(): PerSizeClassStats {
  return { previousExecutions: [], initialPageRankProbability: 0 };
}

export const PerSizeClassStats: MessageFns<PerSizeClassStats> = {
  encode(message: PerSizeClassStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.previousExecutions) {
      PreviousExecution.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.initialPageRankProbability !== 0) {
      writer.uint32(25).double(message.initialPageRankProbability);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PerSizeClassStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePerSizeClassStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.previousExecutions.push(PreviousExecution.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.initialPageRankProbability = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PerSizeClassStats {
    return {
      previousExecutions: globalThis.Array.isArray(object?.previousExecutions)
        ? object.previousExecutions.map((e: any) => PreviousExecution.fromJSON(e))
        : [],
      initialPageRankProbability: isSet(object.initialPageRankProbability)
        ? globalThis.Number(object.initialPageRankProbability)
        : 0,
    };
  },

  toJSON(message: PerSizeClassStats): unknown {
    const obj: any = {};
    if (message.previousExecutions?.length) {
      obj.previousExecutions = message.previousExecutions.map((e) => PreviousExecution.toJSON(e));
    }
    if (message.initialPageRankProbability !== 0) {
      obj.initialPageRankProbability = message.initialPageRankProbability;
    }
    return obj;
  },

  create(base?: DeepPartial<PerSizeClassStats>): PerSizeClassStats {
    return PerSizeClassStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PerSizeClassStats>): PerSizeClassStats {
    const message = createBasePerSizeClassStats();
    message.previousExecutions = object.previousExecutions?.map((e) => PreviousExecution.fromPartial(e)) || [];
    message.initialPageRankProbability = object.initialPageRankProbability ?? 0;
    return message;
  },
};

function createBasePreviousExecutionStats(): PreviousExecutionStats {
  return { sizeClasses: {}, lastSeenFailure: undefined };
}

export const PreviousExecutionStats: MessageFns<PreviousExecutionStats> = {
  encode(message: PreviousExecutionStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.sizeClasses).forEach(([key, value]) => {
      PreviousExecutionStats_SizeClassesEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    if (message.lastSeenFailure !== undefined) {
      Timestamp.encode(toTimestamp(message.lastSeenFailure), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PreviousExecutionStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePreviousExecutionStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = PreviousExecutionStats_SizeClassesEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.sizeClasses[entry1.key] = entry1.value;
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.lastSeenFailure = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PreviousExecutionStats {
    return {
      sizeClasses: isObject(object.sizeClasses)
        ? Object.entries(object.sizeClasses).reduce<{ [key: number]: PerSizeClassStats }>((acc, [key, value]) => {
          acc[globalThis.Number(key)] = PerSizeClassStats.fromJSON(value);
          return acc;
        }, {})
        : {},
      lastSeenFailure: isSet(object.lastSeenFailure) ? fromJsonTimestamp(object.lastSeenFailure) : undefined,
    };
  },

  toJSON(message: PreviousExecutionStats): unknown {
    const obj: any = {};
    if (message.sizeClasses) {
      const entries = Object.entries(message.sizeClasses);
      if (entries.length > 0) {
        obj.sizeClasses = {};
        entries.forEach(([k, v]) => {
          obj.sizeClasses[k] = PerSizeClassStats.toJSON(v);
        });
      }
    }
    if (message.lastSeenFailure !== undefined) {
      obj.lastSeenFailure = message.lastSeenFailure.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<PreviousExecutionStats>): PreviousExecutionStats {
    return PreviousExecutionStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PreviousExecutionStats>): PreviousExecutionStats {
    const message = createBasePreviousExecutionStats();
    message.sizeClasses = Object.entries(object.sizeClasses ?? {}).reduce<{ [key: number]: PerSizeClassStats }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[globalThis.Number(key)] = PerSizeClassStats.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.lastSeenFailure = object.lastSeenFailure ?? undefined;
    return message;
  },
};

function createBasePreviousExecutionStats_SizeClassesEntry(): PreviousExecutionStats_SizeClassesEntry {
  return { key: 0, value: undefined };
}

export const PreviousExecutionStats_SizeClassesEntry: MessageFns<PreviousExecutionStats_SizeClassesEntry> = {
  encode(message: PreviousExecutionStats_SizeClassesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== 0) {
      writer.uint32(8).uint32(message.key);
    }
    if (message.value !== undefined) {
      PerSizeClassStats.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PreviousExecutionStats_SizeClassesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePreviousExecutionStats_SizeClassesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.key = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = PerSizeClassStats.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PreviousExecutionStats_SizeClassesEntry {
    return {
      key: isSet(object.key) ? globalThis.Number(object.key) : 0,
      value: isSet(object.value) ? PerSizeClassStats.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: PreviousExecutionStats_SizeClassesEntry): unknown {
    const obj: any = {};
    if (message.key !== 0) {
      obj.key = Math.round(message.key);
    }
    if (message.value !== undefined) {
      obj.value = PerSizeClassStats.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<PreviousExecutionStats_SizeClassesEntry>): PreviousExecutionStats_SizeClassesEntry {
    return PreviousExecutionStats_SizeClassesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PreviousExecutionStats_SizeClassesEntry>): PreviousExecutionStats_SizeClassesEntry {
    const message = createBasePreviousExecutionStats_SizeClassesEntry();
    message.key = object.key ?? 0;
    message.value = (object.value !== undefined && object.value !== null)
      ? PerSizeClassStats.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseGetPreviousExecutionStatsRequest(): GetPreviousExecutionStatsRequest {
  return { instanceName: "", reducedActionDigest: undefined, digestFunction: 0 };
}

export const GetPreviousExecutionStatsRequest: MessageFns<GetPreviousExecutionStatsRequest> = {
  encode(message: GetPreviousExecutionStatsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.instanceName !== "") {
      writer.uint32(10).string(message.instanceName);
    }
    if (message.reducedActionDigest !== undefined) {
      Digest.encode(message.reducedActionDigest, writer.uint32(18).fork()).join();
    }
    if (message.digestFunction !== 0) {
      writer.uint32(24).int32(message.digestFunction);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPreviousExecutionStatsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPreviousExecutionStatsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.instanceName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reducedActionDigest = Digest.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.digestFunction = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPreviousExecutionStatsRequest {
    return {
      instanceName: isSet(object.instanceName) ? globalThis.String(object.instanceName) : "",
      reducedActionDigest: isSet(object.reducedActionDigest) ? Digest.fromJSON(object.reducedActionDigest) : undefined,
      digestFunction: isSet(object.digestFunction) ? digestFunction_ValueFromJSON(object.digestFunction) : 0,
    };
  },

  toJSON(message: GetPreviousExecutionStatsRequest): unknown {
    const obj: any = {};
    if (message.instanceName !== "") {
      obj.instanceName = message.instanceName;
    }
    if (message.reducedActionDigest !== undefined) {
      obj.reducedActionDigest = Digest.toJSON(message.reducedActionDigest);
    }
    if (message.digestFunction !== 0) {
      obj.digestFunction = digestFunction_ValueToJSON(message.digestFunction);
    }
    return obj;
  },

  create(base?: DeepPartial<GetPreviousExecutionStatsRequest>): GetPreviousExecutionStatsRequest {
    return GetPreviousExecutionStatsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetPreviousExecutionStatsRequest>): GetPreviousExecutionStatsRequest {
    const message = createBaseGetPreviousExecutionStatsRequest();
    message.instanceName = object.instanceName ?? "";
    message.reducedActionDigest = (object.reducedActionDigest !== undefined && object.reducedActionDigest !== null)
      ? Digest.fromPartial(object.reducedActionDigest)
      : undefined;
    message.digestFunction = object.digestFunction ?? 0;
    return message;
  },
};

function createBaseUpdatePreviousExecutionStatsRequest(): UpdatePreviousExecutionStatsRequest {
  return { instanceName: "", reducedActionDigest: undefined, previousExecutionStats: undefined, digestFunction: 0 };
}

export const UpdatePreviousExecutionStatsRequest: MessageFns<UpdatePreviousExecutionStatsRequest> = {
  encode(message: UpdatePreviousExecutionStatsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.instanceName !== "") {
      writer.uint32(10).string(message.instanceName);
    }
    if (message.reducedActionDigest !== undefined) {
      Digest.encode(message.reducedActionDigest, writer.uint32(18).fork()).join();
    }
    if (message.previousExecutionStats !== undefined) {
      PreviousExecutionStats.encode(message.previousExecutionStats, writer.uint32(26).fork()).join();
    }
    if (message.digestFunction !== 0) {
      writer.uint32(32).int32(message.digestFunction);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdatePreviousExecutionStatsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdatePreviousExecutionStatsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.instanceName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reducedActionDigest = Digest.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.previousExecutionStats = PreviousExecutionStats.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.digestFunction = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdatePreviousExecutionStatsRequest {
    return {
      instanceName: isSet(object.instanceName) ? globalThis.String(object.instanceName) : "",
      reducedActionDigest: isSet(object.reducedActionDigest) ? Digest.fromJSON(object.reducedActionDigest) : undefined,
      previousExecutionStats: isSet(object.previousExecutionStats)
        ? PreviousExecutionStats.fromJSON(object.previousExecutionStats)
        : undefined,
      digestFunction: isSet(object.digestFunction) ? digestFunction_ValueFromJSON(object.digestFunction) : 0,
    };
  },

  toJSON(message: UpdatePreviousExecutionStatsRequest): unknown {
    const obj: any = {};
    if (message.instanceName !== "") {
      obj.instanceName = message.instanceName;
    }
    if (message.reducedActionDigest !== undefined) {
      obj.reducedActionDigest = Digest.toJSON(message.reducedActionDigest);
    }
    if (message.previousExecutionStats !== undefined) {
      obj.previousExecutionStats = PreviousExecutionStats.toJSON(message.previousExecutionStats);
    }
    if (message.digestFunction !== 0) {
      obj.digestFunction = digestFunction_ValueToJSON(message.digestFunction);
    }
    return obj;
  },

  create(base?: DeepPartial<UpdatePreviousExecutionStatsRequest>): UpdatePreviousExecutionStatsRequest {
    return UpdatePreviousExecutionStatsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdatePreviousExecutionStatsRequest>): UpdatePreviousExecutionStatsRequest {
    const message = createBaseUpdatePreviousExecutionStatsRequest();
    message.instanceName = object.instanceName ?? "";
    message.reducedActionDigest = (object.reducedActionDigest !== undefined && object.reducedActionDigest !== null)
      ? Digest.fromPartial(object.reducedActionDigest)
      : undefined;
    message.previousExecutionStats =
      (object.previousExecutionStats !== undefined && object.previousExecutionStats !== null)
        ? PreviousExecutionStats.fromPartial(object.previousExecutionStats)
        : undefined;
    message.digestFunction = object.digestFunction ?? 0;
    return message;
  },
};

/**
 * The Initial Size Class Cache (ISCC) is a data store that can be used
 * by bb_scheduler to store outcomes of previous executions of an
 * action. This data is then used during successive actions of the same
 * shape to pick the initial size class on which the action needs to be
 * run.
 *
 * It generally only makes sense to use this data store in case
 * platforms are declared that have multiple size classes.
 */
export type InitialSizeClassCacheDefinition = typeof InitialSizeClassCacheDefinition;
export const InitialSizeClassCacheDefinition = {
  name: "InitialSizeClassCache",
  fullName: "buildbarn.iscc.InitialSizeClassCache",
  methods: {
    /**
     * GetPreviousExecutionStats() reads a single PreviousExecutionStats
     * message from the ISCC.
     */
    getPreviousExecutionStats: {
      name: "GetPreviousExecutionStats",
      requestType: GetPreviousExecutionStatsRequest,
      requestStream: false,
      responseType: PreviousExecutionStats,
      responseStream: false,
      options: {},
    },
    /**
     * UpdatePreviousExecutionStats() writes a single
     * PreviousExecutionStats message to the ISCC.
     */
    updatePreviousExecutionStats: {
      name: "UpdatePreviousExecutionStats",
      requestType: UpdatePreviousExecutionStatsRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
  },
} as const;

export interface InitialSizeClassCacheServiceImplementation<CallContextExt = {}> {
  /**
   * GetPreviousExecutionStats() reads a single PreviousExecutionStats
   * message from the ISCC.
   */
  getPreviousExecutionStats(
    request: GetPreviousExecutionStatsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<PreviousExecutionStats>>;
  /**
   * UpdatePreviousExecutionStats() writes a single
   * PreviousExecutionStats message to the ISCC.
   */
  updatePreviousExecutionStats(
    request: UpdatePreviousExecutionStatsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
}

export interface InitialSizeClassCacheClient<CallOptionsExt = {}> {
  /**
   * GetPreviousExecutionStats() reads a single PreviousExecutionStats
   * message from the ISCC.
   */
  getPreviousExecutionStats(
    request: DeepPartial<GetPreviousExecutionStatsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<PreviousExecutionStats>;
  /**
   * UpdatePreviousExecutionStats() writes a single
   * PreviousExecutionStats message to the ISCC.
   */
  updatePreviousExecutionStats(
    request: DeepPartial<UpdatePreviousExecutionStatsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000).toString();
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (globalThis.Number(t.seconds) || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
